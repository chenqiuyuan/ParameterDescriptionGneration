{"sink": ["  public long copyTo(CharSink sink) throws IOException {", "    checkNotNull(sink);", "      Writer writer = closer.register(sink.openStream());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"b": ["  public int read(byte[] b, int off, int len) throws IOException {", "    checkPositionIndexes(off, off + len, b.length);", "        totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);", "        if (totalBytesRead == len || doneFlushing) {", "          return (totalBytesRead > 0) ? totalBytesRead : -1;"], "off": ["  public int read(byte[] b, int off, int len) throws IOException {", "    checkPositionIndexes(off, off + len, b.length);", "        totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);", "        if (totalBytesRead == len || doneFlushing) {", "          return (totalBytesRead > 0) ? totalBytesRead : -1;"], "len": ["  public int read(byte[] b, int off, int len) throws IOException {", "    checkPositionIndexes(off, off + len, b.length);", "    if (len == 0) {", "        totalBytesRead += drain(b, off + totalBytesRead, len - totalBytesRead);", "        if (totalBytesRead == len || doneFlushing) {", "          return (totalBytesRead > 0) ? totalBytesRead : -1;"]}
{"buf": ["private static CharBuffer grow(CharBuffer buf) {", "    char[] copy = Arrays.copyOf(buf.array(), buf.capacity() * 2);", "    bigger.position(buf.position());", "    bigger.limit(buf.limit());"]}
{"Result": "Method without Parameter"}
{"overflow": ["private void startDraining(boolean overflow) {", "    if (overflow && byteBuffer.remaining() == 0) {"]}
{"iterable": ["  public static <T> T[] toArray(Iterable<? extends T> iterable, Class<T> type) {", "    return toArray(iterable, ObjectArrays.newArray(type, 0));"], "type": ["  public static <T> T[] toArray(Iterable<? extends T> iterable, Class<T> type) {", "    return toArray(iterable, ObjectArrays.newArray(type, 0));"]}
{"iterable": ["public static boolean isEmpty(Iterable<?> iterable) {", "    if (iterable instanceof Collection) {", "      return ((Collection<?>) iterable).isEmpty();", "    return !iterable.iterator().hasNext();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"iterator": ["static void clear(Iterator<?> iterator) {", "    checkNotNull(iterator);", "    while (iterator.hasNext()) {", "      iterator.next();", "      iterator.remove();"]}
{"bytes": ["public void write(byte[] bytes) throws IOException {", "    checkNotNull(bytes);", "      out.write(bytes);"]}
{"cacheBuilderSpecification": ["public static CacheBuilderSpec parse(String cacheBuilderSpecification) {", "    CacheBuilderSpec spec = new CacheBuilderSpec(cacheBuilderSpecification);", "    if (!cacheBuilderSpecification.isEmpty()) {", "      for (String keyValuePair : KEYS_SPLITTER.split(cacheBuilderSpecification)) {", "        List<String> keyAndValue = ImmutableList.copyOf(KEY_VALUE_SPLITTER.split(keyValuePair));", "        checkArgument(!keyAndValue.isEmpty(), \"blank key-value pair\");", "            keyAndValue.size() <= 2,", "            keyValuePair);", "        String key = keyAndValue.get(0);", "        ValueParser valueParser = VALUE_PARSERS.get(key);", "        checkArgument(valueParser != null, \"unknown key %s\", key);", "        String value = keyAndValue.size() == 1 ? null : keyAndValue.get(1);", "        valueParser.parse(spec, key, value);", "    return spec;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"first": ["public static ImmutableIntArray of(int first, int... rest) {", "    array[0] = first;", "    System.arraycopy(rest, 0, array, 1, rest.length);", "    return new ImmutableIntArray(array);"]}
{"startIndex": ["public ImmutableIntArray subArray(int startIndex, int endIndex) {", "    Preconditions.checkPositionIndexes(startIndex, endIndex, length());", "    return startIndex == endIndex", "        : new ImmutableIntArray(array, start + startIndex, start + endIndex);"], "endIndex": ["public ImmutableIntArray subArray(int startIndex, int endIndex) {", "    Preconditions.checkPositionIndexes(startIndex, endIndex, length());", "    return startIndex == endIndex", "        : new ImmutableIntArray(array, start + startIndex, start + endIndex);"]}
{"Result": "Method without Parameter"}
{"bytes": ["  public int read(byte[] bytes, int off, int len) throws IOException {", "    int numOfBytesRead = in.read(bytes, off, len);", "      hasher.putBytes(bytes, off, numOfBytesRead);"], "off": ["  public int read(byte[] bytes, int off, int len) throws IOException {", "    int numOfBytesRead = in.read(bytes, off, len);", "      hasher.putBytes(bytes, off, numOfBytesRead);"], "len": ["  public int read(byte[] bytes, int off, int len) throws IOException {", "    int numOfBytesRead = in.read(bytes, off, len);", "    if (numOfBytesRead != -1) {", "      hasher.putBytes(bytes, off, numOfBytesRead);", "    return numOfBytesRead;"]}
{"map": ["static <K, V> void writeMap(Map<K, V> map, ObjectOutputStream stream) throws IOException {", "    stream.writeInt(map.size());", "    for (Map.Entry<K, V> entry : map.entrySet()) {", "      stream.writeObject(entry.getKey());", "      stream.writeObject(entry.getValue());"], "stream": ["static <K, V> void writeMap(Map<K, V> map, ObjectOutputStream stream) throws IOException {", "    stream.writeInt(map.size());", "      stream.writeObject(entry.getKey());", "      stream.writeObject(entry.getValue());"]}
{"multiset": ["static <E> void writeMultiset(Multiset<E> multiset, ObjectOutputStream stream)", "    int entryCount = multiset.entrySet().size();", "    for (Multiset.Entry<E> entry : multiset.entrySet()) {", "      stream.writeObject(entry.getElement());", "      stream.writeInt(entry.getCount());"], "stream": ["static <E> void writeMultiset(Multiset<E> multiset, ObjectOutputStream stream)", "    stream.writeInt(entryCount);", "      stream.writeObject(entry.getElement());", "      stream.writeInt(entry.getCount());"]}
{"clazz": ["static <T> FieldSetter<T> getFieldSetter(final Class<T> clazz, String fieldName) {", "      Field field = clazz.getDeclaredField(fieldName);"], "fieldName": ["static <T> FieldSetter<T> getFieldSetter(final Class<T> clazz, String fieldName) {", "      Field field = clazz.getDeclaredField(fieldName);", "      return new FieldSetter<T>(field);"]}
{"Result": "Method without Parameter"}
{"element": ["  public int add(E element, int occurrences) {", "    checkNotNull(element);", "      return count(element);", "      AtomicInteger existingCounter = Maps.safeGet(countMap, element);", "      if (existingCounter == null) {", "        existingCounter = countMap.putIfAbsent(element, new AtomicInteger(occurrences));", "        if (existingCounter == null) {", "        int oldValue = existingCounter.get();", "        if (oldValue != 0) {", "            int newValue = IntMath.checkedAdd(oldValue, occurrences);", "            if (existingCounter.compareAndSet(oldValue, newValue)) {", "              return oldValue;", "                \"Overflow adding \" + occurrences + \" occurrences to a count of \" + oldValue);", "          if ((countMap.putIfAbsent(element, newCounter) == null)", "              || countMap.replace(element, existingCounter, newCounter)) {"], "occurrences": ["  public int add(E element, int occurrences) {", "    if (occurrences == 0) {", "    CollectPreconditions.checkPositive(occurrences, \"occurences\");", "        existingCounter = countMap.putIfAbsent(element, new AtomicInteger(occurrences));", "        if (existingCounter == null) {", "        int oldValue = existingCounter.get();", "        if (oldValue != 0) {", "            int newValue = IntMath.checkedAdd(oldValue, occurrences);", "            if (existingCounter.compareAndSet(oldValue, newValue)) {", "              return oldValue;", "                \"Overflow adding \" + occurrences + \" occurrences to a count of \" + oldValue);", "          AtomicInteger newCounter = new AtomicInteger(occurrences);", "          if ((countMap.putIfAbsent(element, newCounter) == null)", "              || countMap.replace(element, existingCounter, newCounter)) {"]}
{"newSize": ["private void resizeMeMaybe(int newSize) {", "    if (newSize > entriesSize) {"]}
{"addr": ["private static InetAddress bytesToInetAddress(byte[] addr) {", "      return InetAddress.getByAddress(addr);"]}
{"hextets": ["private static void compressLongestRunOfZeroes(int[] hextets) {", "    for (int i = 0; i < hextets.length + 1; i++) {", "      if (i < hextets.length && hextets[i] == 0) {", "      Arrays.fill(hextets, bestRunStart, bestRunStart + bestRunLength, -1);"]}
{"hextets": ["private static String hextetsToIPv6String(int[] hextets) {", "    for (int i = 0; i < hextets.length; i++) {", "      boolean thisIsNumber = hextets[i] >= 0;", "      if (thisIsNumber) {", "        if (lastWasNumber) {", "        buf.append(Integer.toHexString(hextets[i]));", "        if (i == 0 || lastWasNumber) {", "      lastWasNumber = thisIsNumber;"]}
{"hostAddr": ["public static InetAddress forUriString(String hostAddr) {", "    InetAddress addr = forUriStringNoThrow(hostAddr);", "    if (addr == null) {", "      throw formatIllegalArgumentException(\"Not a valid URI IP literal: '%s'\", hostAddr);", "    return addr;"]}
{"ip": ["public static boolean isCompatIPv4Address(Inet6Address ip) {", "    if (!ip.isIPv4CompatibleAddress()) {", "    byte[] bytes = ip.getAddress();"]}
{"ip": ["public static Inet4Address getCompatIPv4Address(Inet6Address ip) {", "        isCompatIPv4Address(ip), \"Address '%s' is not IPv4-compatible.\", toAddrString(ip));", "    return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));"]}
{"ip": ["public static boolean isTeredoAddress(Inet6Address ip) {", "    byte[] bytes = ip.getAddress();"]}
{"ip": ["public static boolean isIsatapAddress(Inet6Address ip) {", "    if (isTeredoAddress(ip)) {", "    byte[] bytes = ip.getAddress();"]}
{"ip": ["public static Inet4Address getIsatapIPv4Address(Inet6Address ip) {", "    checkArgument(isIsatapAddress(ip), \"Address '%s' is not an ISATAP address.\", toAddrString(ip));", "    return getInet4Address(Arrays.copyOfRange(ip.getAddress(), 12, 16));"]}
{"ip": ["public static Inet4Address getEmbeddedIPv4ClientAddress(Inet6Address ip) {", "    if (isCompatIPv4Address(ip)) {", "      return getCompatIPv4Address(ip);", "    if (is6to4Address(ip)) {", "      return get6to4IPv4Address(ip);", "    if (isTeredoAddress(ip)) {", "      return getTeredoInfo(ip).getClient();", "    throw formatIllegalArgumentException(\"'%s' has no embedded IPv4 address.\", toAddrString(ip));"]}
{"ipString": ["public static boolean isMappedIPv4Address(String ipString) {", "    byte[] bytes = ipStringToBytes(ipString);", "    if (bytes != null && bytes.length == 16) {", "        if (bytes[i] != 0) {", "        if (bytes[i] != (byte) 0xff) {"]}
{"address": ["public static InetAddress decrement(InetAddress address) {", "    byte[] addr = address.getAddress();", "    checkArgument(i >= 0, \"Decrementing %s would wrap.\", address);"]}
{"file": ["  public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException {", "    checkNotNull(file);", "    return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));"], "charset": ["  public static BufferedReader newReader(File file, Charset charset) throws FileNotFoundException {", "    checkNotNull(charset);", "    return new BufferedReader(new InputStreamReader(new FileInputStream(file), charset));"]}
{"from": ["  public static void write(byte[] from, File to) throws IOException {", "    asByteSink(to).write(from);"], "to": ["  public static void write(byte[] from, File to) throws IOException {", "    asByteSink(to).write(from);"]}
{"from": ["  public static void copy(File from, OutputStream to) throws IOException {", "    asByteSource(from).copyTo(to);"], "to": ["  public static void copy(File from, OutputStream to) throws IOException {", "    asByteSource(from).copyTo(to);"]}
{"from": ["  public static void copy(File from, File to) throws IOException {", "    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);", "    asByteSource(from).copyTo(asByteSink(to));"], "to": ["  public static void copy(File from, File to) throws IOException {", "    checkArgument(!from.equals(to), \"Source %s and destination %s must be different\", from, to);", "    asByteSource(from).copyTo(asByteSink(to));"]}
{"file": ["  public static void touch(File file) throws IOException {", "    checkNotNull(file);", "    if (!file.createNewFile() && !file.setLastModified(System.currentTimeMillis())) {", "      throw new IOException(\"Unable to update modification time of \" + file);"]}
{"file": ["  static String readFirstLine(File file, Charset charset) throws IOException {", "    return asCharSource(file, charset).readFirstLine();"], "charset": ["  static String readFirstLine(File file, Charset charset) throws IOException {", "    return asCharSource(file, charset).readFirstLine();"]}
{"expectedSize": ["  public static <K, V> Builder<K, V> builderWithExpectedSize(int expectedSize) {", "    checkNonnegative(expectedSize, \"expectedSize\");", "    return new Builder<>(expectedSize);"]}
{"key": [], "value": []}
{"initialContents": ["      Iterable<? extends E> initialContents) {", "    return new Builder<E>(Ordering.<E>natural()).create(initialContents);"]}
{"Result": "Method without Parameter"}
{"h1": [], "length": ["private static HashCode fmix(int h1, int length) {", "    h1 ^= length;", "    h1 ^= h1 >>> 16;"]}
{"Result": "Method without Parameter"}
{"time": ["  public boolean enter(long time, TimeUnit unit) {", "    final long timeoutNanos = toSafeNanos(time, unit);"], "unit": ["  public boolean enter(long time, TimeUnit unit) {", "    final long timeoutNanos = toSafeNanos(time, unit);", "      for (long remainingNanos = timeoutNanos; ; ) {", "          return lock.tryLock(remainingNanos, TimeUnit.NANOSECONDS);", "          remainingNanos = remainingNanos(startTime, timeoutNanos);"]}
{"time": ["  public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException {", "    return lock.tryLock(time, unit);"], "unit": ["  public boolean enterInterruptibly(long time, TimeUnit unit) throws InterruptedException {", "    return lock.tryLock(time, unit);"]}
{"guard": ["public void enterWhen(Guard guard) throws InterruptedException {", "    if (guard.monitor != this) {", "      if (!guard.isSatisfied()) {", "        await(guard, signalBeforeWaiting);"]}
{"guard": ["  public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException {", "    if (guard.monitor != this) {", "          guard.isSatisfied()", "                  guard,"], "time": ["  public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException {", "    final long timeoutNanos = toSafeNanos(time, unit);", "      if (!lock.tryLock(time, unit)) {"], "unit": ["  public boolean enterWhen(Guard guard, long time, TimeUnit unit) throws InterruptedException {", "    final long timeoutNanos = toSafeNanos(time, unit);", "      startTime = initNanoTime(timeoutNanos);", "      if (!lock.tryLock(time, unit)) {", "                  (startTime == 0L) ? timeoutNanos : remainingNanos(startTime, timeoutNanos),"]}
{"guard": ["public void enterWhenUninterruptibly(Guard guard) {", "    if (guard.monitor != this) {", "      if (!guard.isSatisfied()) {", "        awaitUninterruptibly(guard, signalBeforeWaiting);"]}
{"guard": ["public boolean enterIf(Guard guard) {", "    if (guard.monitor != this) {", "      return satisfied = guard.isSatisfied();"]}
{"guard": ["  public boolean enterIf(Guard guard, long time, TimeUnit unit) {", "    if (guard.monitor != this) {", "      return satisfied = guard.isSatisfied();"], "time": ["  public boolean enterIf(Guard guard, long time, TimeUnit unit) {", "    if (!enter(time, unit)) {"], "unit": ["  public boolean enterIf(Guard guard, long time, TimeUnit unit) {", "    if (!enter(time, unit)) {"]}
{"guard": ["public boolean enterIfInterruptibly(Guard guard) throws InterruptedException {", "    if (guard.monitor != this) {", "      return satisfied = guard.isSatisfied();"]}
{"guard": ["public boolean tryEnterIf(Guard guard) {", "    if (guard.monitor != this) {", "      return satisfied = guard.isSatisfied();"]}
{"guard": ["public void waitFor(Guard guard) throws InterruptedException {", "    if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {", "    if (!guard.isSatisfied()) {", "      await(guard, true);"]}
{"guard": ["public void waitForUninterruptibly(Guard guard) {", "    if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {", "    if (!guard.isSatisfied()) {", "      awaitUninterruptibly(guard, true);"]}
{"guard": ["  public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit) {", "    if (!((guard.monitor == this) & lock.isHeldByCurrentThread())) {", "    if (guard.isSatisfied()) {", "          return awaitNanos(guard, remainingNanos, signalBeforeWaiting);", "          if (guard.isSatisfied()) {"], "time": ["  public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit) {", "    final long timeoutNanos = toSafeNanos(time, unit);"], "unit": ["  public boolean waitForUninterruptibly(Guard guard, long time, TimeUnit unit) {", "    final long timeoutNanos = toSafeNanos(time, unit);", "    final long startTime = initNanoTime(timeoutNanos);", "      for (long remainingNanos = timeoutNanos; ; ) {", "          return awaitNanos(guard, remainingNanos, signalBeforeWaiting);", "          remainingNanos = remainingNanos(startTime, timeoutNanos);"]}
{"guard": ["public int getWaitQueueLength(Guard guard) {", "    if (guard.monitor != this) {", "      return guard.waiterCount;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"guard": []}
{"guard": []}
{"guard": ["  private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)", "          beginWaitingFor(guard);", "        nanos = guard.condition.awaitNanos(nanos);", "      } while (!guard.isSatisfied());", "        endWaitingFor(guard);"], "nanos": ["  private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)", "        if (nanos <= 0L) {", "        nanos = guard.condition.awaitNanos(nanos);"], "signalBeforeWaiting": ["  private boolean awaitNanos(Guard guard, long nanos, boolean signalBeforeWaiting)", "          if (signalBeforeWaiting) {"]}
{"service": ["      ExecutorService service, long timeout, TimeUnit unit) {", "    service.shutdown();", "      if (!service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS)) {", "        service.shutdownNow();", "        service.awaitTermination(halfTimeoutNanos, TimeUnit.NANOSECONDS);", "      service.shutdownNow();", "    return service.isTerminated();"], "timeout": ["      ExecutorService service, long timeout, TimeUnit unit) {", "    long halfTimeoutNanos = unit.toNanos(timeout) / 2;"], "unit": ["      ExecutorService service, long timeout, TimeUnit unit) {", "    long halfTimeoutNanos = unit.toNanos(timeout) / 2;"]}
{"charSequence": ["public void write(CharSequence charSequence) throws IOException {", "    checkNotNull(charSequence);", "      out.append(charSequence);"]}
{"Result": "Method without Parameter"}
{"input": ["static long load64Safely(byte[] input, int offset, int length) {", "      result |= (input[offset + i] & 0xFFL) << (i * 8);", "    return result;"], "offset": ["static long load64Safely(byte[] input, int offset, int length) {", "      result |= (input[offset + i] & 0xFFL) << (i * 8);", "    return result;"], "length": ["static long load64Safely(byte[] input, int offset, int length) {", "    int limit = Math.min(length, 8);"]}
{"sink": ["static void store64(byte[] sink, int offset, long value) {", "    assert offset >= 0 && offset + 8 <= sink.length;", "    byteArray.putLongLittleEndian(sink, offset, value);"], "offset": ["static void store64(byte[] sink, int offset, long value) {", "    assert offset >= 0 && offset + 8 <= sink.length;", "    byteArray.putLongLittleEndian(sink, offset, value);"], "value": ["static void store64(byte[] sink, int offset, long value) {", "    byteArray.putLongLittleEndian(sink, offset, value);"]}
{"source": ["static int load32(byte[] source, int offset) {", "    return (source[offset] & 0xFF)", "        | ((source[offset + 1] & 0xFF) << 8)", "        | ((source[offset + 2] & 0xFF) << 16)", "        | ((source[offset + 3] & 0xFF) << 24);"], "offset": ["static int load32(byte[] source, int offset) {", "    return (source[offset] & 0xFF)", "        | ((source[offset + 1] & 0xFF) << 8)", "        | ((source[offset + 2] & 0xFF) << 16)", "        | ((source[offset + 3] & 0xFF) << 24);"]}
{"type": ["public static MediaType create(String type, String subtype) {", "    MediaType mediaType = create(type, subtype, ImmutableListMultimap.<String, String>of());"], "subtype": ["public static MediaType create(String type, String subtype) {", "    MediaType mediaType = create(type, subtype, ImmutableListMultimap.<String, String>of());"]}
{"input": ["public static MediaType parse(String input) {", "    checkNotNull(input);", "    Tokenizer tokenizer = new Tokenizer(input);", "      String type = tokenizer.consumeToken(TOKEN_MATCHER);", "      tokenizer.consumeCharacter('/');", "      String subtype = tokenizer.consumeToken(TOKEN_MATCHER);", "      while (tokenizer.hasMore()) {", "        tokenizer.consumeTokenIfPresent(LINEAR_WHITE_SPACE);", "        tokenizer.consumeCharacter(';');", "        tokenizer.consumeTokenIfPresent(LINEAR_WHITE_SPACE);", "        String attribute = tokenizer.consumeToken(TOKEN_MATCHER);", "        tokenizer.consumeCharacter('=');", "        if ('\"' == tokenizer.previewChar()) {", "          tokenizer.consumeCharacter('\"');", "          while ('\"' != tokenizer.previewChar()) {", "            if ('\\\\' == tokenizer.previewChar()) {", "              tokenizer.consumeCharacter('\\\\');", "              valueBuilder.append(tokenizer.consumeCharacter(ascii()));", "              valueBuilder.append(tokenizer.consumeToken(QUOTED_TEXT_MATCHER));", "          tokenizer.consumeCharacter('\"');", "          value = tokenizer.consumeToken(TOKEN_MATCHER);", "        parameters.put(attribute, value);", "      throw new IllegalArgumentException(\"Could not parse '\" + input + \"'\", e);"]}
{"Result": "Method without Parameter"}
{"set": ["static boolean removeAllImpl(Set<?> set, Iterator<?> iterator) {", "      changed |= set.remove(iterator.next());", "    return changed;"], "iterator": ["static boolean removeAllImpl(Set<?> set, Iterator<?> iterator) {", "    while (iterator.hasNext()) {", "      changed |= set.remove(iterator.next());", "    return changed;"]}
{"string": ["  public String escape(String string) {", "    checkNotNull(string); // GWT specific check (do not optimize)", "    int length = string.length();", "      if (escape(string.charAt(index)) != null) {", "        return escapeSlow(string, index);", "    return string;"]}
{"dest": ["private static char[] growBuffer(char[] dest, int index, int size) {", "      System.arraycopy(dest, 0, copy, 0, index);"], "index": ["private static char[] growBuffer(char[] dest, int index, int size) {", "    if (index > 0) {", "      System.arraycopy(dest, 0, copy, 0, index);"], "size": ["private static char[] growBuffer(char[] dest, int index, int size) {", "    if (size < 0) { // overflow - should be OutOfMemoryError but GWT/j2cl don't support it", "    char[] copy = new char[size];", "      System.arraycopy(dest, 0, copy, 0, index);", "    return copy;"]}
{"concurrencyLevel": ["public CacheBuilder<K, V> concurrencyLevel(int concurrencyLevel) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"value": ["public void add(double value) {", "      mean = value;", "      min = value;", "      max = value;", "      if (!isFinite(value)) {", "      if (isFinite(value) && isFinite(mean)) {", "        double delta = value - mean;", "        sumOfSquaresOfDeltas += delta * (value - mean);", "        mean = calculateNewMeanNonFinite(mean, value);", "      min = Math.min(min, value);", "      max = Math.max(max, value);"]}
{"previousMean": ["static double calculateNewMeanNonFinite(double previousMean, double value) {", "    if (isFinite(previousMean)) {", "    } else if (isFinite(value) || previousMean == value) {", "      return previousMean;"], "value": ["static double calculateNewMeanNonFinite(double previousMean, double value) {", "      return value;", "    } else if (isFinite(value) || previousMean == value) {"]}
{"newTableSize": ["static Object[] rebuildHashTable(int newTableSize, Object[] elements, int n) {", "    Object[] hashTable = new Object[newTableSize];", "    int mask = hashTable.length - 1;", "        if (hashTable[index] == null) {", "    return hashTable;"], "elements": ["static Object[] rebuildHashTable(int newTableSize, Object[] elements, int n) {", "      Object e = elements[i];", "      int j0 = Hashing.smear(e.hashCode());", "      for (int j = j0; ; j++) {", "        if (hashTable[index] == null) {", "          hashTable[index] = e;", "    return hashTable;"], "n": ["static Object[] rebuildHashTable(int newTableSize, Object[] elements, int n) {", "    for (int i = 0; i < n; i++) {"]}
{"setSize": ["  static int chooseTableSize(int setSize) {", "    setSize = Math.max(setSize, 2);"]}
{"Result": "Method without Parameter"}
{"rowKey": ["public static <R, C, V> ImmutableTable<R, C, V> of(R rowKey, C columnKey, V value) {", "    return new SingletonImmutableTable<>(rowKey, columnKey, value);"], "columnKey": ["public static <R, C, V> ImmutableTable<R, C, V> of(R rowKey, C columnKey, V value) {", "    return new SingletonImmutableTable<>(rowKey, columnKey, value);"], "value": ["public static <R, C, V> ImmutableTable<R, C, V> of(R rowKey, C columnKey, V value) {", "    return new SingletonImmutableTable<>(rowKey, columnKey, value);"]}
{"table": ["      Table<? extends R, ? extends C, ? extends V> table) {", "    if (table instanceof ImmutableTable) {", "      ImmutableTable<R, C, V> parameterizedTable = (ImmutableTable<R, C, V>) table;", "      return parameterizedTable;", "      return copyOf(table.cellSet());"]}
{"Result": "Method without Parameter"}
{"cellList": ["      ImmutableList<Cell<R, C, V>> cellList,", "    return (cellList.size() > (((long) rowSpace.size() * columnSpace.size()) / 2))", "        ? new DenseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace)", "        : new SparseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace);"], "rowSpace": ["      ImmutableSet<R> rowSpace,", "    return (cellList.size() > (((long) rowSpace.size() * columnSpace.size()) / 2))", "        ? new DenseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace)", "        : new SparseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace);"], "columnSpace": ["      ImmutableSet<C> columnSpace) {", "    return (cellList.size() > (((long) rowSpace.size() * columnSpace.size()) / 2))", "        ? new DenseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace)", "        : new SparseImmutableTable<R, C, V>(cellList, rowSpace, columnSpace);"]}
{"element": ["public static <E extends Comparable<? super E>> ImmutableSortedMultiset<E> of(E element) {", "    RegularImmutableSortedSet<E> elementSet =", "        (RegularImmutableSortedSet<E>) ImmutableSortedSet.of(element);", "    return new RegularImmutableSortedMultiset<E>(elementSet, cumulativeCounts, 0, 1);"]}
{"Result": "Method without Parameter"}
{"multisetToModify": ["      Multiset<E> multisetToModify, Multiset<?> occurrencesToRetain) {", "    checkNotNull(multisetToModify);", "    Iterator<Entry<E>> entryIterator = multisetToModify.entrySet().iterator();", "        multisetToModify.setCount(entry.getElement(), retainCount);"], "occurrencesToRetain": ["      Multiset<E> multisetToModify, Multiset<?> occurrencesToRetain) {", "    checkNotNull(occurrencesToRetain);", "      int retainCount = occurrencesToRetain.count(entry.getElement());", "      if (retainCount == 0) {", "      } else if (retainCount < entry.getCount()) {", "        multisetToModify.setCount(entry.getElement(), retainCount);"]}
{"root": ["  public final FluentIterable<T> preOrderTraversal(final T root) {", "    checkNotNull(root);", "        return preOrderIterator(root);", "        }.accept(root);"]}
{"size": ["static StringBuilder newStringBuilderForCollection(int size) {", "    checkNonnegative(size, \"size\");", "    return new StringBuilder((int) Math.min(size * 8L, Ints.MAX_POWER_OF_TWO));"]}
{"contextType": ["static TypeResolver invariantly(Type contextType) {", "    Type invariantContext = WildcardCapturer.INSTANCE.capture(contextType);", "    return new TypeResolver().where(TypeMappingIntrospector.getTypeMappings(invariantContext));"]}
{"map": ["final void setMap(Map<K, Collection<V>> map) {", "    this.map = map;", "    for (Collection<V> values : map.values()) {", "      checkArgument(!values.isEmpty());", "      totalSize += values.size();"]}
{"key": ["private void removeValuesForKey(Object key) {", "    Collection<V> collection = Maps.safeRemove(map, key);", "    if (collection != null) {", "      int count = collection.size();", "      collection.clear();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"type": ["  public final E[] toArray(Class<E> type) {", "    return Iterables.toArray(getDelegate(), type);"]}
{"k1": ["public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2) {", "    return ImmutableListMultimap.of(k1, v1, k2, v2);"], "v1": ["public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2) {", "    return ImmutableListMultimap.of(k1, v1, k2, v2);"], "k2": ["public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2) {", "    return ImmutableListMultimap.of(k1, v1, k2, v2);"], "v2": ["public static <K, V> ImmutableMultimap<K, V> of(K k1, V v1, K k2, V v2) {", "    return ImmutableListMultimap.of(k1, v1, k2, v2);"]}
{"Result": "Method without Parameter"}
{"in": ["private long countBySkipping(InputStream in) throws IOException {", "    while ((skipped = skipUpTo(in, Integer.MAX_VALUE)) > 0) {", "      count += skipped;", "    return count;"]}
{"Result": "Method without Parameter"}
{"hashFunction": ["public HashCode hash(HashFunction hashFunction) throws IOException {", "    Hasher hasher = hashFunction.newHasher();"]}
{"other": ["public boolean contentEquals(ByteSource other) throws IOException {", "    checkNotNull(other);", "      InputStream in2 = closer.register(other.openStream());"]}
{"Result": "Method without Parameter"}
{"range": ["public static <K extends Comparable<?>, V> ImmutableRangeMap<K, V> of(Range<K> range, V value) {", "    return new ImmutableRangeMap<>(ImmutableList.of(range), ImmutableList.of(value));"], "value": ["public static <K extends Comparable<?>, V> ImmutableRangeMap<K, V> of(Range<K> range, V value) {", "    return new ImmutableRangeMap<>(ImmutableList.of(range), ImmutableList.of(value));"]}
{"first": ["      HashFunction first, HashFunction second, HashFunction... rest) {", "    list.add(first);"], "second": ["      HashFunction first, HashFunction second, HashFunction... rest) {", "    list.add(second);"]}
{"element": ["public static <E extends Comparable<? super E>> ImmutableSortedSet<E> of(E element) {", "    return new RegularImmutableSortedSet<E>(ImmutableList.of(element), Ordering.natural());"]}
{"expectedNodeCount": ["public ValueGraphBuilder<N, V> expectedNodeCount(int expectedNodeCount) {"]}
{"comparator": ["public static <T, S extends T> Comparator<Iterable<S>> lexicographical(Comparator<T> comparator) {", "    return new LexicographicalOrdering<S>(checkNotNull(comparator));"]}
{"finalizableReferenceClass": ["      Class<?> finalizableReferenceClass,", "    if (!finalizableReferenceClass.getName().equals(FINALIZABLE_REFERENCE)) {", "    Finalizer finalizer = new Finalizer(finalizableReferenceClass, queue, frqReference);"], "queue": ["      ReferenceQueue<Object> queue,", "    Finalizer finalizer = new Finalizer(finalizableReferenceClass, queue, frqReference);"], "frqReference": ["      PhantomReference<Object> frqReference) {", "    Finalizer finalizer = new Finalizer(finalizableReferenceClass, queue, frqReference);", "                (ThreadGroup) null, finalizer, threadName, defaultStackSize, inheritThreadLocals);", "      thread = new Thread((ThreadGroup) null, finalizer, threadName);"]}
{"Result": "Method without Parameter"}
{"k1": ["public static <K extends Comparable<? super K>, V> ImmutableSortedMap<K, V> of(K k1, V v1) {", "    return of(Ordering.natural(), k1, v1);"], "v1": ["public static <K extends Comparable<? super K>, V> ImmutableSortedMap<K, V> of(K k1, V v1) {", "    return of(Ordering.natural(), k1, v1);"]}
{"k1": ["      K k1, V v1, K k2, V v2) {", "    return ofEntries(entryOf(k1, v1), entryOf(k2, v2));"], "v1": ["      K k1, V v1, K k2, V v2) {", "    return ofEntries(entryOf(k1, v1), entryOf(k2, v2));"], "k2": ["      K k1, V v1, K k2, V v2) {", "    return ofEntries(entryOf(k1, v1), entryOf(k2, v2));"], "v2": ["      K k1, V v1, K k2, V v2) {", "    return ofEntries(entryOf(k1, v1), entryOf(k2, v2));"]}
{"map": ["  public static <K, V> ImmutableSortedMap<K, V> copyOfSorted(SortedMap<K, ? extends V> map) {", "    Comparator<? super K> comparator = map.comparator();", "    if (map instanceof ImmutableSortedMap) {", "      ImmutableSortedMap<K, V> kvMap = (ImmutableSortedMap<K, V>) map;", "      if (!kvMap.isPartialView()) {", "        return kvMap;", "    return fromEntries(comparator, true, map.entrySet());"]}
{"bytes": ["      byte[] bytes, int offset, long seedA, long seedB, long[] output) {", "    long part1 = load64(bytes, offset);", "    long part2 = load64(bytes, offset + 8);", "    long part3 = load64(bytes, offset + 16);", "    long part4 = load64(bytes, offset + 24);"], "offset": ["      byte[] bytes, int offset, long seedA, long seedB, long[] output) {", "    long part1 = load64(bytes, offset);", "    long part2 = load64(bytes, offset + 8);", "    long part3 = load64(bytes, offset + 16);", "    long part4 = load64(bytes, offset + 24);", "    seedA += part1;", "    seedB = rotateRight(seedB + seedA + part4, 21);", "    long c = seedA;", "    output[1] = seedB + c;"], "seedA": [], "seedB": ["      byte[] bytes, int offset, long seedA, long seedB, long[] output) {", "    seedB = rotateRight(seedB + seedA + part4, 21);"], "output": []}
{"expected": ["  private void checkCurrentState(State expected) {", "    if (actual != expected) {", "            \"Expected the service \" + this + \" to be \" + expected + \", but the service has FAILED\",", "          \"Expected the service \" + this + \" to be \" + expected + \", but was \" + actual);"]}
{"dir": ["public static ImmutableList<Path> listFiles(Path dir) throws IOException {", "    try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {"]}
{"dir": ["      SecureDirectoryStream<Path> dir, Path name, LinkOption... options) throws IOException {", "    return dir.getFileAttributeView(name, BasicFileAttributeView.class, options)"], "name": ["      SecureDirectoryStream<Path> dir, Path name, LinkOption... options) throws IOException {", "    return dir.getFileAttributeView(name, BasicFileAttributeView.class, options)"]}
{"path1": ["public static boolean equal(Path path1, Path path2) throws IOException {", "    checkNotNull(path1);", "    if (Files.isSameFile(path1, path2)) {", "    ByteSource source1 = asByteSource(path1);", "    long len1 = source1.sizeIfKnown().or(0L);", "    return source1.contentEquals(source2);"], "path2": ["public static boolean equal(Path path1, Path path2) throws IOException {", "    checkNotNull(path2);", "    if (Files.isSameFile(path1, path2)) {", "    ByteSource source2 = asByteSource(path2);", "    long len2 = source2.sizeIfKnown().or(0L);", "    return source1.contentEquals(source2);"]}
{"path": ["  public static void touch(Path path) throws IOException {", "    checkNotNull(path);", "      Files.setLastModifiedTime(path, FileTime.fromMillis(System.currentTimeMillis()));", "        Files.createFile(path);"]}
{"path": ["private static @Nullable Path getParentPath(Path path) {", "    Path parent = path.getParent();", "    if (path.getNameCount() == 0) {", "      return path.getFileSystem().getPath(\".\");"]}
{"path": ["private static void checkAllowsInsecure(Path path, RecursiveDeleteOption[] options)", "      throw new InsecureRecursiveDeleteException(path.toString());"], "options": ["private static void checkAllowsInsecure(Path path, RecursiveDeleteOption[] options)", "    if (!Arrays.asList(options).contains(RecursiveDeleteOption.ALLOW_INSECURE)) {"]}
{"path": ["private static void throwDeleteFailed(Path path, Collection<IOException> exceptions)", "            path.toString(),"], "exceptions": ["private static void throwDeleteFailed(Path path, Collection<IOException> exceptions)", "    for (IOException e : exceptions) {", "      deleteFailed.addSuppressed(e);"]}
{"h": ["static int rehash(int h) {", "    h += (h << 15) ^ 0xffffcd7d;"]}
{"hash": ["Segment<K, V, E, S> segmentFor(int hash) {", "    return segments[(hash >>> segmentShift) & segmentMask];"]}
{"list": ["static <E> ImmutableList<E> unsafeDelegateList(List<? extends E> list) {", "    switch (list.size()) {", "        return of(list.get(0));", "        List<E> castedList = (List<E>) list;", "        return new RegularImmutableList<E>(castedList);"]}
{"range": ["private Range<K> coalescedRange(Range<K> range, V value) {", "    Range<K> coalescedRange = range;", "        entriesByLowerBound.lowerEntry(range.lowerBound);", "    coalescedRange = coalesce(coalescedRange, value, lowerEntry);", "        entriesByLowerBound.floorEntry(range.upperBound);"], "value": ["private Range<K> coalescedRange(Range<K> range, V value) {", "    coalescedRange = coalesce(coalescedRange, value, lowerEntry);", "    coalescedRange = coalesce(coalescedRange, value, higherEntry);"]}
{"listener": ["void unregister(Object listener) {", "    Multimap<Class<?>, Subscriber> listenerMethods = findAllSubscribers(listener);", "    for (Entry<Class<?>, Collection<Subscriber>> entry : listenerMethods.asMap().entrySet()) {", "      Class<?> eventType = entry.getKey();", "      Collection<Subscriber> listenerMethodsForType = entry.getValue();", "      CopyOnWriteArraySet<Subscriber> currentSubscribers = subscribers.get(eventType);", "      if (currentSubscribers == null || !currentSubscribers.removeAll(listenerMethodsForType)) {", "            \"missing event subscriber for an annotated method. Is \" + listener + \" registered?\");"]}
{"event": ["Iterator<Subscriber> getSubscribers(Object event) {", "    ImmutableSet<Class<?>> eventTypes = flattenHierarchy(event.getClass());"]}
{"listener": ["private Multimap<Class<?>, Subscriber> findAllSubscribers(Object listener) {", "    Class<?> clazz = listener.getClass();", "      methodsInListener.put(eventType, Subscriber.create(bus, listener, method));"]}
{"elements": ["      Iterable<? extends E> elements) {", "    Comparable<?>[] array = Iterables.toArray(elements, new Comparable<?>[0]);"]}
{"elements": ["static <E> ImmutableList<E> asImmutableList(Object[] elements) {", "    return asImmutableList(elements, elements.length);"]}
{"elements": ["static <E> ImmutableList<E> asImmutableList(Object[] elements, int length) {", "    return new RegularImmutableList<E>(elements, length);"], "length": ["static <E> ImmutableList<E> asImmutableList(Object[] elements, int length) {", "    if (length == 0) {", "    return new RegularImmutableList<E>(elements, length);"]}
{"expectedSize": ["  public static <E> Builder<E> builderWithExpectedSize(int expectedSize) {", "    checkNonnegative(expectedSize, \"expectedSize\");", "    return new ImmutableList.Builder<E>(expectedSize);"]}
{"first": ["  public static <T> T[] concat(T[] first, T[] second, Class<T> type) {", "    T[] result = newArray(type, first.length + second.length);", "    System.arraycopy(first, 0, result, 0, first.length);", "    System.arraycopy(second, 0, result, first.length, second.length);"], "second": ["  public static <T> T[] concat(T[] first, T[] second, Class<T> type) {", "    T[] result = newArray(type, first.length + second.length);", "    System.arraycopy(second, 0, result, first.length, second.length);"], "type": ["  public static <T> T[] concat(T[] first, T[] second, Class<T> type) {", "    T[] result = newArray(type, first.length + second.length);"]}
{"c": ["static <T> T[] toArrayImpl(Collection<?> c, T[] array) {", "    int size = c.size();", "    fillArray(c, array);"], "array": ["static <T> T[] toArrayImpl(Collection<?> c, T[] array) {", "    if (array.length < size) {", "      array = newArray(array, size);", "    fillArray(c, array);", "    if (array.length > size) {", "    return array;"]}
{"element": ["  static Object checkElementNotNull(Object element, int index) {", "    if (element == null) {", "    return element;"], "index": ["  static Object checkElementNotNull(Object element, int index) {", "      throw new NullPointerException(\"at index \" + index);"]}
{"Result": "Method without Parameter"}
{"declaration": ["      TypeVariable<?> declaration, WildcardType type) {", "    Type[] declared = declaration.getBounds();"], "type": ["      TypeVariable<?> declaration, WildcardType type) {", "    for (Type bound : type.getUpperBounds()) {", "      if (!any(declared).isSubtypeOf(bound)) {", "        upperBounds.add(canonicalizeWildcardsInType(bound));", "    return new Types.WildcardTypeImpl(type.getLowerBounds(), upperBounds.toArray(new Type[0]));"]}
{"elements": ["static <E> ImmutableList<E> asImmutableList(Object[] elements, int length) {", "        return of((E) elements[0]);", "        if (length < elements.length) {", "          elements = Arrays.copyOf(elements, length);", "        return new RegularImmutableList<E>(elements);"], "length": ["static <E> ImmutableList<E> asImmutableList(Object[] elements, int length) {", "    switch (length) {", "        if (length < elements.length) {", "          elements = Arrays.copyOf(elements, length);", "        return new RegularImmutableList<E>(elements);"]}
{"expectedSize": []}
{"Result": "Method without Parameter"}
{"sawNewline": ["  private boolean finishLine(boolean sawNewline) throws IOException {", "    String separator = sawReturn ? (sawNewline ? \"\\r\\n\" : \"\\r\") : (sawNewline ? \"\\n\" : \"\");", "    return sawNewline;"]}
{"function": ["      final Function<? super V1, V2> function) {", "    checkNotNull(function);", "        return function.apply(value);"]}
{"transformer": ["      final EntryTransformer<? super K, ? super V1, V2> transformer, final Entry<K, V1> entry) {", "    checkNotNull(transformer);", "        return transformer.transformEntry(entry.getKey(), entry.getValue());"], "entry": ["      final EntryTransformer<? super K, ? super V1, V2> transformer, final Entry<K, V1> entry) {", "    checkNotNull(entry);", "        return entry.getKey();", "        return transformer.transformEntry(entry.getKey(), entry.getValue());"]}
{"transformer": ["      final EntryTransformer<? super K, ? super V1, V2> transformer) {", "    checkNotNull(transformer);", "        return transformEntry(transformer, entry);"]}
{"list": ["static <E> ImmutableMap<E, Integer> indexMap(Collection<E> list) {", "    ImmutableMap.Builder<E, Integer> builder = new ImmutableMap.Builder<>(list.size());", "    for (E e : list) {", "      builder.put(e, i++);"]}
{"Result": "Method without Parameter"}
{"b": ["protected void update(ByteBuffer b) {", "    if (b.hasArray()) {", "      update(b.array(), b.arrayOffset() + b.position(), b.remaining());", "      b.position(b.limit());", "      for (int remaining = b.remaining(); remaining > 0; remaining--) {", "        update(b.get());"]}
{"delegate": ["      SortedSet<E> delegate, boolean isSubset) {", "    return delegate.isEmpty()", "        ? emptySet(delegate.comparator())", "        : new RegularImmutableSortedSet<E>(delegate, isSubset);"], "isSubset": ["      SortedSet<E> delegate, boolean isSubset) {", "        : new RegularImmutableSortedSet<E>(delegate, isSubset);"]}
{"reader": ["  public static ImmutableSetMultimap<Object, Object> instantiate(SerializationStreamReader reader)", "    Comparator<Object> valueComparator = (Comparator<Object>) reader.readObject();", "        Multimap_CustomFieldSerializerBase.instantiate(reader, builder);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"from": ["public static void copy(URL from, OutputStream to) throws IOException {", "    asByteSource(from).copyTo(to);"], "to": ["public static void copy(URL from, OutputStream to) throws IOException {", "    asByteSource(from).copyTo(to);"]}
{"event": ["public void post(Object event) {", "    Iterator<Subscriber> eventSubscribers = subscribers.getSubscribers(event);", "    if (eventSubscribers.hasNext()) {", "      dispatcher.dispatch(event, eventSubscribers);", "    } else if (!(event instanceof DeadEvent)) {", "      post(new DeadEvent(this, event));"]}
{"concurrencyLevel": ["  public MapMaker concurrencyLevel(int concurrencyLevel) {"]}
{"forward": ["void setDelegates(Map<K, V> forward, Map<V, K> backward) {", "    checkArgument(forward.isEmpty());", "    checkArgument(forward != backward);", "    delegate = forward;"], "backward": ["void setDelegates(Map<K, V> forward, Map<V, K> backward) {", "    checkArgument(backward.isEmpty());", "    checkArgument(forward != backward);", "    inverse = makeInverse(backward);"]}
{"valueClass": ["  public V[][] toArray(Class<V> valueClass) {", "    V[][] copy = (V[][]) Array.newInstance(valueClass, rowList.size(), columnList.size());"]}
{"task": ["  public void execute(final Runnable task) {", "    checkNotNull(task);", "        queue.add(task);", "              task.run();"]}
{"fromTable": ["      Table<R, C, V1> fromTable, Function<? super V1, V2> function) {", "    return new TransformedTable<>(fromTable, function);"], "function": ["      Table<R, C, V1> fromTable, Function<? super V1, V2> function) {", "    return new TransformedTable<>(fromTable, function);"]}
{"elements": ["public static <E extends Comparable> TreeMultiset<E> create(Iterable<? extends E> elements) {", "    Iterables.addAll(multiset, elements);"]}
{"seen": ["private static boolean addCausalChain(Set<Throwable> seen, Throwable t) {", "      boolean firstTimeSeen = seen.add(t);", "      if (!firstTimeSeen) {"], "t": ["private static boolean addCausalChain(Set<Throwable> seen, Throwable t) {", "    for (; t != null; t = t.getCause()) {", "      boolean firstTimeSeen = seen.add(t);", "      if (!firstTimeSeen) {"]}
{"duration": ["  public CacheBuilder<K, V> expireAfterWrite(java.time.Duration duration) {", "    return expireAfterWrite(duration.toNanos(), TimeUnit.NANOSECONDS);"]}
{"priority": ["public ThreadFactoryBuilder setPriority(int priority) {", "        priority >= Thread.MIN_PRIORITY,", "        priority,", "        priority <= Thread.MAX_PRIORITY,", "        priority,", "    this.priority = priority;"]}
{"host": ["public static HostAndPort fromParts(String host, int port) {", "    HostAndPort parsedHost = fromString(host);", "    checkArgument(!parsedHost.hasPort(), \"Host has a port: %s\", host);", "    return new HostAndPort(parsedHost.host, port, parsedHost.hasBracketlessColons);"], "port": ["public static HostAndPort fromParts(String host, int port) {", "    checkArgument(isValidPort(port), \"Port out of range: %s\", port);", "    return new HostAndPort(parsedHost.host, port, parsedHost.hasBracketlessColons);"]}
{"host": ["public static HostAndPort fromHost(String host) {", "    HostAndPort parsedHost = fromString(host);", "    checkArgument(!parsedHost.hasPort(), \"Host has a port: %s\", host);", "    return parsedHost;"]}
{"hostPortString": ["public static HostAndPort fromString(String hostPortString) {", "    checkNotNull(hostPortString);", "    if (hostPortString.startsWith(\"[\")) {", "      String[] hostAndPort = getHostAndPortFromBracketedHost(hostPortString);", "      host = hostAndPort[0];", "      portString = hostAndPort[1];", "      int colonPos = hostPortString.indexOf(':');", "      if (colonPos >= 0 && hostPortString.indexOf(':', colonPos + 1) == -1) {", "        host = hostPortString.substring(0, colonPos);", "        portString = hostPortString.substring(colonPos + 1);", "        host = hostPortString;", "      checkArgument(!portString.startsWith(\"+\"), \"Unparseable port number: %s\", hostPortString);", "        throw new IllegalArgumentException(\"Unparseable port number: \" + hostPortString);", "      checkArgument(isValidPort(port), \"Port number out of range: %s\", hostPortString);", "    return new HostAndPort(host, port, hasBracketlessColons);"]}
{"hostPortString": ["private static String[] getHostAndPortFromBracketedHost(String hostPortString) {", "        hostPortString.charAt(0) == '[',", "        hostPortString);", "    colonIndex = hostPortString.indexOf(':');", "    closeBracketIndex = hostPortString.lastIndexOf(']');", "        hostPortString);", "    String host = hostPortString.substring(1, closeBracketIndex);", "    if (closeBracketIndex + 1 == hostPortString.length()) {", "          hostPortString.charAt(closeBracketIndex + 1) == ':',", "          hostPortString);", "      for (int i = closeBracketIndex + 2; i < hostPortString.length(); ++i) {", "            Character.isDigit(hostPortString.charAt(i)),", "            hostPortString);", "      return new String[] {host, hostPortString.substring(closeBracketIndex + 2)};"]}
{"comparator": ["static <T> GeneralRange<T> all(Comparator<? super T> comparator) {", "    return new GeneralRange<T>(comparator, false, null, OPEN, false, null, OPEN);"]}
{"Result": "Method without Parameter"}
{"delegate": ["static <E> ImmutableSet<E> unsafeDelegate(Set<E> delegate) {", "    switch (delegate.size()) {", "        return new SingletonImmutableSet<E>(delegate.iterator().next());", "        return new RegularImmutableSet<E>(delegate);"]}
{"Result": "Method without Parameter"}
{"lock": ["private void aboutToAcquire(CycleDetectingLock lock) {", "    if (!lock.isAcquiredByCurrentThread()) {", "      LockGraphNode node = lock.getLockGraphNode();"]}
{"range": ["  public ImmutableRangeSet<C> subRangeSet(Range<C> range) {", "      if (range.encloses(span)) {", "      } else if (range.isConnected(span)) {", "        return new ImmutableRangeSet<C>(intersectRanges(range));"]}
{"entry": ["static <K, V> ImmutableMapEntry<K, V> makeImmutable(Entry<K, V> entry, K key, V value) {", "        entry instanceof ImmutableMapEntry && ((ImmutableMapEntry<K, V>) entry).isReusable();", "    return reusable ? (ImmutableMapEntry<K, V>) entry : new ImmutableMapEntry<K, V>(key, value);"], "key": ["static <K, V> ImmutableMapEntry<K, V> makeImmutable(Entry<K, V> entry, K key, V value) {", "    return reusable ? (ImmutableMapEntry<K, V>) entry : new ImmutableMapEntry<K, V>(key, value);"], "value": ["static <K, V> ImmutableMapEntry<K, V> makeImmutable(Entry<K, V> entry, K key, V value) {", "    return reusable ? (ImmutableMapEntry<K, V>) entry : new ImmutableMapEntry<K, V>(key, value);"]}
{"entry": ["static <K, V> ImmutableMapEntry<K, V> makeImmutable(Entry<K, V> entry) {", "    return makeImmutable(entry, entry.getKey(), entry.getValue());"]}
{"escaper": ["private static UnicodeEscaper wrap(final CharEscaper escaper) {", "          return escaper.escape((char) cp);", "        char[] hiChars = escaper.escape(surrogateChars[0]);", "        char[] loChars = escaper.escape(surrogateChars[1]);"]}
{"x": ["public void add(double x, double y) {", "    xStats.add(x);", "    if (isFinite(x) && isFinite(y)) {", "        sumOfProductsOfDeltas += (x - xStats.mean()) * (y - yStats.mean());"], "y": ["public void add(double x, double y) {", "    if (isFinite(x) && isFinite(y)) {", "        sumOfProductsOfDeltas += (x - xStats.mean()) * (y - yStats.mean());", "    yStats.add(y);"]}
{"k1": ["public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1) {", "    checkEntryNotNull(k1, v1);", "    return new RegularImmutableBiMap<>(new Object[] {k1, v1}, 1);"], "v1": ["public static <K, V> ImmutableBiMap<K, V> of(K k1, V v1) {", "    checkEntryNotNull(k1, v1);", "    return new RegularImmutableBiMap<>(new Object[] {k1, v1}, 1);"]}
{"entries": ["      Iterable<? extends Entry<? extends K, ? extends V>> entries) {", "        (entries instanceof Collection)", "            ? ((Collection<?>) entries).size()", "    return new Builder<K, V>(estimatedSize).putAll(entries).build();"]}
{"Result": "Method without Parameter"}
{"predicate": ["public static <T> Function<T, Boolean> forPredicate(Predicate<T> predicate) {", "    return new PredicateFunction<T>(predicate);"]}
{"Result": "Method without Parameter"}
{"entry": ["boolean isExpired(ReferenceEntry<K, V> entry, long now) {", "    checkNotNull(entry);", "    if (expiresAfterAccess() && (now - entry.getAccessTime() >= expireAfterAccessNanos)) {", "    if (expiresAfterWrite() && (now - entry.getWriteTime() >= expireAfterWriteNanos)) {"], "now": ["boolean isExpired(ReferenceEntry<K, V> entry, long now) {", "    if (expiresAfterAccess() && (now - entry.getAccessTime() >= expireAfterAccessNanos)) {", "    if (expiresAfterWrite() && (now - entry.getWriteTime() >= expireAfterWriteNanos)) {"]}
{"permits": ["final long reserveAndGetWaitLength(int permits, long nowMicros) {", "    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);"], "nowMicros": ["final long reserveAndGetWaitLength(int permits, long nowMicros) {", "    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);", "    return max(momentAvailable - nowMicros, 0);"]}
{"seq": ["protected static int codePointAt(CharSequence seq, int index, int end) {", "    checkNotNull(seq);", "      char c1 = seq.charAt(index++);", "        char c2 = seq.charAt(index);", "                + seq", "                + seq"], "index": ["protected static int codePointAt(CharSequence seq, int index, int end) {", "    if (index < end) {"], "end": ["protected static int codePointAt(CharSequence seq, int index, int end) {", "    if (index < end) {", "        if (index == end) {"]}
{"minCapacity": ["private void ensureCapacity(int minCapacity) {", "    if (nextInBucketKToV.length < minCapacity) {", "      int newCapacity = ImmutableCollection.Builder.expandedCapacity(oldCapacity, minCapacity);", "      keys = Arrays.copyOf(keys, newCapacity);", "      values = Arrays.copyOf(values, newCapacity);", "      nextInBucketKToV = expandAndFillWithAbsent(nextInBucketKToV, newCapacity);", "      nextInBucketVToK = expandAndFillWithAbsent(nextInBucketVToK, newCapacity);", "      prevInInsertionOrder = expandAndFillWithAbsent(prevInInsertionOrder, newCapacity);", "      nextInInsertionOrder = expandAndFillWithAbsent(nextInInsertionOrder, newCapacity);", "    if (hashTableKToV.length < minCapacity) {", "      int newTableSize = Hashing.closedTableSize(minCapacity, 1.0);", "      for (int entryToRehash = 0; entryToRehash < size; entryToRehash++) {", "        int keyHash = Hashing.smearedHash(keys[entryToRehash]);", "        int keyBucket = bucket(keyHash);", "        nextInBucketKToV[entryToRehash] = hashTableKToV[keyBucket];", "        hashTableKToV[keyBucket] = entryToRehash;", "        int valueHash = Hashing.smearedHash(values[entryToRehash]);", "        int valueBucket = bucket(valueHash);", "        nextInBucketVToK[entryToRehash] = hashTableVToK[valueBucket];", "        hashTableVToK[valueBucket] = entryToRehash;"]}
{"entry": ["private void insertIntoTableKToV(int entry, int keyHash) {", "    checkArgument(entry != ABSENT);"], "keyHash": ["private void insertIntoTableKToV(int entry, int keyHash) {", "    int keyBucket = bucket(keyHash);", "    nextInBucketKToV[entry] = hashTableKToV[keyBucket];", "    hashTableKToV[keyBucket] = entry;"]}
{"entry": ["private void insertIntoTableVToK(int entry, int valueHash) {", "    checkArgument(entry != ABSENT);"], "valueHash": ["private void insertIntoTableVToK(int entry, int valueHash) {", "    int valueBucket = bucket(valueHash);", "    nextInBucketVToK[entry] = hashTableVToK[valueBucket];", "    hashTableVToK[valueBucket] = entry;"]}
{"entry": ["private void deleteFromTableKToV(int entry, int keyHash) {", "    checkArgument(entry != ABSENT);", "    if (hashTableKToV[keyBucket] == entry) {", "      hashTableKToV[keyBucket] = nextInBucketKToV[entry];", "    int prevInBucket = hashTableKToV[keyBucket];", "    for (int entryInBucket = nextInBucketKToV[prevInBucket];", "        entryInBucket != ABSENT;", "        entryInBucket = nextInBucketKToV[entryInBucket]) {", "      if (entryInBucket == entry) {", "        nextInBucketKToV[prevInBucket] = nextInBucketKToV[entry];", "      prevInBucket = entryInBucket;", "    throw new AssertionError(\"Expected to find entry with key \" + keys[entry]);"], "keyHash": ["private void deleteFromTableKToV(int entry, int keyHash) {", "    int keyBucket = bucket(keyHash);", "    if (hashTableKToV[keyBucket] == entry) {", "    int prevInBucket = hashTableKToV[keyBucket];", "    for (int entryInBucket = nextInBucketKToV[prevInBucket];", "        entryInBucket != ABSENT;", "        entryInBucket = nextInBucketKToV[entryInBucket]) {", "      if (entryInBucket == entry) {", "      prevInBucket = entryInBucket;"]}
{"entry": ["private void deleteFromTableVToK(int entry, int valueHash) {", "    checkArgument(entry != ABSENT);", "    if (hashTableVToK[valueBucket] == entry) {", "      hashTableVToK[valueBucket] = nextInBucketVToK[entry];", "    int prevInBucket = hashTableVToK[valueBucket];", "    for (int entryInBucket = nextInBucketVToK[prevInBucket];", "        entryInBucket != ABSENT;", "        entryInBucket = nextInBucketVToK[entryInBucket]) {", "      if (entryInBucket == entry) {", "        nextInBucketVToK[prevInBucket] = nextInBucketVToK[entry];", "      prevInBucket = entryInBucket;", "    throw new AssertionError(\"Expected to find entry with value \" + values[entry]);"], "valueHash": ["private void deleteFromTableVToK(int entry, int valueHash) {", "    int valueBucket = bucket(valueHash);", "    if (hashTableVToK[valueBucket] == entry) {", "    int prevInBucket = hashTableVToK[valueBucket];", "    for (int entryInBucket = nextInBucketVToK[prevInBucket];", "        entryInBucket != ABSENT;", "        entryInBucket = nextInBucketVToK[entryInBucket]) {", "      if (entryInBucket == entry) {", "      prevInBucket = entryInBucket;"]}
{"entry": ["private void removeEntry(int entry, int keyHash, int valueHash) {", "    checkArgument(entry != ABSENT);", "    deleteFromTableKToV(entry, keyHash);", "    deleteFromTableVToK(entry, valueHash);", "    int oldPredecessor = prevInInsertionOrder[entry];", "    int oldSuccessor = nextInInsertionOrder[entry];", "    setSucceeds(oldPredecessor, oldSuccessor);", "    moveEntryToIndex(size - 1, entry);"], "keyHash": ["private void removeEntry(int entry, int keyHash, int valueHash) {", "    deleteFromTableKToV(entry, keyHash);"], "valueHash": ["private void removeEntry(int entry, int keyHash, int valueHash) {", "    deleteFromTableVToK(entry, valueHash);"]}
{"entry": ["void removeEntryKeyHashKnown(int entry, int keyHash) {", "    removeEntry(entry, keyHash, Hashing.smearedHash(values[entry]));"], "keyHash": ["void removeEntryKeyHashKnown(int entry, int keyHash) {", "    removeEntry(entry, keyHash, Hashing.smearedHash(values[entry]));"]}
{"entry": ["void removeEntryValueHashKnown(int entry, int valueHash) {", "    removeEntry(entry, Hashing.smearedHash(keys[entry]), valueHash);"], "valueHash": ["void removeEntryValueHashKnown(int entry, int valueHash) {", "    removeEntry(entry, Hashing.smearedHash(keys[entry]), valueHash);"]}
{"expectedNodeCount": ["public NetworkBuilder<N, E> expectedNodeCount(int expectedNodeCount) {"]}
{"expectedEdgeCount": ["public NetworkBuilder<N, E> expectedEdgeCount(int expectedEdgeCount) {"]}
{"Result": "Method without Parameter"}
{"name": ["public void setParameterValue(final String name, final Object value) {", "    namedParameterValues.put(name, new Value(value));"], "value": ["public void setParameterValue(final String name, final Object value) {", "    namedParameterValues.put(name, new Value(value));"]}
{"o": ["public static byte[] objectToBlob(Object o) {", "            return SerializerContext.getInstance().serialize(o);"]}
{"blob": ["public static <T> T blobToObject(byte[] blob, Class<T> type) {", "            return SerializerContext.getInstance().deSerialize(blob, type);"], "type": ["public static <T> T blobToObject(byte[] blob, Class<T> type) {", "            return SerializerContext.getInstance().deSerialize(blob, type);"]}
{"groupId": ["private void lockDataLine(String groupId, String unitId, Set<String> lockIdSet, boolean isXLock) throws TxcLogicException {", "            if (!reliableMessenger.acquireLocks(groupId, lockIdSet, isXLock ? DTXLocks.X_LOCK : DTXLocks.S_LOCK)) {", "            globalContext.addTxcLockId(groupId, unitId, lockIdSet);"], "unitId": ["private void lockDataLine(String groupId, String unitId, Set<String> lockIdSet, boolean isXLock) throws TxcLogicException {", "            globalContext.addTxcLockId(groupId, unitId, lockIdSet);"], "lockIdSet": ["private void lockDataLine(String groupId, String unitId, Set<String> lockIdSet, boolean isXLock) throws TxcLogicException {", "            if (!reliableMessenger.acquireLocks(groupId, lockIdSet, isXLock ? DTXLocks.X_LOCK : DTXLocks.S_LOCK)) {", "            globalContext.addTxcLockId(groupId, unitId, lockIdSet);"], "isXLock": ["private void lockDataLine(String groupId, String unitId, Set<String> lockIdSet, boolean isXLock) throws TxcLogicException {", "            if (!reliableMessenger.acquireLocks(groupId, lockIdSet, isXLock ? DTXLocks.X_LOCK : DTXLocks.S_LOCK)) {"]}
{"groupId": ["private void saveUndoLog(String groupId, String unitId, int sqlType, TableRecordList recordList) throws TxcLogicException {", "        undoLogDO.setGroupId(groupId);"], "unitId": ["private void saveUndoLog(String groupId, String unitId, int sqlType, TableRecordList recordList) throws TxcLogicException {", "        undoLogDO.setUnitId(unitId);"], "sqlType": ["private void saveUndoLog(String groupId, String unitId, int sqlType, TableRecordList recordList) throws TxcLogicException {", "        undoLogDO.setSqlType(sqlType);"], "recordList": ["private void saveUndoLog(String groupId, String unitId, int sqlType, TableRecordList recordList) throws TxcLogicException {", "        undoLogDO.setRollbackInfo(SqlUtils.objectToBlob(recordList));"]}
{"redisConnectionFactory": ["    public RedisTemplate<String, Object> functionDomainRedisTemplate(RedisConnectionFactory redisConnectionFactory) {", "        redisTemplate.setConnectionFactory(redisConnectionFactory);"]}
{"Result": "Method without Parameter"}
{"filename": ["public static URL locateOnClassPath(String filename) {", "    result = Thread.currentThread().getContextClassLoader().getResource(filename);", "    if (result == null) {", "      result = P6Util.class.getClassLoader().getResource(filename);", "    if (result == null) {", "      result = ClassLoader.getSystemResource(filename);", "    return result;"]}
{"connection": ["public static ConnectionInformation fromConnection(Connection connection) {", "    connectionInformation.connection = connection;", "    return connectionInformation;"]}
{"throwable": ["public Integer mapThrowable(final Throwable throwable) {", "        Throwable throwableToCheck = throwable;", "            Integer resId = mapThrowableFlat(throwableToCheck);", "            if (resId != null) {", "                return resId;", "                throwableToCheck = throwableToCheck.getCause();", "                if (depthToGo <= 0 || throwableToCheck == throwable || throwableToCheck == null) {", "                    Log.d(\"EventBus\", \"No specific message resource ID found for \" + throwable);"]}
{"messager": ["private void checkForSubscribersToSkip(Messager messager, String myPackage) {", "                        messager.printMessage(Diagnostic.Kind.NOTE, msg, subscriberClass);", "                        TypeMirror typeMirror = getParamTypeMirror(param, messager);", "                        if (!(typeMirror instanceof DeclaredType) ||", "                                !(((DeclaredType) typeMirror).asElement() instanceof TypeElement)) {", "                            TypeElement eventTypeElement = (TypeElement) ((DeclaredType) typeMirror).asElement();", "                            if (!isVisible(myPackage, eventTypeElement)) {", "                                messager.printMessage(Diagnostic.Kind.NOTE, msg, param);"], "myPackage": ["private void checkForSubscribersToSkip(Messager messager, String myPackage) {", "                if (!isVisible(myPackage, subscriberClass)) {", "                            if (!isVisible(myPackage, eventTypeElement)) {"]}
{"Result": "Method without Parameter"}
{"subscriber": ["private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {", "        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);", "                throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \"", "        List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);", "        if (subscribedEvents == null) {", "            typesBySubscriber.put(subscriber, subscribedEvents);", "        subscribedEvents.add(eventType);"], "subscriberMethod": ["private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {", "        Class<?> eventType = subscriberMethod.eventType;", "        Subscription newSubscription = new Subscription(subscriber, subscriberMethod);", "            if (subscriptions.contains(newSubscription)) {", "            if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {", "                subscriptions.add(i, newSubscription);", "        if (subscriberMethod.sticky) {", "                        checkPostStickyEventToSubscription(newSubscription, stickyEvent);", "                checkPostStickyEventToSubscription(newSubscription, stickyEvent);"]}
{"subscriber": ["private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {", "                if (subscription.subscriber == subscriber) {"], "eventType": ["private void unsubscribeByEventType(Object subscriber, Class<?> eventType) {", "        List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);", "        if (subscriptions != null) {", "            int size = subscriptions.size();", "                Subscription subscription = subscriptions.get(i);", "                if (subscription.subscriber == subscriber) {", "                    subscriptions.remove(i);"]}
{"subscriber": ["public synchronized void unregister(Object subscriber) {", "        List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);", "        if (subscribedTypes != null) {", "            for (Class<?> eventType : subscribedTypes) {", "                unsubscribeByEventType(subscriber, eventType);", "            typesBySubscriber.remove(subscriber);", "            logger.log(Level.WARNING, \"Subscriber to unregister was not registered before: \" + subscriber.getClass());"]}
{"event": ["public void post(Object event) {", "        eventQueue.add(event);"]}
{"eventType": ["public <T> T getStickyEvent(Class<T> eventType) {", "            return eventType.cast(stickyEvents.get(eventType));"]}
{"eventType": ["public <T> T removeStickyEvent(Class<T> eventType) {", "            return eventType.cast(stickyEvents.remove(eventType));"]}
{"event": ["public boolean removeStickyEvent(Object event) {", "            Class<?> eventType = event.getClass();", "            if (event.equals(existingEvent)) {"]}
{"eventClass": ["private static List<Class<?>> lookupAllEventTypes(Class<?> eventClass) {", "            List<Class<?>> eventTypes = eventTypesCache.get(eventClass);", "            if (eventTypes == null) {", "                Class<?> clazz = eventClass;", "                while (clazz != null) {", "                    eventTypes.add(clazz);", "                    addInterfaces(eventTypes, clazz.getInterfaces());", "                    clazz = clazz.getSuperclass();", "                eventTypesCache.put(eventClass, eventTypes);", "            return eventTypes;"]}
{"eventTypes": ["static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {", "            if (!eventTypes.contains(interfaceClass)) {", "                eventTypes.add(interfaceClass);", "                addInterfaces(eventTypes, interfaceClass.getInterfaces());"], "interfaces": ["static void addInterfaces(List<Class<?>> eventTypes, Class<?>[] interfaces) {", "        for (Class<?> interfaceClass : interfaces) {", "            if (!eventTypes.contains(interfaceClass)) {", "                eventTypes.add(interfaceClass);", "                addInterfaces(eventTypes, interfaceClass.getInterfaces());"]}
{"index": ["public EventBusBuilder addIndex(SubscriberInfoIndex index) {", "        subscriberInfoIndexes.add(index);"]}
{"activity": ["public static void attachTo(Activity activity, boolean finishAfterDialog, Bundle argumentsForErrorDialog) {", "        Object executionScope = activity.getClass();", "        attachTo(activity, executionScope, finishAfterDialog, argumentsForErrorDialog);"], "finishAfterDialog": ["public static void attachTo(Activity activity, boolean finishAfterDialog, Bundle argumentsForErrorDialog) {", "        attachTo(activity, executionScope, finishAfterDialog, argumentsForErrorDialog);"], "argumentsForErrorDialog": ["public static void attachTo(Activity activity, boolean finishAfterDialog, Bundle argumentsForErrorDialog) {", "        attachTo(activity, executionScope, finishAfterDialog, argumentsForErrorDialog);"]}
{"event": ["protected T prepareErrorFragment(ThrowableFailureEvent event, boolean finishAfterDialog,", "        if (event.isSuppressErrorUi()) {", "            String title = getTitleFor(event, bundle);", "            String message = getMessageFor(event, bundle);", "        return createErrorFragment(event, bundle);"], "finishAfterDialog": ["protected T prepareErrorFragment(ThrowableFailureEvent event, boolean finishAfterDialog,", "            bundle.putBoolean(ErrorDialogManager.KEY_FINISH_AFTER_DIALOG, finishAfterDialog);"], "argumentsForErrorDialog": ["            Bundle argumentsForErrorDialog) {", "        if (argumentsForErrorDialog != null) {", "            bundle = (Bundle) argumentsForErrorDialog.clone();"]}
{"event": [], "arguments": []}
{"event": ["protected String getMessageFor(ThrowableFailureEvent event, Bundle arguments) {", "        int msgResId = config.getMessageIdForThrowable(event.throwable);"], "arguments": []}
{"n": ["static <T, F> boolean postCompleteDrain(long n,", "\t\tlong e = n & COMPLETED_MASK;", "\t\t\twhile (e != n) {"], "actual": ["\t\t\tSubscriber<? super T> actual,", "\t\t\t\t\tactual.onComplete();", "\t\t\t\tactual.onNext(t);", "\t\t\t\tactual.onComplete();"], "queue": ["\t\t\tQueue<T> queue,", "\t\t\t\tT t = queue.poll();", "\t\t\t\tif (t == null) {", "\t\t\t\tactual.onNext(t);", "\t\t\tif (queue.isEmpty()) {"], "field": ["\t\t\tAtomicLongFieldUpdater<F> field,", "\t\t\tn = field.get(instance);", "\t\t\tif (n == e) {", "\t\t\t\tn = field.addAndGet(instance, -(e & REQUESTED_MASK));", "\t\t\t\tif ((n & REQUESTED_MASK) == 0L) {", "\t\t\t\te = n & COMPLETED_MASK;"], "instance": ["\t\t\tF instance,", "\t\t\tn = field.get(instance);", "\t\t\tif (n == e) {", "\t\t\t\tn = field.addAndGet(instance, -(e & REQUESTED_MASK));", "\t\t\t\tif ((n & REQUESTED_MASK) == 0L) {", "\t\t\t\te = n & COMPLETED_MASK;"], "isCancelled": ["\t\t\tBooleanSupplier isCancelled) {", "\t\t\t\tif (isCancelled.getAsBoolean()) {", "\t\t\tif (isCancelled.getAsBoolean()) {"]}
{"timeout": ["\tfinal T blockingGet(long timeout, TimeUnit unit) {", "\t\t\t\tif (!await(timeout, unit)) {", "\t\t\t\t\tthrow new IllegalStateException(\"Timeout on blocking read for \" + timeout + \" \" + unit);"], "unit": ["\tfinal T blockingGet(long timeout, TimeUnit unit) {", "\t\t\t\tif (!await(timeout, unit)) {", "\t\t\t\t\tthrow new IllegalStateException(\"Timeout on blocking read for \" + timeout + \" \" + unit);"]}
{"index": ["public final Mono<T> elementAt(int index, T defaultValue) {", "\t\treturn Mono.onAssembly(new MonoElementAt<>(this, index, defaultValue));"], "defaultValue": ["public final Mono<T> elementAt(int index, T defaultValue) {", "\t\treturn Mono.onAssembly(new MonoElementAt<>(this, index, defaultValue));"]}
{"fallback": ["public final Flux<T> onErrorResume(Function<? super Throwable, ? extends Publisher<? extends T>> fallback) {", "\t\treturn onAssembly(new FluxOnErrorResume<>(this, fallback));"]}
{"numRepeat": ["public final Flux<T> repeat(long numRepeat, BooleanSupplier predicate) {", "\t\tif (numRepeat < 0L) {", "\t\tif (numRepeat == 0) {", "\t\treturn defer( () -> repeat(countingBooleanSupplier(predicate, numRepeat)));"], "predicate": ["public final Flux<T> repeat(long numRepeat, BooleanSupplier predicate) {", "\t\treturn defer( () -> repeat(countingBooleanSupplier(predicate, numRepeat)));"]}
{"supplier": ["static <T> Mono<T> convertToMono(Callable<T> supplier) {", "\t\tif (supplier instanceof Fuseable.ScalarCallable) {", "\t\t\tFuseable.ScalarCallable<T> scalarCallable = (Fuseable.ScalarCallable<T>) supplier;", "\t\t\t\tv = scalarCallable.call();", "\t\treturn Mono.onAssembly(new MonoCallable<>(supplier));"]}
{"sequence": ["static long getAndSub(RingBuffer.Sequence sequence, long toSub) {", "\t\t\tr = sequence.getAsLong();", "\t\twhile (!sequence.compareAndSet(r, u));"], "toSub": ["static long getAndSub(RingBuffer.Sequence sequence, long toSub) {", "\t\t\tu = Operators.subOrZero(r, toSub);", "\t\twhile (!sequence.compareAndSet(r, u));"]}
{"s": ["\tpublic static <T> QueueSubscription<T> as(Subscription s) {", "\t\tif (s instanceof QueueSubscription) {", "\t\t\treturn (QueueSubscription<T>) s;"]}
{"s": ["public static void error(Subscriber<?> s, Throwable e) {", "\t\ts.onSubscribe(EmptySubscription.INSTANCE);", "\t\ts.onError(e);"], "e": ["public static void error(Subscriber<?> s, Throwable e) {", "\t\ts.onError(e);"]}
{"updater": ["public static <T> long produced(AtomicLongFieldUpdater<T> updater, T instance, long toSub) {", "\t\t\tr = updater.get(instance);", "\t\t} while (!updater.compareAndSet(instance, r, u));"], "instance": ["public static <T> long produced(AtomicLongFieldUpdater<T> updater, T instance, long toSub) {", "\t\t\tr = updater.get(instance);", "\t\t\tif (r == 0 || r == Long.MAX_VALUE) {", "\t\t\t\treturn r;", "\t\t\tu = subOrZero(r, toSub);", "\t\t} while (!updater.compareAndSet(instance, r, u));"], "toSub": ["public static <T> long produced(AtomicLongFieldUpdater<T> updater, T instance, long toSub) {", "\t\t\tu = subOrZero(r, toSub);", "\t\t} while (!updater.compareAndSet(instance, r, u));", "\t\treturn u;"]}
{"subscriber": ["public static <T> Subscription scalarSubscription(CoreSubscriber<? super T> subscriber,", "\t\treturn new ScalarSubscription<>(subscriber, value);"], "value": ["\t\t\tT value){", "\t\treturn new ScalarSubscription<>(subscriber, value);"]}
{"newLast": ["<U> MonoIgnoreThen<U> shift(Mono<U> newLast) {", "        Objects.requireNonNull(newLast, \"newLast\");", "        return new MonoIgnoreThen<>(b, newLast);"]}
{"spinTimeout": ["public static WaitStrategy phasedOffSleep(long spinTimeout, long yieldTimeout, TimeUnit units) {", "        return phasedOff(spinTimeout, yieldTimeout, units, parking(0));"], "yieldTimeout": ["public static WaitStrategy phasedOffSleep(long spinTimeout, long yieldTimeout, TimeUnit units) {", "        return phasedOff(spinTimeout, yieldTimeout, units, parking(0));"], "units": ["public static WaitStrategy phasedOffSleep(long spinTimeout, long yieldTimeout, TimeUnit units) {", "        return phasedOff(spinTimeout, yieldTimeout, units, parking(0));"]}
{"other": ["public final Mono<Void> and(Publisher<?> other) {", "\t\t\tMono<Void> result = o.whenAdditionalSource(other);", "\t\t\tif (result != null) {", "\t\t\t\treturn result;", "\t\treturn when(this, other);"]}
{"defaultV": ["public final Mono<T> defaultIfEmpty(T defaultV) {", "\t\t\t\t    return Mono.just(defaultV);", "\t\treturn onAssembly(new MonoDefaultIfEmpty<>(this, defaultV));"]}
{"other": ["public final Mono<T> or(Mono<? extends T> other) {", "\t\t\tMono<T> result =  a.orAdditionalSource(other);", "\t\t\tif (result != null) {", "\t\t\t\treturn result;", "\t\treturn first(this, other);"]}
{"fallback": ["\t\t\tT>> fallback) {", "\t\treturn onAssembly(new MonoOnErrorResume<>(this, fallback));"]}
{"Result": "Method without Parameter"}
{"delayError": [], "triggerGenerator": ["\t\t\tFunction<? super T, ? extends Publisher<?>> triggerGenerator) {", "\t\tObjects.requireNonNull(triggerGenerator, \"triggerGenerator\");", "\t\tnewTriggers[oldTriggers.length] = triggerGenerator;", "\t\treturn new MonoDelayUntil<>(this.source, newTriggers);"]}
{"q": ["static <Q, S> void drainMaxLoop(Queue<Q> q, Subscriber<? super S> a, boolean delayError,", "\t\t\t\tQ v = q.poll();", "\t\t\t\tboolean empty = v == null;", "\t\t\t\tif (checkTerminated(d, empty, a, delayError, q, qd)) {", "\t\t\t\tif (empty) {", "\t\t\t\t\tif (qd.accept(a, v)) {", "\t\t\t\t\tq.clear();"], "a": ["static <Q, S> void drainMaxLoop(Queue<Q> q, Subscriber<? super S> a, boolean delayError,", "\t\t\t\tif (checkTerminated(d, empty, a, delayError, q, qd)) {", "\t\t\t\t\tif (qd.accept(a, v)) {", "\t\t\t\t\ta.onError(Exceptions.failWithOverflow(\"Could not emit value due to lack of requests.\"));"], "delayError": ["static <Q, S> void drainMaxLoop(Queue<Q> q, Subscriber<? super S> a, boolean delayError,", "\t\t\t\tif (checkTerminated(d, empty, a, delayError, q, qd)) {"], "dispose": ["\t\t\tDisposable dispose, QueueDrainSubscriber<?, Q, S> qd) {", "\t\t\t\t\tif (dispose != null) {", "\t\t\t\t\t\tdispose.dispose();", "\t\t\t\t\tif (dispose != null) {", "\t\t\t\t\t\tdispose.dispose();"], "qd": ["\t\t\tDisposable dispose, QueueDrainSubscriber<?, Q, S> qd) {", "\t\t\t\tboolean d = qd.done();", "\t\t\t\tif (checkTerminated(d, empty, a, delayError, q, qd)) {", "\t\t\t\tlong r = qd.requested();", "\t\t\t\tif (r != 0L) {", "\t\t\t\t\tif (qd.accept(a, v)) {", "\t\t\t\t\t\tif (r != Long.MAX_VALUE) {", "\t\t\t\t\t\t\tqd.produced(1);", "\t\t\tmissed = qd.leave(-missed);", "\t\t\tif (missed == 0) {"]}
{"source": ["\tstatic <T, R> boolean trySubscribeScalarMap(Publisher<? extends T> source,", "\t\tif (source instanceof Callable) {", "\t\t\t\tt = ((Callable<? extends T>) source).call();"], "s": ["\t\t\tCoreSubscriber<? super R> s,", "\t\t\t\tOperators.error(s, Operators.onOperatorError(e, s.currentContext()));", "\t\t\t\tOperators.complete(s);", "\t\t\t\tOperators.error(s, Operators.onOperatorError(null, e, t, s.currentContext()));", "\t\t\t\t\tOperators.error(s, Operators.onOperatorError(null, e, t, s.currentContext()));", "\t\t\t\t\ts.onSubscribe(Operators.scalarSubscription(s, v));", "\t\t\t\t\tOperators.complete(s);", "\t\t\t\t\tp.subscribe(s);", "\t\t\t\t\tp.subscribe(new FluxHide.SuppressFuseableSubscriber<>(s));"], "mapper": ["\t\t\tFunction<? super T, ? extends Publisher<? extends R>> mapper,", "\t\t\t\tp = Objects.requireNonNull(mapper.apply(t),"], "fuseableExpected": ["\t\t\tboolean fuseableExpected) {", "\t\t\t\tif (!fuseableExpected || p instanceof Fuseable) {"]}
{"converter": ["public final <U> U as(Function<? super ParallelFlux<T>, U> converter) {", "\t\treturn converter.apply(this);"]}
{"collectionSupplier": ["public final <C> ParallelFlux<C> collect(Supplier<? extends C> collectionSupplier,", "\t\treturn onAssembly(new ParallelCollect<>(this, collectionSupplier, collector));"], "collector": ["\t\t\tBiConsumer<? super C, ? super T> collector) {", "\t\treturn onAssembly(new ParallelCollect<>(this, collectionSupplier, collector));"]}
{"mapper": ["public final <R> ParallelFlux<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper) {", "\t\treturn concatMap(mapper, 2, ErrorMode.IMMEDIATE);"]}
{"onCancel": ["public final ParallelFlux<T> doOnCancel(Runnable onCancel) {", "\t\tObjects.requireNonNull(onCancel, \"onCancel\");", "\t\treturn doOnSignal(this, null, null, null, null, null, null, null, onCancel);"]}
{"onComplete": ["public final ParallelFlux<T> doOnComplete(Runnable onComplete) {", "\t\tObjects.requireNonNull(onComplete, \"onComplete\");", "\t\treturn doOnSignal(this, null, null, null, onComplete, null, null, null, null);"]}
{"onError": ["public final ParallelFlux<T> doOnError(Consumer<? super Throwable> onError) {", "\t\tObjects.requireNonNull(onError, \"onError\");", "\t\treturn doOnSignal(this, null, null, onError, null, null, null, null, null);"]}
{"onRequest": ["public final ParallelFlux<T> doOnRequest(LongConsumer onRequest) {", "\t\tObjects.requireNonNull(onRequest, \"onRequest\");", "\t\treturn doOnSignal(this, null, null, null, null, null, null, onRequest, null);"]}
{"mapper": ["public final <R> ParallelFlux<R> flatMap(Function<? super T, ? extends Publisher<? extends R>> mapper,", "\t\t\t\tmapper,"], "delayError": ["\t\t\tboolean delayError,", "\t\t\t\tdelayError,"], "maxConcurrency": ["\t\t\tint maxConcurrency,", "\t\t\t\tmaxConcurrency,", "\t\t\t\tQueues.get(maxConcurrency),"], "prefetch": ["\t\t\tint prefetch) {", "\t\t\t\tprefetch, Queues.get(prefetch)));"]}
{"prefetch": ["public final Flux<T> sequential(int prefetch) {", "\t\t\t\tprefetch,", "\t\t\t\tQueues.get(prefetch)));"]}
{"subscribers": ["protected final boolean validate(Subscriber<?>[] subscribers) {", "\t\tif (subscribers.length != p) {", "\t\t\t\t\t\"\" + p + \", subscribers = \" + subscribers.length);", "\t\t\tfor (Subscriber<?> s : subscribers) {", "\t\t\t\tOperators.error(s, iae);"]}
{"mapper": ["final <R> ParallelFlux<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper,", "\t\t\t\tmapper,"], "prefetch": ["\t\t\tint prefetch,", "\t\t\t\tQueues.get(prefetch),", "\t\t\t\tprefetch,"], "errorMode": ["\t\t\tErrorMode errorMode) {", "\t\t\t\terrorMode));"]}
{"mapper": ["\t\t\tPublisher<? extends R>> mapper,", "\t\treturn concatMap(mapper, prefetch, delayUntilEnd ? ErrorMode.END: ErrorMode.BOUNDARY);"], "delayUntilEnd": ["\t\t\tboolean delayUntilEnd,", "\t\treturn concatMap(mapper, prefetch, delayUntilEnd ? ErrorMode.END: ErrorMode.BOUNDARY);"], "prefetch": ["\t\t\tint prefetch) {", "\t\treturn concatMap(mapper, prefetch, delayUntilEnd ? ErrorMode.END: ErrorMode.BOUNDARY);"]}
{"field": ["\tpublic static <T> Throwable terminate(AtomicReferenceFieldUpdater<T, Throwable> field,", "\t\tThrowable current = field.get(instance);", "\t\t\tcurrent = field.getAndSet(instance, TERMINATED);"], "instance": ["\t\t\tT instance) {", "\t\tThrowable current = field.get(instance);", "\t\tif (current != TERMINATED) {", "\t\t\tcurrent = field.getAndSet(instance, TERMINATED);", "\t\treturn current;"]}
{"signalType": ["void log(SignalType signalType, Object signalValue) {", "\t\t\tlog.trace(line, signalType, signalValue);", "\t\t\tlog.debug(line, signalType, signalValue);", "\t\t\tlog.info(line, signalType, signalValue);", "\t\t\tlog.warn(line, signalType, signalValue);", "\t\t\tlog.error(line, signalType, signalValue);"], "signalValue": ["void log(SignalType signalType, Object signalValue) {", "\t\t\tlog.trace(line, signalType, signalValue);", "\t\t\tlog.debug(line, signalType, signalValue);", "\t\t\tlog.info(line, signalType, signalValue);", "\t\t\tlog.warn(line, signalType, signalValue);", "\t\t\tlog.error(line, signalType, signalValue);"]}
{"listener": ["public boolean start(final FileDownloadListener listener, final boolean isSerial) {", "        if (listener == null) {", "                ? getQueuesHandler().startQueueSerial(listener)", "                : getQueuesHandler().startQueueParallel(listener);"], "isSerial": ["public boolean start(final FileDownloadListener listener, final boolean isSerial) {", "                    + \"provided is null: [null, %B]\", isSerial);", "        return isSerial"]}
{"Result": "Method without Parameter"}
{"downloadId": ["public long getSoFar(final int downloadId) {", "        BaseDownloadTask.IRunningTask task = FileDownloadList.getImpl().get(downloadId);", "        if (task == null) {", "            return FileDownloadServiceProxy.getImpl().getSofar(downloadId);", "        return task.getOrigin().getLargeFileSoFarBytes();"]}
{"Result": "Method without Parameter"}
{"count": ["public boolean setMaxNetworkThreadCount(final int count) {", "        return FileDownloadServiceProxy.getImpl().setMaxNetworkThreadCount(count);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"destination": ["                    destination) {", "                if (!destination.contains(iRunningTask)) {", "                    destination.add(iRunningTask);"]}
{"task": ["void addUnchecked(final BaseDownloadTask.IRunningTask task) {", "        if (task.isMarkedAdded2List()) {", "            if (mList.contains(task)) {", "                FileDownloadLog.w(this, \"already has %s\", task);", "                task.markAdded2List();", "                mList.add(task);", "                    FileDownloadLog.v(this, \"add list in all %s %d %d\", task,", "                            task.getOrigin().getStatus(), mList.size());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"responseCode": ["public static boolean isAcceptRange(int responseCode, FileDownloadConnection connection) {", "        if (responseCode == HttpURLConnection.HTTP_PARTIAL", "                || responseCode == FileDownloadConnection.RESPONSE_CODE_FROM_OFFSET) return true;"], "connection": ["public static boolean isAcceptRange(int responseCode, FileDownloadConnection connection) {", "        final String acceptRanges = connection.getResponseHeaderField(\"Accept-Ranges\");"]}
{"connection": ["public static long findInstanceLengthForTrial(FileDownloadConnection connection) {", "        long length = findInstanceLengthFromContentRange(connection);", "        if (length < 0) {", "        if (length == 0 && FileDownloadProperties.getImpl().trialConnectionHeadMethod) {", "        return length;"]}
{"animated": ["public void setAnimated(boolean animated) {", "        mIsAnimated = animated;", "        mOpenAnimatorSet.setDuration(animated ? ANIMATION_DURATION : 0);", "        mCloseAnimatorSet.setDuration(animated ? ANIMATION_DURATION : 0);"]}
{"elevation": ["    public void setElevationCompat(float elevation) {\r", "        mShadowRadius = Math.round(elevation / 2);\r", "        mShadowYOffset = Math.round(mFabSize == SIZE_NORMAL ? elevation : elevation / 2);\r", "            super.setElevation(elevation);\r"]}
{"colorNormal": ["public void setLabelColors(int colorNormal, int colorPressed, int colorRipple) {\r", "        label.setColors(colorNormal, colorPressed, colorRipple);\r"], "colorPressed": ["public void setLabelColors(int colorNormal, int colorPressed, int colorRipple) {\r", "        label.setColors(colorNormal, colorPressed, colorRipple);\r"], "colorRipple": ["public void setLabelColors(int colorNormal, int colorPressed, int colorRipple) {\r", "        label.setColors(colorNormal, colorPressed, colorRipple);\r"]}
{"properties": ["    public void addConfigurationProperties(Properties properties) {", "        suppressDate = isTrue(properties", "        suppressAllComments = isTrue(properties"]}
{"topLevelClass": ["    public void addModelClassComment(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) {", "        map.put(\"topLevelClass\", topLevelClass);", "        addJavaElementComment(topLevelClass, map, EnumNode.ADD_MODEL_CLASS_COMMENT);"], "introspectedTable": ["    public void addModelClassComment(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) {", "        map.put(\"introspectedTable\", introspectedTable);"]}
{"innerEnum": ["    public void addEnumComment(InnerEnum innerEnum, IntrospectedTable introspectedTable) {", "        map.put(\"innerEnum\", innerEnum);", "        addJavaElementComment(innerEnum, map, EnumNode.ADD_ENUM_COMMENT);"], "introspectedTable": ["    public void addEnumComment(InnerEnum innerEnum, IntrospectedTable introspectedTable) {", "        map.put(\"introspectedTable\", introspectedTable);"]}
{"method": ["    public void addGetterComment(Method method, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) {", "        map.put(\"method\", method);", "        addJavaElementComment(method, map, EnumNode.ADD_GETTER_COMMENT);"], "introspectedTable": ["    public void addGetterComment(Method method, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) {", "        map.put(\"introspectedTable\", introspectedTable);"], "introspectedColumn": ["    public void addGetterComment(Method method, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn) {", "        map.put(\"introspectedColumn\", introspectedColumn);"]}
{"method": ["    public void addGeneralMethodComment(Method method, IntrospectedTable introspectedTable) {", "        map.put(\"method\", method);", "        addJavaElementComment(method, map, EnumNode.ADD_GENERAL_METHOD_COMMENT);"], "introspectedTable": ["    public void addGeneralMethodComment(Method method, IntrospectedTable introspectedTable) {", "        map.put(\"introspectedTable\", introspectedTable);"]}
{"xmlElement": ["    public void addComment(XmlElement xmlElement) {", "        map.put(\"xmlElement\", xmlElement);", "        addXmlElementComment(xmlElement, map, EnumNode.ADD_COMMENT);"]}
{"Result": "Method without Parameter"}
{"introspectedColumn": ["public static Element getSelectKey(IntrospectedColumn introspectedColumn, GeneratedKey generatedKey) {", "        return getSelectKey(introspectedColumn, generatedKey, null);"], "generatedKey": ["public static Element getSelectKey(IntrospectedColumn introspectedColumn, GeneratedKey generatedKey) {", "        return getSelectKey(introspectedColumn, generatedKey, null);"]}
{"resourcePath": ["public PackageResourceTable newFrameworkResourceTable(ResourcePath resourcePath) {", "              if (resourcePath.getRClass() != null) {", "                addRClassValues(resourceTable, resourcePath.getRClass());", "                addMissingStyleableAttributes(resourceTable, resourcePath.getRClass());", "              if (resourcePath.getInternalRClass() != null) {", "                addRClassValues(resourceTable, resourcePath.getInternalRClass());", "                addMissingStyleableAttributes(resourceTable, resourcePath.getInternalRClass());", "              parseResourceFiles(resourcePath, resourceTable);"]}
{"packageName": ["public PackageResourceTable newResourceTable(String packageName, ResourcePath... resourcePaths) {", "              PackageResourceTable resourceTable = new PackageResourceTable(packageName);", "                  addRClassValues(resourceTable, resourcePath.getRClass());", "                parseResourceFiles(resourcePath, resourceTable);", "              return resourceTable;"]}
{"resourceTable": ["private void addMissingStyleableAttributes(PackageResourceTable resourceTable, Class<?> rClass) {", "              resourceTable.addResource(attributeResId, \"attr\", attributeName);"], "rClass": ["private void addMissingStyleableAttributes(PackageResourceTable resourceTable, Class<?> rClass) {", "    for (Class innerClass : rClass.getClasses()) {", "      if (innerClass.getSimpleName().equals(\"styleable\")) {", "        for (Field field : innerClass.getDeclaredFields()) {", "          if (field.getType().equals(int[].class) && Modifier.isStatic(field.getModifiers())) {", "            styleableName = field.getName();", "              styleableArray = (int[]) (field.get(null));", "          } else if (field.getType().equals(Integer.TYPE) && Modifier.isStatic(field.getModifiers())) {", "            String attributeName = field.getName().substring(styleableName.length() + 1);", "              int styleableIndex = field.getInt(null);", "              int attributeResId = styleableArray[styleableIndex];", "              resourceTable.addResource(attributeResId, \"attr\", attributeName);"]}
{"isOn": ["public static void setWifiOn(boolean isOn) {", "        RuntimeEnvironment.application.getContentResolver(), Settings.Global.WIFI_ON, isOn ? 1 : 0);", "        RuntimeEnvironment.application.getContentResolver(), Settings.System.WIFI_ON, isOn ? 1 : 0);"]}
{"qualifiers": ["  public static String addSmallestScreenWidth(String qualifiers, int smallestScreenWidth) {", "    int qualifiersSmallestScreenWidth = Qualifiers.getSmallestScreenWidth(qualifiers);", "    if (qualifiersSmallestScreenWidth == -1) {", "      if (qualifiers.length() > 0) {", "    return qualifiers;"], "smallestScreenWidth": ["  public static String addSmallestScreenWidth(String qualifiers, int smallestScreenWidth) {", "      qualifiers += \"sw\" + smallestScreenWidth + \"dp\";"]}
{"mutableClass": [], "method": ["protected void instrumentNativeMethod(MutableClass mutableClass, MethodNode method) {", "    method.access = method.access & ~Opcodes.ACC_NATIVE;"]}
{"mutableClass": ["private void rewriteMethodBody(MutableClass mutableClass, MethodNode callingMethod) {", "          newInsnNode.desc = mutableClass.config.mappedTypeName(newInsnNode.desc);", "          fieldInsnNode.desc = mutableClass.config.mappedTypeName(fieldInsnNode.desc); // todo test", "          targetMethod.desc = mutableClass.config.remapParams(targetMethod.desc);", "          if (isGregorianCalendarBooleanConstructor(targetMethod)) {", "            replaceGregorianCalendarBooleanConstructor(instructions, targetMethod);", "          } else if (mutableClass.config.shouldIntercept(targetMethod)) {", "            interceptInvokeVirtualMethod(mutableClass, instructions, targetMethod);"], "callingMethod": ["private void rewriteMethodBody(MutableClass mutableClass, MethodNode callingMethod) {", "    ListIterator<AbstractInsnNode> instructions = callingMethod.instructions.iterator();"]}
{"targetMethod": ["private boolean isGregorianCalendarBooleanConstructor(MethodInsnNode targetMethod) {", "    return targetMethod.owner.equals(\"java/util/GregorianCalendar\") &&", "        targetMethod.name.equals(\"<init>\") &&", "        targetMethod.desc.equals(\"(Z)V\");"]}
{"clazz": ["private void makeClassPublic(ClassNode clazz) {", "    clazz.access = (clazz.access | Opcodes.ACC_PUBLIC) & ~(Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE);"]}
{"method": ["protected void makeMethodPublic(MethodNode method) {", "    method.access = (method.access | Opcodes.ACC_PUBLIC) & ~(Opcodes.ACC_PROTECTED | Opcodes.ACC_PRIVATE);"]}
{"method": ["protected void makeMethodPrivate(MethodNode method) {", "    method.access = (method.access | Opcodes.ACC_PRIVATE) & ~(Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED);"]}
{"info": ["public void setTraversalAfter(AccessibilityNodeInfo info) {", "    this.traversalAfter = obtain(info);"]}
{"info": ["public void setTraversalBefore(AccessibilityNodeInfo info) {", "    this.traversalBefore = obtain(info);"]}
{"child": ["public void addChild(AccessibilityNodeInfo child) {", "    children.add(child);", "    ShadowAccessibilityNodeInfo shadowAccessibilityNodeInfo = Shadow.extract(child);"]}
{"type": ["public void pushDefaultReturnValueToStack(Type type) {", "    if (type.equals(Type.BOOLEAN_TYPE)) {", "    } else if (type.equals(Type.INT_TYPE) || type.equals(Type.SHORT_TYPE) || type.equals(Type.BYTE_TYPE) || type.equals(Type.CHAR_TYPE)) {", "    } else if (type.equals(Type.LONG_TYPE)) {", "    } else if (type.equals(Type.FLOAT_TYPE)) {", "    } else if (type.equals(Type.DOUBLE_TYPE)) {", "    } else if (type.getSort() == ARRAY || type.getSort() == OBJECT) {"]}
{"path": ["public static int getMode(String path) {", "    if (path == null) {", "    File file = new File(path);", "    if (file.isDirectory()) {", "    if (file.isFile()) {", "    if (!canonicalize(path).equals(path)) {"]}
{"savedInstanceState": ["public ActivityController<T> setup(Bundle savedInstanceState) {", "    return create(savedInstanceState)", "        .restoreInstanceState(savedInstanceState)", "        .postCreate(savedInstanceState)"]}
{"newConfiguration": ["public ActivityController<T> configurationChange(final Configuration newConfiguration) {", "    final int changedBits = currentConfig.diff(newConfiguration);", "    currentConfig.setTo(newConfiguration);", "    if ((getActivityInfo(component.getApplication()).configChanges & changedBits) == changedBits) {", "      shadowMainLooper.runPaused(() -> component.onConfigurationChanged(newConfiguration));", "                  Activity.class, component, \"mConfigChangeFlags\", changedBits);"]}
{"Result": "Method without Parameter"}
{"callState": ["public void setCallState(int callState, String incomingPhoneNumber) {", "    if (callState != CALL_STATE_RINGING) {", "    this.callState = callState;", "      listener.onCallStateChanged(callState, incomingPhoneNumber);"], "incomingPhoneNumber": ["public void setCallState(int callState, String incomingPhoneNumber) {", "    this.incomingPhoneNumber = incomingPhoneNumber;", "      listener.onCallStateChanged(callState, incomingPhoneNumber);"]}
{"level": ["public void expectLogMessage(int level, String tag, String message) {", "    expectedLogs.add(new LogItem(level, tag, message, null));"], "tag": ["public void expectLogMessage(int level, String tag, String message) {", "    checkTag(tag);", "    expectedLogs.add(new LogItem(level, tag, message, null));"], "message": ["public void expectLogMessage(int level, String tag, String message) {", "    expectedLogs.add(new LogItem(level, tag, message, null));"]}
{"Result": "Method without Parameter"}
{"type": ["private static void getShapeEndPoint(int type, float[] coords, float[] point) {", "    int pointIndex = (getNumberOfPoints(type) - 1) * 2;"], "coords": ["private static void getShapeEndPoint(int type, float[] coords, float[] point) {", "    point[0] = coords[pointIndex];", "    point[1] = coords[pointIndex + 1];"], "point": []}
{"type": ["      int type, float[] coords, float lastX, float lastY, float t, float[] point) {", "    if (type == PathIterator.SEG_LINETO) {", "    int lastPointIndex = (getNumberOfPoints(type) - 1) * 2;", "    if (type == PathIterator.SEG_CUBICTO) {"], "coords": ["      int type, float[] coords, float lastX, float lastY, float t, float[] point) {", "      point[0] = lastX + (coords[0] - lastX) * t;", "      point[1] = lastY + (coords[1] - lastY) * t;", "    System.arraycopy(coords, 0, curve, 2, coords.length);"], "lastX": ["      int type, float[] coords, float lastX, float lastY, float t, float[] point) {", "      point[0] = lastX + (coords[0] - lastX) * t;", "    curve[0] = lastX;"], "lastY": ["      int type, float[] coords, float lastX, float lastY, float t, float[] point) {", "      point[1] = lastY + (coords[1] - lastY) * t;", "    curve[1] = lastY;", "      cubicCurveSegment(curve, 0f, t);", "      quadCurveSegment(curve, 0f, t);", "    point[0] = curve[2 + lastPointIndex];", "    point[1] = curve[2 + lastPointIndex + 1];"], "t": ["      int type, float[] coords, float lastX, float lastY, float t, float[] point) {", "      point[0] = lastX + (coords[0] - lastX) * t;", "      point[1] = lastY + (coords[1] - lastY) * t;", "    int lastPointIndex = (getNumberOfPoints(type) - 1) * 2;", "    System.arraycopy(coords, 0, curve, 2, coords.length);", "      cubicCurveSegment(curve, 0f, t);", "      quadCurveSegment(curve, 0f, t);"], "point": []}
{"buffer": ["static ResTable_config createConfig(ByteBuffer buffer) {", "    int startPosition = buffer.position();  // The starting buffer position to calculate bytes read.", "    int size = buffer.getInt();", "    int mcc = buffer.getShort() & 0xFFFF;", "    int mnc = buffer.getShort() & 0xFFFF;", "    buffer.get(language);", "    buffer.get(region);", "    int orientation = UnsignedBytes.toInt(buffer.get());", "    int touchscreen = UnsignedBytes.toInt(buffer.get());", "    int density = buffer.getShort() & 0xFFFF;", "    int keyboard = UnsignedBytes.toInt(buffer.get());", "    int navigation = UnsignedBytes.toInt(buffer.get());", "    int inputFlags = UnsignedBytes.toInt(buffer.get());", "    buffer.get();  // 1 byte of padding", "    int screenWidth = buffer.getShort() & 0xFFFF;", "    int screenHeight = buffer.getShort() & 0xFFFF;", "    int sdkVersion = buffer.getShort() & 0xFFFF;", "    int minorVersion = buffer.getShort() & 0xFFFF;", "      screenLayout = UnsignedBytes.toInt(buffer.get());", "      uiMode = UnsignedBytes.toInt(buffer.get());", "      smallestScreenWidthDp = buffer.getShort() & 0xFFFF;", "      screenWidthDp = buffer.getShort() & 0xFFFF;", "      screenHeightDp = buffer.getShort() & 0xFFFF;", "      buffer.get(localeScript);", "      buffer.get(localeVariant);", "      screenLayout2 = (byte) UnsignedBytes.toInt(buffer.get());", "      screenConfigPad1 = buffer.get();  // Reserved padding", "      screenConfigPad2 = buffer.getShort();  // More reserved padding", "    int bytesRead = buffer.position() - startPosition;", "    buffer.get(unknown);"]}
{"o": ["int diff(final ResTable_config o) {", "    if (mcc != o.mcc) diffs |= CONFIG_MCC;", "    if (mnc != o.mnc) diffs |= CONFIG_MNC;", "    if (orientation != o.orientation) diffs |= CONFIG_ORIENTATION;", "    if (density != o.density) diffs |= CONFIG_DENSITY;", "    if (touchscreen != o.touchscreen) diffs |= CONFIG_TOUCHSCREEN;", "    if (((inputFlags^o.inputFlags)&(MASK_KEYSHIDDEN|MASK_NAVHIDDEN)) != 0)", "    if (keyboard != o.keyboard) diffs |= CONFIG_KEYBOARD;", "    if (navigation != o.navigation) diffs |= CONFIG_NAVIGATION;", "    if (screenSize() != o.screenSize()) diffs |= CONFIG_SCREEN_SIZE;", "    if (version() != o.version()) diffs |= CONFIG_VERSION;", "    if ((screenLayout & MASK_LAYOUTDIR) != (o.screenLayout & MASK_LAYOUTDIR)) diffs |= CONFIG_LAYOUTDIR;", "    if ((screenLayout & ~MASK_LAYOUTDIR) != (o.screenLayout & ~MASK_LAYOUTDIR)) diffs |= CONFIG_SCREEN_LAYOUT;", "    if ((screenLayout2 & MASK_SCREENROUND) != (o.screenLayout2 & MASK_SCREENROUND)) diffs |= CONFIG_SCREEN_ROUND;", "    if ((colorMode & MASK_WIDE_COLOR_GAMUT) != (o.colorMode & MASK_WIDE_COLOR_GAMUT)) diffs |= CONFIG_COLOR_MODE;", "    if ((colorMode & MASK_HDR) != (o.colorMode & MASK_HDR)) diffs |= CONFIG_COLOR_MODE;", "    if (uiMode != o.uiMode) diffs |= CONFIG_UI_MODE;", "    if (smallestScreenWidthDp != o.smallestScreenWidthDp) diffs |= CONFIG_SMALLEST_SCREEN_SIZE;", "    if (screenSizeDp() != o.screenSizeDp()) diffs |= CONFIG_SCREEN_SIZE;", "    int diff = compareLocales(this, o);", "    if (isTruthy(diff)) diffs |= CONFIG_LOCALE;"]}
{"Result": "Method without Parameter"}
{"packageName": ["  protected Bundle getApplicationRestrictions(String packageName) {", "    Bundle bundle = applicationRestrictions.get(packageName);", "    return bundle != null ? bundle : new Bundle();"]}
{"userHandle": ["public long addUserProfile(UserHandle userHandle) {", "    userProfiles.put(userHandle, serialNumber);"]}
{"id": ["public UserHandle addUser(int id, String name, int flags) {", "    UserHandle userHandle =", "        id == UserHandle.USER_SYSTEM ? Process.myUserHandle() : new UserHandle(id);", "    addUserProfile(userHandle);", "    setSerialNumberForUser(userHandle, (long) id);", "    userInfoMap.put(id, new UserInfo(id, name, flags));", "        id,", "        id == UserHandle.USER_SYSTEM", "            : id * UserHandle.PER_USER_RANGE + ShadowProcess.getRandomApplicationUid());", "    return userHandle;"], "name": ["public UserHandle addUser(int id, String name, int flags) {", "    userInfoMap.put(id, new UserInfo(id, name, flags));"], "flags": ["public UserHandle addUser(int id, String name, int flags) {", "    userInfoMap.put(id, new UserInfo(id, name, flags));"]}
{"Result": "Method without Parameter"}
{"instructions": ["      ListIterator<AbstractInsnNode> instructions, MethodInsnNode targetMethod) {", "    instructions.remove();  // remove the method invocation", "    instructions.add(new InvokeDynamicInsnNode(targetMethod.name, description, BOOTSTRAP_INTRINSIC, owner));"], "targetMethod": ["      ListIterator<AbstractInsnNode> instructions, MethodInsnNode targetMethod) {", "    Type type = Type.getObjectType(targetMethod.owner);", "    String description = targetMethod.desc;", "    if (targetMethod.getOpcode() != Opcodes.INVOKESTATIC) {", "    instructions.add(new InvokeDynamicInsnNode(targetMethod.name, description, BOOTSTRAP_INTRINSIC, owner));"]}
{"other": ["int addMappings(final DynamicRefTable other) {", "    if (mAssignedPackageId != other.mAssignedPackageId) {", "    for (Entry<String, Byte> otherEntry : other.mEntries.entrySet()) {", "      String key = otherEntry.getKey();", "      Byte curValue = mEntries.get(key);", "      if (curValue == null) {", "        mEntries.put(key, otherEntry.getValue());", "        if (!Objects.equals(otherEntry.getValue(), curValue)) {", "    for (int i = 0; i < 256; i++) {", "      if (mLookupTable[i] != other.mLookupTable[i]) {", "        if (mLookupTable[i] == 0) {", "          mLookupTable[i] = other.mLookupTable[i];", "        } else if (other.mLookupTable[i] != 0) {"]}
{"packageName": ["int addMapping(final String packageName, byte packageId) {", "    Byte index = mEntries.get(packageName);", "    if (index == null) {"], "packageId": ["int addMapping(final String packageName, byte packageId) {", "    mLookupTable[index] = packageId;"]}
{"pid": ["public void grantPermissions(int pid, int uid, String... permissions) {", "    getShadowInstrumentation().grantPermissions(pid, uid, permissions);"], "uid": ["public void grantPermissions(int pid, int uid, String... permissions) {", "    getShadowInstrumentation().grantPermissions(pid, uid, permissions);"]}
{"pid": ["public void denyPermissions(int pid, int uid, String... permissions) {", "    getShadowInstrumentation().denyPermissions(pid, uid, permissions);"], "uid": ["public void denyPermissions(int pid, int uid, String... permissions) {", "    getShadowInstrumentation().denyPermissions(pid, uid, permissions);"]}
{"configuration": ["  public List<Sdk> selectSdks(Configuration configuration, UsesSdk usesSdk) {", "    Config config = configuration.get(Config.class);"], "usesSdk": ["  public List<Sdk> selectSdks(Configuration configuration, UsesSdk usesSdk) {", "    Set<Sdk> sdks = new TreeSet<>(configuredSdks(config, usesSdk));", "      sdks = Sets.intersection(sdks, enabledSdks);", "    return Lists.newArrayList(sdks);"]}
{"path": ["private static Path getFileFromZip(Path path) {", "      try (InputStream zis = Fs.getInputStream(path)) {", "        Path fileFromZip = outputDir.resolve(path.getFileName().toString());"]}
{"Result": "Method without Parameter"}
{"method": ["public static void addHttpResponseRule(String method, String uri, HttpResponse response) {", "    getFakeHttpLayer().addHttpResponseRule(method, uri, response);"], "uri": ["public static void addHttpResponseRule(String method, String uri, HttpResponse response) {", "    getFakeHttpLayer().addHttpResponseRule(method, uri, response);"], "response": ["public static void addHttpResponseRule(String method, String uri, HttpResponse response) {", "    getFakeHttpLayer().addHttpResponseRule(method, uri, response);"]}
{"requestMatcher": ["public static void addHttpResponseRule(RequestMatcher requestMatcher, List<? extends HttpResponse> responses) {", "    getFakeHttpLayer().addHttpResponseRule(requestMatcher, responses);"], "responses": ["public static void addHttpResponseRule(RequestMatcher requestMatcher, List<? extends HttpResponse> responses) {", "    getFakeHttpLayer().addHttpResponseRule(requestMatcher, responses);"]}
{"nativeObject": ["  protected static void nativeStop(long nativeObject) {", "      getStream(nativeObject).close();", "      fdToStream.remove(outputStreams.remove(nativeObject).getFD());"]}
{"requestMatcher": ["public void addHttpResponseRule(RequestMatcher requestMatcher, List<? extends HttpResponse> responses) {", "    addHttpResponseRule(new RequestMatcherResponseRule(requestMatcher, responses));"], "responses": ["public void addHttpResponseRule(RequestMatcher requestMatcher, List<? extends HttpResponse> responses) {", "    addHttpResponseRule(new RequestMatcherResponseRule(requestMatcher, responses));"]}
{"Result": "Method without Parameter"}
{"tid": ["  protected static final void setThreadPriority(int tid, int priority) {", "    if (tid == 0) {", "      threadPriorities.put(tid, priority);"], "priority": ["  protected static final void setThreadPriority(int tid, int priority) {", "        priority >= android.os.Process.THREAD_PRIORITY_URGENT_AUDIO", "            && priority <= android.os.Process.THREAD_PRIORITY_LOWEST,", "        priority);", "      threadPriorities.put(tid, priority);"]}
{"tid": ["  protected static final int getThreadPriority(int tid) {", "    if (tid == 0) {", "      return threadPriorities.getOrDefault(tid, 0);"]}
{"n": ["int getIndexOfBit(int n) {", "    for (int i = 0; i < n; i++) {"]}
{"op": ["  public void setMode(String op, int uid, String packageName, int mode) {", "    setMode(AppOpsManager.strOpToOp(op), uid, packageName, mode);"], "uid": ["  public void setMode(String op, int uid, String packageName, int mode) {", "    setMode(AppOpsManager.strOpToOp(op), uid, packageName, mode);"], "packageName": ["  public void setMode(String op, int uid, String packageName, int mode) {", "    setMode(AppOpsManager.strOpToOp(op), uid, packageName, mode);"], "mode": ["  public void setMode(String op, int uid, String packageName, int mode) {", "    setMode(AppOpsManager.strOpToOp(op), uid, packageName, mode);"]}
{"value": ["public static int getColor(String value) {", "    if (value != null) {", "      if (value.startsWith(\"#\") == false) {", "            String.format(\"Color value '%s' must start with #\", value));", "      value = value.substring(1);"]}
{"value": ["public static int getColorType(String value) {", "    if (value != null && value.startsWith(\"#\")) {", "      switch (value.length()) {"]}
{"attribute": ["public static boolean parseFloatAttribute(String attribute, String value,", "    assert requireUnit == false || attribute != null;", "                    value, attribute));"], "value": ["public static boolean parseFloatAttribute(String attribute, String value,", "    value = value.trim();"], "outValue": ["      TypedValue outValue, boolean requireUnit) {", "        if (parseUnit(end, outValue, sFloatOut)) {", "          computeTypedValue(outValue, f, sFloatOut[0]);", "        if (outValue != null) {"], "requireUnit": ["      TypedValue outValue, boolean requireUnit) {", "    assert requireUnit == false || attribute != null;", "          if (requireUnit == false) {"]}
{"asset": ["  protected static ImageDecoder nCreate(long asset, Source source) throws IOException {", "    return ImageDecoder_nCreateAsset(asset, source);"], "source": ["  protected static ImageDecoder nCreate(long asset, Source source) throws IOException {", "    return ImageDecoder_nCreateAsset(asset, source);"]}
{"fd": ["  protected static ImageDecoder nCreate(FileDescriptor fd, Source src) throws IOException {", "    return ImageDecoder_nCreateFd(fd, src);"], "src": ["  protected static ImageDecoder nCreate(FileDescriptor fd, Source src) throws IOException {", "    return ImageDecoder_nCreateFd(fd, src);"]}
{"menuItemResId": ["public boolean clickMenuItem(int menuItemResId) {", "    final RoboMenuItem item = new RoboMenuItem(menuItemResId);", "    return realActivity.onMenuItemSelected(Window.FEATURE_OPTIONS_PANEL, item);"]}
{"requestCode": ["public void callOnActivityResult(int requestCode, int resultCode, Intent resultData) {", "        .with(requestCode, resultCode, resultData);"], "resultCode": ["public void callOnActivityResult(int requestCode, int resultCode, Intent resultData) {", "        .with(requestCode, resultCode, resultData);"], "resultData": ["public void callOnActivityResult(int requestCode, int resultCode, Intent resultData) {", "        .with(requestCode, resultCode, resultData);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"runnable": ["public synchronized void postDelayed(Runnable runnable, long delay, TimeUnit unit) {", "      runnables.add(new ScheduledRunnable(runnable, currentTime + delayMillis));", "      runOrQueueRunnable(runnable, currentTime + delayMillis);"], "delay": ["public synchronized void postDelayed(Runnable runnable, long delay, TimeUnit unit) {", "    long delayMillis = unit.toMillis(delay);", "    if ((idleState != CONSTANT_IDLE && (isPaused() || delayMillis > 0)) || Thread.currentThread() != associatedThread) {", "      runnables.add(new ScheduledRunnable(runnable, currentTime + delayMillis));", "      runOrQueueRunnable(runnable, currentTime + delayMillis);"], "unit": ["public synchronized void postDelayed(Runnable runnable, long delay, TimeUnit unit) {", "    long delayMillis = unit.toMillis(delay);"]}
{"runnable": ["public synchronized void postAtFrontOfQueue(Runnable runnable) {", "      runnables.add(new ScheduledRunnable(runnable, 0, timeDisambiguator));", "      runOrQueueRunnable(runnable, currentTime);"]}
{"runnable": ["public synchronized void remove(Runnable runnable) {", "      if (iterator.next().runnable == runnable) {"]}
{"Result": "Method without Parameter"}
{"amount": ["public synchronized boolean advanceBy(long amount, TimeUnit unit) {", "    long endingTime = currentTime + unit.toMillis(amount);", "    return advanceTo(endingTime);"], "unit": ["public synchronized boolean advanceBy(long amount, TimeUnit unit) {", "    long endingTime = currentTime + unit.toMillis(amount);"]}
{"endTime": ["public synchronized boolean advanceTo(long endTime) {", "    if (endTime < currentTime || runnables.isEmpty()) {", "      currentTime = endTime;", "    while (nextTaskIsScheduledBefore(endTime)) {", "    currentTime = endTime;"]}
{"Result": "Method without Parameter"}
{"intent": ["      Intent intent, final ServiceConnection serviceConnection, int i, UserHandle userHandle) {", "    return getShadowInstrumentation().bindService(intent, serviceConnection, i);"], "serviceConnection": ["      Intent intent, final ServiceConnection serviceConnection, int i, UserHandle userHandle) {", "    return getShadowInstrumentation().bindService(intent, serviceConnection, i);"], "i": ["      Intent intent, final ServiceConnection serviceConnection, int i, UserHandle userHandle) {", "    return getShadowInstrumentation().bindService(intent, serviceConnection, i);"], "userHandle": []}
{"millis": ["  protected static boolean setCurrentTimeMillis(long millis) {", "    if (currentTimeMillis > millis) {", "    currentTimeMillis = millis;", "      listener.clockUpdated(currentTimeMillis);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"activityClass": ["public static <T extends Activity> ActivityController<T> buildActivity(Class<T> activityClass) {", "    return buildActivity(activityClass, null);"]}
{"activityClass": ["      Class<T> activityClass, Intent intent) {", "    return ActivityController.of(ReflectionHelpers.callConstructor(activityClass), intent);"], "intent": ["      Class<T> activityClass, Intent intent) {", "    return ActivityController.of(ReflectionHelpers.callConstructor(activityClass), intent);"]}
{"activityClass": ["  public static <T extends Activity> T setupActivity(Class<T> activityClass) {", "    return buildActivity(activityClass).setup().get();"]}
{"fragmentClass": ["  public static <T extends Fragment> FragmentController<T> buildFragment(Class<T> fragmentClass) {", "    return FragmentController.of(ReflectionHelpers.callConstructor(fragmentClass));"]}
{"text": ["      final String text, final int queueMode, final HashMap<String, String> params) {", "      return Shadow.directlyOn(tts, TextToSpeech.class).speak(text, queueMode, params);", "        text, queueMode, null, params == null ? null : params.get(Engine.KEY_PARAM_UTTERANCE_ID));"], "queueMode": ["      final String text, final int queueMode, final HashMap<String, String> params) {", "      return Shadow.directlyOn(tts, TextToSpeech.class).speak(text, queueMode, params);", "        text, queueMode, null, params == null ? null : params.get(Engine.KEY_PARAM_UTTERANCE_ID));"], "params": ["      final String text, final int queueMode, final HashMap<String, String> params) {", "      return Shadow.directlyOn(tts, TextToSpeech.class).speak(text, queueMode, params);", "        text, queueMode, null, params == null ? null : params.get(Engine.KEY_PARAM_UTTERANCE_ID));"]}
{"Result": "Method without Parameter"}
{"jarFile": ["private static FileSystem getJarFs(Path jarFile) throws IOException {", "    Path key = jarFile.toAbsolutePath();"]}
{"tag": ["public static List<LogItem> getLogsForTag(String tag) {", "    Queue<LogItem> logs = logsByTag.get(tag);", "    return logs == null ? Collections.emptyList() : new ArrayList<>(logs);"]}
{"Result": "Method without Parameter"}
{"className": ["public @Nullable BroadcastReceiverData getBroadcastReceiver(String className) {", "      if (receiver.getName().equals(className)) {"]}
{"channelGroupId": ["  protected void deleteNotificationChannelGroup(String channelGroupId) {", "    if (getNotificationChannelGroup(channelGroupId) != null) {", "        if (channelGroupId.equals(groupId)) {", "      notificationChannelGroups.remove(channelGroupId);"]}
{"Result": "Method without Parameter"}
{"matrix": ["  protected final void transform(Matrix matrix) {", "    checkNotNull(matrix);", "    ShadowMatrix shadowMatrix = Shadow.extract(matrix);", "    shadowMatrix.getValues(m);"]}
{"key": ["  protected <T> T get(Key<T> key) {", "    return (T) resultsKeyToValue.get(key);"]}
{"ident": ["  protected final int loadResourceBagValue(int ident, int bagEntryId, TypedValue outValue,", "    return loadResourceBagValueInternal(ident, bagEntryId, outValue, resolve, res);"], "bagEntryId": ["  protected final int loadResourceBagValue(int ident, int bagEntryId, TypedValue outValue,", "    return loadResourceBagValueInternal(ident, bagEntryId, outValue, resolve, res);"], "outValue": ["  protected final int loadResourceBagValue(int ident, int bagEntryId, TypedValue outValue,", "    return loadResourceBagValueInternal(ident, bagEntryId, outValue, resolve, res);"], "resolve": ["      boolean resolve) {", "    return loadResourceBagValueInternal(ident, bagEntryId, outValue, resolve, res);"]}
{"runnable": ["  public boolean post(Runnable runnable, long delayMillis) {", "      getScheduler().postDelayed(runnable, delayMillis, TimeUnit.MILLISECONDS);"], "delayMillis": ["  public boolean post(Runnable runnable, long delayMillis) {", "      getScheduler().postDelayed(runnable, delayMillis, TimeUnit.MILLISECONDS);"]}
{"runnable": ["  public boolean postAtFrontOfQueue(Runnable runnable) {", "      getScheduler().postAtFrontOfQueue(runnable);"]}
{"componentName": ["public ActivityInfo addActivityIfNotPresent(ComponentName componentName) {", "        updateName(componentName, new ActivityInfo()),"]}
{"componentName": ["public ServiceInfo addServiceIfNotPresent(ComponentName componentName) {", "        updateName(componentName, new ServiceInfo()),"]}
{"componentName": ["public ActivityInfo addReceiverIfNotPresent(ComponentName componentName) {", "        updateName(componentName, new ActivityInfo()),"]}
{"componentName": ["public ProviderInfo addProviderIfNotPresent(ComponentName componentName) {", "        updateName(componentName, new ProviderInfo()),"]}
{"activityInfo": ["public void addOrUpdateActivity(ActivityInfo activityInfo) {", "        new ActivityInfo(activityInfo),"]}
{"serviceInfo": ["public void addOrUpdateService(ServiceInfo serviceInfo) {", "        new ServiceInfo(serviceInfo),"]}
{"receiverInfo": ["public void addOrUpdateReceiver(ActivityInfo receiverInfo) {", "        new ActivityInfo(receiverInfo),"]}
{"providerInfo": ["public void addOrUpdateProvider(ProviderInfo providerInfo) {", "        new ProviderInfo(providerInfo),"]}
{"componentName": ["  public ActivityInfo removeActivity(ComponentName componentName) {", "        componentName, activityFilters, p -> p.activities, (p, a) -> p.activities = a);"]}
{"componentName": ["  public ServiceInfo removeService(ComponentName componentName) {", "        componentName, serviceFilters, p -> p.services, (p, a) -> p.services = a);"]}
{"componentName": ["  public ProviderInfo removeProvider(ComponentName componentName) {", "        componentName, providerFilters, p -> p.providers, (p, a) -> p.providers = a);"]}
{"componentName": ["  public ActivityInfo removeReceiver(ComponentName componentName) {", "        componentName, receiverFilters, p -> p.receivers, (p, a) -> p.receivers = a);"]}
{"intent": ["  public void setResolveInfosForIntent(Intent intent, List<ResolveInfo> info) {", "    resolveInfoForIntent.remove(intent);", "      addResolveInfoForIntent(intent, resolveInfo);"], "info": ["  public void setResolveInfosForIntent(Intent intent, List<ResolveInfo> info) {", "    for (ResolveInfo resolveInfo : info) {", "      addResolveInfoForIntent(intent, resolveInfo);"]}
{"intent": ["  public void addResolveInfoForIntent(Intent intent, ResolveInfo info) {", "    addResolveInfoForIntentNoDefaults(intent, info);"], "info": []}
{"appPackage": ["public void addPackageInternal(Package appPackage) {", "    for (PermissionGroup permissionGroup : appPackage.permissionGroups) {", "      PermissionGroupInfo permissionGroupInfo =", "          PackageParser.generatePermissionGroupInfo(permissionGroup, flags);", "      addPermissionGroupInfo(permissionGroupInfo);", "            .generatePackageInfo(appPackage, new int[] {0}, flags, 0, 0);", "    addFilters(activityFilters, appPackage.activities);", "    addFilters(serviceFilters, appPackage.services);", "    addFilters(providerFilters, appPackage.providers);", "    addFilters(receiverFilters, appPackage.receivers);"]}
{"componentName": ["public void addIntentFilterForActivity(ComponentName componentName, IntentFilter filter)", "    addIntentFilterForComponent(componentName, filter, activityFilters);"], "filter": ["public void addIntentFilterForActivity(ComponentName componentName, IntentFilter filter)", "    addIntentFilterForComponent(componentName, filter, activityFilters);"]}
{"componentName": ["public void addIntentFilterForService(ComponentName componentName, IntentFilter filter)", "    addIntentFilterForComponent(componentName, filter, serviceFilters);"], "filter": ["public void addIntentFilterForService(ComponentName componentName, IntentFilter filter)", "    addIntentFilterForComponent(componentName, filter, serviceFilters);"]}
{"componentName": ["public void addIntentFilterForReceiver(ComponentName componentName, IntentFilter filter)", "    addIntentFilterForComponent(componentName, filter, receiverFilters);"], "filter": ["public void addIntentFilterForReceiver(ComponentName componentName, IntentFilter filter)", "    addIntentFilterForComponent(componentName, filter, receiverFilters);"]}
{"componentName": ["public void addIntentFilterForProvider(ComponentName componentName, IntentFilter filter)", "    addIntentFilterForComponent(componentName, filter, providerFilters);"], "filter": ["public void addIntentFilterForProvider(ComponentName componentName, IntentFilter filter)", "    addIntentFilterForComponent(componentName, filter, providerFilters);"]}
{"packed_locale": ["private static int findParent(int packed_locale, final String script) {", "    if (hasRegion(packed_locale)) {", "          Integer lookup_result = map.get(packed_locale);", "          if (lookup_result != null) {", "            return lookup_result;", "      return dropRegion(packed_locale);"], "script": ["private static int findParent(int packed_locale, final String script) {", "        if (script.equals(entry.getKey())) {"]}
{"out": ["static int findAncestors(int[] out, Ref<Long> stop_list_index,", "      if (out != null) {"], "stop_list_index": ["static int findAncestors(int[] out, Ref<Long> stop_list_index,", "          stop_list_index.set((long) i);", "    stop_list_index.set((long) -1);"], "packed_locale": ["      int packed_locale, final String script,", "    int ancestor = packed_locale;", "        out[count] = ancestor;", "        if (stop_list[i] == ancestor) {", "      ancestor = findParent(ancestor, script);"], "script": ["      int packed_locale, final String script,", "      ancestor = findParent(ancestor, script);", "    } while (ancestor != PACKED_ROOT);"], "stop_list": ["      final int[] stop_list, int stop_set_length) {", "        if (stop_list[i] == ancestor) {"], "stop_set_length": ["      final int[] stop_list, int stop_set_length) {", "      for (int i = 0; i < stop_set_length; i++) {"]}
{"apkFile": ["public static Package callParsePackage(Path apkFile) {", "        thePackage = packageParser.parsePackage(apkFile.toFile(), flags);", "                    apkFile.toFile(), Fs.externalize(apkFile), new DisplayMetrics(), flags);", "              \"Failed to parse package \" + apkFile);", "              \"Failed to parse package \" + apkFile + \": \" + logItem.msg, logItem.throwable);"]}
{"activityClass": ["  public Intent getIntentForActivity(Class<? extends Activity> activityClass) {", "    ComponentName componentName = new ComponentName(getTargetContext(), activityClass);", "    Intent intent = Intent.makeMainActivity(componentName);", "    if (packageManager.resolveActivity(intent, 0) != null) {", "      return intent;", "    return Intent.makeMainActivity(new ComponentName(getContext(), activityClass));"]}
{"header": ["static boolean VerifyResTableType(ResTable_type header) {", "    if (header.id == 0) {", "    int entry_count = dtohl(header.entryCount);", "    int offsets_offset = dtohs(header.header.headerSize);", "    int entries_offset = dtohl(header.entriesStart);", "    if (entries_offset > dtohl(header.header.size)) {"]}
{"resDirectory": ["private static List<ManifestIdentifier> findLibraries(Path resDirectory) throws IOException {", "    if (resDirectory != null) {", "      Path baseDir = resDirectory.getParent();"]}
{"admin": ["  protected CharSequence getOrganizationName(ComponentName admin) {", "      enforceDeviceOwnerOrProfileOwner(admin);", "      enforceProfileOwner(admin);"]}
{"admin": ["      ComponentName admin, List<String> packageNames) {", "    enforceDeviceOwnerOrProfileOwner(admin);"], "packageNames": ["      ComponentName admin, List<String> packageNames) {", "    permittedAccessibilityServices = packageNames;"]}
{"admin": ["  protected boolean setPermittedInputMethods(ComponentName admin, List<String> packageNames) {", "    enforceDeviceOwnerOrProfileOwner(admin);"], "packageNames": ["  protected boolean setPermittedInputMethods(ComponentName admin, List<String> packageNames) {", "    permittedInputMethods = packageNames;"]}
{"admin": ["public boolean activateResetToken(ComponentName admin) {", "    if (!passwordResetTokens.containsKey(admin)) {", "      throw new IllegalArgumentException(\"No token set for comopnent: \" + admin);", "    return componentsWithActivatedTokens.add(admin);"]}
{"exclude_system": ["public Set<ResTable_config> GetResourceConfigurations(boolean exclude_system,", "        if (exclude_system && package_.loaded_package_.IsSystem()) {"], "exclude_mipmap": ["      boolean exclude_mipmap) {", "        package_.loaded_package_.CollectConfigurations(exclude_mipmap, configurations);"]}
{"exclude_system": ["public Set<String> GetResourceLocales(boolean exclude_system,", "        if (exclude_system && package_.loaded_package_.IsSystem()) {"], "merge_equivalent_languages": ["      boolean merge_equivalent_languages) {", "        package_.loaded_package_.CollectLocales(merge_equivalent_languages, locales);"]}
{"filename": ["public Asset OpenNonAsset(final String filename,", "      Asset asset = apk_assets_.get(i).Open(filename, mode);", "      if (isTruthy(asset)) {", "        return asset;"], "mode": ["      Asset.AccessMode mode,", "      Asset asset = apk_assets_.get(i).Open(filename, mode);", "      if (isTruthy(asset)) {", "        return asset;"], "out_cookie": ["      Ref<ApkAssetsCookie> out_cookie) {", "        if (out_cookie != null) {", "          out_cookie.set(ApkAssetsCookie.forInt(i));", "    if (out_cookie != null) {", "      out_cookie.set(K_INVALID_COOKIE);"]}
{"restoreToken": ["public void addAvailableRestoreSets(long restoreToken, List<String> packages) {", "    serviceState.restoreData.put(restoreToken, packages);"], "packages": ["public void addAvailableRestoreSets(long restoreToken, List<String> packages) {", "    serviceState.restoreData.put(restoreToken, packages);"]}
{"runnable": ["  public void runPaused(Runnable runnable) {", "      runnable.run();"]}
{"runnable": ["private void executeOnLooper(ControlRunnable runnable) {", "      runnable.run();", "      looperExecutor.execute(runnable);", "      runnable.waitTillComplete();"]}
{"loader": ["  protected <T extends Parcelable> T readParcelable(ClassLoader loader) {", "    Parcelable.Creator<?> creator = readParcelableCreator(loader);", "    if (creator == null) {", "    if (creator instanceof Parcelable.ClassLoaderCreator<?>) {", "      Parcelable.ClassLoaderCreator<?> classLoaderCreator =", "          (Parcelable.ClassLoaderCreator<?>) creator;", "      return (T) classLoaderCreator.createFromParcel(realObject, loader);", "    return (T) creator.createFromParcel(realObject);"]}
{"b": ["  protected void writeBlob(byte[] b, int offset, int len) {", "    if (b == null) {", "    throwsIfOutOfBounds(b.length, offset, len);", "    nativeWriteBlob(nativePtr, b, offset, len);"], "offset": ["  protected void writeBlob(byte[] b, int offset, int len) {", "    throwsIfOutOfBounds(b.length, offset, len);", "    nativeWriteBlob(nativePtr, b, offset, len);"], "len": ["  protected void writeBlob(byte[] b, int offset, int len) {", "    throwsIfOutOfBounds(b.length, offset, len);", "    nativeWriteBlob(nativePtr, b, offset, len);"]}
{"nativePtr": ["  protected static void nativeWriteBlob(long nativePtr, byte[] b, int offset, int len) {", "    nativeWriteByteArray(nativePtr, b, offset, len);"], "b": ["  protected static void nativeWriteBlob(long nativePtr, byte[] b, int offset, int len) {", "    nativeWriteByteArray(nativePtr, b, offset, len);"], "offset": ["  protected static void nativeWriteBlob(long nativePtr, byte[] b, int offset, int len) {", "    nativeWriteByteArray(nativePtr, b, offset, len);"], "len": ["  protected static void nativeWriteBlob(long nativePtr, byte[] b, int offset, int len) {", "    nativeWriteByteArray(nativePtr, b, offset, len);"]}
{"Result": "Method without Parameter"}
{"pos": ["public void setDataPosition(int pos) {", "      if (pos > dataSize) {", "        throw new UnreliableBehaviorError(pos + \" greater than dataSize \" + dataSize);", "      dataPosition = pos;"]}
{"clazz": ["private void checkConsistentReadAndIncrementPosition(Class<?> clazz, FakeEncodedItem item) {", "              clazz,"], "item": ["private void checkConsistentReadAndIncrementPosition(Class<?> clazz, FakeEncodedItem item) {", "      int endPosition = dataPosition + item.sizeBytes;", "        if (foundItemItem != item) {", "              item,", "      dataPosition = Math.min(dataSize, dataPosition + item.sizeBytes);"]}
{"Result": "Method without Parameter"}
{"clazz": ["private <T> FakeEncodedItem readNextItem(Class<T> clazz) {", "      checkConsistentReadAndIncrementPosition(clazz, item);"]}
{"pastEndValue": ["private <T> T readValue(T pastEndValue, Class<T> clazz, boolean allowNull) {", "        return pastEndValue;", "        return pastEndValue;"], "clazz": ["private <T> T readValue(T pastEndValue, Class<T> clazz, boolean allowNull) {", "      FakeEncodedItem item = readNextItem(clazz);", "      if (item == null) {", "      } else if (item.value == null && allowNull) {", "      } else if (clazz.isInstance(item.value)) {", "        return clazz.cast(item.value);", "                clazz, startPosition, item, \"and it is non-portable to reinterpret it\"));"], "allowNull": ["private <T> T readValue(T pastEndValue, Class<T> clazz, boolean allowNull) {", "      } else if (item.value == null && allowNull) {"]}
{"bytes": ["private boolean readZeroes(int bytes) {", "      int endPosition = dataPosition + bytes;", "      if (endPosition > dataSize) {", "      for (int i = dataPosition; i < endPosition; i++) {", "      dataPosition = endPosition;"]}
{"defaultSizeBytes": ["private <T> T readPrimitive(int defaultSizeBytes, T defaultValue, Class<T> clazz) {", "      if (readZeroes(defaultSizeBytes)) {"], "defaultValue": ["private <T> T readPrimitive(int defaultSizeBytes, T defaultValue, Class<T> clazz) {", "        return defaultValue;", "      return readValue(defaultValue, clazz, /* allowNull= */ false);"], "clazz": ["private <T> T readPrimitive(int defaultSizeBytes, T defaultValue, Class<T> clazz) {", "      return readValue(defaultValue, clazz, /* allowNull= */ false);"]}
{"item": ["private void writeItem(FakeEncodedItem item) {", "      int endPosition = dataPosition + item.sizeBytes;", "      Arrays.fill(data, dataPosition, endPosition, item);"]}
{"is": ["public static byte[] readBytes(InputStream is) throws IOException {", "    try (ByteArrayOutputStream bos = new ByteArrayOutputStream(is.available())) {", "      copy(is, bos);"]}
{"o": ["  public synchronized long getNativeObjectId(T o) {", "    checkNotNull(o);", "    Long nativeId = nativeObjToIdMap.inverse().get(o);", "    if (nativeId == null) {", "        System.out.printf(\"NativeObjRegistry %s: register %d -> %s%n\", name, nativeId, o);", "      nativeObjToIdMap.put(nativeId, o);", "    return nativeId;"]}
{"nativeId": ["public synchronized T getNativeObject(long nativeId) {", "    T object = nativeObjToIdMap.get(nativeId);", "    if (object != null) {", "      return object;", "              nativeId, nativeObjToIdMap.keySet()));"]}
{"context": ["public void callAttach(Context context) {", "        ReflectionHelpers.ClassParameter.from(Context.class, context));"]}
{"isActive": ["public void setDefaultNetworkActive(boolean isActive) {", "    defaultNetworkActive = isActive;", "    if (defaultNetworkActive) {"]}
{"soundID": ["      int soundID, float leftVolume, float rightVolume, int priority, int loop, float rate) {", "    playedSounds.add(new Playback(soundID, leftVolume, rightVolume, priority, loop, rate));"], "leftVolume": ["      int soundID, float leftVolume, float rightVolume, int priority, int loop, float rate) {", "    playedSounds.add(new Playback(soundID, leftVolume, rightVolume, priority, loop, rate));"], "rightVolume": ["      int soundID, float leftVolume, float rightVolume, int priority, int loop, float rate) {", "    playedSounds.add(new Playback(soundID, leftVolume, rightVolume, priority, loop, rate));"], "priority": ["      int soundID, float leftVolume, float rightVolume, int priority, int loop, float rate) {", "    playedSounds.add(new Playback(soundID, leftVolume, rightVolume, priority, loop, rate));"], "loop": ["      int soundID, float leftVolume, float rightVolume, int priority, int loop, float rate) {", "    playedSounds.add(new Playback(soundID, leftVolume, rightVolume, priority, loop, rate));"], "rate": ["      int soundID, float leftVolume, float rightVolume, int priority, int loop, float rate) {", "    playedSounds.add(new Playback(soundID, leftVolume, rightVolume, priority, loop, rate));"]}
{"path": ["  protected int load(String path, int priority) {", "    idToPaths.put(soundId, path);"], "priority": []}
{"appWidgetId": ["public void reconstructWidgetViewAsIfPhoneWasRotated(int appWidgetId) {", "    WidgetInfo widgetInfo = widgetInfos.get(appWidgetId);", "    widgetInfo.view = createWidgetView(widgetInfo.layoutId);"]}
{"appWidgetProviderClass": ["public int[] createWidgets(Class<? extends AppWidgetProvider> appWidgetProviderClass, int widgetLayoutId, int howManyToCreate) {", "    AppWidgetProvider appWidgetProvider = ReflectionHelpers.callConstructor(appWidgetProviderClass);", "      widgetInfos.put(myWidgetId, new WidgetInfo(widgetView, widgetLayoutId, appWidgetProvider));", "    appWidgetProvider.onUpdate(context, realAppWidgetManager, newWidgetIds);"], "widgetLayoutId": ["public int[] createWidgets(Class<? extends AppWidgetProvider> appWidgetProviderClass, int widgetLayoutId, int howManyToCreate) {", "      View widgetView = createWidgetView(widgetLayoutId);", "      widgetInfos.put(myWidgetId, new WidgetInfo(widgetView, widgetLayoutId, appWidgetProvider));"], "howManyToCreate": ["public int[] createWidgets(Class<? extends AppWidgetProvider> appWidgetProviderClass, int widgetLayoutId, int howManyToCreate) {", "    int[] newWidgetIds = new int[howManyToCreate];", "    for (int i = 0; i < howManyToCreate; i++) {"]}
{"Result": "Method without Parameter"}
{"what": ["public void invokeInfoListener(int what, int extra) {", "      infoListener.onInfo(player, what, extra);"], "extra": ["public void invokeInfoListener(int what, int extra) {", "      infoListener.onInfo(player, what, extra);"]}
{"what": ["public void invokeErrorListener(int what, int extra) {", "        && errorListener.onError(player, what, extra);"], "extra": ["public void invokeErrorListener(int what, int extra) {", "    boolean handled = errorListener != null", "        && errorListener.onError(player, what, extra);", "    if (!handled) {"]}
{"Result": "Method without Parameter"}
{"densityDpi": ["public void setDensityDpi(int densityDpi) {", "      this.densityDpi = densityDpi;", "          di -> di.logicalDensityDpi = densityDpi);"]}
{"xdpi": ["public void setXdpi(float xdpi) {", "      this.xdpi = xdpi;", "          di -> di.physicalXDpi = xdpi);"]}
{"ydpi": ["public void setYdpi(float ydpi) {", "      this.ydpi = ydpi;", "          di -> di.physicalYDpi = ydpi);"]}
{"name": ["public void setName(String name) {", "      this.name = name;", "          di -> di.name = name);"]}
{"flags": ["public void setFlags(int flags) {", "    reflector(_Display_.class, realObject).setFlags(flags);", "          di -> di.flags = flags);"]}
{"width": ["public void setWidth(int width) {", "      this.width = width;", "          di -> di.appWidth = width);"]}
{"height": ["public void setHeight(int height) {", "      this.height = height;", "          di -> di.appHeight = height);"]}
{"width": ["public void setRealWidth(int width) {", "      this.realWidth = width;", "          di -> di.logicalWidth = width);"]}
{"height": ["public void setRealHeight(int height) {", "      this.realHeight = height;", "          di -> di.logicalHeight = height);"]}
{"rotation": ["public void setRotation(int rotation) {", "      this.rotation = rotation;", "          di -> di.rotation = rotation);"]}
{"state": ["public void setState(int state) {", "          di -> di.state = state);"]}
{"Result": "Method without Parameter"}
{"route": ["protected void establishRoute(HttpRoute route, HttpContext context)", "      step = rowdy.nextStep(route, fact);", "        managedConn.open(route, context, this.params);", "        boolean secure = createTunnelToTarget(route, context);", "        boolean secure = createTunnelToProxy(route, hop, context);", "        managedConn.tunnelProxy(route.getHopTarget(hop),", "           \"\\nplanned = \" + route +"], "context": ["protected void establishRoute(HttpRoute route, HttpContext context)", "        managedConn.open(route, context, this.params);", "        boolean secure = createTunnelToTarget(route, context);", "        managedConn.tunnelTarget(secure, this.params);", "        boolean secure = createTunnelToProxy(route, hop, context);", "                    secure, this.params);", "        managedConn.layerProtocol(context, this.params);"]}
{"type1": ["  protected String getCommonSuperClass(final String type1, final String type2) {", "      ClassNode info1 = typeInfo(type1);", "      if ((info1.access & Opcodes.ACC_INTERFACE) != 0) {", "        if (typeImplements(type2, info2, type1)) {", "          return type1;", "          if (typeImplements(type1, info1, type2)) {", "        if (typeImplements(type1, info1, type2)) {", "      String b1 = typeAncestors(type1, info1);", "      int end1 = b1.length();", "        int start1 = b1.lastIndexOf(';', end1 - 1);", "        if (start1 != -1 && start2 != -1", "            && end1 - start1 == end2 - start2) {", "          String p1 = b1.substring(start1 + 1, end1);", "          if (p1.equals(p2)) {", "            result = p1;", "            end1 = start1;", "            return result;", "          return result;"], "type2": ["  protected String getCommonSuperClass(final String type1, final String type2) {", "      ClassNode info2 = typeInfo(type2);", "        if (typeImplements(type2, info2, type1)) {", "        if ((info2.access & Opcodes.ACC_INTERFACE) != 0) {", "          if (typeImplements(type1, info1, type2)) {", "            return type2;", "      if ((info2.access & Opcodes.ACC_INTERFACE) != 0) {", "        if (typeImplements(type1, info1, type2)) {", "          return type2;", "      String b2 = typeAncestors(type2, info2);", "      int end2 = b2.length();", "        int start2 = b2.lastIndexOf(';', end2 - 1);", "        if (start1 != -1 && start2 != -1", "            && end1 - start1 == end2 - start2) {", "          String p2 = b2.substring(start2 + 1, end2);", "          if (p1.equals(p2)) {", "            end2 = start2;"]}
{"value": ["public String qualify(String value) {", "    if (value == null) return null;", "    if (AttributeResource.isResourceReference(value)) {", "      return \"@\" + ResName.qualifyResourceName(value.trim().substring(1).replace(\"+\", \"\"), packageName, \"attr\");", "    } else if (AttributeResource.isStyleReference(value)) {", "      return \"?\" + ResName.qualifyResourceName(value.trim().substring(1), packageName, \"attr\");", "      return StringResources.processStringResources(value);"]}
{"node": ["int navigateToNextNode(Node node)", "    Node nextNode = node.getNextSibling();", "      if (document.getDocumentElement().equals(node)) {", "      currentNode = node.getParentNode();"]}
{"name": ["private static boolean isAndroidSupportedFeature(String name) {", "    if (name == null) {", "      if (feature.equals(name)) {"]}
{"asset": ["      Asset asset, Asset idmapAsset, final int cookie, boolean copyData,", "    final byte[] data = asset.getBuffer(true);", "    return addInternal(data, (int) asset.getLength(),"], "idmapAsset": ["      Asset asset, Asset idmapAsset, final int cookie, boolean copyData,", "    if (idmapAsset != NULL) {", "      idmapData = idmapAsset.getBuffer(true);", "      idmapSize = (int) idmapAsset.getLength();"], "cookie": ["      Asset asset, Asset idmapAsset, final int cookie, boolean copyData,", "        idmapData, idmapSize, appAsLib, cookie, copyData, isSystemAsset);"], "copyData": ["      Asset asset, Asset idmapAsset, final int cookie, boolean copyData,", "        idmapData, idmapSize, appAsLib, cookie, copyData, isSystemAsset);"], "appAsLib": ["      boolean appAsLib, boolean isSystemAsset) {", "        idmapData, idmapSize, appAsLib, cookie, copyData, isSystemAsset);"], "isSystemAsset": ["      boolean appAsLib, boolean isSystemAsset) {", "        idmapData, idmapSize, appAsLib, cookie, copyData, isSystemAsset);"]}
{"configuration": ["public static String getQualifiers(Configuration configuration, DisplayMetrics displayMetrics) {", "    return ConfigurationV25.resourceQualifierString(configuration, displayMetrics);"], "displayMetrics": ["public static String getQualifiers(Configuration configuration, DisplayMetrics displayMetrics) {", "    return ConfigurationV25.resourceQualifierString(configuration, displayMetrics);"]}
{"newQualifiers": ["public static void setQualifiers(String newQualifiers) {", "    if (newQualifiers.startsWith(\"+\")) {", "    Bootstrap.applyQualifiers(newQualifiers, getApiLevel(), configuration, displayMetrics);"]}
{"data": ["public static String buildString(char[] data) {", "    for (count=0; count < data.length; count++) {", "      if (data[count] == 0) {", "    return new String(data, 0, count);"]}
{"service": ["public static <S> ServiceFinder<S> load(Class<S> service,", "    return new ServiceFinder<>(service, loader);"], "loader": ["      ClassLoader loader)", "    return new ServiceFinder<>(service, loader);"]}
{"service": ["public static <S> ServiceFinder<S> loadInstalled(Class<S> service) {", "    return load(service, prev);"]}
{"service": ["public static <S> S loadFromSystemProperty(final Class<S> service) {", "      final String className = System.getProperty(service.getName());"]}
{"device": ["public boolean hasPermissionForPackage(UsbDevice device, String packageName) {", "    return usbDevices != null && usbDevices.contains(device);"], "packageName": ["public boolean hasPermissionForPackage(UsbDevice device, String packageName) {", "    List<UsbDevice> usbDevices = grantedPermissions.get(packageName);", "    return usbDevices != null && usbDevices.contains(device);"]}
{"device": ["public void revokePermission(UsbDevice device, String packageName) {", "      usbDevices.remove(device);"], "packageName": ["public void revokePermission(UsbDevice device, String packageName) {", "    List<UsbDevice> usbDevices = grantedPermissions.get(packageName);", "    if (usbDevices != null) {", "      usbDevices.remove(device);"]}
{"usbDevice": ["public void addOrUpdateUsbDevice(UsbDevice usbDevice, boolean hasPermission) {", "    Preconditions.checkNotNull(usbDevice);", "    Preconditions.checkNotNull(usbDevice.getDeviceName());", "    usbDevices.put(usbDevice.getDeviceName(), usbDevice);", "      grantPermission(usbDevice);", "      revokePermission(usbDevice, RuntimeEnvironment.application.getPackageName());"], "hasPermission": ["public void addOrUpdateUsbDevice(UsbDevice usbDevice, boolean hasPermission) {", "    if (hasPermission) {"]}
{"usbDevice": ["public void removeUsbDevice(UsbDevice usbDevice) {", "    Preconditions.checkNotNull(usbDevice);", "    usbDevices.remove(usbDevice.getDeviceName());", "    revokePermission(usbDevice, RuntimeEnvironment.application.getPackageName());"]}
{"portId": ["public void addPort(String portId) {", "          (UsbPort) createUsbPort(realUsbManager, portId, UsbPortStatus.MODE_DUAL),", "            from(String.class, portId),"]}
{"accessory": []}
{"tag": ["void addData(String tag, long timestamp, byte[] data) {", "    entries.put(timestamp, new DropBoxManager.Entry(tag, timestamp, data, DropBoxManager.IS_TEXT));"], "timestamp": ["void addData(String tag, long timestamp, byte[] data) {", "    entries.put(timestamp, new DropBoxManager.Entry(tag, timestamp, data, DropBoxManager.IS_TEXT));"], "data": ["void addData(String tag, long timestamp, byte[] data) {", "    entries.put(timestamp, new DropBoxManager.Entry(tag, timestamp, data, DropBoxManager.IS_TEXT));"]}
{"parentId": ["public MediaItem createMediaItem(String parentId, String mediaId, String title, int flag) {", "    if (parentId != null) {", "      final MediaItem parentItem = mediaItems.get(parentId);", "      List<MediaItem> children = mediaItemChildren.get(parentItem);", "      if (children == null) {", "        mediaItemChildren.put(parentItem, children);", "      children.add(mediaItem);"], "mediaId": ["public MediaItem createMediaItem(String parentId, String mediaId, String title, int flag) {", "            .putString(MediaMetadataCompat.METADATA_KEY_MEDIA_ID, mediaId)", "            .putString(MediaMetadataCompat.METADATA_KEY_MEDIA_URI, Uri.parse(mediaId).toString())", "    mediaItems.put(mediaId, mediaItem);"], "title": ["public MediaItem createMediaItem(String parentId, String mediaId, String title, int flag) {", "            .putString(MediaMetadataCompat.METADATA_KEY_TITLE, title)"], "flag": ["public MediaItem createMediaItem(String parentId, String mediaId, String title, int flag) {", "    final MediaItem mediaItem = new MediaItem(metadataCompat.getDescription(), flag);", "    mediaItems.put(mediaId, mediaItem);", "      children.add(mediaItem);", "    return mediaItem;"]}
{"clazz": ["public static <T> T createDeepProxy(Class<T> clazz) {", "            clazz.getClassLoader(),", "            new Class[] {clazz},"]}
{"object": ["  public static <R> R getField(final Object object, final String fieldName) {", "      return traverseClassHierarchy(object.getClass(), NoSuchFieldException.class, new InsideTraversal<R>() {", "          return (R) field.get(object);"], "fieldName": ["  public static <R> R getField(final Object object, final String fieldName) {", "          Field field = traversalClass.getDeclaredField(fieldName);", "          field.setAccessible(true);", "          return (R) field.get(object);"]}
{"instance": ["public static <R> R callInstanceMethod(final Object instance, final String methodName, ClassParameter<?>... classParameters) {", "      return traverseClassHierarchy(instance.getClass(), NoSuchMethodException.class, new InsideTraversal<R>() {", "          return (R) declaredMethod.invoke(instance, values);"], "methodName": ["public static <R> R callInstanceMethod(final Object instance, final String methodName, ClassParameter<?>... classParameters) {", "          Method declaredMethod = traversalClass.getDeclaredMethod(methodName, classes);"]}
{"cl": ["public static <R> R callInstanceMethod(Class<?> cl, final Object instance, final String methodName, ClassParameter<?>... classParameters) {", "      Method method = cl.getDeclaredMethod(methodName, classes);"], "instance": ["public static <R> R callInstanceMethod(Class<?> cl, final Object instance, final String methodName, ClassParameter<?>... classParameters) {", "      return (R) method.invoke(instance, values);"], "methodName": ["public static <R> R callInstanceMethod(Class<?> cl, final Object instance, final String methodName, ClassParameter<?>... classParameters) {", "      Method method = cl.getDeclaredMethod(methodName, classes);"]}
{"classLoader": ["      ClassLoader classLoader,", "    Class<?> clazz = loadClass(classLoader, fullyQualifiedClassName);"], "fullyQualifiedClassName": ["      String fullyQualifiedClassName,", "    Class<?> clazz = loadClass(classLoader, fullyQualifiedClassName);", "    return callStaticMethod(clazz, methodName, classParameters);"], "methodName": ["      String methodName,", "    return callStaticMethod(clazz, methodName, classParameters);"]}
{"clazz": ["  public static <R> R callStaticMethod(Class<?> clazz, String methodName, ClassParameter<?>... classParameters) {", "      Method method = clazz.getDeclaredMethod(methodName, classes);", "      throw new RuntimeException(\"no such method \" + clazz + \".\" + methodName, e);"], "methodName": ["  public static <R> R callStaticMethod(Class<?> clazz, String methodName, ClassParameter<?>... classParameters) {", "      Method method = clazz.getDeclaredMethod(methodName, classes);", "      throw new RuntimeException(\"no such method \" + clazz + \".\" + methodName, e);"]}
{"cl": ["public static <T> T newInstance(Class<T> cl) {", "      return cl.getDeclaredConstructor().newInstance();"]}
{"clazz": ["public static <R> R callConstructor(Class<? extends R> clazz, ClassParameter<?>... classParameters) {", "      Constructor<? extends R> constructor = clazz.getDeclaredConstructor(classes);", "      throw new RuntimeException(\"error instantiating \" + clazz.getName(), e);"]}
{"request": [], "executor": ["      RangingRequest request, Executor executor, RangingResultCallback callback) {", "      executor.execute(() -> callback.onRangingResults(this.rangingResults));", "      executor.execute(() -> callback.onRangingFailure(RangingResultCallback.STATUS_CODE_FAIL));"], "callback": ["      RangingRequest request, Executor executor, RangingResultCallback callback) {", "      executor.execute(() -> callback.onRangingResults(this.rangingResults));", "      executor.execute(() -> callback.onRangingFailure(RangingResultCallback.STATUS_CODE_FAIL));"]}
{"request": ["  public static Typeface getFontSync(FontRequest request) {", "    return Typeface.create(request.getQuery(), Typeface.NORMAL);"]}
{"Result": "Method without Parameter"}
{"view": ["  public static void dump(View view) {", "    ShadowView shadowView = Shadow.extract(view);", "    shadowView.dump();"]}
{"view": ["  public static String innerText(View view) {", "    ShadowView shadowView = Shadow.extract(view);", "    return shadowView.innerText();"]}
{"intent": ["private List<Wrapper> getAppropriateWrappers(Intent intent, String receiverPermission) {", "    broadcastIntents.add(intent);", "        intent.getComponent() != null ? intent.getComponent().getClassName() : null;", "              && wrapper.intentFilter.matchAction(intent.getAction()))", "        final int match =", "            wrapper.intentFilter.matchData(intent.getType(), intent.getScheme(), intent.getData());", "        if (match != IntentFilter.NO_MATCH_DATA && match != IntentFilter.NO_MATCH_TYPE) {"], "receiverPermission": ["private List<Wrapper> getAppropriateWrappers(Intent intent, String receiverPermission) {", "      if ((hasMatchingPermission(wrapper.broadcastPermission, receiverPermission)"]}
{"wrapper": ["      final Wrapper wrapper,", "        (wrapper.scheduler != null) ? wrapper.scheduler : getMainHandler(context);", "            wrapper.broadcastReceiver.setPendingResult(result);", "                      Shadow.extract(wrapper.broadcastReceiver);"], "intent": ["      final Intent intent,", "                  shadowBroadcastReceiver.onReceive(context, intent, abort);"], "oldResult": ["      ListenableFuture<BroadcastResultHolder> oldResult,", "        oldResult,"], "abort": ["      final AtomicBoolean abort,", "                  shadowBroadcastReceiver.onReceive(context, intent, abort);"], "context": ["      final Context context) {", "    final Handler scheduler =", "        (wrapper.scheduler != null) ? wrapper.scheduler : getMainHandler(context);", "            scheduler.post(", "                  shadowBroadcastReceiver.onReceive(context, intent, abort);"]}
{"red": ["  protected static void RGBToHSV(int red, int green, int blue, float hsv[]) {", "    java.awt.Color.RGBtoHSB(red, green, blue, hsv);"], "green": ["  protected static void RGBToHSV(int red, int green, int blue, float hsv[]) {", "    java.awt.Color.RGBtoHSB(red, green, blue, hsv);"], "blue": ["  protected static void RGBToHSV(int red, int green, int blue, float hsv[]) {", "    java.awt.Color.RGBtoHSB(red, green, blue, hsv);"], "hsv": ["  protected static void RGBToHSV(int red, int green, int blue, float hsv[]) {", "    java.awt.Color.RGBtoHSB(red, green, blue, hsv);", "    hsv[0] = hsv[0] * 360;"]}
{"sectionName": ["  protected static void beginSection(String sectionName) {", "        if (sectionName.length() > MAX_SECTION_NAME_LEN) {", "      } else if (sectionName == null) {", "      } else if (sectionName.length() > MAX_SECTION_NAME_LEN) {", "        currentSections.addFirst(sectionName);"]}
{"Result": "Method without Parameter"}
{"key": ["  private synchronized <T> Provider<T> getProvider(final Key<T> key) {", "    return (Provider<T>) providers.computeIfAbsent(key, k -> {", "      if (key.isAutoFactory()) {", "        return memoized(new ScopeBuilderProvider<>(key.getDependencyClass()));", "      return findLocalProvider(key);"]}
{"origFileName": ["boolean create(String origFileName, int fd, long offset, int length,", "    this.mFileName = origFileName;"], "fd": ["boolean create(String origFileName, int fd, long offset, int length,", "    this.fd = fd;"], "offset": ["boolean create(String origFileName, int fd, long offset, int length,", "    this.mDataOffset = offset;"], "length": [], "readOnly": ["      boolean readOnly)", "    this.readOnly = readOnly;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"audioFocusRequest": ["  protected int requestAudioFocus(android.media.AudioFocusRequest audioFocusRequest) {", "    lastAudioFocusRequest = new AudioFocusRequest(audioFocusRequest);"]}
{"audioFocusRequest": ["  protected int abandonAudioFocusRequest(android.media.AudioFocusRequest audioFocusRequest) {", "    lastAbandonedAudioFocusRequest = audioFocusRequest;"]}
{"Result": "Method without Parameter"}
{"input": ["  protected ByteBuffer getBuffer(boolean input, int index) {", "    ByteBuffer[] buffers = input ? inputBuffers : outputBuffers;"], "index": ["  protected ByteBuffer getBuffer(boolean input, int index) {", "    return (index >= 0 && index < buffers.length) ? buffers[index] : null;"]}
{"index": ["      int index, int offset, int size, long presentationTimeUs, int flags) {", "    makeOutputBufferAvailable(index, info);"], "offset": ["      int index, int offset, int size, long presentationTimeUs, int flags) {", "    info.set(offset, size, presentationTimeUs, flags);"], "size": ["      int index, int offset, int size, long presentationTimeUs, int flags) {", "    info.set(offset, size, presentationTimeUs, flags);"], "presentationTimeUs": ["      int index, int offset, int size, long presentationTimeUs, int flags) {", "    info.set(offset, size, presentationTimeUs, flags);"], "flags": ["      int index, int offset, int size, long presentationTimeUs, int flags) {", "    if ((flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {", "    info.set(offset, size, presentationTimeUs, flags);"]}
{"index": ["  protected void releaseOutputBuffer(int index, boolean render, boolean updatePTS, long timeNs) {", "    makeInputBufferAvailable(index);"], "render": [], "updatePTS": [], "timeNs": []}
{"offsetToAddInMillis": ["public void simulateTimeChange(long offsetToAddInMillis) {", "      long newTimestamp = event.getTimeStamp() + offsetToAddInMillis;", "          newTimestamp, EventBuilder.fromEvent(event).setTimeStamp(newTimestamp).build());"]}
{"meta": ["private static Bundle metaDataToBundle(Map<String, Object> meta) {", "    if (meta.size() == 0) {", "    for (Map.Entry<String, Object> entry : meta.entrySet()) {", "      String key = entry.getKey();", "      Object value = entry.getValue();", "      if (Boolean.class.isInstance(value)) {", "        bundle.putBoolean(key, (Boolean) value);", "      } else if (Float.class.isInstance(value)) {", "        bundle.putFloat(key, (Float) value);", "      } else if (Integer.class.isInstance(value)) {", "        bundle.putInt(key, (Integer) value);", "        bundle.putString(key, value == null ? null : value.toString());"]}
{"sql": ["static String convertSQLWithLocalizedUnicodeCollator(String sql) {", "    Matcher matcher = COLLATE_LOCALIZED_UNICODE_PATTERN.matcher(sql);", "    return matcher.replaceAll(\" COLLATE NOCASE\");"]}
{"orig": ["private static PackageInfo newPackageInfo(PackageInfo orig) {", "    orig.writeToParcel(parcel, 0);"]}
{"pkgName": ["private boolean isGrantedForBackwardsCompatibility(String pkgName, PackageInfo permissionsInfo) {", "        || pkgName.equals(RuntimeEnvironment.application.getPackageName());"], "permissionsInfo": ["private boolean isGrantedForBackwardsCompatibility(String pkgName, PackageInfo permissionsInfo) {", "    return permissionsInfo.requestedPermissionsFlags == null"]}
{"componentInfo": ["private void applyFlagsToComponentInfo(ComponentInfo componentInfo, int flags)", "    componentInfo.name = (componentInfo.name == null) ? \"\" : componentInfo.name;"], "flags": ["private void applyFlagsToComponentInfo(ComponentInfo componentInfo, int flags)", "      applyFlagsToApplicationInfo(componentInfo.applicationInfo, flags);", "    if ((flags & GET_META_DATA) == 0) {", "    if ((flags & MATCH_ALL) != 0 && Build.VERSION.SDK_INT >= 23) {", "    if ((flags & MATCH_DISABLED_COMPONENTS) == 0 && !isEnabledForFiltering) {", "    if (isFlagSet(flags, PackageManager.MATCH_SYSTEM_ONLY)) {", "        final int applicationFlags = applicationInfo.flags;", "        if ((applicationFlags & ApplicationInfo.FLAG_SYSTEM) != ApplicationInfo.FLAG_SYSTEM) {", "    if (!isFlagSet(flags, MATCH_UNINSTALLED_PACKAGES)"]}
{"packageInfo": ["private int getPermissionIndex(PackageInfo packageInfo, String permissionName) {", "    if (packageInfo.requestedPermissions != null) {", "      for (int i = 0; i < packageInfo.requestedPermissions.length; i++) {", "        if (permissionName.equals(packageInfo.requestedPermissions[i])) {"], "permissionName": ["private int getPermissionIndex(PackageInfo packageInfo, String permissionName) {", "        if (permissionName.equals(packageInfo.requestedPermissions[i])) {"]}
{"icon": ["  protected Drawable getUserBadgedIcon(Drawable icon, UserHandle user) {", "    return icon;"], "user": []}
{"Result": "Method without Parameter"}
{"codePoint": ["private static char[] extractCodePoint(String codePoint) {", "      return Character.toChars(Integer.valueOf(codePoint, 16));", "      throw new IllegalArgumentException(\"Invalid code point: \\\\u\" + codePoint, e);"]}
{"iClass": ["public static <T> T reflector(Class<T> iClass, Object target) {", "    Class<?> targetClass = determineTargetClass(iClass);", "    Constructor<? extends T> ctor = (Constructor<? extends T>) CACHE.get(iClass);", "      if (ctor == null) {", "        Class<? extends T> reflectorClass = createReflectorClass(iClass, targetClass);", "        ctor = reflectorClass.getConstructor(targetClass);", "        ctor.setAccessible(true);", "      CACHE.put(iClass, ctor);", "      return ctor.newInstance(target);"], "target": ["public static <T> T reflector(Class<T> iClass, Object target) {", "      return ctor.newInstance(target);"]}
{"account": ["public static Status getStatus(Account account, String authority, boolean create) {", "    Status status = map.get(account);", "    if (status == null && create) {", "      map.put(account, status);", "    return status;"], "authority": ["public static Status getStatus(Account account, String authority, boolean create) {", "    Map<Account, Status> map = syncableAccounts.get(authority);", "    if (map == null) {", "      syncableAccounts.put(authority, map);", "    Status status = map.get(account);", "      map.put(account, status);"], "create": ["public static Status getStatus(Account account, String authority, boolean create) {", "    if (status == null && create) {"]}
{"uri": ["public Collection<ContentObserver> getContentObservers(Uri uri) {", "      if (entry.matches(uri)) {"]}
{"qualifiersStr": ["public static int addDisplay(String qualifiersStr) {", "    int id = getShadowDisplayManagerGlobal().addDisplay(createDisplayInfo(qualifiersStr, null));"]}
{"displayId": ["static void changeDisplay(int displayId, Consumer<DisplayConfig> consumer) {", "    DisplayInfo displayInfo = DisplayManagerGlobal.getInstance().getDisplayInfo(displayId);", "    if (displayInfo != null) {", "      DisplayConfig displayConfig = new DisplayConfig(displayInfo);", "      consumer.accept(displayConfig);", "      displayConfig.copyTo(displayInfo);", "      fixNominalDimens(displayInfo);", "    getShadowDisplayManagerGlobal().changeDisplay(displayId, displayInfo);"], "consumer": ["static void changeDisplay(int displayId, Consumer<DisplayConfig> consumer) {", "      consumer.accept(displayConfig);"]}
{"tracePath": ["private static String fixTracePath(String tracePath) {", "    if (tracePath == null || tracePath.charAt(0) != '/') {", "      if (tracePath == null) {", "        tracePath = new File(dir, tracePath).getAbsolutePath();", "    if (!tracePath.endsWith(defaultTraceExtension)) {", "    return tracePath;"]}
{"bits": ["private int findNext(BitSet bits, int value, Calendar calendar, int field, int nextField, List<Integer> lowerOrders) {", "\t\tint nextValue = bits.nextSetBit(value);", "\t\t\tnextValue = bits.nextSetBit(0);"], "value": ["private int findNext(BitSet bits, int value, Calendar calendar, int field, int nextField, List<Integer> lowerOrders) {", "\t\tint nextValue = bits.nextSetBit(value);", "\t\tif (nextValue == -1) {", "\t\tif (nextValue != value) {", "\t\t\tcalendar.set(field, nextValue);", "\t\treturn nextValue;"], "calendar": ["private int findNext(BitSet bits, int value, Calendar calendar, int field, int nextField, List<Integer> lowerOrders) {", "\t\t\tcalendar.add(nextField, 1);", "\t\t\treset(calendar, Arrays.asList(field));", "\t\t\tcalendar.set(field, nextValue);", "\t\t\treset(calendar, lowerOrders);"], "field": ["private int findNext(BitSet bits, int value, Calendar calendar, int field, int nextField, List<Integer> lowerOrders) {", "\t\t\treset(calendar, Arrays.asList(field));", "\t\t\tcalendar.set(field, nextValue);"], "nextField": ["private int findNext(BitSet bits, int value, Calendar calendar, int field, int nextField, List<Integer> lowerOrders) {", "\t\t\tcalendar.add(nextField, 1);"], "lowerOrders": ["private int findNext(BitSet bits, int value, Calendar calendar, int field, int nextField, List<Integer> lowerOrders) {", "\t\t\treset(calendar, lowerOrders);"]}
{"calendar": ["private void reset(Calendar calendar, List<Integer> fields) {", "\t\t\tcalendar.set(field, field == Calendar.DAY_OF_MONTH ? 1 : 0);"], "fields": ["private void reset(Calendar calendar, List<Integer> fields) {", "\t\tfor (int field : fields) {", "\t\t\tcalendar.set(field, field == Calendar.DAY_OF_MONTH ? 1 : 0);"]}
{"expression": ["private void parse(String expression) throws IllegalArgumentException {", "\t\tString[] fields = Strings.splitIgnoreBlank(expression, \" \");", "\t\t\t\t\t\"Cron expression must consist of 6 fields (found %d in \\\"%s\\\")\", fields.length, expression));"]}
{"arg": ["private int getArgIndex(final int arg) {", "        for (int i = 0; i < arg; i++) {"]}
{"type": ["private void loadInsn(final Type type, final int index) {", "        mv.visitVarInsn(type.getOpcode(Opcodes.ILOAD), index);"], "index": ["private void loadInsn(final Type type, final int index) {", "        mv.visitVarInsn(type.getOpcode(Opcodes.ILOAD), index);"]}
{"type": ["private void storeInsn(final Type type, final int index) {", "        mv.visitVarInsn(type.getOpcode(Opcodes.ISTORE), index);"], "index": ["private void storeInsn(final Type type, final int index) {", "        mv.visitVarInsn(type.getOpcode(Opcodes.ISTORE), index);"]}
{"arg": ["public void loadArgs(final int arg, final int count) {", "        int index = getArgIndex(arg);", "            Type t = argumentTypes[arg + i];", "            loadInsn(t, index);", "            index += t.getSize();"], "count": ["public void loadArgs(final int arg, final int count) {", "        for (int i = 0; i < count; ++i) {"]}
{"Result": "Method without Parameter"}
{"local": ["public void loadLocal(final int local, final Type type) {", "        setLocalType(local, type);", "        loadInsn(type, local);"], "type": ["public void loadLocal(final int local, final Type type) {", "        setLocalType(local, type);", "        loadInsn(type, local);"]}
{"local": ["public void storeLocal(final int local, final Type type) {", "        setLocalType(local, type);", "        storeInsn(type, local);"], "type": ["public void storeLocal(final int local, final Type type) {", "        setLocalType(local, type);", "        storeInsn(type, local);"]}
{"prev": ["public void swap(final Type prev, final Type type) {", "            if (prev.getSize() == 1) {", "            if (prev.getSize() == 1) {"], "type": ["public void swap(final Type prev, final Type type) {", "        if (type.getSize() == 1) {"]}
{"type": ["public void box(final Type type) {", "        if (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) {", "        if (type == Type.VOID_TYPE) {", "            Type boxed = getBoxedType(type);", "            newInstance(boxed);", "            if (type.getSize() == 2) {", "            invokeConstructor(boxed, new Method(\"<init>\", Type.VOID_TYPE,", "                    new Type[] { type }));"]}
{"type": ["public void unbox(final Type type) {", "        switch (type.getSort()) {", "            checkCast(type);"]}
{"type": ["public void ifCmp(final Type type, final int mode, final Label label) {", "        switch (type.getSort()) {", "                    + type);"], "mode": ["public void ifCmp(final Type type, final int mode, final Label label) {", "            mv.visitInsn(mode == GE || mode == GT ? Opcodes.DCMPL", "            mv.visitInsn(mode == GE || mode == GT ? Opcodes.FCMPL", "            switch (mode) {", "            switch (mode) {", "        mv.visitJumpInsn(mode, label);"], "label": ["public void ifCmp(final Type type, final int mode, final Label label) {", "                mv.visitJumpInsn(Opcodes.IF_ACMPEQ, label);", "                mv.visitJumpInsn(Opcodes.IF_ACMPNE, label);", "            mv.visitJumpInsn(intOp, label);", "        mv.visitJumpInsn(mode, label);"]}
{"opcode": ["private void fieldInsn(final int opcode, final Type ownerType,", "        mv.visitFieldInsn(opcode, ownerType.getInternalName(), name,"], "ownerType": ["private void fieldInsn(final int opcode, final Type ownerType,", "        mv.visitFieldInsn(opcode, ownerType.getInternalName(), name,"], "name": ["            final String name, final Type fieldType) {", "        mv.visitFieldInsn(opcode, ownerType.getInternalName(), name,"], "fieldType": ["            final String name, final Type fieldType) {", "                fieldType.getDescriptor());"]}
{"owner": ["public void getStatic(final Type owner, final String name, final Type type) {", "        fieldInsn(Opcodes.GETSTATIC, owner, name, type);"], "name": ["public void getStatic(final Type owner, final String name, final Type type) {", "        fieldInsn(Opcodes.GETSTATIC, owner, name, type);"], "type": ["public void getStatic(final Type owner, final String name, final Type type) {", "        fieldInsn(Opcodes.GETSTATIC, owner, name, type);"]}
{"owner": ["public void putStatic(final Type owner, final String name, final Type type) {", "        fieldInsn(Opcodes.PUTSTATIC, owner, name, type);"], "name": ["public void putStatic(final Type owner, final String name, final Type type) {", "        fieldInsn(Opcodes.PUTSTATIC, owner, name, type);"], "type": ["public void putStatic(final Type owner, final String name, final Type type) {", "        fieldInsn(Opcodes.PUTSTATIC, owner, name, type);"]}
{"owner": ["public void getField(final Type owner, final String name, final Type type) {", "        fieldInsn(Opcodes.GETFIELD, owner, name, type);"], "name": ["public void getField(final Type owner, final String name, final Type type) {", "        fieldInsn(Opcodes.GETFIELD, owner, name, type);"], "type": ["public void getField(final Type owner, final String name, final Type type) {", "        fieldInsn(Opcodes.GETFIELD, owner, name, type);"]}
{"owner": ["public void putField(final Type owner, final String name, final Type type) {", "        fieldInsn(Opcodes.PUTFIELD, owner, name, type);"], "name": ["public void putField(final Type owner, final String name, final Type type) {", "        fieldInsn(Opcodes.PUTFIELD, owner, name, type);"], "type": ["public void putField(final Type owner, final String name, final Type type) {", "        fieldInsn(Opcodes.PUTFIELD, owner, name, type);"]}
{"opcode": ["private void invokeInsn(final int opcode, final Type type,", "        mv.visitMethodInsn(opcode, owner, method.getName(),"], "type": ["private void invokeInsn(final int opcode, final Type type,", "        String owner = type.getSort() == Type.ARRAY ? type.getDescriptor()", "                : type.getInternalName();"], "method": ["            final Method method, final boolean itf) {", "        mv.visitMethodInsn(opcode, owner, method.getName(),", "                method.getDescriptor(), itf);"], "itf": ["            final Method method, final boolean itf) {", "                method.getDescriptor(), itf);"]}
{"owner": ["public void invokeVirtual(final Type owner, final Method method) {", "        invokeInsn(Opcodes.INVOKEVIRTUAL, owner, method, false);"], "method": ["public void invokeVirtual(final Type owner, final Method method) {", "        invokeInsn(Opcodes.INVOKEVIRTUAL, owner, method, false);"]}
{"type": ["public void invokeConstructor(final Type type, final Method method) {", "        invokeInsn(Opcodes.INVOKESPECIAL, type, method, false);"], "method": ["public void invokeConstructor(final Type type, final Method method) {", "        invokeInsn(Opcodes.INVOKESPECIAL, type, method, false);"]}
{"owner": ["public void invokeStatic(final Type owner, final Method method) {", "        invokeInsn(Opcodes.INVOKESTATIC, owner, method, false);"], "method": ["public void invokeStatic(final Type owner, final Method method) {", "        invokeInsn(Opcodes.INVOKESTATIC, owner, method, false);"]}
{"owner": ["public void invokeInterface(final Type owner, final Method method) {", "        invokeInsn(Opcodes.INVOKEINTERFACE, owner, method, true);"], "method": ["public void invokeInterface(final Type owner, final Method method) {", "        invokeInsn(Opcodes.INVOKEINTERFACE, owner, method, true);"]}
{"type": ["public void throwException(final Type type, final String msg) {", "        newInstance(type);", "        invokeConstructor(type, Method.getMethod(\"void <init> (String)\"));"], "msg": ["public void throwException(final Type type, final String msg) {", "        push(msg);"]}
{"type": ["public void checkCast(final Type type) {", "        if (!type.equals(OBJECT_TYPE)) {", "            typeInsn(Opcodes.CHECKCAST, type);"]}
{"Result": "Method without Parameter"}
{"offset": ["private int startFrame(final int offset, final int nLocal, final int nStack) {", "        frame[0] = offset;"], "nLocal": ["private int startFrame(final int offset, final int nLocal, final int nStack) {", "        int n = 3 + nLocal + nStack;", "        frame[1] = nLocal;"], "nStack": ["private int startFrame(final int offset, final int nLocal, final int nStack) {", "        int n = 3 + nLocal + nStack;", "        if (frame == null || frame.length < n) {", "            frame = new int[n];", "        frame[2] = nStack;"]}
{"owner": ["Item newMethodItem(final String owner, final String name,", "        key3.set(type, owner, name, desc);", "            put122(type, newClass(owner), newNameType(name, desc));"], "name": ["Item newMethodItem(final String owner, final String name,", "        key3.set(type, owner, name, desc);", "            put122(type, newClass(owner), newNameType(name, desc));"], "desc": ["            final String desc, final boolean itf) {", "        key3.set(type, owner, name, desc);", "            put122(type, newClass(owner), newNameType(name, desc));"], "itf": ["            final String desc, final boolean itf) {", "        int type = itf ? IMETH : METH;"]}
{"value": ["Item newFloat(final float value) {", "        key.set(value);"]}
{"value": ["private Item newString(final String value) {", "        key2.set(STR, value, null, null);", "            pool.put12(STR, newUTF8(value));"]}
{"name": ["Item newNameTypeItem(final String name, final String desc) {", "        key2.set(NAME_TYPE, name, desc, null);", "            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));"], "desc": ["Item newNameTypeItem(final String name, final String desc) {", "        key2.set(NAME_TYPE, name, desc, null);", "            put122(NAME_TYPE, newUTF8(name), newUTF8(desc));"]}
{"key": ["private Item get(final Item key) {", "        Item i = items[key.hashCode % items.length];", "        while (i != null && (i.type != key.type || !key.isEqualTo(i))) {"]}
{"b": ["private void put122(final int b, final int s1, final int s2) {", "        pool.put12(b, s1).putShort(s2);"], "s1": ["private void put122(final int b, final int s1, final int s2) {", "        pool.put12(b, s1).putShort(s2);"], "s2": ["private void put122(final int b, final int s1, final int s2) {", "        pool.put12(b, s1).putShort(s2);"]}
{"b1": ["private void put112(final int b1, final int b2, final int s) {", "        pool.put11(b1, b2).putShort(s);"], "b2": ["private void put112(final int b1, final int b2, final int s) {", "        pool.put11(b1, b2).putShort(s);"], "s": ["private void put112(final int b1, final int b2, final int s) {", "        pool.put11(b1, b2).putShort(s);"]}
{"name": ["public void visitEnum(String name, String desc, String value) {", "            av.visitEnum(name, desc, value);"], "desc": ["public void visitEnum(String name, String desc, String value) {", "            av.visitEnum(name, desc, value);"], "value": ["public void visitEnum(String name, String desc, String value) {", "            av.visitEnum(name, desc, value);"]}
{"name": ["public AnnotationVisitor visitAnnotation(String name, String desc) {", "            return av.visitAnnotation(name, desc);"], "desc": ["public AnnotationVisitor visitAnnotation(String name, String desc) {", "            return av.visitAnnotation(name, desc);"]}
{"rank": ["private static int pos4twist(double rank,", "        double dyOrX = Math.PI * rank * yOrX / hOrW + phase;"], "phase": ["                                 double phase,", "        double dyOrX = Math.PI * rank * yOrX / hOrW + phase;", "        double dxOrY = Math.sin(dyOrX);", "        return xOrY + (int) (dxOrY * period);"], "period": ["                                 double period,", "        return xOrY + (int) (dxOrY * period);"], "hOrW": ["                                 int hOrW,", "        double dyOrX = Math.PI * rank * yOrX / hOrW + phase;"], "xOrY": ["                                 int xOrY,", "        return xOrY + (int) (dxOrY * period);"], "yOrX": ["                                 int yOrX) {", "        double dyOrX = Math.PI * rank * yOrX / hOrW + phase;"]}
{"raster": ["private static BufferedImage createJPEG4(Raster raster) {", "        int w = raster.getWidth();", "        int h = raster.getHeight();", "        float[] Y = raster.getSamples(0, 0, w, h, 0, (float[]) null);", "        float[] Cb = raster.getSamples(0, 0, w, h, 1, (float[]) null);", "        float[] Cr = raster.getSamples(0, 0, w, h, 2, (float[]) null);", "        float[] K = raster.getSamples(0, 0, w, h, 3, (float[]) null);"]}
{"name": ["public void visitParameter(String name, int access) {", "            mv.visitParameter(name, access);"], "access": ["public void visitParameter(String name, int access) {", "            mv.visitParameter(name, access);"]}
{"desc": ["public AnnotationVisitor visitAnnotation(String desc, boolean visible) {", "            return mv.visitAnnotation(desc, visible);"], "visible": ["public AnnotationVisitor visitAnnotation(String desc, boolean visible) {", "            return mv.visitAnnotation(desc, visible);"]}
{"parameter": ["public AnnotationVisitor visitParameterAnnotation(int parameter,", "            return mv.visitParameterAnnotation(parameter, desc, visible);"], "desc": ["            String desc, boolean visible) {", "            return mv.visitParameterAnnotation(parameter, desc, visible);"], "visible": ["            String desc, boolean visible) {", "            return mv.visitParameterAnnotation(parameter, desc, visible);"]}
{"opcode": ["public void visitTypeInsn(int opcode, String type) {", "            mv.visitTypeInsn(opcode, type);"], "type": ["public void visitTypeInsn(int opcode, String type) {", "            mv.visitTypeInsn(opcode, type);"]}
{"opcode": ["public void visitFieldInsn(int opcode, String owner, String name,", "            mv.visitFieldInsn(opcode, owner, name, desc);"], "owner": ["public void visitFieldInsn(int opcode, String owner, String name,", "            mv.visitFieldInsn(opcode, owner, name, desc);"], "name": ["public void visitFieldInsn(int opcode, String owner, String name,", "            mv.visitFieldInsn(opcode, owner, name, desc);"], "desc": ["            String desc) {", "            mv.visitFieldInsn(opcode, owner, name, desc);"]}
{"opcode": ["    public void visitMethodInsn(int opcode, String owner, String name,", "            boolean itf = opcode == Opcodes.INVOKEINTERFACE;", "            visitMethodInsn(opcode, owner, name, desc, itf);", "            mv.visitMethodInsn(opcode, owner, name, desc);"], "owner": ["    public void visitMethodInsn(int opcode, String owner, String name,", "            visitMethodInsn(opcode, owner, name, desc, itf);", "            mv.visitMethodInsn(opcode, owner, name, desc);"], "name": ["    public void visitMethodInsn(int opcode, String owner, String name,", "            visitMethodInsn(opcode, owner, name, desc, itf);", "            mv.visitMethodInsn(opcode, owner, name, desc);"], "desc": ["            String desc) {", "            visitMethodInsn(opcode, owner, name, desc, itf);", "            mv.visitMethodInsn(opcode, owner, name, desc);"]}
{"min": ["public void visitTableSwitchInsn(int min, int max, Label dflt,", "            mv.visitTableSwitchInsn(min, max, dflt, labels);"], "max": ["public void visitTableSwitchInsn(int min, int max, Label dflt,", "            mv.visitTableSwitchInsn(min, max, dflt, labels);"], "dflt": ["public void visitTableSwitchInsn(int min, int max, Label dflt,", "            mv.visitTableSwitchInsn(min, max, dflt, labels);"]}
{"dflt": ["public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {", "            mv.visitLookupSwitchInsn(dflt, keys, labels);"], "keys": ["public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {", "            mv.visitLookupSwitchInsn(dflt, keys, labels);"], "labels": ["public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {", "            mv.visitLookupSwitchInsn(dflt, keys, labels);"]}
{"desc": ["public void visitMultiANewArrayInsn(String desc, int dims) {", "            mv.visitMultiANewArrayInsn(desc, dims);"], "dims": ["public void visitMultiANewArrayInsn(String desc, int dims) {", "            mv.visitMultiANewArrayInsn(desc, dims);"]}
{"typeRef": ["public AnnotationVisitor visitLocalVariableAnnotation(int typeRef,", "            return mv.visitLocalVariableAnnotation(typeRef, typePath, start,"], "typePath": ["            TypePath typePath, Label[] start, Label[] end, int[] index,", "            return mv.visitLocalVariableAnnotation(typeRef, typePath, start,"], "start": ["            TypePath typePath, Label[] start, Label[] end, int[] index,", "            return mv.visitLocalVariableAnnotation(typeRef, typePath, start,"], "end": ["            TypePath typePath, Label[] start, Label[] end, int[] index,", "                    end, index, desc, visible);"], "index": ["            TypePath typePath, Label[] start, Label[] end, int[] index,", "                    end, index, desc, visible);"], "desc": ["            String desc, boolean visible) {", "                    end, index, desc, visible);"], "visible": ["            String desc, boolean visible) {", "                    end, index, desc, visible);"]}
{"line": ["public void visitLineNumber(int line, Label start) {", "            mv.visitLineNumber(line, start);"], "start": ["public void visitLineNumber(int line, Label start) {", "            mv.visitLineNumber(line, start);"]}
{"frame": [], "index": [], "v": [], "buf": ["            final char[] buf, final Label[] labels) {", "            frame[index] = readClass(v, buf);"], "labels": ["            final char[] buf, final Label[] labels) {", "            frame[index] = readLabel(readUnsignedShort(v), labels);"]}
{"cw": ["final void set(ClassWriter cw, final int nLocal, final Object[] local,", "        int i = convert(cw, nLocal, local, inputLocals);", "        convert(cw, nStack, stack, inputStack);"], "nLocal": ["final void set(ClassWriter cw, final int nLocal, final Object[] local,", "        int i = convert(cw, nLocal, local, inputLocals);"], "local": ["final void set(ClassWriter cw, final int nLocal, final Object[] local,", "        int i = convert(cw, nLocal, local, inputLocals);", "        while (i < local.length) {"], "nStack": ["            final int nStack, final Object[] stack) {", "        for (int j = 0; j < nStack; ++j) {", "        inputStack = new int[nStack + nStackTop];", "        convert(cw, nStack, stack, inputStack);"], "stack": ["            final int nStack, final Object[] stack) {", "            if (stack[j] == Opcodes.LONG || stack[j] == Opcodes.DOUBLE) {", "        convert(cw, nStack, stack, inputStack);"]}
{"local": ["private int get(final int local) {", "        if (outputLocals == null || local >= outputLocals.length) {", "            return LOCAL | local;", "            int type = outputLocals[local];", "            if (type == 0) {", "                type = outputLocals[local] = LOCAL | local;", "            return type;"]}
{"local": ["private void set(final int local, final int type) {", "        if (local >= n) {", "            int[] t = new int[Math.max(local + 1, 2 * n)];"], "type": ["private void set(final int local, final int type) {", "        outputLocals[local] = type;"]}
{"cw": ["private void push(final ClassWriter cw, final String desc) {", "        int type = type(cw, desc);"], "desc": ["private void push(final ClassWriter cw, final String desc) {", "        int type = type(cw, desc);", "        if (type != 0) {", "            push(type);", "            if (type == LONG || type == DOUBLE) {"]}
{"cw": ["private static int type(final ClassWriter cw, final String desc) {", "            return OBJECT | cw.addType(t);", "                data = OBJECT | cw.addType(t);"], "desc": ["private static int type(final ClassWriter cw, final String desc) {", "        int index = desc.charAt(0) == '(' ? desc.indexOf(')') + 1 : 0;", "        switch (desc.charAt(index)) {", "            t = desc.substring(index + 1, desc.length() - 1);", "            while (desc.charAt(dims) == '[') {", "            switch (desc.charAt(dims)) {", "                t = desc.substring(dims + 1, desc.length() - 1);"]}
{"elements": ["private void pop(final int elements) {", "        if (outputStackTop >= elements) {", "            outputStackTop -= elements;", "            owner.inputStackTop -= elements - outputStackTop;"]}
{"desc": ["private void pop(final String desc) {", "        char c = desc.charAt(0);", "            pop((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);"]}
{"var": ["private void init(final int var) {", "        initializations[initializationCount++] = var;"]}
{"cw": ["private int init(final ClassWriter cw, final int t) {", "            s = OBJECT | cw.addType(cw.thisName);", "            String type = cw.typeTable[t & BASE_VALUE].strVal1;", "            s = OBJECT | cw.addType(type);"], "t": ["private int init(final ClassWriter cw, final int t) {", "        if (t == UNINITIALIZED_THIS) {", "        } else if ((t & (DIM | BASE_KIND)) == UNINITIALIZED) {", "            String type = cw.typeTable[t & BASE_VALUE].strVal1;", "            return t;", "            if (t == u) {", "        return t;"]}
{"source": ["public void visitSource(String source, String debug) {", "            cv.visitSource(source, debug);"], "debug": ["public void visitSource(String source, String debug) {", "            cv.visitSource(source, debug);"]}
{"owner": ["public void visitOuterClass(String owner, String name, String desc) {", "            cv.visitOuterClass(owner, name, desc);"], "name": ["public void visitOuterClass(String owner, String name, String desc) {", "            cv.visitOuterClass(owner, name, desc);"], "desc": ["public void visitOuterClass(String owner, String name, String desc) {", "            cv.visitOuterClass(owner, name, desc);"]}
{"desc": ["public AnnotationVisitor visitAnnotation(String desc, boolean visible) {", "            return cv.visitAnnotation(desc, visible);"], "visible": ["public AnnotationVisitor visitAnnotation(String desc, boolean visible) {", "            return cv.visitAnnotation(desc, visible);"]}
{"typeRef": ["public AnnotationVisitor visitTypeAnnotation(int typeRef,", "            return cv.visitTypeAnnotation(typeRef, typePath, desc, visible);"], "typePath": ["            TypePath typePath, String desc, boolean visible) {", "            return cv.visitTypeAnnotation(typeRef, typePath, desc, visible);"], "desc": ["            TypePath typePath, String desc, boolean visible) {", "            return cv.visitTypeAnnotation(typeRef, typePath, desc, visible);"], "visible": ["            TypePath typePath, String desc, boolean visible) {", "            return cv.visitTypeAnnotation(typeRef, typePath, desc, visible);"]}
{"bs": ["public static int extract(int bs, int low, int high) {\r", "        bs = bs >> low;\r"], "low": ["public static int extract(int bs, int low, int high) {\r", "        bs = bs >> low;\r", "        for (int i = 0; i < (high - low); i++) {\r", "        return bs & mask;\r"], "high": ["public static int extract(int bs, int low, int high) {\r", "        for (int i = 0; i < (high - low); i++) {\r"]}
{"internalName": ["public static Type getObjectType(final String internalName) {", "        char[] buf = internalName.toCharArray();"]}
{"methodDescriptor": ["public static Type[] getArgumentTypes(final String methodDescriptor) {", "        char[] buf = methodDescriptor.toCharArray();"]}
{"methodDescriptor": ["public static Type getReturnType(final String methodDescriptor) {", "        char[] buf = methodDescriptor.toCharArray();"]}
{"desc": ["public static int getArgumentsAndReturnSizes(final String desc) {", "            char car = desc.charAt(c++);", "            if (car == ')') {", "                car = desc.charAt(c);", "                        | (car == 'V' ? 0 : (car == 'D' || car == 'J' ? 2 : 1));", "            } else if (car == 'L') {", "                while (desc.charAt(c++) != ';') {", "            } else if (car == '[') {", "                while ((car = desc.charAt(c)) == '[') {", "                if (car == 'D' || car == 'J') {", "            } else if (car == 'D' || car == 'J') {"]}
{"buf": ["private static Type getType(final char[] buf, final int off) {", "        switch (buf[off]) {", "            while (buf[off + len] == '[') {", "            if (buf[off + len] == 'L') {", "                while (buf[off + len] != ';') {", "            return new Type(ARRAY, buf, off, len + 1);", "            while (buf[off + len] != ';') {", "            return new Type(OBJECT, buf, off + 1, len - 1);", "            return new Type(METHOD, buf, off, buf.length - off);"], "off": ["private static Type getType(final char[] buf, final int off) {", "        switch (buf[off]) {", "            while (buf[off + len] == '[') {", "            if (buf[off + len] == 'L') {", "                while (buf[off + len] != ';') {", "            return new Type(ARRAY, buf, off, len + 1);", "            while (buf[off + len] != ';') {", "            return new Type(OBJECT, buf, off + 1, len - 1);", "            return new Type(METHOD, buf, off, buf.length - off);"]}
{"buf": ["private void getDescriptor(final StringBuilder buf) {", "        if (this.buf == null) {", "            buf.append((char) ((off & 0xFF000000) >>> 24));", "            buf.append('L');", "            buf.append(this.buf, off, len);", "            buf.append(';');", "            buf.append(this.buf, off, len);"]}
{"c": ["public static String getDescriptor(final Class<?> c) {", "        getDescriptor(buf, c);"]}
{"opcode": ["public int getOpcode(final int opcode) {", "        if (opcode == Opcodes.IALOAD || opcode == Opcodes.IASTORE) {", "            return opcode + (buf == null ? (off & 0xFF00) >> 8 : 4);", "            return opcode + (buf == null ? (off & 0xFF0000) >> 16 : 4);"]}
{"b": ["public ByteVector putByte(final int b) {", "        data[length++] = (byte) b;", "        this.length = length;"]}
{"b1": ["ByteVector put11(final int b1, final int b2) {", "        data[length++] = (byte) b1;"], "b2": ["ByteVector put11(final int b1, final int b2) {", "        data[length++] = (byte) b2;", "        this.length = length;"]}
{"s": ["public ByteVector putShort(final int s) {", "        data[length++] = (byte) (s >>> 8);", "        data[length++] = (byte) s;", "        this.length = length;"]}
{"b": ["ByteVector put12(final int b, final int s) {", "        data[length++] = (byte) b;"], "s": ["ByteVector put12(final int b, final int s) {", "        data[length++] = (byte) (s >>> 8);", "        data[length++] = (byte) s;", "        this.length = length;"]}
{"i": ["public ByteVector putInt(final int i) {", "        data[length++] = (byte) (i >>> 24);", "        data[length++] = (byte) (i >>> 16);", "        data[length++] = (byte) (i >>> 8);", "        data[length++] = (byte) i;", "        this.length = length;"]}
{"l": ["public ByteVector putLong(final long l) {", "        int i = (int) (l >>> 32);", "        i = (int) l;", "        data[length++] = (byte) (i >>> 24);", "        data[length++] = (byte) (i >>> 16);", "        data[length++] = (byte) (i >>> 8);", "        data[length++] = (byte) i;", "        this.length = length;"]}
{"s": ["public ByteVector putUTF8(final String s) {", "        int charLength = s.length();", "            char c = s.charAt(i);", "            if (c >= '\\001' && c <= '\\177') {", "                data[len++] = (byte) c;", "                length = len;", "                return encodeUTF8(s, i, 65535);", "        length = len;"]}
{"b": ["public ByteVector putByteArray(final byte[] b, final int off, final int len) {", "        if (b != null) {", "            System.arraycopy(b, off, data, length, len);"], "off": ["public ByteVector putByteArray(final byte[] b, final int off, final int len) {", "            System.arraycopy(b, off, data, length, len);"], "len": ["public ByteVector putByteArray(final byte[] b, final int off, final int len) {", "        if (length + len > data.length) {", "            enlarge(len);", "            System.arraycopy(b, off, data, length, len);", "        length += len;"]}
{"size": ["private void enlarge(final int size) {", "        int length2 = length + size;", "        byte[] newData = new byte[length1 > length2 ? length1 : length2];", "        System.arraycopy(data, 0, newData, 0, length);", "        data = newData;"]}
{"col": ["   public String getColumnName(int col) {", "      return (col < header.length) ? columnMapping.get(header[col].toUpperCase()) : null;"]}
{"columnMapping": ["public void setColumnMapping(Map<String, String> columnMapping) {", "      this.columnMapping.clear();", "      for (Map.Entry<String, String> entry : columnMapping.entrySet()) {", "         this.columnMapping.put(entry.getKey().toUpperCase(), entry.getValue());"]}
{"propertyName": ["    public <T> T getValue(String propertyName, Class<T> returnType) {", "        return getContainer().getValue(propertyName, returnType);"], "returnType": ["    public <T> T getValue(String propertyName, Class<T> returnType) {", "        return getContainer().getValue(propertyName, returnType);"]}
{"Result": "Method without Parameter"}
{"name": ["public static IOCase forName(String name) {", "        if (IOCase.SENSITIVE.name.equals(name)){", "        if (IOCase.INSENSITIVE.name.equals(name)){", "        if (IOCase.SYSTEM.name.equals(name)){", "        throw new IllegalArgumentException(\"Invalid IOCase name: \" + name);"]}
{"str": ["String convertCase(String str) {", "        if (str == null) {", "        return isSensitive ? str : str.toLowerCase();"]}
{"change": ["public Object getCurrentValue(Change change) {", "            for (PropertyDescriptor descriptor : PropertyUtils.getInstance().getDescriptors(change.getClass())) {", "                if (descriptor.getDisplayName().equals(this.parameterName)) {", "                    Method readMethod = descriptor.getReadMethod();", "                    if (readMethod == null) {", "                        readMethod = change.getClass().getMethod(", "                            \"is\" + StringUtil.upperCaseFirst(descriptor.getName())", "                    return readMethod.invoke(change);"]}
{"change": ["public void setValue(Change change, Object value) {", "            for (PropertyDescriptor descriptor : PropertyUtils.getInstance().getDescriptors(change.getClass())) {", "                if (descriptor.getDisplayName().equals(this.parameterName)) {", "                    Method writeMethod = descriptor.getWriteMethod();", "                    if (writeMethod == null) {", "                    Class<?> expectedWriteType = writeMethod.getParameterTypes()[0];", "                    if ((value != null) && !expectedWriteType.isAssignableFrom(value.getClass())) {", "                        if (expectedWriteType.equals(String.class)) {", "                                expectedWriteType.getName()", "                    writeMethod.invoke(change, value);"], "value": ["public void setValue(Change change, Object value) {", "        if ((value instanceof String) && (!\"string\".equals(dataType))) {", "                        value = new BigInteger((String) value);", "                        value = new DatabaseFunction((String) value);", "                throw new UnexpectedLiquibaseException(\"Cannot convert string value '\" + value + \"' to \" +", "                    if ((value != null) && !expectedWriteType.isAssignableFrom(value.getClass())) {", "                            value = value.toString();", "                                \"Could not convert \" + value.getClass().getName() +", "                    writeMethod.invoke(change, value);", "            throw new UnexpectedLiquibaseException(\"Error setting \" + this.parameterName + \" to \" + value, e);"]}
{"arguments": ["public static <T> T[] createIfNull(T[] arguments) {", "        if (arguments == null) {", "            return arguments;"]}
{"currentValue": ["public static <T> Set<T> createIfNull(Set<T> currentValue) {", "        if (currentValue == null) {", "            return currentValue;"]}
{"property": ["private Boolean getGlobalParam(Map property) {", "\t\tObject globalObj = property.get(\"global\");"]}
{"cols": ["protected void attachParams(List<ColumnConfig> cols, PreparedStatement stmt)", "        for (ColumnConfig col : cols) {", "            LOG.fine(LogType.LOG, \"Applying column parameter = \" + i + \" for column \" + col.getName());", "            applyColumnParameter(stmt, i, col);"], "stmt": ["protected void attachParams(List<ColumnConfig> cols, PreparedStatement stmt)", "            applyColumnParameter(stmt, i, col);"]}
{"path": ["public String getAbsolutePath(String path) {", "        String p = path;", "        File f = new File(p);", "        if (!f.isAbsolute()) {", "            p = FilenameUtils.normalize(basePath + p);", "        return p;"]}
{"checksumValue": ["public static CheckSum parse(String checksumValue) {", "        if (checksumValue == null) {", "        Matcher matcher = CHECKSUM_PATTERN.matcher(checksumValue);", "        if (matcher.find()) {", "            return new CheckSum(matcher.group(2), Integer.parseInt(matcher.group(1)));", "            return new CheckSum(checksumValue, 1);"]}
{"valueToChecksum": ["public static CheckSum compute(String valueToChecksum) {", "                    StringUtil.standardizeLineEndings(valueToChecksum)"]}
{"Result": "Method without Parameter"}
{"indent": ["protected void printSettings(String indent) {", "        if (indent == null) {", "        getLog().info(indent + \"driver: \" + driver);", "        getLog().info(indent + \"url: \" + url);", "        getLog().info(indent + \"username: \" + username);", "        getLog().info(indent + \"password: \" + \"*****\");", "        getLog().info(indent + \"use empty password: \" + emptyPassword);", "        getLog().info(indent + \"properties file: \" + propertyFile);", "        getLog().info(indent + \"properties file will override? \" + propertyFileWillOverride);", "        getLog().info(indent + \"prompt on non-local database? \" + promptOnNonLocalDatabase);", "        getLog().info(indent + \"clear checksums? \" + clearCheckSums);"]}
{"propertiesInputStream": ["protected void parsePropertiesFile(InputStream propertiesInputStream)", "        if (propertiesInputStream == null) {", "            props.load(propertiesInputStream);"]}
{"f": ["private boolean isCurrentFieldValueSpecified(Field f) throws IllegalAccessException {", "        Object currentValue = f.get(this);", "        Object defaultValue = getDefaultValue(f);", "        if (defaultValue == null) {", "            return !defaultValue.equals(f.get(this));"]}
{"nextLine": ["public void writeNext(String[] nextLine, boolean applyQuotesToAll) {", "      if (nextLine == null) {", "      StringBuilder sb = new StringBuilder(nextLine.length * 2); // This is for the worse case where all elements have to be escaped.", "      for (int i = 0; i < nextLine.length; i++) {", "         String nextElement = nextLine[i];", "         if (nextElement == null) {", "         Boolean stringContainsSpecialCharacters = stringContainsSpecialCharacters(nextElement);", "         if ((applyQuotesToAll || stringContainsSpecialCharacters) && (quotechar != NO_QUOTE_CHARACTER)) {", "         if (stringContainsSpecialCharacters) {", "            sb.append(processLine(nextElement));", "            sb.append(nextElement);", "         if ((applyQuotesToAll || stringContainsSpecialCharacters) && (quotechar != NO_QUOTE_CHARACTER)) {"], "applyQuotesToAll": ["public void writeNext(String[] nextLine, boolean applyQuotesToAll) {", "         if ((applyQuotesToAll || stringContainsSpecialCharacters) && (quotechar != NO_QUOTE_CHARACTER)) {", "         if ((applyQuotesToAll || stringContainsSpecialCharacters) && (quotechar != NO_QUOTE_CHARACTER)) {"]}
{"line": ["protected boolean stringContainsSpecialCharacters(String line) {", "      return (line.indexOf(quotechar) != -1) || (line.indexOf(escapechar) != -1) || (line.indexOf(separator) != -1)", "          || line.contains(DEFAULT_LINE_END) || line.contains(\"\\r\");"]}
{"nextElement": ["protected StringBuilder processLine(String nextElement) {", "      StringBuilder sb = new StringBuilder(nextElement.length() * 2); // this is for the worse case where all elements have to be escaped.", "      for (int j = 0; j < nextElement.length(); j++) {", "         char nextChar = nextElement.charAt(j);", "         processCharacter(sb, nextChar);"]}
{"sb": ["private void processCharacter(StringBuilder sb, char nextChar) {", "         sb.append(escapechar).append(nextChar);", "         sb.append(nextChar);"], "nextChar": ["private void processCharacter(StringBuilder sb, char nextChar) {", "      if ((escapechar != NO_ESCAPE_CHARACTER) && checkCharactersToEscape(nextChar)) {", "         sb.append(escapechar).append(nextChar);", "         sb.append(nextChar);"]}
{"servletContext": ["private void executeUpdate(ServletContext servletContext, InitialContext ic) throws NamingException, SQLException, LiquibaseException {", "            Enumeration<String> initParameters = servletContext.getInitParameterNames();"], "ic": ["private void executeUpdate(ServletContext servletContext, InitialContext ic) throws NamingException, SQLException, LiquibaseException {", "            DataSource dataSource = (DataSource) ic.lookup(this.dataSourceName);"]}
{"value": ["protected Object valueOf(Object value) {", "        if (value == null) {", "            return value;", "        } else if (type.isAssignableFrom(value.getClass())) {", "            return value;", "        } else if (value instanceof String) {", "                return Boolean.valueOf((String) value);", "                return Integer.valueOf((String) value);", "                return new BigDecimal((String) value);", "            \treturn Long.valueOf((String) value);", "                return StringUtil.splitAndTrim((String) value, \",\");", "                throw new UnexpectedLiquibaseException(\"Cannot parse property \"+value.getClass().getSimpleName()+\" to a \"+type.getSimpleName());", "            throw new UnexpectedLiquibaseException(\"Could not convert \"+value.getClass().getSimpleName()+\" to a \"+type.getSimpleName());"]}
{"type": ["public <T> T getValue(Class<T> type) {", "        if (!this.type.isAssignableFrom(type)) {", "            throw new UnexpectedLiquibaseException(\"Property \"+name+\" on is of type \"+this.type.getSimpleName()+\", not \"+type.getSimpleName());"]}
{"value": ["public void setValue(Object value) {", "        if ((value != null) && !type.isAssignableFrom(value.getClass())) {", "            throw new UnexpectedLiquibaseException(\"Property \"+name+\" on is of type \"+type.getSimpleName()+\", not \"+value.getClass().getSimpleName());", "        this.value = value;"]}
{"Result": "Method without Parameter"}
{"defaultValue": ["public ConfigurationProperty setDefaultValue(Object defaultValue) {", "        if ((defaultValue != null) && !type.isAssignableFrom(defaultValue.getClass())) {", "            if ((type == Long.class) && (defaultValue instanceof Integer)) {", "                return setDefaultValue(((Integer) defaultValue).longValue());", "            throw new UnexpectedLiquibaseException(\"Property \"+name+\" on is of type \"+type.getSimpleName()+\", not \"+defaultValue.getClass().getSimpleName());", "        this.defaultValue = defaultValue;"]}
{"statement": ["    public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain)  {", "        List<String> associatedWith = StringUtil.splitAndTrim(statement.getAssociatedWith(), \",\");", "        if ((statement.isUnique() != null) && statement.isUnique()) {", "        ColumnAnalysisResult result = analyseColumns(statement, database);", "        if (statement.getIndexName() != null) {", "            String indexSchema = statement.getTableSchemaName();", "            buffer.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema,", "                    statement.getIndexName())).append(\" \");", "        buffer.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(),", "                statement.getTableName()));", "        return new Sql[]{new UnparsedSql(buffer.toString(), getAffectedIndex(statement))};"], "database": ["    public Sql[] generateSql(CreateIndexStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain)  {", "        ColumnAnalysisResult result = analyseColumns(statement, database);", "        if (result.isFoundDescColumns())", "            buffer.append(database.escapeIndexName(statement.getTableCatalogName(), indexSchema,", "        buffer.append(database.escapeTableName(statement.getTableCatalogName(), statement.getTableSchemaName(),", "        if (result.getNumComputedCols() > 0)", "        buffer.append(String.format(\"(%s)\", result.getColumnExpression()));"], "sqlGeneratorChain": []}
{"column": ["private boolean applyIsComputedExpressionHeuristic(ColumnConfig column, Database database) {", "        String expr = column.getName();"], "database": ["private boolean applyIsComputedExpressionHeuristic(ColumnConfig column, Database database) {", "        if (database.isFunction(expr))"]}
{"tagString": ["public void tag(String tagString) throws LiquibaseException {", "            getDatabase().tag(tagString);"]}
{"Result": "Method without Parameter"}
{"contexts": ["public List<ChangeSetStatus> getChangeSetStatuses(Contexts contexts, LabelExpression labelExpression,", "        changeLogParameters.setContexts(contexts);", "            checkLiquibaseTables(true, changeLog, contexts, labelExpression);", "        changeLog.validate(database, contexts, labelExpression);", "        ChangeLogIterator logIterator = getStandardChangelogIterator(contexts, labelExpression, changeLog);", "        logIterator.run(visitor, new RuntimeEnvironment(database, contexts, labelExpression));"], "labelExpression": ["public List<ChangeSetStatus> getChangeSetStatuses(Contexts contexts, LabelExpression labelExpression,", "        changeLogParameters.setLabels(labelExpression);", "            checkLiquibaseTables(true, changeLog, contexts, labelExpression);", "        changeLog.validate(database, contexts, labelExpression);", "        ChangeLogIterator logIterator = getStandardChangelogIterator(contexts, labelExpression, changeLog);", "        logIterator.run(visitor, new RuntimeEnvironment(database, contexts, labelExpression));"], "checkLiquibaseTables": ["                                                      boolean checkLiquibaseTables) throws LiquibaseException {", "        if (checkLiquibaseTables) {", "            checkLiquibaseTables(true, changeLog, contexts, labelExpression);"]}
{"Result": "Method without Parameter"}
{"mapper": ["public List<T> parse(MappingStrategy<T> mapper, Reader reader) {", "      return parse(mapper, new CSVReader(reader));"], "reader": ["public List<T> parse(MappingStrategy<T> mapper, Reader reader) {", "      return parse(mapper, new CSVReader(reader));"]}
{"mapper": ["protected T processLine(MappingStrategy<T> mapper, String[] line) throws ReflectiveOperationException, IntrospectionException {", "      T bean = mapper.createBean();", "         if (mapper.isAnnotationDriven()) {", "            processField(mapper, line, bean, col);", "            processProperty(mapper, line, bean, col);"], "line": ["protected T processLine(MappingStrategy<T> mapper, String[] line) throws ReflectiveOperationException, IntrospectionException {", "      for (int col = 0; col < line.length; col++) {", "            processField(mapper, line, bean, col);", "            processProperty(mapper, line, bean, col);"]}
{"desc": ["protected PropertyEditor getPropertyEditor(PropertyDescriptor desc) throws ReflectiveOperationException {", "      Class<?> cls = desc.getPropertyEditorClass();", "      return getPropertyEditorValue(desc.getPropertyType());"]}
{"parentPackage": ["            String parentPackage,", "                                        parentPackage,", "            if (name.contains(parentPackage)) {"], "parentFileStream": ["            InputStream parentFileStream,", "            if (parentFileStream instanceof JarInputStream) {", "                jarStream = (JarInputStream) parentFileStream;", "                jarStream = new JarInputStream(parentFileStream);", "            while ((entry = jarStream.getNextJarEntry()) != null) {", "                String name = entry.getName();", "                if (name != null) {", "                    if (name.endsWith(\".jar\")) { //in a nested jar", "                        log.fine(LogType.LOG, \"Found nested jar \" + name);", "                        InputStream nestedJarResourceStream = loader.getResourceAsStream(name);", "                        if (nestedJarResourceStream != null) {", "                            JarInputStream nestedJarStream = new JarInputStream(nestedJarResourceStream);", "                                        nestedJarStream,", "                                        parentFileName + \"!\" + name,", "                                nestedJarStream.close();", "                    } else if (!entry.isDirectory() && name.endsWith(\".class\")) {", "                        classFiles.add(name.trim());", "                        grandparentClassFiles.add(name.trim());"], "loader": ["            ClassLoader loader,", "                        InputStream nestedJarResourceStream = loader.getResourceAsStream(name);", "                        if (nestedJarResourceStream != null) {", "                            JarInputStream nestedJarStream = new JarInputStream(nestedJarResourceStream);", "                                        nestedJarStream,", "                                        loader,", "                                nestedJarStream.close();", "                loadClass(name, loader);"], "parentFileName": ["            String parentFileName,", "        Set<String> classFiles = classFilesByLocation.get(parentFileName);", "        if (classFiles == null) {", "            classFilesByLocation.put(parentFileName, classFiles);", "                                        parentFileName + \"!\" + name,", "                                        parentFileName);", "        for (String name : classFiles) {", "            if (name.contains(parentPackage)) {", "                loadClass(name, loader);"], "grandparentFileName": ["            String grandparentFileName) throws IOException {", "            Set<String> grandparentClassFiles = classFilesByLocation.get(grandparentFileName);", "            if (grandparentClassFiles == null) {", "                classFilesByLocation.put(grandparentFileName, grandparentClassFiles);", "                        grandparentClassFiles.add(name.trim());"]}
{"test": ["protected void addIfMatching(PackageScanFilter test, String fqn, Set<Class<?>> classes) {", "                log.fine(LogType.LOG, \"Testing that class \" + externalName + \" matches criteria [\" + test + \"] using classloader:\" + classLoader);", "                    if (test.matches(type)) {"], "fqn": ["protected void addIfMatching(PackageScanFilter test, String fqn, Set<Class<?>> classes) {", "            String externalName = fqn.substring(0, fqn.indexOf('.')).replace('/', '.');", "                    log.fine(LogType.LOG, \"Cannot find class '\" + fqn + \"' in classloader: \" + classLoader", "                    log.fine(LogType.LOG, \"Cannot find the class definition '\" + fqn + \"' in classloader: \" + classLoader", "                    log.severe(LogType.LOG, \"Cannot load class '\"+fqn+\"' in classloader: \"+classLoader+\".  Reason: \"+e, e);", "                log.fine(LogType.LOG, \"Cannot find class '\" + fqn + \"' in any classloaders: \" + set);", "            log.warning(LogType.LOG, \"Cannot examine class '\" + fqn + \"' due to a \" + e.getClass().getName()"], "classes": ["protected void addIfMatching(PackageScanFilter test, String fqn, Set<Class<?>> classes) {", "                        classes.add(type);"]}
{"object": ["public static Class getPropertyType(Object object, String propertyName) {", "        Method readMethod = getReadMethod(object, propertyName);"], "propertyName": ["public static Class getPropertyType(Object object, String propertyName) {", "        Method readMethod = getReadMethod(object, propertyName);", "        if (readMethod == null) {", "        return readMethod.getReturnType();"]}
{"object": ["public static boolean hasProperty(Object object, String propertyName) {", "        return hasReadProperty(object, propertyName) && hasWriteProperty(object, propertyName);"], "propertyName": ["public static boolean hasProperty(Object object, String propertyName) {", "        return hasReadProperty(object, propertyName) && hasWriteProperty(object, propertyName);"]}
{"object": ["public static void setProperty(Object object, String propertyName, String propertyValue)  {", "        Method method = getWriteMethod(object, propertyName);", "                    object.getClass().getName()", "            method.invoke(object, finalValue);"], "propertyName": ["public static void setProperty(Object object, String propertyName, String propertyValue)  {", "        Method method = getWriteMethod(object, propertyName);", "        if (method == null) {", "                String.format(\"Property [%s] was not found for object type [%s]\", propertyName,", "        Class<?> parameterType = method.getParameterTypes()[0];", "            method.invoke(object, finalValue);", "            throw new UnexpectedLiquibaseException(\"Cannot call \" + method.toString()"], "propertyValue": ["public static void setProperty(Object object, String propertyName, String propertyValue)  {", "        Object finalValue = propertyValue;", "            finalValue = Boolean.valueOf(propertyValue);", "            finalValue = Integer.valueOf(propertyValue);", "            finalValue = Long.valueOf(propertyValue);", "            finalValue = new BigInteger(propertyValue);", "            finalValue = new BigDecimal(propertyValue);", "            finalValue = new DatabaseFunction(propertyValue);", "            finalValue = new SequenceNextValueFunction(propertyValue);", "            finalValue = new SequenceCurrentValueFunction(propertyValue);", "            finalValue = Enum.valueOf((Class<Enum>) parameterType, propertyValue);", "            method.invoke(object, finalValue);", "                + \" with value of type \" + finalValue.getClass().getName());"]}
{"object": ["private static Method getReadMethod(Object object, String propertyName) {", "        Method[] methods = getMethods(object);", "        for (Method method : methods) {", "            if ((method.getName().equals(getMethodName) || method.getName().equals(isMethodName)) && (method", "                return method;"], "propertyName": ["private static Method getReadMethod(Object object, String propertyName) {", "        String getMethodName = \"get\" + propertyName.substring(0, 1).toUpperCase(Locale.ENGLISH)", "            + propertyName.substring(1);", "        String isMethodName = \"is\" + propertyName.substring(0, 1).toUpperCase(Locale.ENGLISH)", "            + propertyName.substring(1);"]}
{"object": ["private static Method getWriteMethod(Object object, String propertyName) {", "        Method[] methods = getMethods(object);", "        for (Method method : methods) {", "            if (method.getName().equals(methodName) && (method.getParameterTypes().length == 1)) {", "                return method;"], "propertyName": ["private static Method getWriteMethod(Object object, String propertyName) {", "            + propertyName.substring(0, 1).toUpperCase(Locale.ENGLISH) + propertyName.substring(1);"]}
{"object": ["private static Method[] getMethods(Object object) {", "        Method[] methods = methodCache.get(object.getClass());", "            methods = object.getClass().getMethods();", "            methodCache.put(object.getClass(), methods);"]}
{"potentialCollection": ["protected Object undoCollection(Object potentialCollection, Object otherObject) {", "        if ((potentialCollection != null) && (otherObject != null) && (potentialCollection instanceof Collection) &&", "            if ((((Collection) potentialCollection).size() == 1) && ((Collection) potentialCollection).iterator()", "                potentialCollection = ((Collection) potentialCollection).iterator().next();", "        return potentialCollection;"], "otherObject": ["protected Object undoCollection(Object potentialCollection, Object otherObject) {", "        if ((potentialCollection != null) && (otherObject != null) && (potentialCollection instanceof Collection) &&", "            !(otherObject instanceof Collection)) {", "                .next().getClass().equals(otherObject.getClass())) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"id": ["CDILiquibaseConfig fileLocked(final String id, Callable<CDILiquibaseConfig> action) throws Exception {", "        log.info(LogType.LOG, String.format(\"[id = %s] JVM lock acquired, acquiring file lock\", id));", "            log.info(LogType.LOG, String.format(\"[id = %s] Created lock file [path='%s'].\", id, lockPath));", "        log.info(LogType.LOG, String.format(\"[id = %s] Trying to acquire the file lock [file='%s']...\", id, lockPath));", "                    log.fine(LogType.LOG, String.format(\"[id = %s] Lock already acquired, waiting for the lock...\", id));", "                    log.fine(LogType.LOG, String.format(\"[id = %s] Waiting for the lock...\", id));", "            log.info(LogType.LOG, String.format(\"[id = %s] File lock acquired, running liquibase...\", id));"], "action": ["CDILiquibaseConfig fileLocked(final String id, Callable<CDILiquibaseConfig> action) throws Exception {", "            actionResult = action.call();"]}
{"entryName": ["public static String getSimplePathForResources(String entryName, String path) {", "                return entryName.replaceFirst(components[1], \"\").substring(1);", "        return entryName;"], "path": ["public static String getSimplePathForResources(String entryName, String path) {", "        String[] components = path.split(\"!\");"]}
{"filterType": ["public boolean isFilteredBy(Class<? extends ChangeSetFilter> filterType) {", "            if (result.getFilter().equals(filterType)) {"]}
{"rs": ["public static String getValueForColumn(ResultSet rs, String columnNameToCheck, Database database) throws SQLException {", "        ResultSetMetaData metadata = rs.getMetaData();", "                return rs.getString(columnName);"], "columnNameToCheck": ["public static String getValueForColumn(ResultSet rs, String columnNameToCheck, Database database) throws SQLException {", "        String correctedColumnName = database.correctObjectName(columnNameToCheck, Column.class);"], "database": ["public static String getValueForColumn(ResultSet rs, String columnNameToCheck, Database database) throws SQLException {", "        String correctedColumnName = database.correctObjectName(columnNameToCheck, Column.class);"]}
{"Result": "Method without Parameter"}
{"username": [], "defaultCatalogName": ["public static void initializeDatabase(String username, String defaultCatalogName, String defaultSchemaName,", "        if (((defaultCatalogName != null) || (defaultSchemaName != null)) && !(database.getConnection() instanceof", "                String schema = defaultCatalogName;", "                if (schema == null) {", "                        database.escapeObjectName(schema, Schema.class)));", "                String schema = defaultCatalogName;", "                if (schema == null) {", "                        + schema));", "                String schema = defaultCatalogName;", "                if (schema == null) {", "                ExecutorService.getInstance().getExecutor(database).execute(new RawSqlStatement(\"USE \" + schema));"], "defaultSchemaName": ["public static void initializeDatabase(String username, String defaultCatalogName, String defaultSchemaName,", "        if (((defaultCatalogName != null) || (defaultSchemaName != null)) && !(database.getConnection() instanceof", "                    schema = defaultSchemaName;", "                        database.escapeObjectName(schema, Schema.class)));", "            } else if (database instanceof PostgresDatabase && defaultSchemaName != null) {", "                    ExecutorService.getInstance().getExecutor(database).execute(new RawSqlStatement(\"SET SEARCH_PATH TO \" + database.escapeObjectName(defaultSchemaName, Schema.class)));", "                    schema = defaultSchemaName;", "                        + schema));", "                    schema = defaultSchemaName;", "                ExecutorService.getInstance().getExecutor(database).execute(new RawSqlStatement(\"USE \" + schema));"], "database": ["                                          Database database) throws DatabaseException {", "        if (((defaultCatalogName != null) || (defaultSchemaName != null)) && !(database.getConnection() instanceof", "            if (database instanceof OracleDatabase) {", "                ExecutorService.getInstance().getExecutor(database).execute(", "                        database.escapeObjectName(schema, Schema.class)));", "            } else if (database instanceof PostgresDatabase && defaultSchemaName != null) {", "                    ExecutorService.getInstance().getExecutor(database).execute(new RawSqlStatement(\"SET SEARCH_PATH TO \" + database.escapeObjectName(defaultSchemaName, Schema.class)));", "            } else if (database instanceof AbstractDb2Database) {", "                ExecutorService.getInstance().getExecutor(database).execute(new RawSqlStatement(\"SET CURRENT SCHEMA \"", "            } else if (database instanceof MySQLDatabase) {", "                ExecutorService.getInstance().getExecutor(database).execute(new RawSqlStatement(\"USE \" + schema));"]}
{"databaseObject1": ["public static boolean nameMatches(DatabaseObject databaseObject1, DatabaseObject databaseObject2, Database accordingTo) {", "        String object1Name = accordingTo.correctObjectName(databaseObject1.getName(), databaseObject1.getClass());"], "databaseObject2": ["public static boolean nameMatches(DatabaseObject databaseObject1, DatabaseObject databaseObject2, Database accordingTo) {", "        String object2Name = accordingTo.correctObjectName(databaseObject2.getName(), databaseObject2.getClass());"], "accordingTo": ["public static boolean nameMatches(DatabaseObject databaseObject1, DatabaseObject databaseObject2, Database accordingTo) {", "        String object1Name = accordingTo.correctObjectName(databaseObject1.getName(), databaseObject1.getClass());", "        String object2Name = accordingTo.correctObjectName(databaseObject2.getName(), databaseObject2.getClass());", "        if (accordingTo.isCaseSensitive()) {"]}
{"database": ["private void setValidateOptionIfAvailable(Database database, ForeignKey foreignKey, CachedRow cachedRow) {", "        if (!(database instanceof OracleDatabase)) {", "            foreignKey.setShouldValidate(VALIDATE.equals(cleanNameFromDatabase(constraintValidate.trim(), database)));"], "foreignKey": ["private void setValidateOptionIfAvailable(Database database, ForeignKey foreignKey, CachedRow cachedRow) {", "            foreignKey.setShouldValidate(VALIDATE.equals(cleanNameFromDatabase(constraintValidate.trim(), database)));"], "cachedRow": ["private void setValidateOptionIfAvailable(Database database, ForeignKey foreignKey, CachedRow cachedRow) {", "        final String constraintValidate = cachedRow.getString(\"FK_VALIDATE\");"]}
{"type": ["public boolean addType(Class<? extends DatabaseObject> type, Database database) {", "        boolean added = this.types.add(type);", "        if (added) {", "            for (Class<? extends DatabaseObject> container : SnapshotGeneratorFactory.getInstance().getContainerTypes(type, database)) {", "                addType(container, database);", "        return added;"], "database": ["public boolean addType(Class<? extends DatabaseObject> type, Database database) {", "            for (Class<? extends DatabaseObject> container : SnapshotGeneratorFactory.getInstance().getContainerTypes(type, database)) {", "                addType(container, database);"]}
{"Result": "Method without Parameter"}
{"s": ["protected String checkForTrim(String s, PropertyDescriptor prop) {", "        return trimmableProperty(prop) ? s.trim() : s;"], "prop": ["protected String checkForTrim(String s, PropertyDescriptor prop) {", "        return trimmableProperty(prop) ? s.trim() : s;"]}
{"value": ["protected Object convertValue(String value, PropertyDescriptor prop) throws ReflectiveOperationException {", "        Object obj = value;", "            editor.setAsText(value);", "        return obj;"], "prop": ["protected Object convertValue(String value, PropertyDescriptor prop) throws ReflectiveOperationException {", "        PropertyEditor editor = getPropertyEditor(prop);", "        if (null != editor) {", "            editor.setAsText(value);", "            obj = editor.getValue();"]}
{"args": ["public static void main(String[] args) {", "            errorLevel = run(args);", "        System.exit(errorLevel);"]}
{"arg": ["    private static String[] splitArg(String arg) throws CommandLineParsingException {", "        String[] splitArg = arg.split(\"=\", 2);", "                    String.format(coreBundle.getString(\"could.not.parse.expression\"), arg)"]}
{"arg": ["private static boolean isCommand(String arg) {", "        return COMMANDS.MIGRATE.equals(arg)", "                || COMMANDS.MIGRATE_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.UPDATE.equalsIgnoreCase(arg)", "                || COMMANDS.UPDATE_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.UPDATE_COUNT.equalsIgnoreCase(arg)", "                || COMMANDS.UPDATE_COUNT_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.UPDATE_TO_TAG.equalsIgnoreCase(arg)", "                || COMMANDS.UPDATE_TO_TAG_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.ROLLBACK.equalsIgnoreCase(arg)", "                || COMMANDS.ROLLBACK_TO_DATE.equalsIgnoreCase(arg)", "                || COMMANDS.ROLLBACK_COUNT.equalsIgnoreCase(arg)", "                || COMMANDS.ROLLBACK_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.ROLLBACK_TO_DATE_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.FUTURE_ROLLBACK_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.FUTURE_ROLLBACK_COUNT_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.FUTURE_ROLLBACK_TO_TAG_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.UPDATE_TESTING_ROLLBACK.equalsIgnoreCase(arg)", "                || COMMANDS.TAG.equalsIgnoreCase(arg)", "                || COMMANDS.TAG_EXISTS.equalsIgnoreCase(arg)", "                || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg)", "                || COMMANDS.DROP_ALL.equalsIgnoreCase(arg)", "                || COMMANDS.RELEASE_LOCKS.equalsIgnoreCase(arg)", "                || COMMANDS.STATUS.equalsIgnoreCase(arg)", "                || COMMANDS.UNEXPECTED_CHANGESETS.equalsIgnoreCase(arg)", "                || COMMANDS.VALIDATE.equalsIgnoreCase(arg)", "                || COMMANDS.HELP.equalsIgnoreCase(arg)", "                || COMMANDS.DIFF.equalsIgnoreCase(arg)", "                || COMMANDS.DIFF_CHANGELOG.equalsIgnoreCase(arg)", "                || COMMANDS.GENERATE_CHANGELOG.equalsIgnoreCase(arg)", "                || COMMANDS.SNAPSHOT.equalsIgnoreCase(arg)", "                || COMMANDS.SNAPSHOT_REFERENCE.equalsIgnoreCase(arg)", "                || COMMANDS.EXECUTE_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.CALCULATE_CHECKSUM.equalsIgnoreCase(arg)", "                || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg)", "                || COMMANDS.DB_DOC.equalsIgnoreCase(arg)", "                || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg)", "                || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.MARK_NEXT_CHANGESET_RAN.equalsIgnoreCase(arg)", "                || COMMANDS.MARK_NEXT_CHANGESET_RAN_SQL.equalsIgnoreCase(arg);"]}
{"arg": ["private static boolean isNoArgCommand(String arg) {", "        return COMMANDS.MIGRATE.equals(arg)", "                || COMMANDS.MIGRATE_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.UPDATE.equalsIgnoreCase(arg)", "                || COMMANDS.UPDATE_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.FUTURE_ROLLBACK_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.UPDATE_TESTING_ROLLBACK.equalsIgnoreCase(arg)", "                || COMMANDS.LIST_LOCKS.equalsIgnoreCase(arg)", "                || COMMANDS.DROP_ALL.equalsIgnoreCase(arg)", "                || COMMANDS.RELEASE_LOCKS.equalsIgnoreCase(arg)", "                || COMMANDS.VALIDATE.equalsIgnoreCase(arg)", "                || COMMANDS.HELP.equalsIgnoreCase(arg)", "                || COMMANDS.CLEAR_CHECKSUMS.equalsIgnoreCase(arg)", "                || COMMANDS.CHANGELOG_SYNC.equalsIgnoreCase(arg)", "                || COMMANDS.CHANGELOG_SYNC_SQL.equalsIgnoreCase(arg)", "                || COMMANDS.MARK_NEXT_CHANGESET_RAN.equalsIgnoreCase(arg)", "                || COMMANDS.MARK_NEXT_CHANGESET_RAN_SQL.equalsIgnoreCase(arg);"]}
{"jar": ["private static File extract(JarFile jar, JarEntry entry) throws IOException {", "                BufferedInputStream inStream = new BufferedInputStream(jar.getInputStream(entry));"], "entry": ["private static File extract(JarFile jar, JarEntry entry) throws IOException {", "                BufferedInputStream inStream = new BufferedInputStream(jar.getInputStream(entry));"]}
{"potentialPropertyFile": ["private void parseDefaultPropertyFileFromResource(File potentialPropertyFile) throws IOException,", "                (potentialPropertyFile.getAbsolutePath())) {"]}
{"args": ["protected String[] fixupArgs(String[] args) {", "        for (int i = 0; i < args.length; i++) {", "            String arg = args[i];", "            if ((arg.startsWith(\"--\") || arg.startsWith(\"-D\")) && !arg.contains(\"=\")) {", "                if ((i + 1) < args.length) {", "                    nextArg = args[i + 1];", "                if ((nextArg != null) && !nextArg.startsWith(\"--\") && !isCommand(nextArg)) {", "                    arg = arg + \"=\" + nextArg;", "            arg = arg.replace(\"\\\\,\", \",\");", "            fixedArgs.add(arg);"]}
{"Result": "Method without Parameter"}
{"messages": ["private void checkForMissingCommandParameters(final List<String> messages) {", "            messages.add(coreBundle.getString(\"changeset.identifier.missing\"));"]}
{"messages": ["private void checkForMalformedCommandParameters(final List<String> messages) {", "                        messages.add(coreBundle.getString(\"changeset.identifier.must.have.form.filepath.id.author\"));", "            messages.add(String.format(coreBundle.getString(\"including.data.diffchangelog.has.no.effect\"),"]}
{"propertiesInputStream": ["protected void parsePropertiesFile(InputStream propertiesInputStream) throws IOException,", "        props.load(propertiesInputStream);"]}
{"errorMessages": ["protected void printHelp(List<String> errorMessages, PrintStream stream) {", "        for (String message : errorMessages) {", "            stream.println(\"  \" + message);"], "stream": ["protected void printHelp(List<String> errorMessages, PrintStream stream) {", "        stream.println(coreBundle.getString(\"errors\"));", "            stream.println(\"  \" + message);", "        stream.println();"]}
{"stream": ["protected void printHelp(PrintStream stream) {", "        stream.println(helpText);"]}
{"paramArgs": ["protected void parseOptions(String[] paramArgs) throws CommandLineParsingException {", "        String[] args = fixupArgs(paramArgs);", "        for (String arg : args) {", "            if (isCommand(arg)) {", "                this.command = arg;", "                if (this.command.equalsIgnoreCase(COMMANDS.MIGRATE)) {", "                } else if (this.command.equalsIgnoreCase(COMMANDS.MIGRATE_SQL)) {", "                if (arg.startsWith(\"-D\")) {", "                    String[] splitArg = splitArg(arg);", "                    String attributeName = splitArg[0].replaceFirst(\"^-D\", \"\");", "                    String value = splitArg[1];", "                    changeLogParameters.put(attributeName, value);", "                    commandParams.add(arg);", "                    if (arg.startsWith(\"--\")) {", "                        parseOptionArgument(arg);", "            } else if (arg.startsWith(\"--\")) {", "                parseOptionArgument(arg);", "                        String.format(coreBundle.getString(\"unexpected.value\"), arg));"]}
{"paramName": ["private String getCommandParam(String paramName, String defaultValue) throws CommandLineParsingException {", "            if (attributeName.equalsIgnoreCase(paramName)) {"], "defaultValue": ["private String getCommandParam(String paramName, String defaultValue) throws CommandLineParsingException {", "        return defaultValue;"]}
{"value": ["public static Integer readInteger(String value) {", "        if (value == null) {", "        return Integer.valueOf(value);"]}
{"runtimeLabels": ["public boolean matches(Labels runtimeLabels) {", "        if ((runtimeLabels == null) || runtimeLabels.isEmpty()) {", "            if (matches(expression, runtimeLabels)) {"]}
{"example": ["public boolean has(DatabaseObject example, Database database) throws DatabaseException, InvalidExampleException {", "        List<Class<? extends DatabaseObject>> types = new ArrayList<>(getContainerTypes(example.getClass(), database));", "        types.add(example.getClass());", "        if ((example instanceof Table) && (example.getName().equals(database.getDatabaseChangeLogTableName()) ||", "            example.getName().equals(database.getDatabaseChangeLogLockTableName()))) {", "                                        database.getLiquibaseSchemaName(), example.getName(), Table.class)));", "        if (createSnapshot(example, database,snapshotControl) != null) {", "        if (example.getSchema() == null) {", "            catalogAndSchema = example.getSchema().toCatalogAndSchema();", "            new SnapshotControl(database, false, example.getClass()).setWarnIfObjectNotFound(false)", "        for (DatabaseObject obj : snapshot.get(example.getClass())) {", "            if (DatabaseObjectComparatorFactory.getInstance().isSameObject(example, obj, null, database)) {"], "database": ["public boolean has(DatabaseObject example, Database database) throws DatabaseException, InvalidExampleException {", "        List<Class<? extends DatabaseObject>> types = new ArrayList<>(getContainerTypes(example.getClass(), database));", "        types.add(example.getClass());", "        if ((example instanceof Table) && (example.getName().equals(database.getDatabaseChangeLogTableName()) ||", "            example.getName().equals(database.getDatabaseChangeLogLockTableName()))) {", "                ExecutorService.getInstance().getExecutor(database).queryForInt(", "                                database.escapeObjectName(database.getLiquibaseCatalogName(),", "                                        database.getLiquibaseSchemaName(), example.getName(), Table.class)));", "                if (database instanceof PostgresDatabase) { // throws \"current transaction is aborted\" unless we roll back the connection", "                    database.rollback();", "        SnapshotControl snapshotControl = (new SnapshotControl(database, false, types.toArray(new Class[types.size()])));", "        if (createSnapshot(example, database,snapshotControl) != null) {", "            catalogAndSchema = database.getDefaultSchema();", "        DatabaseSnapshot snapshot = createSnapshot(catalogAndSchema, database,", "            new SnapshotControl(database, false, example.getClass()).setWarnIfObjectNotFound(false)", "            if (DatabaseObjectComparatorFactory.getInstance().isSameObject(example, obj, null, database)) {"]}
{"examples": ["public DatabaseSnapshot createSnapshot(DatabaseObject[] examples, Database database,", "            DatabaseSnapshot snapshot = ((OfflineConnection) conn).getSnapshot(examples);", "            if (snapshot == null) {", "            return snapshot;", "        return new JdbcDatabaseSnapshot(examples, database, snapshotControl);"], "database": ["public DatabaseSnapshot createSnapshot(DatabaseObject[] examples, Database database,", "        DatabaseConnection conn = database.getConnection();", "            return new EmptyDatabaseSnapshot(database, snapshotControl);", "        return new JdbcDatabaseSnapshot(examples, database, snapshotControl);"], "snapshotControl": ["                                           SnapshotControl snapshotControl)", "            return new EmptyDatabaseSnapshot(database, snapshotControl);", "        return new JdbcDatabaseSnapshot(examples, database, snapshotControl);"]}
{"example": ["public <T extends DatabaseObject> T createSnapshot(T example, Database database) throws DatabaseException, InvalidExampleException {", "        return createSnapshot(example, database, new SnapshotControl(database));"], "database": ["public <T extends DatabaseObject> T createSnapshot(T example, Database database) throws DatabaseException, InvalidExampleException {", "        return createSnapshot(example, database, new SnapshotControl(database));"]}
{"database": ["private List<DropForeignKeyConstraintChange> generateChildren(Database database) {", "            SnapshotControl control = new SnapshotControl(database);", "            control.getTypesToInclude().add(ForeignKey.class);", "            catalogAndSchema = catalogAndSchema.standardize(database);", "            Table target = SnapshotGeneratorFactory.getInstance().createSnapshot(", "                    new Table(catalogAndSchema.getCatalogName(), catalogAndSchema.getSchemaName(),", "                            database.correctObjectName(getBaseTableName(), Table.class))", "                    , database);", "            List<ForeignKey> results = ((target == null) ? null : target.getOutgoingForeignKeys());", "                            target,", "                            database"]}
{"directory": ["private static void cleanDirectory(final File directory) throws IOException {", "        if ( !directory.exists() ) {", "        if ( !directory.isDirectory() ) {", "        final File[] files = directory.listFiles();"]}
{"multiLineSQL": ["public static String[] splitSQL(String multiLineSQL, String endDelimiter) {", "        return processMutliLineSQL(multiLineSQL, false, true, endDelimiter);"], "endDelimiter": ["public static String[] splitSQL(String multiLineSQL, String endDelimiter) {", "        return processMutliLineSQL(multiLineSQL, false, true, endDelimiter);"]}
{"value": ["public static String pad(String value, int length) {", "        value = StringUtil.trimToEmpty(value);", "        if (value.length() >= length) {", "            return value;", "        return value + StringUtil.repeat(\" \", length - value.length());"], "length": ["public static String pad(String value, int length) {", "        if (value.length() >= length) {", "        return value + StringUtil.repeat(\" \", length - value.length());"]}
{"value": ["public static String leftPad(String value, int length) {", "        value = StringUtil.trimToEmpty(value);", "        if (value.length() >= length) {", "            return value;", "        return StringUtil.repeat(\" \", length - value.length()) + value;"], "length": ["public static String leftPad(String value, int length) {", "        if (value.length() >= length) {", "        return StringUtil.repeat(\" \", length - value.length()) + value;"]}
{"len": ["public static String randomIdentifer(int len) {", "        StringBuilder sb = new StringBuilder( len );", "        for (int i = 0; i < len; i++)", "            sb.append( AB.charAt( rnd.nextInt(AB.length()) ) );", "        return sb.toString();"]}
{"sqlString": ["public static String stripSqlCommentsAndWhitespacesFromTheEnd(String sqlString) {", "        if (isEmpty(sqlString)) {", "            return sqlString;", "        StringBuilder str = new StringBuilder(sqlString);", "            String lastBlockComment = getLastBlockComment(str.toString());", "            if (isNotEmpty(lastBlockComment)) {", "                str.setLength(str.length() - lastBlockComment.length());", "            String lastLineComment = getLastLineComment(str.toString());", "            if (isNotEmpty(lastLineComment)) {", "                str.setLength(str.length() - lastLineComment.length());", "        return trimRight(str.toString());"]}
{"baseString": ["public static String concatConsistentCase(String baseString, String addition) {", "        boolean hasLowerCase = hasLowerCase(baseString);", "        boolean hasUpperCase = hasUpperCase(baseString);", "        if ((hasLowerCase && hasUpperCase) || (!hasLowerCase && !hasUpperCase)) { //mixed case || no letters", "            return baseString + addition;", "        } else if (hasLowerCase) {", "            return baseString + addition.toLowerCase();", "            return baseString + addition.toUpperCase();"], "addition": ["public static String concatConsistentCase(String baseString, String addition) {", "            return baseString + addition;", "            return baseString + addition.toLowerCase();", "            return baseString + addition.toUpperCase();"]}
{"database": ["protected String[] getDatabaseCatalogNames(Database database) throws SQLException, DatabaseException {", "            if (((AbstractJdbcDatabase) database).jdbcCallsCatalogsSchemas()) {", "                catalogs = ((JdbcConnection) database.getConnection()).getMetaData().getSchemas();", "                catalogs = ((JdbcConnection) database.getConnection()).getMetaData().getCatalogs();", "                if (((AbstractJdbcDatabase) database).jdbcCallsCatalogsSchemas()) {"]}
{"key": ["public StringClauses append(String key, String clause) {", "        Validate.notNull(StringUtil.trimToNull(key), \"key must be a non-null, non-empty value\");", "        key = StringUtil.trimToEmpty(key).toLowerCase();"], "clause": ["public StringClauses append(String key, String clause) {", "        clause = StringUtil.trimToEmpty(clause);", "        clauses.put(key, clause.trim());"]}
{"key": ["public StringClauses append(String key, StringClauses subclauses) {", "        Validate.notNull(StringUtil.trimToNull(key), \"key must be a non-null, non-empty value\");", "        key = StringUtil.trimToEmpty(key).toLowerCase();"], "subclauses": ["public StringClauses append(String key, StringClauses subclauses) {", "        clauses.put(key, subclauses);"]}
{"key": ["public StringClauses prepend(String key, String clause) {", "        return prependImpl(key, StringUtil.trimToEmpty(clause));"], "clause": ["public StringClauses prepend(String key, String clause) {", "        return prependImpl(key, StringUtil.trimToEmpty(clause));"]}
{"existingKey": ["public StringClauses insertBefore(String existingKey, String newKey, String newValue) throws IllegalArgumentException {", "        return insertBeforeImpl(existingKey, newKey, newValue);"], "newKey": ["public StringClauses insertBefore(String existingKey, String newKey, String newValue) throws IllegalArgumentException {", "        return insertBeforeImpl(existingKey, newKey, newValue);"], "newValue": ["public StringClauses insertBefore(String existingKey, String newKey, String newValue) throws IllegalArgumentException {", "        return insertBeforeImpl(existingKey, newKey, newValue);"]}
{"existingKey": ["public StringClauses insertAfter(String existingKey, String newKey, String newValue) {", "        return insertAfterImpl(existingKey, newKey, newValue);"], "newKey": ["public StringClauses insertAfter(String existingKey, String newKey, String newValue) {", "        return insertAfterImpl(existingKey, newKey, newValue);"], "newValue": ["public StringClauses insertAfter(String existingKey, String newKey, String newValue) {", "        return insertAfterImpl(existingKey, newKey, newValue);"]}
{"exitingKey": ["public String get(String exitingKey) {", "        exitingKey = StringUtil.trimToEmpty(exitingKey).toLowerCase();"]}
{"exitingKey": ["public StringClauses getSubclause(String exitingKey) {", "        exitingKey = StringUtil.trimToEmpty(exitingKey).toLowerCase();"]}
{"out": ["public void print(PrintStream out, ChangeLogSerializer changeLogSerializer) throws ParserConfigurationException, IOException, DatabaseException {", "        changeLogSerializer.write(changeSets, out);", "        out.flush();"], "changeLogSerializer": ["public void print(PrintStream out, ChangeLogSerializer changeLogSerializer) throws ParserConfigurationException, IOException, DatabaseException {", "        changeLogSerializer.write(changeSets, out);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"database": ["public boolean validate(Database database) {", "        int maxParameters = this.getMaxParameters(database);", "        int minParameters = this.getMinParameters(database);", "        if (parameters.size() > maxParameters) {", "            throw new UnexpectedLiquibaseException(\"Type \"+getClass()+\" doesn't support \"+ maxParameters+\" parameters\");", "        if (parameters.size() < minParameters) {", "            throw new UnexpectedLiquibaseException(\"Type \"+getClass()+\" requires \"+ minParameters+\" parameters\");"]}
{"database": ["public DatabaseDataType toDatabaseDataType(Database database) {", "        if (database instanceof MSSQLDatabase) {", "            String name = database.escapeDataTypeName(getName());", "            int dataTypeMaxParameters = database.getDataTypeMaxParameters(getName());"]}
{"value": ["public String objectToSql(Object value, Database database) {", "        if ((value == null) || \"null\".equals(value.toString().toLowerCase(Locale.US))) {", "        } else if (value instanceof DatabaseFunction) {", "            return functionToSql((DatabaseFunction) value, database);", "        } else if (value instanceof Number) {", "            return numberToSql((Number) value, database);", "        return otherToSql(value, database);"], "database": ["public String objectToSql(Object value, Database database) {", "            return functionToSql((DatabaseFunction) value, database);", "            return numberToSql((Number) value, database);", "        return otherToSql(value, database);"]}
{"string": ["protected boolean isCurrentDateTimeFunction(String string, Database database) {", "        return string.toLowerCase(Locale.US).startsWith(\"current_timestamp\")", "                || string.toLowerCase(Locale.US).startsWith(DatabaseFunction.CURRENT_DATE_TIME_PLACE_HOLDER)", "                || database.getCurrentDateTimeFunction().toLowerCase(Locale.US).equals(string.toLowerCase(Locale.US));"], "database": ["protected boolean isCurrentDateTimeFunction(String string, Database database) {", "                || database.getCurrentDateTimeFunction().toLowerCase(Locale.US).equals(string.toLowerCase(Locale.US));"]}
{"Result": "Method without Parameter"}
{"values": ["private String getConcatSql(List<String> values) {", "        if (values.size() == 1) {", "            return values.get(0);", "            return START_CONCAT + values.get(0) + SEP_CONCAT + getConcatSql(values.subList(1, values.size())) + END_CONCAT;"]}
{"statement": ["public boolean generateStatementsVolatile(SqlStatement statement, Database database) {", "        for (SqlGenerator generator : getGenerators(statement, database)) {", "            if (generator.generateStatementsIsVolatile(database)) {"], "database": ["public boolean generateStatementsVolatile(SqlStatement statement, Database database) {", "        for (SqlGenerator generator : getGenerators(statement, database)) {", "            if (generator.generateStatementsIsVolatile(database)) {"]}
{"urls": ["private static void addArtifact(Set<URI> urls,", "      addFile(urls, f, log, verbose);"], "artifact": ["                                  Artifact artifact,", "    File f = artifact.getFile();", "      log.warn(\"Artifact with no actual file, '\" + artifact.getGroupId()", "               + \":\" + artifact.getArtifactId() + \"'\");"], "log": ["                                  Log log,", "      log.warn(\"Artifact with no actual file, '\" + artifact.getGroupId()", "      addFile(urls, f, log, verbose);"], "verbose": ["                                  boolean verbose)", "      addFile(urls, f, log, verbose);"]}
{"clazz": ["public static Field getDeclaredField(Class clazz, String fieldName)", "    Field f = getField(clazz, fieldName);", "      Class parent = clazz.getSuperclass();"], "fieldName": ["public static Field getDeclaredField(Class clazz, String fieldName)", "    Field f = getField(clazz, fieldName);", "    if (f == null) {", "        return getDeclaredField(parent, fieldName);", "        throw new NoSuchFieldException(\"The field '\" + fieldName + \"' could not be \"", "      return f;"]}
{"path": ["protected List<String> getAlternatePaths(String path) {", "        if (path.startsWith(\"/\")) { //People are often confused about leading slashes in resource paths...", "            alternatePaths.add(path.substring(1));"]}
{"runtimeContexts": ["public boolean matches(Contexts runtimeContexts) {", "        if ((runtimeContexts == null) || runtimeContexts.isEmpty()) {", "            if (matches(expression, runtimeContexts)) {"]}
{"classLoader": ["private ResourceAccessor createResourceAccessor(ClassLoader classLoader) {", "        resourceAccessors.add(new ClassLoaderResourceAccessor(classLoader));"]}
{"database": ["protected void closeDatabase(Database database) {", "            if(database != null) {", "                database.close();"]}
{"line": ["private int appendNextCharacterAndAdvanceLoop(String line, StringBuilder sb, int i) {", "        sb.append(line.charAt(i + 1));"], "sb": ["private int appendNextCharacterAndAdvanceLoop(String line, StringBuilder sb, int i) {", "        sb.append(line.charAt(i + 1));"], "i": ["private int appendNextCharacterAndAdvanceLoop(String line, StringBuilder sb, int i) {", "        sb.append(line.charAt(i + 1));"]}
{"nextLine": ["private boolean isNextCharacterEscapedQuote(String nextLine, boolean inQuotes, int i) {", "            && (nextLine.length() > (i + 1))  // there is indeed another character to check.", "            && isCharacterQuoteCharacter(nextLine.charAt(i + 1));"], "inQuotes": ["private boolean isNextCharacterEscapedQuote(String nextLine, boolean inQuotes, int i) {", "        return inQuotes  // we are in quotes, therefore there can be escaped quotes in here."], "i": ["private boolean isNextCharacterEscapedQuote(String nextLine, boolean inQuotes, int i) {", "            && (nextLine.length() > (i + 1))  // there is indeed another character to check.", "            && isCharacterQuoteCharacter(nextLine.charAt(i + 1));"]}
{"nextLine": ["protected boolean isNextCharacterEscapable(String nextLine, boolean inQuotes, int i) {", "            && (nextLine.length() > (i + 1))  // there is indeed another character to check.", "            && isCharacterEscapable(nextLine.charAt(i + 1));"], "inQuotes": ["protected boolean isNextCharacterEscapable(String nextLine, boolean inQuotes, int i) {", "        return inQuotes  // we are in quotes, therefore there can be escaped quotes in here."], "i": ["protected boolean isNextCharacterEscapable(String nextLine, boolean inQuotes, int i) {", "            && (nextLine.length() > (i + 1))  // there is indeed another character to check.", "            && isCharacterEscapable(nextLine.charAt(i + 1));"]}
{"namespace": ["public List<ParsedNode> getChildren(String namespace, String nodename) {", "            if (nodeMatches(node, namespace, nodename)) {"], "nodename": ["public List<ParsedNode> getChildren(String namespace, String nodename) {", "            if (nodeMatches(node, namespace, nodename)) {"]}
{"value": ["public ParsedNode setValue(Object value) throws ParsedNodeException {", "        if (value instanceof ParsedNode) {", "            this.addChild((ParsedNode) value);", "        } else if (value instanceof Collection) {", "            for (Object obj : ((Collection) value)) {", "                if (obj instanceof Map) {", "                    addChildren((Map) obj);", "                } else if (obj instanceof ParsedNode) {", "                    addChild(((ParsedNode) obj));", "                    newValue.add(obj);", "        } else if (value instanceof Map) {", "            addChildren(((Map) value));", "            this.value = value;"]}
{"type": ["public <T> T getValue(Class<T> type) throws ParsedNodeException {", "        return convertObject(value, type);"]}
{"namespace": ["public ParsedNode getChild(String namespace, String name) throws ParsedNodeException {", "            if (nodeMatches(node, namespace, name)) {", "                    throw new ParsedNodeException(\"Multiple nodes match \"+namespace+\"/\"+name);"], "name": ["public ParsedNode getChild(String namespace, String name) throws ParsedNodeException {", "            if (nodeMatches(node, namespace, name)) {", "                    throw new ParsedNodeException(\"Multiple nodes match \"+namespace+\"/\"+name);"]}
{"namespace": ["public <T> T getChildValue(String namespace, String nodename, Class<T> type) throws ParsedNodeException {", "        Object rawValue = getChildValue(namespace, nodename);"], "nodename": ["public <T> T getChildValue(String namespace, String nodename, Class<T> type) throws ParsedNodeException {", "        Object rawValue = getChildValue(namespace, nodename);", "        if (rawValue == null) {", "        return convertObject(rawValue, type);"], "type": ["public <T> T getChildValue(String namespace, String nodename, Class<T> type) throws ParsedNodeException {", "        return convertObject(rawValue, type);"]}
{"namespace": ["public Object getChildValue(String namespace, String nodename) throws ParsedNodeException {", "        ParsedNode child = getChild(namespace, nodename);"], "nodename": ["public Object getChildValue(String namespace, String nodename) throws ParsedNodeException {", "        ParsedNode child = getChild(namespace, nodename);", "        if (child == null) {", "        return child.getValue();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"path": ["protected boolean isCompressedFile(Path path) {", "        return path != null && (path.toString().startsWith(\"jar:\") || path.toString().toLowerCase().endsWith(\".jar\") || path.toString().toLowerCase().endsWith(\".zip\"));"]}
{"columnName": ["public Column getColumn(String columnName) {", "            if (column.getName().equalsIgnoreCase(columnName)) {"]}
{"type": ["public <T extends SingletonObject> T getSingleton(Class<T> type) {", "            return getParent().getSingleton(type);", "        String key = type.getName();", "        T singleton = get(key, type);", "        if (singleton == null) {", "                    Constructor<T> constructor = type.getDeclaredConstructor(Scope.class);", "                    Constructor<T> constructor = type.getDeclaredConstructor();", "        return singleton;"]}
{"tagString": ["    public void tag(final String tagString) throws DatabaseException {", "        executor.execute(new TagDatabaseStatement(tagString));", "            ranChangeSetList.get(ranChangeSetList.size() - 1).setTag(tagString);"]}
{"tagName": ["public Precondition create(String tagName) {", "        Class<?> aClass = preconditions.get(tagName);", "        if (aClass == null) {", "            return (Precondition) aClass.getConstructor().newInstance();"]}
{"value": ["public static boolean isNowOrTodayFormat(String value) {", "        if (value != null) {", "            String lowerValue = value.toLowerCase();"]}
{"key": ["public Object getValue(String key, DatabaseChangeLog changeLog) {", "        ChangeLogParameter parameter = findParameter(key, changeLog);"], "changeLog": ["public Object getValue(String key, DatabaseChangeLog changeLog) {", "        ChangeLogParameter parameter = findParameter(key, changeLog);", "        return (parameter != null) ? parameter.getValue() : null;"]}
{"database": ["private void setValidateOptionIfAvailable(Database database, UniqueConstraint uniqueConstraint, Map<String, ?> columnsMetadata) {", "        if (!(database instanceof OracleDatabase)) {", "            uniqueConstraint.setShouldValidate(VALIDATE.equals(cleanNameFromDatabase(constraintValidate.toString().trim(), database)));"], "uniqueConstraint": ["private void setValidateOptionIfAvailable(Database database, UniqueConstraint uniqueConstraint, Map<String, ?> columnsMetadata) {", "            uniqueConstraint.setShouldValidate(VALIDATE.equals(cleanNameFromDatabase(constraintValidate.toString().trim(), database)));"], "columnsMetadata": ["private void setValidateOptionIfAvailable(Database database, UniqueConstraint uniqueConstraint, Map<String, ?> columnsMetadata) {", "        final Object constraintValidate = columnsMetadata.get(\"CONSTRAINT_VALIDATE\");"]}
{"database": ["private String getUniqueConstraintsSqlInformix(InformixDatabase database, Schema schema, String name) {", "        String catalogName = database.correctObjectName(schema.getCatalogName(), Catalog.class);", "        String constraintName = database.correctObjectName(name, UniqueConstraint.class);"], "schema": ["private String getUniqueConstraintsSqlInformix(InformixDatabase database, Schema schema, String name) {", "        String catalogName = database.correctObjectName(schema.getCatalogName(), Catalog.class);"], "name": ["private String getUniqueConstraintsSqlInformix(InformixDatabase database, Schema schema, String name) {", "        String constraintName = database.correctObjectName(name, UniqueConstraint.class);"]}
{"change": ["public Map<String, ChangeParameterMetaData> getSetParameters(Change change) {", "            if (entry.getValue().getCurrentValue(change) != null) {"]}
{"database": ["public Map<String, ChangeParameterMetaData> getRequiredParameters(Database database) {", "            if (metaData.isRequiredFor(database)) {"]}
{"newValue": ["private String convertToString(Object newValue, Database database) {", "    if (newValue == null || newValue.toString().equals(\"\") || newValue.toString().equalsIgnoreCase(\"NULL\")) {", "    } else if (newValue instanceof String && !looksLikeFunctionCall(((String) newValue), database)) {", "      sqlString = \"'\" + database.escapeStringForDatabase(newValue.toString()) + \"'\";", "    } else if (newValue instanceof Date) {", "      sqlString = database.getDateLiteral(((Date) newValue));", "    } else if (newValue instanceof Boolean) {", "      if (((Boolean) newValue)) {", "      sqlString = newValue.toString();", "    return sqlString;"], "database": ["private String convertToString(Object newValue, Database database) {", "    } else if (newValue instanceof String && !looksLikeFunctionCall(((String) newValue), database)) {", "      sqlString = \"'\" + database.escapeStringForDatabase(newValue.toString()) + \"'\";", "      sqlString = database.getDateLiteral(((Date) newValue));", "        sqlString = DataTypeFactory.getInstance().getTrueBooleanValue(database);", "        sqlString = DataTypeFactory.getInstance().getFalseBooleanValue(database);", "    return sqlString;"]}
{"Result": "Method without Parameter"}
{"filename": ["private static String doGetFullPath(String filename, boolean includeSeparator) {", "        if (filename == null) {", "        int prefix = getPrefixLength(filename);", "        if (prefix < 0) {", "        if (prefix >= filename.length()) {", "                return getPrefix(filename);  // add end slash if necessary", "                return filename;", "        int index = indexOfLastSeparator(filename);", "        if (index < 0) {", "            return filename.substring(0, prefix);", "        int end = index + (includeSeparator ?  1 : 0);", "        return filename.substring(0, end);"], "includeSeparator": ["private static String doGetFullPath(String filename, boolean includeSeparator) {", "            if (includeSeparator) {", "        int end = index + (includeSeparator ?  1 : 0);"]}
{"values": ["protected void createIndexLookup(String[] values) {", "         for (int i = 0; i < values.length; i++) {", "            indexLookup.put(values[i], i);"]}
{"name": ["   public Integer getColumnIndex(String name) {", "      return indexLookup.get(name);"]}
{"col": ["   public PropertyDescriptor findDescriptor(int col) throws IntrospectionException {", "      String columnName = getColumnName(col);", "      return (StringUtil.trimToNull(columnName) != null) ? findDescriptor(columnName) : null;"]}
{"col": ["   public BeanField findField(int col) {", "      String columnName = getColumnName(col);", "      return (StringUtil.trimToNull(columnName) != null) ? findField(columnName) : null;"]}
{"col": ["public String getColumnName(int col) {", "      return ((null != header) && (col < header.length)) ? header[col] : null;"]}
{"name": ["protected PropertyDescriptor findDescriptor(String name) throws IntrospectionException {", "      return descriptorMap.get(name.toUpperCase().trim());"]}
{"name": ["protected BeanField findField(String name) {", "      return fieldMap.get(name.toUpperCase().trim());"]}
{"name": ["protected boolean matches(String name, PropertyDescriptor desc) {", "      return desc.getName().equals(name.trim());"], "desc": ["protected boolean matches(String name, PropertyDescriptor desc) {", "      return desc.getName().equals(name.trim());"]}
{"Result": "Method without Parameter"}
{"col": ["   public String getColumnName(int col) {", "      return (col < columnMapping.length) ? columnMapping[col] : null;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"columnType": ["public static boolean supportsDefaultValueComputed(String columnType, String defaultValue) {", "        HashSet<String> possibleComputedValues = SUPPORTED_DEFAULT_VALUE_COMPUTED_MAP.get(columnType);", "        return (possibleComputedValues != null) && possibleComputedValues.contains(defaultValue.toLowerCase());"], "defaultValue": ["public static boolean supportsDefaultValueComputed(String columnType, String defaultValue) {", "        return (possibleComputedValues != null) && possibleComputedValues.contains(defaultValue.toLowerCase());"]}
{"Result": "Method without Parameter"}
{"objectName": ["    public String escapeObjectName(String objectName, Class<? extends DatabaseObject> objectType) {", "        if ((quotingStrategy == ObjectQuotingStrategy.LEGACY) && hasMixedCase(objectName)) {", "            return \"\\\"\" + objectName + \"\\\"\";", "            return (objectName != null && !objectName.isEmpty()) ? objectName.trim() : objectName;", "        return super.escapeObjectName(objectName, objectType);"], "objectType": ["    public String escapeObjectName(String objectName, Class<? extends DatabaseObject> objectType) {", "        } else if (objectType != null && LiquibaseColumn.class.isAssignableFrom(objectType)) {", "        return super.escapeObjectName(objectName, objectType);"]}
{"valueNumeric": ["public ColumnConfig setValueNumeric(String valueNumeric) {", "        if ((valueNumeric == null) || \"null\".equalsIgnoreCase(valueNumeric)) {", "            String saved = valueNumeric;", "            if (valueNumeric.startsWith(\"(\")) {", "                valueNumeric = valueNumeric.replaceFirst(\"^\\\\(\", \"\");", "                this.valueNumeric = ValueNumeric.of(Locale.US, valueNumeric);", "                this.valueComputed = new DatabaseFunction(saved);"]}
{"valueBoolean": ["public ColumnConfig setValueBoolean(String valueBoolean) {", "        valueBoolean = StringUtil.trimToNull(valueBoolean);", "        if ((valueBoolean == null) || \"null\".equalsIgnoreCase(valueBoolean)) {", "            if (\"true\".equalsIgnoreCase(valueBoolean) || \"1\".equals(valueBoolean)) {", "            } else if (\"false\".equalsIgnoreCase(valueBoolean) || \"0\".equals(valueBoolean)) {", "                this.valueComputed = new DatabaseFunction(valueBoolean);"]}
{"defaultValueBoolean": ["public ColumnConfig setDefaultValueBoolean(String defaultValueBoolean) {", "        defaultValueBoolean = StringUtil.trimToNull(defaultValueBoolean);", "        if ((defaultValueBoolean == null) || \"null\".equalsIgnoreCase(defaultValueBoolean)) {", "            if (\"true\".equalsIgnoreCase(defaultValueBoolean) || \"1\".equals(defaultValueBoolean)) {", "            } else if (\"false\".equalsIgnoreCase(defaultValueBoolean) || \"0\".equals(defaultValueBoolean)) {", "                this.defaultValueComputed = new DatabaseFunction(defaultValueBoolean);"]}
{"name": ["public void unregister(String name) {", "            if (getChangeMetaData(change).getName().equals(name)) {"]}
{"Result": "Method without Parameter"}
{"name": ["public Change create(String name) {", "        Change plugin = getPlugin(name);", "        if (plugin == null) {", "            return plugin.getClass().getConstructor().newInstance();"]}
{"database": ["    public boolean promptForNonLocalDatabase(Database database) throws DatabaseException {", "                \"Database URL is: \" + database.getConnection().getURL() + StreamUtil.getLineSeparator() +", "                \"Username is: \" + database.getConnection().getConnectionUserName() + StreamUtil.getLineSeparator() + StreamUtil.getLineSeparator() +"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"visitors": ["protected List<SqlVisitor> filterRollbackVisitors(final List<SqlVisitor> visitors) {", "        if (visitors != null) {", "            for (SqlVisitor visitor : visitors) {", "                if (visitor.isApplyToRollback()) {", "                    rollbackVisitors.add(visitor);"]}
{"Result": "Method without Parameter"}
{"text": ["protected String checkString(String text) throws UnexpectedLiquibaseException {", "        if (null == text || text.isEmpty()) {", "            return text;", "        final int len = text.length();", "            current = text.charAt(i);", "            if (Character.isHighSurrogate(current) && i + 1 < len && Character.isLowSurrogate(text.charAt(i + 1))) {", "                codePoint = text.codePointAt(i++);", "                codePoint = current;", "            if ((codePoint == '\\n')", "                    || (codePoint == '\\r')", "                    || (codePoint == '\\t')", "                    || (codePoint == 0xB)", "                    || (codePoint == 0xC)", "                    || ((codePoint >= 0x20) && (codePoint <= 0x7E))", "                    || ((codePoint >= 0xA0) && (codePoint <= 0xD7FF))", "                    || ((codePoint >= 0xE000) && (codePoint <= 0xFFFD))", "                    || ((codePoint >= 0x10000) && (codePoint <= 0x10FFFF))", "        return text;"]}
{"nodeNamespace": ["public Element createNode(String nodeNamespace, String nodeName, String nodeContent) {", "        Element element = currentChangeLogFileDOM.createElementNS(nodeNamespace, nodeName);"], "nodeName": ["public Element createNode(String nodeNamespace, String nodeName, String nodeContent) {", "        Element element = currentChangeLogFileDOM.createElementNS(nodeNamespace, nodeName);", "        element.setTextContent(nodeContent);", "        return element;"], "nodeContent": ["public Element createNode(String nodeNamespace, String nodeName, String nodeContent) {", "        element.setTextContent(nodeContent);"]}
{"object": ["public static void notNull(Object object, String failMessage) throws UnexpectedLiquibaseException {", "        if (object == null) {"], "failMessage": ["public static void notNull(Object object, String failMessage) throws UnexpectedLiquibaseException {", "            fail(failMessage);"]}
{"dbProductName": ["boolean isSybaseProductName(String dbProductName) {", "                PRODUCT_NAME.equals(dbProductName)", "                || \"Sybase SQL Server\".equals(dbProductName)", "                || \"sql server\".equals(dbProductName)", "                || \"ASE\".equals(dbProductName);"]}
{"tagName": ["public SqlVisitor create(String tagName) {", "        Class<?> aClass = tagToClassMap.get(tagName);", "        if (aClass == null) {", "            return (SqlVisitor) aClass.getConstructor().newInstance();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"sql": ["public static void surroundWithSchemaSets(List<Sql> sql, String schemaName, Database database) {", "                sql.add(0, new UnparsedSql(\"ALTER SESSION SET CURRENT_SCHEMA=\" + database.escapeObjectName(schemaName, Schema.class)));", "                sql.add(new UnparsedSql(\"ALTER SESSION SET CURRENT_SCHEMA=\" + database.escapeObjectName(defaultSchema, Schema.class)));", "                sql.add(0, new UnparsedSql(\"SET CURRENT SCHEMA \" + schemaName));", "                sql.add(new UnparsedSql(\"SET CURRENT SCHEMA \" + defaultSchema));"], "schemaName": ["public static void surroundWithSchemaSets(List<Sql> sql, String schemaName, Database database) {", "        if ((StringUtil.trimToNull(schemaName) != null) && !LiquibaseConfiguration.getInstance().getProperty(ChangeLogParserCofiguration.class, ChangeLogParserCofiguration.USE_PROCEDURE_SCHEMA).getValue(Boolean.class)) {", "                sql.add(0, new UnparsedSql(\"ALTER SESSION SET CURRENT_SCHEMA=\" + database.escapeObjectName(schemaName, Schema.class)));", "                sql.add(0, new UnparsedSql(\"SET CURRENT SCHEMA \" + schemaName));"], "database": ["public static void surroundWithSchemaSets(List<Sql> sql, String schemaName, Database database) {", "            String defaultSchema = database.getDefaultSchemaName();", "            if (database instanceof OracleDatabase) {", "                sql.add(0, new UnparsedSql(\"ALTER SESSION SET CURRENT_SCHEMA=\" + database.escapeObjectName(schemaName, Schema.class)));", "                sql.add(new UnparsedSql(\"ALTER SESSION SET CURRENT_SCHEMA=\" + database.escapeObjectName(defaultSchema, Schema.class)));", "            } else if (database instanceof AbstractDb2Database) {"]}
{"procedureText": ["public static String addSchemaToText(String procedureText, String schemaName, String keywordBeforeName, Database database) {", "            return procedureText;", "            StringClauses parsedSql = SqlParser.parse(procedureText, true, true);", "            StringClauses.ClauseIterator clauseIterator = parsedSql.getClauseIterator();", "                    return procedureText;", "                procedureText = parsedSql.toString();", "        return procedureText;"], "schemaName": ["public static String addSchemaToText(String procedureText, String schemaName, String keywordBeforeName, Database database) {", "        if (schemaName == null) {", "        if ((StringUtil.trimToNull(schemaName) != null) && LiquibaseConfiguration.getInstance().getProperty(ChangeLogParserCofiguration.class, ChangeLogParserCofiguration.USE_PROCEDURE_SCHEMA).getValue(Boolean.class)) {", "                        finalName = database.escapeObjectName(schemaName, Schema.class) + \".\" + nameParts[0];", "                        finalName = database.escapeObjectName(schemaName, Schema.class) + \".\" + nameParts[1];", "                        finalName = nameParts[0] + \".\" + database.escapeObjectName(schemaName, Schema.class) + \".\" + nameParts[2];"], "keywordBeforeName": ["public static String addSchemaToText(String procedureText, String schemaName, String keywordBeforeName, Database database) {", "            while ((next != null) && !next.toString().equalsIgnoreCase(keywordBeforeName) && clauseIterator.hasNext()) {", "                if (!\"PACKAGE\".equalsIgnoreCase(keywordBeforeName) && \"PACKAGE\".equalsIgnoreCase((String) next)) {"], "database": ["public static String addSchemaToText(String procedureText, String schemaName, String keywordBeforeName, Database database) {", "                        finalName = database.escapeObjectName(schemaName, Schema.class) + \".\" + nameParts[0];", "                        finalName = database.escapeObjectName(schemaName, Schema.class) + \".\" + nameParts[1];", "                        finalName = nameParts[0] + \".\" + database.escapeObjectName(schemaName, Schema.class) + \".\" + nameParts[2];"]}
{"data": ["private static char[] encodeHex(byte[] data) {", "        int l = data.length;", "            out[j++] = DIGITS_LOWER[(0xF0 & data[i]) >>> 4];", "            out[j++] = DIGITS_LOWER[0x0F & data[i]];", "        return out;"]}
{"database": ["protected String[] getDatabaseSchemaNames(Database database) throws SQLException, DatabaseException {", "            schemas = ((JdbcConnection) database.getConnection()).getMetaData().getSchemas();", "                returnList.add(JdbcUtils.getValueForColumn(schemas, \"TABLE_SCHEM\", database));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"source": ["public synchronized void startPolling(PolledConfigurationSource source, AbstractPollingScheduler scheduler) {", "        this.source = source;", "        init(source, scheduler);", "        scheduler.startPolling(source, this);        "], "scheduler": ["public synchronized void startPolling(PolledConfigurationSource source, AbstractPollingScheduler scheduler) {", "        this.scheduler = scheduler;", "        init(source, scheduler);", "        scheduler.startPolling(source, this);        "]}
{"Result": "Method without Parameter"}
{"appConfFolderFromConfig": ["public static void setAppConfFolder(File appConfFolderFromConfig, String baseConfigFileName) {", "\t\tWebApplicationProperties.appConfFolder = appConfFolderFromConfig;"], "baseConfigFileName": ["public static void setAppConfFolder(File appConfFolderFromConfig, String baseConfigFileName) {", "\t\tWebApplicationProperties.baseConfigFileName = baseConfigFileName;"]}
{"propName": ["public DynamicIntProperty getIntProperty(String propName, int defaultValue, final Runnable propertyChangeCallback) {", "        checkAndWarn(propName);", "        DynamicIntProperty property = new DynamicIntProperty(propName, defaultValue);"], "defaultValue": ["public DynamicIntProperty getIntProperty(String propName, int defaultValue, final Runnable propertyChangeCallback) {", "        DynamicIntProperty property = new DynamicIntProperty(propName, defaultValue);", "        addCallback(propertyChangeCallback, property);", "        return property;"], "propertyChangeCallback": ["public DynamicIntProperty getIntProperty(String propName, int defaultValue, final Runnable propertyChangeCallback) {", "        addCallback(propertyChangeCallback, property);"]}
{"propName": ["public DynamicLongProperty getLongProperty(String propName, long defaultValue, final Runnable propertyChangeCallback) {", "        checkAndWarn(propName);", "        DynamicLongProperty property = new DynamicLongProperty(propName, defaultValue);"], "defaultValue": ["public DynamicLongProperty getLongProperty(String propName, long defaultValue, final Runnable propertyChangeCallback) {", "        DynamicLongProperty property = new DynamicLongProperty(propName, defaultValue);", "        addCallback(propertyChangeCallback, property);", "        return property;"], "propertyChangeCallback": ["public DynamicLongProperty getLongProperty(String propName, long defaultValue, final Runnable propertyChangeCallback) {", "        addCallback(propertyChangeCallback, property);"]}
{"propName": ["public DynamicBooleanProperty getBooleanProperty(String propName, boolean defaultValue, final Runnable propertyChangeCallback) {", "        checkAndWarn(propName);", "        DynamicBooleanProperty property = new DynamicBooleanProperty(propName, defaultValue);"], "defaultValue": ["public DynamicBooleanProperty getBooleanProperty(String propName, boolean defaultValue, final Runnable propertyChangeCallback) {", "        DynamicBooleanProperty property = new DynamicBooleanProperty(propName, defaultValue);", "        addCallback(propertyChangeCallback, property);", "        return property;"], "propertyChangeCallback": ["public DynamicBooleanProperty getBooleanProperty(String propName, boolean defaultValue, final Runnable propertyChangeCallback) {", "        addCallback(propertyChangeCallback, property);"]}
{"propName": ["public DynamicFloatProperty getFloatProperty(String propName, float defaultValue, final Runnable propertyChangeCallback) {", "        checkAndWarn(propName);", "        DynamicFloatProperty property = new DynamicFloatProperty(propName, defaultValue);"], "defaultValue": ["public DynamicFloatProperty getFloatProperty(String propName, float defaultValue, final Runnable propertyChangeCallback) {", "        DynamicFloatProperty property = new DynamicFloatProperty(propName, defaultValue);", "        addCallback(propertyChangeCallback, property);", "        return property;"], "propertyChangeCallback": ["public DynamicFloatProperty getFloatProperty(String propName, float defaultValue, final Runnable propertyChangeCallback) {", "        addCallback(propertyChangeCallback, property);"]}
{"propName": ["public DynamicDoubleProperty getDoubleProperty(String propName, double defaultValue, final Runnable propertyChangeCallback) {", "        checkAndWarn(propName);", "        DynamicDoubleProperty property = new DynamicDoubleProperty(propName, defaultValue);"], "defaultValue": ["public DynamicDoubleProperty getDoubleProperty(String propName, double defaultValue, final Runnable propertyChangeCallback) {", "        DynamicDoubleProperty property = new DynamicDoubleProperty(propName, defaultValue);", "        addCallback(propertyChangeCallback, property);", "        return property;"], "propertyChangeCallback": ["public DynamicDoubleProperty getDoubleProperty(String propName, double defaultValue, final Runnable propertyChangeCallback) {", "        addCallback(propertyChangeCallback, property);"]}
{"table": ["    protected Map<String, PropertyWithDeploymentContext> loadPropertiesFromTable(String table) {", "                    .withTableName(table)"]}
{"propName": ["public static DynamicProperty getInstance(String propName) {", "        DynamicProperty prop = ALL_PROPS.get(propName);", "        if (prop == null) {", "            prop = new DynamicProperty(propName);", "            DynamicProperty oldProp = ALL_PROPS.putIfAbsent(propName, prop);", "            if (oldProp != null) {", "                prop = oldProp;", "        return prop;"]}
{"Result": "Method without Parameter"}
{"callback": ["    public void addCallback(Runnable callback) {", "        if (callback != null) {", "            prop.addCallback(callback);", "            callbacks.add(callback);"]}
{"Result": "Method without Parameter"}
{"propValue": ["public static HttpVerbUriRegexPropertyValue getVerbUriRegex(String propValue) {", "        if (propValue != null) {", "            propValue = propValue.trim();"]}
{"fin": ["public static Properties loadPropertiesFromInputStream(InputStream fin) throws IOException {", "        InputStreamReader reader = new InputStreamReader(fin, \"UTF-8\");", "            if (fin != null) {", "                fin.close();"]}
{"name": ["    public void addProperty(String name, Object value) {", "        if (containsKey(name)) {", "            clearPropertyDirect(name);", "        super.addProperty(name, value);        "], "value": ["    public void addProperty(String name, Object value) {", "        super.addProperty(name, value);        "]}
{"result": ["public void updateProperties(final WatchedUpdateResult result, final Configuration config,", "        if (result == null || !result.hasChanges()) {", "        logger.debug(\"incremental result? [{}]\", result.isIncremental());", "        if (!result.isIncremental()) {", "            Map<String, Object> props = result.getComplete();", "            Map<String, Object> props = result.getAdded();", "            props = result.getChanged();", "                props = result.getDeleted();"], "config": ["public void updateProperties(final WatchedUpdateResult result, final Configuration config,", "                addOrChangeProperty(entry.getKey(), entry.getValue(), config);", "            for (Iterator<String> i = config.getKeys(); i.hasNext();) {", "                existingKeys.add(i.next());", "                        deleteProperty(key, config);", "                    addOrChangeProperty(entry.getKey(), entry.getValue(), config);", "                    addOrChangeProperty(entry.getKey(), entry.getValue(), config);", "                        deleteProperty(name, config);"], "ignoreDeletesFromSource": ["            final boolean ignoreDeletesFromSource) {", "        logger.debug(\"ignored deletes from source? [{}]\", ignoreDeletesFromSource);", "            if (!ignoreDeletesFromSource) {", "            if (!ignoreDeletesFromSource) {"]}
{"name": ["void addOrChangeProperty(final String name, final Object newValue, final Configuration config) {", "            if (!config.containsKey(name)) {", "                logger.debug(\"adding property key [{}], value [{}]\", name, newValue);", "                config.addProperty(name, newValue);", "                Object oldValue = config.getProperty(name);", "                    if (oldValue instanceof CopyOnWriteArrayList && AbstractConfiguration.getDefaultListDelimiter() != '\\0'){", "                    if (!newValueArray.equals(oldValue)) {", "                        logger.debug(\"updating property key [{}], value [{}]\", name, newValue);", "                        config.setProperty(name, newValue);", "                } else if (oldValue != null) {", "                    logger.debug(\"nulling out property key [{}]\", name);", "                    config.setProperty(name, null);", "            logger.warn(\"Validation failed for property \" + name, e);"], "newValue": ["void addOrChangeProperty(final String name, final Object newValue, final Configuration config) {", "                logger.debug(\"adding property key [{}], value [{}]\", name, newValue);", "                config.addProperty(name, newValue);", "                if (newValue != null) {", "                      Iterable<String> stringiterator = Splitter.on(AbstractConfiguration.getDefaultListDelimiter()).omitEmptyStrings().trimResults().split((String)newValue);", "                      for(String s :stringiterator){", "                            ((CopyOnWriteArrayList) newValueArray).add(s);", "                          newValueArray = newValue;", "                    if (!newValueArray.equals(oldValue)) {", "                        logger.debug(\"updating property key [{}], value [{}]\", name, newValue);", "                        config.setProperty(name, newValue);"], "config": ["void addOrChangeProperty(final String name, final Object newValue, final Configuration config) {", "            if (!config.containsKey(name)) {", "                config.addProperty(name, newValue);", "                Object oldValue = config.getProperty(name);", "                        config.setProperty(name, newValue);", "                    config.setProperty(name, null);"]}
{"key": ["void deleteProperty(final String key, final Configuration config) {", "        if (config.containsKey(key)) {", "            logger.debug(\"deleting property key [\" + key + \"]\");", "            config.clearProperty(key);"], "config": ["void deleteProperty(final String key, final Configuration config) {", "        if (config.containsKey(key)) {", "            config.clearProperty(key);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"source": ["protected synchronized void initialLoad(final PolledConfigurationSource source, final Configuration config) {      ", "            result = source.poll(true, null); ", "            throw new RuntimeException(\"Unable to load Properties source from \" + source, e);"], "config": ["protected synchronized void initialLoad(final PolledConfigurationSource source, final Configuration config) {      ", "            populateProperties(result, config);"]}
{"config": ["public void addConfigurationAtIndex(AbstractConfiguration config, String name, int index) ", "        if (!configList.contains(config)) {", "            configList.add(index, config);", "                namedConfigurations.put(name, config);", "            config.addConfigurationListener(eventPropagater);", "            logger.warn(config + \" is not added as it already exits\");"], "name": ["public void addConfigurationAtIndex(AbstractConfiguration config, String name, int index) ", "            if (name != null) {", "                namedConfigurations.put(name, config);"], "index": ["public void addConfigurationAtIndex(AbstractConfiguration config, String name, int index) ", "            checkIndex(index);", "            configList.add(index, config);"]}
{"config": ["public  boolean removeConfiguration(Configuration config)", "        if (!config.equals(containerConfiguration))", "            String configName = getNameForConfiguration(config);", "            if (configName != null) {", "                namedConfigurations.remove(configName);", "            return configList.remove(config);"]}
{"name": ["public Configuration removeConfiguration(String name)", "        Configuration conf = getConfiguration(name);", "        if (conf != null && !conf.equals(containerConfiguration))", "            configList.remove(conf);", "            namedConfigurations.remove(name);", "        } else if (conf != null && conf.equals(containerConfiguration)) {", "        return conf;"]}
{"Result": "Method without Parameter"}
{"prefix": ["    public Iterator<String> getKeys(String prefix)", "        for (Iterator<String> it = overrideProperties.getKeys(prefix); it.hasNext();) {", "            keys.add(it.next());", "            for (Iterator<String> it = config.getKeys(prefix); it.hasNext();)", "                keys.add(it.next());"]}
{"key": ["    public boolean containsKey(String key)", "        if (overrideProperties.containsKey(key)) {", "            if (config.containsKey(key))"]}
{"key": ["    public List getList(String key, List defaultValue)", "        if (overrideProperties.containsKey(key)) {", "            appendListProperty(list, overrideProperties, key);", "                    && config.containsKey(key))", "                appendListProperty(list, config, key);", "            appendListProperty(list, containerConfiguration, key);"], "defaultValue": ["    public List getList(String key, List defaultValue)", "            return defaultValue;"]}
{"key": ["    public String[] getStringArray(String key)", "        List<Object> list = getList(key);", "        String[] tokens = new String[list.size()];", "        for (int i = 0; i < tokens.length; i++)", "            tokens[i] = String.valueOf(list.get(i));", "        return tokens;"]}
{"configName": ["public static void loadCascadedPropertiesFromResources(String configName) throws IOException {", "        Properties props = loadCascadedProperties(configName);", "            config.loadProperties(props);", "            ((AggregatedConfiguration) instance).addConfiguration(config, configName);", "            ConfigurationUtils.loadProperties(props, instance);"]}
{"config": ["public static void loadPropertiesFromConfiguration(AbstractConfiguration config) {", "            ((AggregatedConfiguration) instance).addConfiguration(config);", "            Properties props = ConfigurationUtils.getProperties(config);", "            ConfigurationUtils.loadProperties(props, instance);"]}
{"properties": ["public static void loadProperties(Properties properties) {", "        ConfigurationUtils.loadProperties(properties, instance);"]}
{"initial": [], "checkPoint": []}
{"location": ["public double getAngle(Location location) {", "        double latitudeDifference = location.latitude - latitude;", "        double longitudeDifference = location.longitude - longitude;"]}
{"key": ["    public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {", "        V value = get(key);", "        if (value != null) {", "            return value;", "        return super.computeIfAbsent(key, mappingFunction);"], "mappingFunction": ["    public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {", "        return super.computeIfAbsent(key, mappingFunction);"]}
{"args": []}
{"member": ["public static String getGetterPropertyName(Member member) {", "        if (member instanceof Field) {", "            return member.getName();", "        } else if (member instanceof Method) {", "            String methodName = member.getName();"]}
{"method": ["public static boolean isGetterMethod(Method method) {", "        if (method.getParameterTypes().length != 0) {", "        String methodName = method.getName();", "        if (methodName.startsWith(PROPERTY_ACCESSOR_PREFIX_GET) && method.getReturnType() != void.class) {", "        } else if (methodName.startsWith(PROPERTY_ACCESSOR_PREFIX_IS) && method.getReturnType() == boolean.class) {"]}
{"kcontext": ["public void addHardConstraintMatch(RuleContext kcontext, BigDecimal hardWeight) {", "        registerConstraintMatch(kcontext,"], "hardWeight": ["public void addHardConstraintMatch(RuleContext kcontext, BigDecimal hardWeight) {", "        hardScore = hardScore.add(hardWeight);", "                () -> hardScore = hardScore.subtract(hardWeight),", "                () -> HardMediumSoftBigDecimalScore.of(hardWeight, BigDecimal.ZERO, BigDecimal.ZERO));"]}
{"kcontext": ["public void addMediumConstraintMatch(RuleContext kcontext, BigDecimal mediumWeight) {", "        registerConstraintMatch(kcontext,"], "mediumWeight": ["public void addMediumConstraintMatch(RuleContext kcontext, BigDecimal mediumWeight) {", "        mediumScore = mediumScore.add(mediumWeight);", "                () -> mediumScore = mediumScore.subtract(mediumWeight),", "                () -> HardMediumSoftBigDecimalScore.of(BigDecimal.ZERO, mediumWeight, BigDecimal.ZERO));"]}
{"kcontext": ["public void addSoftConstraintMatch(RuleContext kcontext, BigDecimal softWeight) {", "        registerConstraintMatch(kcontext,"], "softWeight": ["public void addSoftConstraintMatch(RuleContext kcontext, BigDecimal softWeight) {", "        softScore = softScore.add(softWeight);", "                () -> softScore = softScore.subtract(softWeight),", "                () -> HardMediumSoftBigDecimalScore.of(BigDecimal.ZERO, BigDecimal.ZERO, softWeight));"]}
{"url": ["public static String cleanPath(final URL url) {", "        String path = url.getPath();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"solution": ["public long getProblemScale(Solution_ solution) {", "        for (Iterator<Object> it = extractAllEntitiesIterator(solution); it.hasNext(); ) {", "            Object entity = it.next();", "            EntityDescriptor<Solution_> entityDescriptor = findEntityDescriptorOrFail(entity.getClass());", "            problemScale += entityDescriptor.getProblemScale(solution, entity);", "        return problemScale;"]}
{"request": ["static String generateTaskName(final Request<?> request) {", "    return request.getBaseUriTemplate() + \" \"", "        + OperationNameGenerator.generate(request.getMethod(), request.getMethodName());"]}
{"requestContext": ["private boolean hasRequestContextTimeout(RequestContext requestContext) {", "    Object requestTimeout = requestContext.getLocalAttr(R2Constants.REQUEST_TIMEOUT);"]}
{"requestContext": ["private boolean needApplyTaskTimeout(RequestContext requestContext, ConfigValue<Long> timeout) {", "    return timeout.getValue() != null && timeout.getValue() > 0 && !hasRequestContextTimeout(requestContext);"], "timeout": ["private boolean needApplyTaskTimeout(RequestContext requestContext, ConfigValue<Long> timeout) {", "    return timeout.getValue() != null && timeout.getValue() > 0 && !hasRequestContextTimeout(requestContext);"]}
{"name": ["private <T> Task<Response<T>> createTaskWithTimeout(final String name, final Request<T> request,", "      requestTask = createBatchableTask(name, request, requestContext, config);", "      requestTask = Task.async(name, () -> sendRequest(request, requestContext));"], "request": ["private <T> Task<Response<T>> createTaskWithTimeout(final String name, final Request<T> request,", "    if (RequestGroup.isBatchable(request, config)) {", "      requestTask = createBatchableTask(name, request, requestContext, config);", "      requestTask = Task.async(name, () -> sendRequest(request, requestContext));"], "requestContext": ["      final RequestContext requestContext, RequestConfig config) {", "      requestTask = createBatchableTask(name, request, requestContext, config);", "      requestTask = Task.async(name, () -> sendRequest(request, requestContext));", "    if (!needApplyTaskTimeout(requestContext, timeout)) {", "      return requestTask;", "      return withTimeout(requestTask, timeout);"], "config": ["      final RequestContext requestContext, RequestConfig config) {", "    ConfigValue<Long> timeout = config.getTimeoutMs();", "    if (RequestGroup.isBatchable(request, config)) {", "      requestTask = createBatchableTask(name, request, requestContext, config);", "      return requestTask;", "      return withTimeout(requestTask, timeout);"]}
{"hash": ["public Task<HttpResponse> build(final String hash, final InputStream body)", "    if (hash == null) {", "      if (_hashManager.contains(hash)) {", "        LOG.info(\"hash found in cache: \" + hash);", "          final Task<Exec.Result> buildTask = getBuildTask(hash, body);", "                  _hashManager.add(hash);", "            _inFlightBuildTasks.remove(hash, buildTask);"], "body": ["public Task<HttpResponse> build(final String hash, final InputStream body)", "        if (body == null) {", "          final Task<Exec.Result> buildTask = getBuildTask(hash, body);", "          return buildTask.transform(\"result\", result -> {", "            _inFlightBuildTasks.remove(hash, buildTask);"]}
{"hash": ["private Task<Exec.Result> getBuildTask(final String hash, final InputStream body) {", "    Task<Exec.Result> existing = _inFlightBuildTasks.get(hash);", "    if (existing != null) {", "      LOG.info(\"using in flight shareable: \" + hash);", "      return existing.shareable();", "      Task<Exec.Result> newBuildTask = createNewBuildTask(hash, body);", "      existing = _inFlightBuildTasks.putIfAbsent(hash, newBuildTask);", "        LOG.info(\"using in flight shareable: \" + hash);"], "body": ["private Task<Exec.Result> getBuildTask(final String hash, final InputStream body) {", "      Task<Exec.Result> newBuildTask = createNewBuildTask(hash, body);", "      existing = _inFlightBuildTasks.putIfAbsent(hash, newBuildTask);", "      if (existing != null) {", "        return existing.shareable();", "        return newBuildTask;"]}
{"hash": ["private Task<Exec.Result> createNewBuildTask(final String hash, final InputStream body) {", "    LOG.info(\"building: \" + hash);", "        () -> Files.copy(body, pathToCacheFile(hash, \"dot\"), StandardCopyOption.REPLACE_EXISTING));", "            \"-Grankdir=LR\", \"-Gnewrank=true\", \"-Gbgcolor=transparent\", pathToCacheFile(hash, \"dot\").toString(), \"-o\",", "            pathToCacheFile(hash, Constants.OUTPUT_TYPE).toString());"], "body": ["private Task<Exec.Result> createNewBuildTask(final String hash, final InputStream body) {", "        () -> Files.copy(body, pathToCacheFile(hash, \"dot\"), StandardCopyOption.REPLACE_EXISTING));"]}
{"result": ["private String writeGenericFailureInfo(final Exec.Result result)", "    sb.append(\"graphviz process returned: \").append(result.getStatus()).append(\"\\n\").append(\"stdout:\\n\");", "    Files.lines(result.getStdout()).forEach(sb::append);", "    Files.lines(result.getStderr()).forEach(sb::append);"]}
{"shallowTrace": ["public static Trace single(ShallowTrace shallowTrace) {", "    return single(shallowTrace, TraceBuilder.UNKNOWN_PLAN_CLASS, TraceBuilder.UNKNOWN_PLAN_ID);"]}
{"desc": ["public Task<T> batchable(final String desc, final K key) {", "    Task<T> batchableTask = Task.async(desc, ctx -> {"], "key": ["public Task<T> batchable(final String desc, final K key) {", "      final G group = classify(key);", "      Batch<K, T> fullBatch = builder.add(group, key, ctx.getShallowTraceBuilder(), result);", "          ctx.run(taskForBatch(group, fullBatch, true));"]}
{"group": [], "batch": ["public String getBatchName(G group, Batch<K, T> batch) {", "    return \"batch(keys: \" + batch.keySize() + \", size: \" + batch.batchSize() + \")\";"]}
{"consumer": ["public synchronized <T> T harvest(Function<Histogram, T> consumer) {", "    return consumer.apply(_recycle);"]}
{"Result": "Method without Parameter"}
{"predecessor": ["      final Consumer3<FusionTraceContext, Promise<S>, Settable<R>> predecessor,", "      predecessor.accept(traceContext, src, new Settable<R>() {"], "propagator": ["      final Consumer3<FusionTraceContext, Promise<R>, Settable<T>> propagator) {", "            propagator.accept(traceContext, Promises.value(value), dst);", "            propagator.accept(traceContext, Promises.error(error), dst);"]}
{"name": ["public static <S, T> FusionTask<?, T> create(final String name, final Task<S> task, final PromisePropagator<S, T> propagator) {", "    return new FusionTask<S, T>(name, task, propagator);"], "task": ["public static <S, T> FusionTask<?, T> create(final String name, final Task<S> task, final PromisePropagator<S, T> propagator) {", "    return new FusionTask<S, T>(name, task, propagator);"], "propagator": ["public static <S, T> FusionTask<?, T> create(final String name, final Task<S> task, final PromisePropagator<S, T> propagator) {", "    return new FusionTask<S, T>(name, task, propagator);"]}
{"key": ["public EngineBuilder setEngineProperty(String key, Object value) {", "    _properties.put(key, value);"], "value": ["public EngineBuilder setEngineProperty(String key, Object value) {", "    _properties.put(key, value);"]}
{"value": ["  public static <T> Promise<T> value(final T value) {"]}
{"source": ["public static <T> void propagateResult(final Promise<T> source, final Settable<T> dest) {", "    source.addListener(new TransformingPromiseListener<T, T>(dest, PromiseTransformer.identity()));"], "dest": ["public static <T> void propagateResult(final Promise<T> source, final Settable<T> dest) {", "    source.addListener(new TransformingPromiseListener<T, T>(dest, PromiseTransformer.identity()));"]}
{"id": ["Task<String> createResilientSummary(int id) {", "    return fetchPerson(id).map(this::shortSummary).recover(e -> \"Member \" + id);"]}
{"id": ["Task<String> createResponsiveSummary(int id) {", "    return fetchPerson(id).withTimeout(100, TimeUnit.MILLISECONDS).map(this::shortSummary).recover(e -> \"Member \" + id);"]}
{"id": ["Task<List<String>> createConnectionsSummaries(int id) {", "    return fetchPerson(id).flatMap(\"createConnectionsSummaries\", person -> createConnectionsSummaries(person.getConnections()));"]}
{"parent": ["  public static <T> Task<T> withSideEffect(final Task<T> parent, final Task<?> sideEffect) {", "    return parent.withSideEffect(t -> sideEffect);"], "sideEffect": ["  public static <T> Task<T> withSideEffect(final Task<T> parent, final Task<?> sideEffect) {", "    return parent.withSideEffect(t -> sideEffect);"]}
{"time": ["  public static <T> Task<T> timeoutWithError(final long time, final TimeUnit unit, final Task<T> task) {", "    return task.withTimeout(time, unit);"], "unit": ["  public static <T> Task<T> timeoutWithError(final long time, final TimeUnit unit, final Task<T> task) {", "    return task.withTimeout(time, unit);"], "task": ["  public static <T> Task<T> timeoutWithError(final long time, final TimeUnit unit, final Task<T> task) {", "    return task.withTimeout(time, unit);"]}
{"children": ["public static String findNodeWithNextLowestSN(List<String> children, String node) {", "    List<String> sortedChildren = children.stream()"], "node": ["public static String findNodeWithNextLowestSN(List<String> children, String node) {", "    int index = sortedChildren.indexOf(node);", "    if (index > 0) {", "      return sortedChildren.get(index-1);", "    } else if (index == 0) {", "      return node;"]}
{"error": ["private void appendTaskStackTrace(final Throwable error) {", "    if (!ParSeqGlobalConfiguration.isCrossThreadStackTracesEnabled() || error == null ||", "    StackTraceElement[] errorStackTrace = error.getStackTrace();", "    error.setStackTrace(concatenatedStackTrace);"]}
{"Result": "Method without Parameter"}
{"currentTime": ["private void checkForStall(long currentTime) {", "    long delta = currentTime - _lastMonitoringStep;"]}
{"name": ["public static <U> Task<U> withRetryPolicy(String name, RetryPolicy policy, Function1<Integer, Task<U>> taskFunction) {", "    RetriableTask<U> retriableTask = new RetriableTask<>(name, policy, taskFunction);", "    Task<U> retryTaskWrapper = Task.async(name + \" retriableTask\", retriableTask::run);"], "policy": ["public static <U> Task<U> withRetryPolicy(String name, RetryPolicy policy, Function1<Integer, Task<U>> taskFunction) {", "    RetriableTask<U> retriableTask = new RetriableTask<>(name, policy, taskFunction);"], "taskFunction": ["public static <U> Task<U> withRetryPolicy(String name, RetryPolicy policy, Function1<Integer, Task<U>> taskFunction) {", "    RetriableTask<U> retriableTask = new RetriableTask<>(name, policy, taskFunction);", "    Task<U> retryTaskWrapper = Task.async(name + \" retriableTask\", retriableTask::run);"]}
{"attempt": ["private Task<T> wrap(int attempt) {", "    Task<T> retryTask = Task.async(_policy.getName() + \", attempt \" + attempt, context -> {", "      Task<T> task = _taskFunction.apply(attempt);", "        if (task.isFailed()) {", "          ErrorClassification errorClassification = _policy.getErrorClassifier().apply(task.getError());", "          retry(attempt + 1, task.getError(), errorClassification, recoveryContext, recoveryResult);", "          recoveryResult.done(task.get());", "      context.after(task).run(recovery);", "      context.run(task);"]}
{"attempt": ["private void retry(int attempt, Throwable error, ErrorClassification errorClassification, Context recoveryContext, SettablePromise<T> recoveryResult) {", "    long backoffTime = _policy.getBackoffPolicy().nextBackoff(attempt, error);", "      LOGGER.debug(String.format(\"Attempt %s of %s interrupted: %s\", attempt, _name, error.getMessage()));", "    } else if (_policy.getTerminationPolicy().shouldTerminate(attempt, System.currentTimeMillis() - _startedAt + backoffTime)) {", "      LOGGER.debug(String.format(\"Too many exceptions after attempt %s of %s, aborting: %s\", attempt, _name, error.getMessage()));", "      LOGGER.debug(String.format(\"Attempt %s of %s failed and will be retried after %s millis: %s\", attempt, _name, backoffTime, error.getMessage()));", "      Task<T> retryTask = wrap(attempt);", "      Promises.propagateResult(retryTask, recoveryResult);", "      recoveryContext.createTimer(backoffTime, TimeUnit.MILLISECONDS, retryTask);"], "error": ["private void retry(int attempt, Throwable error, ErrorClassification errorClassification, Context recoveryContext, SettablePromise<T> recoveryResult) {", "    long backoffTime = _policy.getBackoffPolicy().nextBackoff(attempt, error);", "      LOGGER.debug(String.format(\"Attempt %s of %s interrupted: %s\", attempt, _name, error.getMessage()));", "      recoveryResult.fail(error);", "    } else if (_policy.getTerminationPolicy().shouldTerminate(attempt, System.currentTimeMillis() - _startedAt + backoffTime)) {", "      LOGGER.debug(String.format(\"Too many exceptions after attempt %s of %s, aborting: %s\", attempt, _name, error.getMessage()));", "      recoveryResult.fail(error);", "      LOGGER.debug(String.format(\"Attempt %s of %s failed and will be retried after %s millis: %s\", attempt, _name, backoffTime, error.getMessage()));", "      recoveryContext.createTimer(backoffTime, TimeUnit.MILLISECONDS, retryTask);"], "errorClassification": ["private void retry(int attempt, Throwable error, ErrorClassification errorClassification, Context recoveryContext, SettablePromise<T> recoveryResult) {", "    if (errorClassification == ErrorClassification.UNRECOVERABLE) {"], "recoveryContext": ["private void retry(int attempt, Throwable error, ErrorClassification errorClassification, Context recoveryContext, SettablePromise<T> recoveryResult) {", "      recoveryContext.createTimer(backoffTime, TimeUnit.MILLISECONDS, retryTask);"], "recoveryResult": ["private void retry(int attempt, Throwable error, ErrorClassification errorClassification, Context recoveryContext, SettablePromise<T> recoveryResult) {", "      recoveryResult.fail(error);", "      recoveryResult.fail(error);", "      Promises.propagateResult(retryTask, recoveryResult);"]}
{"context": ["private Promise<? extends T> run(Context context) {", "    context.run(task);"]}
{"object": ["private static Exception failCoercion(final Object object, final Class<?> targetType)", "        + object.getClass().getName() + \", value: \" + object.toString());"], "targetType": ["private static Exception failCoercion(final Object object, final Class<?> targetType)", "    return new Exception(\"Could not convert object to \" + targetType.getSimpleName() + \". Object is instance of: \""]}
{"client": ["  public ParSeqRestliClientBuilder setRestClient(RestClient client) {", "    ArgumentUtil.requireNotNull(client, \"client\");", "    _client = client;"]}
{"deadline": ["private Task<String> acquire(long deadline) {", "        safeCreateLockNode(uuid, deadline, false)", "            .flatMap(lockNode -> tryAcquire(lockNode, deadline)", "                .withTimeout(deadline - System.currentTimeMillis(), TimeUnit.MILLISECONDS)"]}
{"Result": "Method without Parameter"}
{"planClass": ["private boolean tryAcquirePermit(String planClass) {", "        (_planBasedRateLimiter == null || _planBasedRateLimiter.tryAcquire(planClass));"]}
{"Result": "Method without Parameter"}
{"cfg": ["  public static synchronized void initialize(AsyncHttpClientConfig cfg) {", "    if (!_client.compareAndSet(null, new AsyncHttpClient(cfg))) {"]}
{"Result": "Method without Parameter"}
{"objects": ["public static void noNullElements(Object[] objects, String msg) {", "        for (Object obj : objects)", "            if (obj == null)"], "msg": ["public static void noNullElements(Object[] objects, String msg) {", "                throw new IllegalArgumentException(msg);"]}
{"string": ["public static void notEmpty(String string, String msg) {", "        if (string == null || string.length() == 0)"], "msg": ["public static void notEmpty(String string, String msg) {", "            throw new IllegalArgumentException(msg);"]}
{"s": ["static Matrix parseTransform(String s) {", "            parseTransformItem(s, matrix);", "            int rparen = s.indexOf(\")\");", "            if (rparen > 0 && s.length() > rparen + 1) {", "                s = s.substring(rparen + 1).replaceFirst(\"[\\\\s,]*\", \"\");"]}
{"query": ["public DBCursor getFileList(final DBObject query, final DBObject sort) {", "        return filesCollection.find(query).sort(sort);"], "sort": ["public DBCursor getFileList(final DBObject query, final DBObject sort) {", "        return filesCollection.find(query).sort(sort);"]}
{"filename": ["public List<GridFSDBFile> find(final String filename, final DBObject sort) {", "        return find(new BasicDBObject(\"filename\", filename), sort);"], "sort": ["public List<GridFSDBFile> find(final String filename, final DBObject sort) {", "        return find(new BasicDBObject(\"filename\", filename), sort);"]}
{"query": ["public List<GridFSDBFile> find(final DBObject query, final DBObject sort) {", "        DBCursor cursor = filesCollection.find(query);", "            cursor.sort(sort);", "            while (cursor.hasNext()) {", "                files.add(injectGridFSInstance(cursor.next()));", "            cursor.close();"], "sort": ["public List<GridFSDBFile> find(final DBObject query, final DBObject sort) {", "        if (sort != null) {", "            cursor.sort(sort);"]}
{"id": ["public void remove(final ObjectId id) {", "        if (id == null) {", "        filesCollection.remove(new BasicDBObject(\"_id\", id));", "        chunksCollection.remove(new BasicDBObject(\"files_id\", id));"]}
{"query": ["public void remove(final DBObject query) {", "        if (query == null) {", "        for (final GridFSDBFile f : find(query)) {", "            f.remove();"]}
{"key": ["    public Object put(final String key, final Object v) {", "        return put(_getInt(key), v);"], "v": ["    public Object put(final String key, final Object v) {", "        return put(_getInt(key), v);"]}
{"key": ["public Object get(final String key) {", "        int i = _getInt(key);", "        if (i < 0) {", "        if (i >= size()) {", "        return get(i);"]}
{"type": ["public static <T> Builder<T> builder(final Class<T> type) {", "        return new Builder<T>(notNull(\"type\", type));"]}
{"timeUnit": ["public long getMaxTime(final TimeUnit timeUnit) {", "        notNull(\"timeUnit\", timeUnit);", "        return timeUnit.convert(maxTimeMS, TimeUnit.MILLISECONDS);"]}
{"key": ["public <T> MongoCompressor withProperty(final String key, final T value) {", "        return new MongoCompressor(this, key, value);"], "value": ["public <T> MongoCompressor withProperty(final String key, final T value) {", "        return new MongoCompressor(this, key, value);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"serverAddress": ["public boolean isMaster(final ServerAddress serverAddress) {", "        return masterServerAddress != null && masterServerAddress.equals(serverAddress);"]}
{"Result": "Method without Parameter"}
{"key": ["public QueryBuilder put(final String key) {", "        _currentKey = key;", "        if (_query.get(key) == null) {", "            _query.put(_currentKey, new NullObject());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"annotations": ["public PropertyModelBuilder<T> readAnnotations(final List<Annotation> annotations) {", "        this.readAnnotations = unmodifiableList(notNull(\"annotations\", annotations));"]}
{"indexes": ["public static List<String> getIndexNames(final List<IndexModel> indexes, final CodecRegistry codecRegistry) {", "        List<String> indexNames = new ArrayList<String>(indexes.size());", "        for (IndexModel index : indexes) {", "            String name = index.getOptions().getName();", "            if (name != null) {", "                indexNames.add(name);", "                indexNames.add(IndexHelper.generateIndexName(index.getKeys().toBsonDocument(BsonDocument.class, codecRegistry)));"], "codecRegistry": ["public static List<String> getIndexNames(final List<IndexModel> indexes, final CodecRegistry codecRegistry) {", "                indexNames.add(IndexHelper.generateIndexName(index.getKeys().toBsonDocument(BsonDocument.class, codecRegistry)));"]}
{"index": ["public static String generateIndexName(final BsonDocument index) {", "        for (final String keyNames : index.keySet()) {", "            indexName.append(keyNames).append('_');", "            BsonValue ascOrDescValue = index.get(keyNames);", "            if (ascOrDescValue instanceof BsonNumber) {", "                indexName.append(((BsonNumber) ascOrDescValue).intValue());", "            } else if (ascOrDescValue instanceof BsonString) {", "                indexName.append(((BsonString) ascOrDescValue).getValue().replace(' ', '_'));"]}
{"Result": "Method without Parameter"}
{"bsonType": ["public Codec<?> get(final BsonType bsonType) {", "        Codec<?> codec = codecs[bsonType.getValue()];", "            Class<?> clazz = bsonTypeClassMap.get(bsonType);", "            if (clazz == null) {", "                throw new CodecConfigurationException(format(\"No class mapped for BSON type %s.\", bsonType));", "                throw new CodecConfigurationException(format(\"Can't find a codec for %s.\", clazz));"]}
{"Result": "Method without Parameter"}
{"string": ["public static long parse(final String string) {", "        if (string.length() == 0) {", "        for (int pos = 0; pos < string.length(); pos++) {", "            int digit = Character.digit(string.charAt(pos), radix);", "            if (digit == -1) {", "                throw new NumberFormatException(string);", "            if (pos > maxSafePos && overflowInParse(value, digit, radix)) {", "                throw new NumberFormatException(\"Too large for unsigned long: \" + string);", "            value = (value * radix) + digit;", "        return value;"]}
{"decoder": ["public <T> T decodeWithChildContext(final Decoder<T> decoder, final BsonReader reader) {", "        return decoder.decode(reader, DEFAULT_CONTEXT);"], "reader": ["public <T> T decodeWithChildContext(final Decoder<T> decoder, final BsonReader reader) {", "        return decoder.decode(reader, DEFAULT_CONTEXT);"]}
{"validStates": ["protected boolean checkState(final State[] validStates) {", "        for (final State cur : validStates) {", "            if (cur == getState()) {"]}
{"reader": ["public void pipe(final BsonReader reader, final List<BsonElement> extraElements) {", "        notNull(\"reader\", reader);", "        pipeDocument(reader, extraElements);"], "extraElements": ["public void pipe(final BsonReader reader, final List<BsonElement> extraElements) {", "        notNull(\"extraElements\", extraElements);", "        pipeDocument(reader, extraElements);"]}
{"extraElements": ["protected void pipeExtraElements(final List<BsonElement> extraElements) {", "        notNull(\"extraElements\", extraElements);", "        for (BsonElement cur : extraElements) {", "            writeName(cur.getName());", "            pipeValue(cur.getValue());"]}
{"Result": "Method without Parameter"}
{"buffer": ["public void putToByteBuffer(final ByteBuffer buffer) {", "        notNull(\"buffer\", buffer);", "        isTrueArgument(\"buffer.remaining() >=12\", buffer.remaining() >= OBJECT_ID_LENGTH);", "        buffer.put(int3(timestamp));", "        buffer.put(int2(timestamp));", "        buffer.put(int1(timestamp));", "        buffer.put(int0(timestamp));", "        buffer.put(int2(randomValue1));", "        buffer.put(int1(randomValue1));", "        buffer.put(int0(randomValue1));", "        buffer.put(short1(randomValue2));", "        buffer.put(short0(randomValue2));", "        buffer.put(int2(counter));", "        buffer.put(int1(counter));", "        buffer.put(int0(counter));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"documentAsMap": ["    public static BasicDBObjectBuilder start(final Map documentAsMap) {", "        Iterator<Map.Entry> i = documentAsMap.entrySet().iterator();"]}
{"key": ["public BasicDBObjectBuilder push(final String key) {", "        _cur().put(key, o);"]}
{"result": ["public void addResult(final BulkWriteResult result, final IndexMap indexMap) {", "        insertedCount += result.getInsertedCount();", "        matchedCount += result.getMatchedCount();", "        deletedCount += result.getDeletedCount();", "        modifiedCount += result.getModifiedCount();", "        mergeUpserts(result.getUpserts(), indexMap);"], "indexMap": ["public void addResult(final BulkWriteResult result, final IndexMap indexMap) {", "        mergeUpserts(result.getUpserts(), indexMap);"]}
{"exception": ["public void addErrorResult(final MongoBulkWriteException exception, final IndexMap indexMap) {", "        addResult(exception.getWriteResult(), indexMap);", "        mergeWriteErrors(exception.getWriteErrors(), indexMap);", "        mergeWriteConcernError(exception.getWriteConcernError());"], "indexMap": ["public void addErrorResult(final MongoBulkWriteException exception, final IndexMap indexMap) {", "        addResult(exception.getWriteResult(), indexMap);", "        mergeWriteErrors(exception.getWriteErrors(), indexMap);"]}
{"writeError": ["public void addWriteErrorResult(final BulkWriteError writeError, final IndexMap indexMap) {", "        notNull(\"writeError\", writeError);", "        mergeWriteErrors(asList(writeError), indexMap);"], "indexMap": ["public void addWriteErrorResult(final BulkWriteError writeError, final IndexMap indexMap) {", "        mergeWriteErrors(asList(writeError), indexMap);"]}
{"writeErrors": ["public void addErrorResult(final List<BulkWriteError> writeErrors,", "        mergeWriteErrors(writeErrors, indexMap);"], "writeConcernError": ["                               final WriteConcernError writeConcernError, final IndexMap indexMap) {", "        mergeWriteConcernError(writeConcernError);"], "indexMap": ["                               final WriteConcernError writeConcernError, final IndexMap indexMap) {", "        mergeWriteErrors(writeErrors, indexMap);"]}
{"Result": "Method without Parameter"}
{"cmp": ["private boolean casNext(Node<E> cmp, Node<E> val) {", "            return compareAndSet(cmp, val);"], "val": ["private boolean casNext(Node<E> cmp, Node<E> val) {", "            return compareAndSet(cmp, val);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"element": ["Node<E> append(E element) {", "                Node<E> x = new Node<E>(element, f, this);", "                if (casNext(f, x)) {", "                    f.setPrev(x); // optimistically link", "                    return x;"]}
{"element": ["Node<E> prepend(E element) {", "                Node<E> x = new Node<E>(element, this, b);", "                if (b.casNext(this, x)) {", "                    setPrev(x); // optimistically link", "                    return x;"]}
{"Result": "Method without Parameter"}
{"newElement": ["Node<E> replace(E newElement) {", "                Node<E> x = new Node<E>(newElement, f, b);", "                if (casNext(f, new Node<E>(x))) {", "                    x.successor(); // to relink f", "                    return x;"]}
{"binding": ["    public BsonDocument execute(final WriteBinding binding) {", "        return withConnection(binding, new CallableWithConnection<BsonDocument>() {", "                    return executeCommand(binding, \"admin\", FSYNC_UNLOCK_COMMAND, connection);"]}
{"clusterDescription": ["public final List<ServerDescription> choose(final ClusterDescription clusterDescription) {", "        switch (clusterDescription.getType()) {", "                return chooseForReplicaSet(clusterDescription);", "                return chooseForNonReplicaSet(clusterDescription);", "                throw new UnsupportedOperationException(\"Unsupported cluster type: \" + clusterDescription.getType());"]}
{"maxStaleness": ["public static ReadPreference primaryPreferred(final long maxStaleness, final TimeUnit timeUnit) {", "        return new PrimaryPreferredReadPreference(Collections.<TagSet>emptyList(), maxStaleness, timeUnit);"], "timeUnit": ["public static ReadPreference primaryPreferred(final long maxStaleness, final TimeUnit timeUnit) {", "        return new PrimaryPreferredReadPreference(Collections.<TagSet>emptyList(), maxStaleness, timeUnit);"]}
{"maxStaleness": ["public static ReadPreference secondary(final long maxStaleness, final TimeUnit timeUnit) {", "        return new SecondaryReadPreference(Collections.<TagSet>emptyList(), maxStaleness, timeUnit);"], "timeUnit": ["public static ReadPreference secondary(final long maxStaleness, final TimeUnit timeUnit) {", "        return new SecondaryReadPreference(Collections.<TagSet>emptyList(), maxStaleness, timeUnit);"]}
{"maxStaleness": ["public static ReadPreference secondaryPreferred(final long maxStaleness, final TimeUnit timeUnit) {", "        return new SecondaryPreferredReadPreference(Collections.<TagSet>emptyList(), maxStaleness, timeUnit);"], "timeUnit": ["public static ReadPreference secondaryPreferred(final long maxStaleness, final TimeUnit timeUnit) {", "        return new SecondaryPreferredReadPreference(Collections.<TagSet>emptyList(), maxStaleness, timeUnit);"]}
{"maxStaleness": ["public static ReadPreference nearest(final long maxStaleness, final TimeUnit timeUnit) {", "        return new NearestReadPreference(Collections.<TagSet>emptyList(), maxStaleness, timeUnit);"], "timeUnit": ["public static ReadPreference nearest(final long maxStaleness, final TimeUnit timeUnit) {", "        return new NearestReadPreference(Collections.<TagSet>emptyList(), maxStaleness, timeUnit);"]}
{"tagSet": ["public static TaggableReadPreference primaryPreferred(final TagSet tagSet,", "        return new PrimaryPreferredReadPreference(singletonList(tagSet), maxStaleness, timeUnit);"], "maxStaleness": ["                                                          final long maxStaleness, final TimeUnit timeUnit) {", "        return new PrimaryPreferredReadPreference(singletonList(tagSet), maxStaleness, timeUnit);"], "timeUnit": ["                                                          final long maxStaleness, final TimeUnit timeUnit) {", "        return new PrimaryPreferredReadPreference(singletonList(tagSet), maxStaleness, timeUnit);"]}
{"tagSet": ["public static TaggableReadPreference secondary(final TagSet tagSet,", "        return new SecondaryReadPreference(singletonList(tagSet), maxStaleness, timeUnit);"], "maxStaleness": ["                                                   final long maxStaleness, final TimeUnit timeUnit) {", "        return new SecondaryReadPreference(singletonList(tagSet), maxStaleness, timeUnit);"], "timeUnit": ["                                                   final long maxStaleness, final TimeUnit timeUnit) {", "        return new SecondaryReadPreference(singletonList(tagSet), maxStaleness, timeUnit);"]}
{"tagSet": ["public static TaggableReadPreference secondaryPreferred(final TagSet tagSet,", "        return new SecondaryPreferredReadPreference(singletonList(tagSet), maxStaleness, timeUnit);"], "maxStaleness": ["                                                            final long maxStaleness, final TimeUnit timeUnit) {", "        return new SecondaryPreferredReadPreference(singletonList(tagSet), maxStaleness, timeUnit);"], "timeUnit": ["                                                            final long maxStaleness, final TimeUnit timeUnit) {", "        return new SecondaryPreferredReadPreference(singletonList(tagSet), maxStaleness, timeUnit);"]}
{"tagSet": ["public static TaggableReadPreference nearest(final TagSet tagSet,", "        return new NearestReadPreference(singletonList(tagSet), maxStaleness, timeUnit);"], "maxStaleness": ["                                                 final long maxStaleness, final TimeUnit timeUnit) {", "        return new NearestReadPreference(singletonList(tagSet), maxStaleness, timeUnit);"], "timeUnit": ["                                                 final long maxStaleness, final TimeUnit timeUnit) {", "        return new NearestReadPreference(singletonList(tagSet), maxStaleness, timeUnit);"]}
{"tagSetList": ["public static TaggableReadPreference primaryPreferred(final List<TagSet> tagSetList,", "        return new PrimaryPreferredReadPreference(tagSetList, maxStaleness, timeUnit);"], "maxStaleness": ["                                                          final long maxStaleness, final TimeUnit timeUnit) {", "        return new PrimaryPreferredReadPreference(tagSetList, maxStaleness, timeUnit);"], "timeUnit": ["                                                          final long maxStaleness, final TimeUnit timeUnit) {", "        return new PrimaryPreferredReadPreference(tagSetList, maxStaleness, timeUnit);"]}
{"tagSetList": ["public static TaggableReadPreference nearest(final List<TagSet> tagSetList,", "        return new NearestReadPreference(tagSetList, maxStaleness, timeUnit);"], "maxStaleness": ["                                                 final long maxStaleness, final TimeUnit timeUnit) {", "        return new NearestReadPreference(tagSetList, maxStaleness, timeUnit);"], "timeUnit": ["                                                 final long maxStaleness, final TimeUnit timeUnit) {", "        return new NearestReadPreference(tagSetList, maxStaleness, timeUnit);"]}
{"name": ["public static ReadPreference valueOf(final String name) {", "        notNull(\"name\", name);", "        String nameToCheck = name.toLowerCase();", "        throw new IllegalArgumentException(\"No match for read preference of \" + name);"]}
{"name": ["public static TaggableReadPreference valueOf(final String name, final List<TagSet> tagSetList) {", "        return valueOf(name, tagSetList, null, MILLISECONDS);"], "tagSetList": ["public static TaggableReadPreference valueOf(final String name, final List<TagSet> tagSetList) {", "        return valueOf(name, tagSetList, null, MILLISECONDS);"]}
{"name": ["public static TaggableReadPreference valueOf(final String name, final List<TagSet> tagSetList, final long maxStaleness,", "        return valueOf(name, tagSetList, (Long) maxStaleness, timeUnit);"], "tagSetList": ["public static TaggableReadPreference valueOf(final String name, final List<TagSet> tagSetList, final long maxStaleness,", "        return valueOf(name, tagSetList, (Long) maxStaleness, timeUnit);"], "maxStaleness": ["public static TaggableReadPreference valueOf(final String name, final List<TagSet> tagSetList, final long maxStaleness,", "        return valueOf(name, tagSetList, (Long) maxStaleness, timeUnit);"], "timeUnit": ["                                                 final TimeUnit timeUnit) {", "        return valueOf(name, tagSetList, (Long) maxStaleness, timeUnit);"]}
{"inputStream": ["public static void readFully(final InputStream inputStream, final byte[] buffer, final int offset, final int length)", "        while (bytesToRead > 0) {", "            int bytesRead = inputStream.read(buffer, arrayOffset, bytesToRead);", "            if (bytesRead < 0) {", "            bytesToRead -= bytesRead;", "            arrayOffset += bytesRead;"], "buffer": ["public static void readFully(final InputStream inputStream, final byte[] buffer, final int offset, final int length)", "        if (buffer.length < length + offset) {", "        while (bytesToRead > 0) {", "            int bytesRead = inputStream.read(buffer, arrayOffset, bytesToRead);", "            if (bytesRead < 0) {", "            bytesToRead -= bytesRead;", "            arrayOffset += bytesRead;"], "offset": ["public static void readFully(final InputStream inputStream, final byte[] buffer, final int offset, final int length)", "        if (buffer.length < length + offset) {", "        int arrayOffset = offset;", "        while (bytesToRead > 0) {", "            int bytesRead = inputStream.read(buffer, arrayOffset, bytesToRead);", "            if (bytesRead < 0) {", "            bytesToRead -= bytesRead;", "            arrayOffset += bytesRead;"], "length": ["public static void readFully(final InputStream inputStream, final byte[] buffer, final int offset, final int length)", "        if (buffer.length < length + offset) {", "        int bytesToRead = length;", "        while (bytesToRead > 0) {", "            int bytesRead = inputStream.read(buffer, arrayOffset, bytesToRead);", "            if (bytesRead < 0) {", "            bytesToRead -= bytesRead;", "            arrayOffset += bytesRead;"]}
{"inputStream": ["public static int readInt(final InputStream inputStream, final byte[] buffer) throws IOException {", "        readFully(inputStream, buffer, 4);"], "buffer": ["public static int readInt(final InputStream inputStream, final byte[] buffer) throws IOException {", "        readFully(inputStream, buffer, 4);", "        return readInt(buffer);"]}
{"buffer": ["public static int readInt(final byte[] buffer, final int offset) {", "        x |= (0xFF & buffer[offset + 0]) << 0;", "        x |= (0xFF & buffer[offset + 1]) << 8;", "        x |= (0xFF & buffer[offset + 2]) << 16;", "        x |= (0xFF & buffer[offset + 3]) << 24;"], "offset": ["public static int readInt(final byte[] buffer, final int offset) {", "        x |= (0xFF & buffer[offset + 0]) << 0;", "        x |= (0xFF & buffer[offset + 1]) << 8;", "        x |= (0xFF & buffer[offset + 2]) << 16;", "        x |= (0xFF & buffer[offset + 3]) << 24;"]}
{"buffer": ["public static int readIntBE(final byte[] buffer, final int offset) {", "        x |= (0xFF & buffer[offset + 0]) << 24;", "        x |= (0xFF & buffer[offset + 1]) << 16;", "        x |= (0xFF & buffer[offset + 2]) << 8;", "        x |= (0xFF & buffer[offset + 3]) << 0;"], "offset": ["public static int readIntBE(final byte[] buffer, final int offset) {", "        x |= (0xFF & buffer[offset + 0]) << 24;", "        x |= (0xFF & buffer[offset + 1]) << 16;", "        x |= (0xFF & buffer[offset + 2]) << 8;", "        x |= (0xFF & buffer[offset + 3]) << 0;"]}
{"inputStream": ["public static long readLong(final InputStream inputStream, final byte[] buffer) throws IOException {", "        readFully(inputStream, buffer, 8);"], "buffer": ["public static long readLong(final InputStream inputStream, final byte[] buffer) throws IOException {", "        readFully(inputStream, buffer, 8);", "        return readLong(buffer);"]}
{"Result": "Method without Parameter"}
{"serverDescriptions": ["private ClusterableServer getRandomServer(final List<ServerDescription> serverDescriptions) {", "        while (!serverDescriptions.isEmpty()) {", "            int serverPos = getRandom().nextInt(serverDescriptions.size());", "            ClusterableServer server = getServer(serverDescriptions.get(serverPos).getAddress());", "            if (server != null) {", "                return server;", "                serverDescriptions.remove(serverPos);"]}
{"connectionString": ["public static MongoClient create(final ConnectionString connectionString,", "        return create(MongoClientSettings.builder().applyConnectionString(connectionString).build(),", "                mongoDriverInformation, connectionString.getStreamType());"], "mongoDriverInformation": ["                                     @Nullable final MongoDriverInformation mongoDriverInformation) {", "                mongoDriverInformation, connectionString.getStreamType());"]}
{"Result": "Method without Parameter"}
{"type": ["public static <S> ClassModelBuilder<S> builder(final Class<S> type) {", "        return new ClassModelBuilder<S>(type);"]}
{"name": ["public DBCollection getCollection(final String name) {", "        DBCollection collection = collectionCache.get(name);", "        if (collection != null) {", "            return collection;", "        collection = new DBCollection(name, this, executor);", "        DBCollection old = collectionCache.putIfAbsent(name, collection);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"command": ["public CommandResult command(final DBObject command, final ReadPreference readPreference, @Nullable final DBEncoder encoder) {"], "readPreference": ["public CommandResult command(final DBObject command, final ReadPreference readPreference, @Nullable final DBEncoder encoder) {", "            return executeCommand(wrap(command, encoder), getCommandReadPreference(command, readPreference));"], "encoder": ["public CommandResult command(final DBObject command, final ReadPreference readPreference, @Nullable final DBEncoder encoder) {", "            return executeCommand(wrap(command, encoder), getCommandReadPreference(command, readPreference));"]}
{"command": ["public CommandResult command(final DBObject command, final ReadPreference readPreference) {"], "readPreference": ["public CommandResult command(final DBObject command, final ReadPreference readPreference) {", "        return command(command, readPreference, null);"]}
{"collectionName": ["public boolean collectionExists(final String collectionName) {", "            if (name.equalsIgnoreCase(collectionName)) {"]}
{"code": ["    public CommandResult doEval(final String code, final Object... args) {", "        DBObject commandDocument = new BasicDBObject(\"$eval\", code).append(\"args\", asList(args));"]}
{"Result": "Method without Parameter"}
{"userName": ["    public WriteResult removeUser(final String userName) {", "            executor.execute(new com.mongodb.operation.DropUserOperation(getName(), userName, getWriteConcern()), getReadConcern());"]}
{"command": ["ReadPreference getCommandReadPreference(final DBObject command, @Nullable final ReadPreference requestedPreference) {", "        String comString = command.keySet().iterator().next().toLowerCase();"], "requestedPreference": ["ReadPreference getCommandReadPreference(final DBObject command, @Nullable final ReadPreference requestedPreference) {", "        } else if (requestedPreference == null) {", "            return requestedPreference;"]}
{"clazz": ["public <U> Codec<U> get(final Class<U> clazz) {", "        if (hasCycles(clazz)) {", "            return new LazyCodec<U>(registry, clazz);", "            return registry.get(new ChildCodecRegistry<U>(this, clazz));"]}
{"document": ["public WriteResult insert(final DBObject document, final WriteConcern writeConcern) {", "        return insert(asList(document), writeConcern);"], "writeConcern": ["public WriteResult insert(final DBObject document, final WriteConcern writeConcern) {", "        return insert(asList(document), writeConcern);"]}
{"query": ["public WriteResult update(final DBObject query, final DBObject update, final DBCollectionUpdateOptions options) {", "        notNull(\"query\", query);", "        UpdateRequest updateRequest = new UpdateRequest(wrap(query), wrap(update, options.getEncoder()), updateType)"], "update": ["public WriteResult update(final DBObject query, final DBObject update, final DBCollectionUpdateOptions options) {"], "options": ["public WriteResult update(final DBObject query, final DBObject update, final DBCollectionUpdateOptions options) {", "        notNull(\"options\", options);", "        WriteConcern writeConcern = options.getWriteConcern() != null ? options.getWriteConcern() : getWriteConcern();", "        UpdateRequest updateRequest = new UpdateRequest(wrap(query), wrap(update, options.getEncoder()), updateType)", "                                              .upsert(options.isUpsert()).multi(options.isMulti())", "                                              .collation(options.getCollation())", "                                              .arrayFilters(wrapAllowNull(options.getArrayFilters(), options.getEncoder()));", "                singletonList(updateRequest)).bypassDocumentValidation(options.getBypassDocumentValidation()));"]}
{"id": ["    public DBObject findOne(final Object id, final DBObject projection) {", "        return findOne(new BasicDBObject(\"_id\", id), new DBCollectionFindOptions().projection(projection));"], "projection": ["    public DBObject findOne(final Object id, final DBObject projection) {", "        return findOne(new BasicDBObject(\"_id\", id), new DBCollectionFindOptions().projection(projection));"]}
{"newName": ["public DBCollection rename(final String newName, final boolean dropTarget) {", "                                                           new MongoNamespace(getNamespace().getDatabaseName(), newName), getWriteConcern())", "            return getDB().getCollection(newName);"], "dropTarget": ["public DBCollection rename(final String newName, final boolean dropTarget) {", "                                     .dropTarget(dropTarget), getReadConcern());"]}
{"map": ["public MapReduceOutput mapReduce(final String map, final String reduce, final String outputTarget,", "        MapReduceCommand command = new MapReduceCommand(this, map, reduce, outputTarget, outputType, query);"], "reduce": ["public MapReduceOutput mapReduce(final String map, final String reduce, final String outputTarget,", "        MapReduceCommand command = new MapReduceCommand(this, map, reduce, outputTarget, outputType, query);"], "outputTarget": ["public MapReduceOutput mapReduce(final String map, final String reduce, final String outputTarget,", "        MapReduceCommand command = new MapReduceCommand(this, map, reduce, outputTarget, outputType, query);"], "outputType": ["                                     final MapReduceCommand.OutputType outputType, final DBObject query,", "        MapReduceCommand command = new MapReduceCommand(this, map, reduce, outputTarget, outputType, query);"], "query": ["                                     final MapReduceCommand.OutputType outputType, final DBObject query,", "        MapReduceCommand command = new MapReduceCommand(this, map, reduce, outputTarget, outputType, query);", "        command.setReadPreference(readPreference);", "        return mapReduce(command);"], "readPreference": ["                                     final ReadPreference readPreference) {", "        command.setReadPreference(readPreference);"]}
{"pipeline": ["public CommandResult explainAggregate(final List<? extends DBObject> pipeline, final AggregationOptions options) {", "        AggregateOperation<BsonDocument> operation = new AggregateOperation<BsonDocument>(getNamespace(), preparePipeline(pipeline),"], "options": ["public CommandResult explainAggregate(final List<? extends DBObject> pipeline, final AggregationOptions options) {", "                                                         .maxTime(options.getMaxTime(MILLISECONDS), MILLISECONDS)", "                                                         .allowDiskUse(options.getAllowDiskUse())", "                                                         .collation(options.getCollation())"]}
{"keys": ["public void createIndex(final DBObject keys, @Nullable final String name, final boolean unique) {", "        createIndex(keys, options);"], "name": ["public void createIndex(final DBObject keys, @Nullable final String name, final boolean unique) {", "        if (name != null && name.length() > 0) {", "            options.put(\"name\", name);"], "unique": ["public void createIndex(final DBObject keys, @Nullable final String name, final boolean unique) {", "        if (unique) {"]}
{"keys": ["public void createIndex(final DBObject keys, final DBObject options) {", "            executor.execute(createIndexOperation(keys, options), getReadConcern());"], "options": ["public void createIndex(final DBObject keys, final DBObject options) {", "            executor.execute(createIndexOperation(keys, options), getReadConcern());"]}
{"query": ["    public DBObject findAndRemove(@Nullable final DBObject query) {", "        return findAndModify(query, null, null, true, null, false, false);"]}
{"factory": ["public synchronized void setDBDecoderFactory(@Nullable final DBDecoderFactory factory) {", "        this.decoderFactory = factory;", "        Decoder<DBObject> decoder = (factory == null || factory == DefaultDBDecoder.FACTORY)", "                                    : new DBDecoderAdapter(factory.create(), this, getBufferPool());"]}
{"factory": ["public synchronized void setDBEncoderFactory(@Nullable final DBEncoderFactory factory) {", "        this.encoderFactory = factory;", "        Encoder<DBObject> encoder = (factory == null || factory == DefaultDBEncoder.FACTORY)", "                                    : new DBEncoderFactoryAdapter(encoderFactory);", "        this.objectCodec = new CompoundDBObjectCodec(encoder, objectCodec.getDecoder());"]}
{"Result": "Method without Parameter"}
{"index": ["public void dropIndex(final DBObject index) {", "            executor.execute(new DropIndexOperation(getNamespace(), wrap(index), getWriteConcern()), getReadConcern());"]}
{"indexName": ["public void dropIndex(final String indexName) {", "            executor.execute(new DropIndexOperation(getNamespace(), indexName, getWriteConcern()), getReadConcern());"]}
{"Result": "Method without Parameter"}
{"path": ["public void setInternalClass(final String path, final Class<? extends DBObject> aClass) {", "        setObjectFactory(objectFactory.update(aClass, asList(path.split(\"\\\\.\"))));"], "aClass": ["public void setInternalClass(final String path, final Class<? extends DBObject> aClass) {", "        setObjectFactory(objectFactory.update(aClass, asList(path.split(\"\\\\.\"))));"]}
{"path": ["protected Class<? extends DBObject> getInternalClass(final String path) {", "        return objectFactory.getClassForPath(asList(path.split(\"\\\\.\")));"]}
{"fieldName": ["public static <TItem> Bson set(final String fieldName, @Nullable final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$set\");"], "value": ["public static <TItem> Bson set(final String fieldName, @Nullable final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$set\");"]}
{"fieldName": ["public static <TItem> Bson setOnInsert(final String fieldName, @Nullable final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$setOnInsert\");"], "value": ["public static <TItem> Bson setOnInsert(final String fieldName, @Nullable final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$setOnInsert\");"]}
{"fieldName": ["public static Bson rename(final String fieldName, final String newFieldName) {", "        return new SimpleUpdate<String>(fieldName, newFieldName, \"$rename\");"], "newFieldName": ["public static Bson rename(final String fieldName, final String newFieldName) {", "        notNull(\"newFieldName\", newFieldName);", "        return new SimpleUpdate<String>(fieldName, newFieldName, \"$rename\");"]}
{"fieldName": ["public static Bson inc(final String fieldName, final Number number) {", "        return new SimpleUpdate<Number>(fieldName, number, \"$inc\");"], "number": ["public static Bson inc(final String fieldName, final Number number) {", "        notNull(\"number\", number);", "        return new SimpleUpdate<Number>(fieldName, number, \"$inc\");"]}
{"fieldName": ["public static Bson mul(final String fieldName, final Number number) {", "        return new SimpleUpdate<Number>(fieldName, number, \"$mul\");"], "number": ["public static Bson mul(final String fieldName, final Number number) {", "        notNull(\"number\", number);", "        return new SimpleUpdate<Number>(fieldName, number, \"$mul\");"]}
{"fieldName": ["public static <TItem> Bson min(final String fieldName, final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$min\");"], "value": ["public static <TItem> Bson min(final String fieldName, final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$min\");"]}
{"fieldName": ["public static <TItem> Bson max(final String fieldName, final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$max\");"], "value": ["public static <TItem> Bson max(final String fieldName, final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$max\");"]}
{"fieldName": ["public static <TItem> Bson addToSet(final String fieldName, @Nullable final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$addToSet\");"], "value": ["public static <TItem> Bson addToSet(final String fieldName, @Nullable final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$addToSet\");"]}
{"fieldName": ["public static <TItem> Bson addEachToSet(final String fieldName, final List<TItem> values) {", "        return new WithEachUpdate<TItem>(fieldName, values, \"$addToSet\");"], "values": ["public static <TItem> Bson addEachToSet(final String fieldName, final List<TItem> values) {", "        return new WithEachUpdate<TItem>(fieldName, values, \"$addToSet\");"]}
{"fieldName": ["public static <TItem> Bson push(final String fieldName, @Nullable final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$push\");"], "value": ["public static <TItem> Bson push(final String fieldName, @Nullable final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$push\");"]}
{"fieldName": ["public static <TItem> Bson pushEach(final String fieldName, final List<TItem> values) {", "        return new PushUpdate<TItem>(fieldName, values, new PushOptions());"], "values": ["public static <TItem> Bson pushEach(final String fieldName, final List<TItem> values) {", "        return new PushUpdate<TItem>(fieldName, values, new PushOptions());"]}
{"fieldName": ["public static <TItem> Bson pull(final String fieldName, @Nullable final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$pull\");"], "value": ["public static <TItem> Bson pull(final String fieldName, @Nullable final TItem value) {", "        return new SimpleUpdate<TItem>(fieldName, value, \"$pull\");"]}
{"filter": ["public static Bson pullByFilter(final Bson filter) {", "                encodeValue(writer, filter, codecRegistry);"]}
{"fieldName": ["public static <TItem> Bson pullAll(final String fieldName, final List<TItem> values) {", "        return new PullAllUpdate<TItem>(fieldName, values);"], "values": ["public static <TItem> Bson pullAll(final String fieldName, final List<TItem> values) {", "        return new PullAllUpdate<TItem>(fieldName, values);"]}
{"bsonOutput": ["protected void writeQueryPrologue(final BsonOutput bsonOutput) {", "        bsonOutput.writeInt32(getCursorFlag());", "        bsonOutput.writeCString(getCollectionName());", "        bsonOutput.writeInt32(skip);", "        bsonOutput.writeInt32(numberToReturn);"]}
{"connection": ["private void incrementGenerationOnSocketException(final InternalConnection connection, final Throwable t) {", "                                   getId(connection), serverId.getAddress(), serverId.getAddress()));"], "t": ["private void incrementGenerationOnSocketException(final InternalConnection connection, final Throwable t) {", "        if (t instanceof MongoSocketException && !(t instanceof MongoSocketReadTimeoutException)) {"]}
{"clazz": ["public static <T> List<Class<?>> getAncestry(final Class<T> clazz) {", "        return ClassAncestry.getAncestry(clazz);"]}
{"updateOptions": ["    public static ReplaceOptions createReplaceOptions(final UpdateOptions updateOptions) {", "        notNull(\"updateOptions\", updateOptions);", "        List<? extends Bson> arrayFilters = updateOptions.getArrayFilters();", "                .bypassDocumentValidation(updateOptions.getBypassDocumentValidation())", "                .collation(updateOptions.getCollation())", "                .upsert(updateOptions.isUpsert());"]}
{"s": ["public static byte[] decode(final String s) {", "        int delta = s.endsWith(\"==\") ? 2 : s.endsWith(\"=\") ? 1 : 0;", "        byte[] buffer = new byte[s.length() * BYTES_PER_UNENCODED_BLOCK / BYTES_PER_ENCODED_BLOCK - delta];", "        for (int i = 0; i < s.length(); i += BYTES_PER_ENCODED_BLOCK) {", "            int c0 = DECODE_TABLE[s.charAt(i)];", "            int c1 = DECODE_TABLE[s.charAt(i + 1)];", "            buffer[pos++] = (byte) (((c0 << 2) | (c1 >> 4)) & mask);", "            if (pos >= buffer.length) {", "                return buffer;", "            int c2 = DECODE_TABLE[s.charAt(i + 2)];", "            buffer[pos++] = (byte) (((c1 << 4) | (c2 >> 2)) & mask);", "            if (pos >= buffer.length) {", "                return buffer;", "            int c3 = DECODE_TABLE[s.charAt(i + 3)];", "            buffer[pos++] = (byte) (((c2 << 6) | c3) & mask);", "        return buffer;"]}
{"in": ["public static String encode(final byte[] in) {", "        int numEncodedBytes = (in.length / BYTES_PER_UNENCODED_BLOCK) * BYTES_PER_ENCODED_BLOCK", "                + ((in.length % BYTES_PER_UNENCODED_BLOCK == 0) ? 0 : 4);", "        for (int b : in) {", "            if (b < 0) {", "            bitWorkArea = (bitWorkArea << 8) + b; //  BITS_PER_BYTE", "                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 18) & SIX_BIT_MASK];", "                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 12) & SIX_BIT_MASK];", "                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 6) & SIX_BIT_MASK];", "                buffer[pos++] = ENCODE_TABLE[bitWorkArea & SIX_BIT_MASK];", "                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 2) & SIX_BIT_MASK]; // top 6 bits", "                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 4) & SIX_BIT_MASK]; // remaining 2", "                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 10) & SIX_BIT_MASK];", "                buffer[pos++] = ENCODE_TABLE[(bitWorkArea >> 4) & SIX_BIT_MASK];", "                buffer[pos++] = ENCODE_TABLE[(bitWorkArea << 2) & SIX_BIT_MASK];"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"async": ["    public CommandResult fsync(final boolean async) {", "        if (async) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"serverValue": ["public ConnectionId withServerValue(final int serverValue) {", "        isTrue(\"server value is null\", this.serverValue == null);", "        return new ConnectionId(serverId, localValue, serverValue);"]}
{"c": ["private static List<Class<?>> computeAncestry(final Class<?> c) {", "        computeAncestry(c, result);"]}
{"Result": "Method without Parameter"}
{"binding": ["    public MapReduceBatchCursor<T> execute(final ReadBinding binding) {", "        return executeCommand(binding, namespace.getDatabaseName(), getCommandCreator(binding.getSessionContext()),"]}
{"timeUnit": ["    public Long getExpireAfter(final TimeUnit timeUnit) {", "        return timeUnit.convert(expireAfterSeconds, TimeUnit.SECONDS);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"serverAddress": ["    public ServerDescription getByServerAddress(final ServerAddress serverAddress) {", "            if (cur.isOk() && cur.getAddress().equals(serverAddress)) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"tagSet": ["    public List<ServerDescription> getSecondaries(final TagSet tagSet) {", "                return serverDescription.isSecondary() && serverDescription.hasTags(tagSet);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"tagSet": ["    public List<ServerDescription> getAnyPrimaryOrSecondary(final TagSet tagSet) {", "                return (serverDescription.isPrimary() || serverDescription.isSecondary()) && serverDescription.hasTags(tagSet);"]}
{"Result": "Method without Parameter"}
{"userName": ["public static MongoCredential createCredential(final String userName, final String database, final char[] password) {", "        return new MongoCredential(null, userName, database, password);"], "database": ["public static MongoCredential createCredential(final String userName, final String database, final char[] password) {", "        return new MongoCredential(null, userName, database, password);"], "password": ["public static MongoCredential createCredential(final String userName, final String database, final char[] password) {", "        return new MongoCredential(null, userName, database, password);"]}
{"userName": ["public static MongoCredential createScramSha256Credential(final String userName, final String source, final char[] password) {", "        return new MongoCredential(SCRAM_SHA_256, userName, source, password);"], "source": ["public static MongoCredential createScramSha256Credential(final String userName, final String source, final char[] password) {", "        return new MongoCredential(SCRAM_SHA_256, userName, source, password);"], "password": ["public static MongoCredential createScramSha256Credential(final String userName, final String source, final char[] password) {", "        return new MongoCredential(SCRAM_SHA_256, userName, source, password);"]}
{"userName": ["public static MongoCredential createPlainCredential(final String userName, final String source, final char[] password) {", "        return new MongoCredential(PLAIN, userName, source, password);"], "source": ["public static MongoCredential createPlainCredential(final String userName, final String source, final char[] password) {", "        return new MongoCredential(PLAIN, userName, source, password);"], "password": ["public static MongoCredential createPlainCredential(final String userName, final String source, final char[] password) {", "        return new MongoCredential(PLAIN, userName, source, password);"]}
{"key": ["public <T> MongoCredential withMechanismProperty(final String key, final T value) {", "        return new MongoCredential(this, key, value);"], "value": ["public <T> MongoCredential withMechanismProperty(final String key, final T value) {", "        return new MongoCredential(this, key, value);"]}
{"mechanism": ["public MongoCredential withMechanism(final AuthenticationMechanism mechanism) {", "        if (this.mechanism != null) {", "        return new MongoCredential(mechanism, userName, source, password, mechanismProperties);"]}
{"key": ["    public <T> T getMechanismProperty(final String key, @Nullable final T defaultValue) {", "        notNull(\"key\", key);", "        T value = (T) mechanismProperties.get(key.toLowerCase());"], "defaultValue": ["    public <T> T getMechanismProperty(final String key, @Nullable final T defaultValue) {", "        return (value == null) ? defaultValue : value;"]}
{"Result": "Method without Parameter"}
{"c": ["    void addObjectSerializer(final Class c, final ObjectSerializer serializer) {", "        _serializers.put(c, serializer);"], "serializer": ["    void addObjectSerializer(final Class c, final ObjectSerializer serializer) {", "        _serializers.put(c, serializer);"]}
{"isMulti": ["public UpdateRequest multi(final boolean isMulti) {", "        if (isMulti && updateType == Type.REPLACE) {", "        this.isMulti = isMulti;"]}
{"bsonOutput": ["public void encode(final BsonOutput bsonOutput, final SessionContext sessionContext) {", "        int messageStartPosition = bsonOutput.getPosition();", "        writeMessagePrologue(bsonOutput);", "        EncodingMetadata encodingMetadata = encodeMessageBodyWithMetadata(bsonOutput, sessionContext);", "        backpatchMessageLength(messageStartPosition, bsonOutput);"], "sessionContext": ["public void encode(final BsonOutput bsonOutput, final SessionContext sessionContext) {", "        notNull(\"sessionContext\", sessionContext);", "        EncodingMetadata encodingMetadata = encodeMessageBodyWithMetadata(bsonOutput, sessionContext);", "        this.encodingMetadata = encodingMetadata;"]}
{"bsonOutput": ["protected void writeMessagePrologue(final BsonOutput bsonOutput) {", "        bsonOutput.writeInt32(0); // length: will set this later", "        bsonOutput.writeInt32(id);", "        bsonOutput.writeInt32(0); // response to", "        bsonOutput.writeInt32(opCode.getValue());"]}
{"document": ["protected void addDocument(final BsonDocument document, final BsonOutput bsonOutput,", "        addDocument(document, getCodec(document), EncoderContext.builder().build(), bsonOutput, validator,"], "bsonOutput": ["protected void addDocument(final BsonDocument document, final BsonOutput bsonOutput,", "        addDocument(document, getCodec(document), EncoderContext.builder().build(), bsonOutput, validator,"], "validator": ["                               final FieldNameValidator validator) {", "        addDocument(document, getCodec(document), EncoderContext.builder().build(), bsonOutput, validator,"]}
{"document": ["protected void addCollectibleDocument(final BsonDocument document, final BsonOutput bsonOutput, final FieldNameValidator validator) {", "        addDocument(document, getCodec(document), EncoderContext.builder().isEncodingCollectibleDocument(true).build(), bsonOutput,"], "bsonOutput": ["protected void addCollectibleDocument(final BsonDocument document, final BsonOutput bsonOutput, final FieldNameValidator validator) {", "        addDocument(document, getCodec(document), EncoderContext.builder().isEncodingCollectibleDocument(true).build(), bsonOutput,"], "validator": ["protected void addCollectibleDocument(final BsonDocument document, final BsonOutput bsonOutput, final FieldNameValidator validator) {", "                    validator, settings.getMaxDocumentSize(), null);"]}
{"startPosition": ["protected void backpatchMessageLength(final int startPosition, final BsonOutput bsonOutput) {", "        int messageLength = bsonOutput.getPosition() - startPosition;", "        bsonOutput.writeInt32(bsonOutput.getPosition() - messageLength, messageLength);"], "bsonOutput": ["protected void backpatchMessageLength(final int startPosition, final BsonOutput bsonOutput) {", "        int messageLength = bsonOutput.getPosition() - startPosition;", "        bsonOutput.writeInt32(bsonOutput.getPosition() - messageLength, messageLength);"]}
{"id": ["protected DBObject createChunk(final Object id, final int currentChunkNumber, final byte[] writeBuffer) {", "        return new BasicDBObject(\"files_id\", id)"], "currentChunkNumber": ["protected DBObject createChunk(final Object id, final int currentChunkNumber, final byte[] writeBuffer) {", "               .append(\"n\", currentChunkNumber)"], "writeBuffer": ["protected DBObject createChunk(final Object id, final int currentChunkNumber, final byte[] writeBuffer) {", "               .append(\"data\", writeBuffer);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"max": ["public List<DBObject> toArray(final int max) {", "        fillArray(max - 1);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"name": ["protected void _put(final String name, final Object value) {", "        cur().put(name, !BSON.hasDecodeHooks() ? value : BSON.applyDecodingHooks(value));"], "value": ["protected void _put(final String name, final Object value) {", "        cur().put(name, !BSON.hasDecodeHooks() ? value : BSON.applyDecodingHooks(value));"]}
{"name": ["protected void putDBRef(final String name, final DBRef ref) {", "        putObject(name, dbRefDocument);"], "ref": ["protected void putDBRef(final String name, final DBRef ref) {", "        BasicDBObject dbRefDocument = new BasicDBObject(\"$ref\", ref.getCollectionName()).append(\"$id\", ref.getId());", "        if (ref.getDatabaseName() != null) {", "            dbRefDocument.put(\"$db\", ref.getDatabaseName());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"fieldName": ["public static <TItem> Bson ne(final String fieldName, @Nullable final TItem value) {", "        return new OperatorFilter<TItem>(\"$ne\", fieldName, value);"], "value": ["public static <TItem> Bson ne(final String fieldName, @Nullable final TItem value) {", "        return new OperatorFilter<TItem>(\"$ne\", fieldName, value);"]}
{"fieldName": ["public static <TItem> Bson gt(final String fieldName, final TItem value) {", "        return new OperatorFilter<TItem>(\"$gt\", fieldName, value);"], "value": ["public static <TItem> Bson gt(final String fieldName, final TItem value) {", "        return new OperatorFilter<TItem>(\"$gt\", fieldName, value);"]}
{"fieldName": ["public static <TItem> Bson lt(final String fieldName, final TItem value) {", "        return new OperatorFilter<TItem>(\"$lt\", fieldName, value);"], "value": ["public static <TItem> Bson lt(final String fieldName, final TItem value) {", "        return new OperatorFilter<TItem>(\"$lt\", fieldName, value);"]}
{"fieldName": ["public static <TItem> Bson gte(final String fieldName, final TItem value) {", "        return new OperatorFilter<TItem>(\"$gte\", fieldName, value);"], "value": ["public static <TItem> Bson gte(final String fieldName, final TItem value) {", "        return new OperatorFilter<TItem>(\"$gte\", fieldName, value);"]}
{"fieldName": ["public static <TItem> Bson lte(final String fieldName, final TItem value) {", "        return new OperatorFilter<TItem>(\"$lte\", fieldName, value);"], "value": ["public static <TItem> Bson lte(final String fieldName, final TItem value) {", "        return new OperatorFilter<TItem>(\"$lte\", fieldName, value);"]}
{"filters": ["public static Bson or(final Iterable<Bson> filters) {", "        return new OrNorFilter(OrNorFilter.Operator.OR, filters);"]}
{"filters": ["public static Bson nor(final Iterable<Bson> filters) {", "        return new OrNorFilter(OrNorFilter.Operator.NOR, filters);"]}
{"fieldName": ["public static Bson exists(final String fieldName, final boolean exists) {", "        return new OperatorFilter<BsonBoolean>(\"$exists\", fieldName, BsonBoolean.valueOf(exists));"], "exists": ["public static Bson exists(final String fieldName, final boolean exists) {"]}
{"search": ["    public static Bson text(final String search, final String language) {", "        notNull(\"search\", search);", "        return text(search, new TextSearchOptions().language(language));"], "language": ["    public static Bson text(final String search, final String language) {", "        return text(search, new TextSearchOptions().language(language));"]}
{"search": ["public static Bson text(final String search, final TextSearchOptions textSearchOptions) {", "        notNull(\"search\", search);", "        return new TextFilter(search, textSearchOptions);"], "textSearchOptions": ["public static Bson text(final String search, final TextSearchOptions textSearchOptions) {", "        notNull(\"textSearchOptions\", textSearchOptions);", "        return new TextFilter(search, textSearchOptions);"]}
{"fieldName": ["public static Bson elemMatch(final String fieldName, final Bson filter) {", "                return new BsonDocument(fieldName, new BsonDocument(\"$elemMatch\", filter.toBsonDocument(documentClass, codecRegistry)));"], "filter": ["public static Bson elemMatch(final String fieldName, final Bson filter) {", "                return new BsonDocument(fieldName, new BsonDocument(\"$elemMatch\", filter.toBsonDocument(documentClass, codecRegistry)));"]}
{"fieldName": ["public static Bson geoWithinBox(final String fieldName, final double lowerLeftX, final double lowerLeftY, final double upperRightX,", "        return new OperatorFilter<BsonDocument>(\"$geoWithin\", fieldName, box);"], "lowerLeftX": ["public static Bson geoWithinBox(final String fieldName, final double lowerLeftX, final double lowerLeftY, final double upperRightX,", "                                                   new BsonArray(asList(new BsonArray(asList(new BsonDouble(lowerLeftX),"], "lowerLeftY": ["public static Bson geoWithinBox(final String fieldName, final double lowerLeftX, final double lowerLeftY, final double upperRightX,", "                                                           new BsonDouble(lowerLeftY))),"], "upperRightX": ["public static Bson geoWithinBox(final String fieldName, final double lowerLeftX, final double lowerLeftY, final double upperRightX,", "                                                           new BsonArray(asList(new BsonDouble(upperRightX),"], "upperRightY": ["                                    final double upperRightY) {", "        BsonDocument box = new BsonDocument(\"$box\",", "                                                                   new BsonDouble(upperRightY))))));", "        return new OperatorFilter<BsonDocument>(\"$geoWithin\", fieldName, box);"]}
{"fieldName": ["public static Bson geoWithinPolygon(final String fieldName, final List<List<Double>> points) {", "        return new OperatorFilter<BsonDocument>(\"$geoWithin\", fieldName, polygon);"], "points": ["public static Bson geoWithinPolygon(final String fieldName, final List<List<Double>> points) {", "        for (List<Double> point : points) {", "            pointsArray.add(new BsonArray(asList(new BsonDouble(point.get(0)), new BsonDouble(point.get(1)))));"]}
{"fieldName": ["public static Bson geoWithinCenter(final String fieldName, final double x, final double y, final double radius) {", "        return new OperatorFilter<BsonDocument>(\"$geoWithin\", fieldName, center);"], "x": ["public static Bson geoWithinCenter(final String fieldName, final double x, final double y, final double radius) {", "                                                      new BsonArray(Arrays.<BsonValue>asList(new BsonArray(asList(new BsonDouble(x),"], "y": ["public static Bson geoWithinCenter(final String fieldName, final double x, final double y, final double radius) {", "                                                              new BsonDouble(y))),"], "radius": ["public static Bson geoWithinCenter(final String fieldName, final double x, final double y, final double radius) {", "        BsonDocument center = new BsonDocument(\"$center\",", "                                                              new BsonDouble(radius))));", "        return new OperatorFilter<BsonDocument>(\"$geoWithin\", fieldName, center);"]}
{"fieldName": ["public static Bson near(final String fieldName, final Point geometry, @Nullable final Double maxDistance,", "        return new GeometryOperatorFilter<Point>(\"$near\", fieldName, geometry, maxDistance, minDistance);"], "geometry": ["public static Bson near(final String fieldName, final Point geometry, @Nullable final Double maxDistance,", "        return new GeometryOperatorFilter<Point>(\"$near\", fieldName, geometry, maxDistance, minDistance);"], "maxDistance": ["public static Bson near(final String fieldName, final Point geometry, @Nullable final Double maxDistance,", "        return new GeometryOperatorFilter<Point>(\"$near\", fieldName, geometry, maxDistance, minDistance);"], "minDistance": ["                            @Nullable final Double minDistance) {", "        return new GeometryOperatorFilter<Point>(\"$near\", fieldName, geometry, maxDistance, minDistance);"]}
{"fieldName": ["public static Bson near(final String fieldName, final double x, final double y, @Nullable final Double maxDistance,", "        return createNearFilterDocument(fieldName, x, y, maxDistance, minDistance, \"$near\");"], "x": ["public static Bson near(final String fieldName, final double x, final double y, @Nullable final Double maxDistance,", "        return createNearFilterDocument(fieldName, x, y, maxDistance, minDistance, \"$near\");"], "y": ["public static Bson near(final String fieldName, final double x, final double y, @Nullable final Double maxDistance,", "        return createNearFilterDocument(fieldName, x, y, maxDistance, minDistance, \"$near\");"], "maxDistance": ["public static Bson near(final String fieldName, final double x, final double y, @Nullable final Double maxDistance,", "        return createNearFilterDocument(fieldName, x, y, maxDistance, minDistance, \"$near\");"], "minDistance": ["                            @Nullable final Double minDistance) {", "        return createNearFilterDocument(fieldName, x, y, maxDistance, minDistance, \"$near\");"]}
{"s": ["public static int regexFlags(final String s) {", "        if (s == null) {", "        for (final char f : s.toLowerCase().toCharArray()) {", "            flags |= regexFlag(f);", "        return flags;"]}
{"c": ["public static int regexFlag(final char c) {", "        int flag = FLAG_LOOKUP[c];", "        if (flag == 0) {", "            throw new IllegalArgumentException(String.format(\"Unrecognized flag [%c]\", c));", "        return flag;"]}
{"flags": ["public static String regexFlags(final int flags) {", "        int processedFlags = flags;", "            if ((processedFlags & FLAG_LOOKUP[i]) > 0) {", "        if (processedFlags > 0) {"]}
{"textVersion": ["public IndexRequest textVersion(final Integer textVersion) {"]}
{"sphereVersion": ["public IndexRequest sphereVersion(final Integer sphereVersion) {"]}
{"Result": "Method without Parameter"}
{"clazz": ["    public static <T> T convertToType(final Class<T> clazz, final Object value, final String errorMessage) {", "        if (!clazz.isAssignableFrom(value.getClass())) {"], "value": ["    public static <T> T convertToType(final Class<T> clazz, final Object value, final String errorMessage) {", "        if (!clazz.isAssignableFrom(value.getClass())) {", "        return (T) value;"], "errorMessage": ["    public static <T> T convertToType(final Class<T> clazz, final Object value, final String errorMessage) {", "            throw new IllegalArgumentException(errorMessage);"]}
{"writer": ["    public void encode(final BsonWriter writer, final DBObject document, final EncoderContext encoderContext) {", "                writer.pipe(reader);"], "document": ["    public void encode(final BsonWriter writer, final DBObject document, final EncoderContext encoderContext) {", "            encoder.writeObject(buffer, document);"], "encoderContext": []}
{"binding": ["    public BulkWriteResult execute(final WriteBinding binding) {", "        return withReleasableConnection(binding, new CallableWithConnectionAndSource<BulkWriteResult>() {", "                            binding.getSessionContext());", "                    return executeBulkWriteBatch(binding, connection, bulkWriteBatch);"]}
{"Result": "Method without Parameter"}
{"arrayFilters": ["public BulkUpdateRequestBuilder arrayFilters(final List<? extends DBObject> arrayFilters) {"]}
{"binding": ["    public MapReduceStatistics execute(final WriteBinding binding) {", "        return withConnection(binding, new OperationHelper.CallableWithConnection<MapReduceStatistics>() {", "                return executeCommand(binding, namespace.getDatabaseName(), getCommand(connection.getDescription()),"]}
{"mongoEmbeddedSettings": ["public static synchronized void init(final MongoEmbeddedSettings mongoEmbeddedSettings) {", "            mongoEmbeddedLibrary = MongoEmbeddedCAPI.create(mongoEmbeddedSettings.getYamlConfig(),", "                    mongoEmbeddedSettings.getLogLevel().toCapiLogLevel(), mongoEmbeddedSettings.getLibraryPath());"]}
{"mongoClientSettings": ["public static synchronized MongoClient create(final MongoClientSettings mongoClientSettings) {", "            Cluster cluster = new EmbeddedCluster(mongoEmbeddedLibrary, mongoClientSettings);", "            return new MongoClientImpl(cluster, mongoClientSettings.getWrappedMongoClientSettings(), null);"]}
{"Result": "Method without Parameter"}
{"host": ["public static void enableSni(final String host, final SSLParameters sslParameters) {", "            SNI_SSL_HELPER.enableSni(host, sslParameters);"], "sslParameters": ["public static void enableSni(final String host, final SSLParameters sslParameters) {", "            SNI_SSL_HELPER.enableSni(host, sslParameters);"]}
{"object": ["    public static byte getType(final Object object) {", "        if (object == null) {", "        if (object instanceof Integer", "            || object instanceof Short", "            || object instanceof Byte", "            || object instanceof AtomicInteger) {", "        if (object instanceof Long || object instanceof AtomicLong) {", "        if (object instanceof Number) {", "        if (object instanceof String) {", "        if (object instanceof java.util.List) {", "        if (object instanceof byte[]) {", "        if (object instanceof ObjectId) {", "        if (object instanceof Boolean) {", "        if (object instanceof java.util.Date) {", "        if (object instanceof BSONTimestamp) {", "        if (object instanceof java.util.regex.Pattern) {", "        if (object instanceof DBObject || object instanceof DBRef) {", "        if (object instanceof CodeWScope) {", "        if (object instanceof Code) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"matchedCount": ["public static UpdateResult acknowledged(final long matchedCount, @Nullable final Long modifiedCount,", "        return new AcknowledgedUpdateResult(matchedCount, modifiedCount, upsertedId);"], "modifiedCount": ["public static UpdateResult acknowledged(final long matchedCount, @Nullable final Long modifiedCount,", "        return new AcknowledgedUpdateResult(matchedCount, modifiedCount, upsertedId);"], "upsertedId": ["                                            @Nullable final BsonValue upsertedId) {", "        return new AcknowledgedUpdateResult(matchedCount, modifiedCount, upsertedId);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"encoder": ["public <T> void encodeWithChildContext(final Encoder<T> encoder, final BsonWriter writer, final T value) {", "        encoder.encode(writer, value, DEFAULT_CONTEXT);"], "writer": ["public <T> void encodeWithChildContext(final Encoder<T> encoder, final BsonWriter writer, final T value) {", "        encoder.encode(writer, value, DEFAULT_CONTEXT);"], "value": ["public <T> void encodeWithChildContext(final Encoder<T> encoder, final BsonWriter writer, final T value) {", "        encoder.encode(writer, value, DEFAULT_CONTEXT);"]}
{"Result": "Method without Parameter"}
{"source": ["    public void compress(final List<ByteBuf> source, final BsonOutput target) {", "        int uncompressedSize = getUncompressedSize(source);", "        byte[] singleByteArraySource = new byte[uncompressedSize];", "        copy(source, singleByteArraySource);", "            byte[] out = new byte[Snappy.maxCompressedLength(uncompressedSize)];", "            int compressedSize = Snappy.compress(singleByteArraySource, 0, singleByteArraySource.length, out, 0);", "            target.writeBytes(out, 0, compressedSize);"], "target": ["    public void compress(final List<ByteBuf> source, final BsonOutput target) {", "            target.writeBytes(out, 0, compressedSize);"]}
{"key": ["public String getString(final String key) {", "        Object foo = get(key);", "        if (foo == null) {", "        return foo.toString();"]}
{"key": ["public boolean getBoolean(final String key, final boolean def) {", "        Object foo = get(key);", "        if (foo == null) {", "        if (foo instanceof Number) {", "            return ((Number) foo).intValue() > 0;", "        if (foo instanceof Boolean) {", "            return (Boolean) foo;", "        throw new IllegalArgumentException(\"can't coerce to bool:\" + foo.getClass());"], "def": ["public boolean getBoolean(final String key, final boolean def) {", "            return def;"]}
{"field": ["public ObjectId getObjectId(final String field, final ObjectId def) {", "        Object foo = get(field);", "        return (foo != null) ? (ObjectId) foo : def;"], "def": ["public ObjectId getObjectId(final String field, final ObjectId def) {", "        return (foo != null) ? (ObjectId) foo : def;"]}
{"field": ["public Date getDate(final String field, final Date def) {", "        Object foo = get(field);", "        return (foo != null) ? (Date) foo : def;"], "def": ["public Date getDate(final String field, final Date def) {", "        return (foo != null) ? (Date) foo : def;"]}
{"from": ["    private static Object canonicalize(final Object from) {", "        if (from instanceof BSONObject && !(from instanceof BasicBSONList)) {", "            return canonicalizeBSONObject((BSONObject) from);", "        } else if (from instanceof List) {", "            return canonicalizeList((List<Object>) from);", "        } else if (from instanceof Map) {", "            return canonicalizeMap((Map<String, Object>) from);", "            return from;"]}
{"Result": "Method without Parameter"}
{"options": ["public ClientSession startSession(final ClientSessionOptions options) {", "        ClientSession clientSession = createClientSession(notNull(\"options\", options));", "        if (clientSession == null) {", "        return clientSession;"]}
{"timeUnit": ["    public Integer getWTimeout(final TimeUnit timeUnit) {", "        notNull(\"timeUnit\", timeUnit);", "        return wTimeoutMS == null ? null : (int) timeUnit.convert(wTimeoutMS, TimeUnit.MILLISECONDS);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"w": ["public WriteConcern withW(final int w) {", "        return new WriteConcern(Integer.valueOf(w), wTimeoutMS, fsync, journal);"]}
{"w": ["public WriteConcern withW(final String w) {", "        notNull(\"w\", w);", "        return new WriteConcern(w, wTimeoutMS, fsync, journal);"]}
{"wTimeout": ["public WriteConcern withWTimeout(final long wTimeout, final TimeUnit timeUnit) {", "        long newWTimeOutMS = TimeUnit.MILLISECONDS.convert(wTimeout, timeUnit);", "        isTrueArgument(\"wTimeout >= 0\", wTimeout >= 0);"], "timeUnit": ["public WriteConcern withWTimeout(final long wTimeout, final TimeUnit timeUnit) {", "        notNull(\"timeUnit\", timeUnit);", "        long newWTimeOutMS = TimeUnit.MILLISECONDS.convert(wTimeout, timeUnit);", "        isTrueArgument(\"wTimeout <= \" + Integer.MAX_VALUE + \" ms\", newWTimeOutMS <= Integer.MAX_VALUE);", "        return new WriteConcern(w, (int) newWTimeOutMS, fsync, journal);"]}
{"wtimeout": ["    public static Majority majorityWriteConcern(final int wtimeout, final boolean fsync, final boolean j) {", "        return new Majority(wtimeout, fsync, j);"], "fsync": ["    public static Majority majorityWriteConcern(final int wtimeout, final boolean fsync, final boolean j) {", "        return new Majority(wtimeout, fsync, j);"], "j": ["    public static Majority majorityWriteConcern(final int wtimeout, final boolean fsync, final boolean j) {", "        return new Majority(wtimeout, fsync, j);"]}
{"document": ["public void insert(final DBObject document) {", "        if (document.get(ID_FIELD_NAME) == null) {", "            document.put(ID_FIELD_NAME, new ObjectId());", "        addRequest(new InsertRequest(document, collection.getObjectCodec()));"]}
{"query": ["public BulkWriteRequestBuilder find(final DBObject query) {", "        return new BulkWriteRequestBuilder(this, query, collection.getDefaultDBObjectCodec(), collection.getObjectCodec());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"fieldName": ["public static Bson geoHaystack(final String fieldName, final Bson additional) {", "        notNull(\"fieldName\", fieldName);", "        return compoundIndex(new BsonDocument(fieldName, new BsonString(\"geoHaystack\")), additional);"], "additional": ["public static Bson geoHaystack(final String fieldName, final Bson additional) {", "        return compoundIndex(new BsonDocument(fieldName, new BsonString(\"geoHaystack\")), additional);"]}
{"Result": "Method without Parameter"}
{"key": ["public BsonValue get(final Object key, final BsonValue defaultValue) {", "        BsonValue value = get(key);", "        return value != null ? value : defaultValue;"], "defaultValue": ["public BsonValue get(final Object key, final BsonValue defaultValue) {", "        return value != null ? value : defaultValue;"]}
{"key": ["public BsonDocument getDocument(final Object key, final BsonDocument defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asDocument();"], "defaultValue": ["public BsonDocument getDocument(final Object key, final BsonDocument defaultValue) {", "            return defaultValue;"]}
{"key": ["public BsonArray getArray(final Object key, final BsonArray defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asArray();"], "defaultValue": ["public BsonArray getArray(final Object key, final BsonArray defaultValue) {", "            return defaultValue;"]}
{"key": ["public BsonNumber getNumber(final Object key, final BsonNumber defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asNumber();"], "defaultValue": ["public BsonNumber getNumber(final Object key, final BsonNumber defaultValue) {", "            return defaultValue;"]}
{"key": ["public BsonInt32 getInt32(final Object key, final BsonInt32 defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asInt32();"], "defaultValue": ["public BsonInt32 getInt32(final Object key, final BsonInt32 defaultValue) {", "            return defaultValue;"]}
{"key": ["public BsonInt64 getInt64(final Object key, final BsonInt64 defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asInt64();"], "defaultValue": ["public BsonInt64 getInt64(final Object key, final BsonInt64 defaultValue) {", "            return defaultValue;"]}
{"key": ["public BsonDecimal128 getDecimal128(final Object key, final BsonDecimal128 defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asDecimal128();"], "defaultValue": ["public BsonDecimal128 getDecimal128(final Object key, final BsonDecimal128 defaultValue) {", "            return defaultValue;"]}
{"key": ["public BsonDouble getDouble(final Object key, final BsonDouble defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asDouble();"], "defaultValue": ["public BsonDouble getDouble(final Object key, final BsonDouble defaultValue) {", "            return defaultValue;"]}
{"key": ["public BsonBoolean getBoolean(final Object key, final BsonBoolean defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asBoolean();"], "defaultValue": ["public BsonBoolean getBoolean(final Object key, final BsonBoolean defaultValue) {", "            return defaultValue;"]}
{"key": ["public BsonString getString(final Object key, final BsonString defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asString();"], "defaultValue": ["public BsonString getString(final Object key, final BsonString defaultValue) {", "            return defaultValue;"]}
{"key": ["public BsonDateTime getDateTime(final Object key, final BsonDateTime defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asDateTime();"], "defaultValue": ["public BsonDateTime getDateTime(final Object key, final BsonDateTime defaultValue) {", "            return defaultValue;"]}
{"key": ["public BsonTimestamp getTimestamp(final Object key, final BsonTimestamp defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asTimestamp();"], "defaultValue": ["public BsonTimestamp getTimestamp(final Object key, final BsonTimestamp defaultValue) {", "            return defaultValue;"]}
{"key": ["public BsonObjectId getObjectId(final Object key, final BsonObjectId defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asObjectId();"], "defaultValue": ["public BsonObjectId getObjectId(final Object key, final BsonObjectId defaultValue) {", "            return defaultValue;"]}
{"key": ["public BsonBinary getBinary(final Object key, final BsonBinary defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asBinary();"], "defaultValue": ["public BsonBinary getBinary(final Object key, final BsonBinary defaultValue) {", "            return defaultValue;"]}
{"key": ["public BsonRegularExpression getRegularExpression(final Object key, final BsonRegularExpression defaultValue) {", "        if (!containsKey(key)) {", "        return get(key).asRegularExpression();"], "defaultValue": ["public BsonRegularExpression getRegularExpression(final Object key, final BsonRegularExpression defaultValue) {", "            return defaultValue;"]}
{"socket": ["private void writeHandlingTasks(final RegisteredSocket socket, final WriteOperation op) throws IOException {", "                socket.tlsChannel.write(op.bufferSet.array, op.bufferSet.offset, op.bufferSet.length);"], "op": ["private void writeHandlingTasks(final RegisteredSocket socket, final WriteOperation op) throws IOException {", "                socket.tlsChannel.write(op.bufferSet.array, op.bufferSet.offset, op.bufferSet.length);"]}
{"document": ["    public static BsonDocument asBsonDocument(final Object document, final CodecRegistry codecRegistry) {", "        if (document == null) {", "        if (document instanceof BsonDocument) {", "            return (BsonDocument) document;", "            return new BsonDocumentWrapper(document, codecRegistry.get(document.getClass()));"], "codecRegistry": ["    public static BsonDocument asBsonDocument(final Object document, final CodecRegistry codecRegistry) {", "            return new BsonDocumentWrapper(document, codecRegistry.get(document.getClass()));"]}
{"name": ["public static <T> T notNull(final String name, final T value, final SingleResultCallback<?> callback) {", "            IllegalArgumentException exception = new IllegalArgumentException(name + \" can not be null\");"], "value": ["public static <T> T notNull(final String name, final T value, final SingleResultCallback<?> callback) {", "        if (value == null) {", "        return value;"], "callback": ["public static <T> T notNull(final String name, final T value, final SingleResultCallback<?> callback) {", "            callback.onResult(null, exception);"]}
{"name": ["public static void isTrue(final String name, final boolean condition, final SingleResultCallback<?> callback) {", "            IllegalStateException exception = new IllegalStateException(\"state should be: \" + name);", "            callback.onResult(null, exception);", "            throw exception;"], "condition": ["public static void isTrue(final String name, final boolean condition, final SingleResultCallback<?> callback) {", "        if (!condition) {"], "callback": ["public static void isTrue(final String name, final boolean condition, final SingleResultCallback<?> callback) {", "            callback.onResult(null, exception);"]}
{"propertyName": ["public PropertyModelBuilder<?> getProperty(final String propertyName) {", "        notNull(\"propertyName\", propertyName);", "            if (propertyModelBuilder.getName().equals(propertyName)) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"c": ["    public static JavaWrapper getWrapperIfReflectionObject(final Class c) {", "        if (ReflectionDBObject.class.isAssignableFrom(c)) {", "            return getWrapper(c);"]}
{"c": ["public static JavaWrapper getWrapper(final Class c) {", "        JavaWrapper w = _wrappers.get(c);", "        if (w == null) {", "            w = new JavaWrapper(c);", "            _wrappers.put(c, w);", "        return w;"]}
{"Result": "Method without Parameter"}
{"uuidRepresentation": ["public UUID asUuid(final UuidRepresentation uuidRepresentation) {", "        Assertions.notNull(\"uuidRepresentation\", uuidRepresentation);", "        final byte uuidType = uuidRepresentation == UuidRepresentation.STANDARD", "        return UuidHelper.decodeBinaryToUuid(data.clone(), type, uuidRepresentation);"]}
{"name": ["protected Object parse(final String name) {", "                value = parseArray(name);", "                value = parseObject(name);", "        return value;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"needQuote": ["public String parseString(final boolean needQuote) {", "        } else if (needQuote) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"name": ["protected Object parseArray(final String name) {", "        if (name != null) {", "            _callback.arrayStart(name);"]}
{"update": ["public void updateOne(final DBObject update) {", "        bulkWriteOperation.addRequest(new UpdateRequest(query, update, false, upsert, queryCodec, collation, arrayFilters));"]}
{"connectionId": ["public ConnectionDescription withConnectionId(final ConnectionId connectionId) {", "        notNull(\"connectionId\", connectionId);", "        return new ConnectionDescription(connectionId, serverVersion, maxWireVersion, serverType, maxBatchCount, maxDocumentSize,"]}
{"count": ["public static WriteConcernResult acknowledged(final int count, final boolean isUpdateOfExisting, @Nullable final BsonValue upsertedId) {", "                return count;", "                if (count != that.getCount()) {", "                int result = count;", "                result = 31 * result + (isUpdateOfExisting ? 1 : 0);", "                       + \"count=\" + count"], "isUpdateOfExisting": ["public static WriteConcernResult acknowledged(final int count, final boolean isUpdateOfExisting, @Nullable final BsonValue upsertedId) {", "            public boolean isUpdateOfExisting() {", "                return isUpdateOfExisting;", "                if (isUpdateOfExisting != that.isUpdateOfExisting()) {", "                result = 31 * result + (isUpdateOfExisting ? 1 : 0);", "                       + \", isUpdateOfExisting=\" + isUpdateOfExisting"], "upsertedId": ["public static WriteConcernResult acknowledged(final int count, final boolean isUpdateOfExisting, @Nullable final BsonValue upsertedId) {", "                return upsertedId;", "                if (upsertedId != null ? !upsertedId.equals(that.getUpsertedId()) : that.getUpsertedId() != null) {", "                result = 31 * result + (upsertedId != null ? upsertedId.hashCode() : 0);", "                       + \", upsertedId=\" + upsertedId"]}
{"Result": "Method without Parameter"}
{"keys": ["    private <T> T getEmbeddedValue(final List<?> keys, final Class<T> clazz, final T defaultValue) {", "        Iterator<?> keyIterator = keys.iterator();"], "clazz": ["    private <T> T getEmbeddedValue(final List<?> keys, final Class<T> clazz, final T defaultValue) {", "        return clazz != null ? clazz.cast(value) : (T) value;"], "defaultValue": ["    private <T> T getEmbeddedValue(final List<?> keys, final Class<T> clazz, final T defaultValue) {", "                    return defaultValue;"]}
{"key": ["    private <T> List<T> constructValuesList(final Object key, final Class<T> clazz, final List<T> defaultValue) {", "        List<?> value = get(key, List.class);"], "clazz": ["    private <T> List<T> constructValuesList(final Object key, final Class<T> clazz, final List<T> defaultValue) {", "            if (!clazz.isAssignableFrom(item.getClass())) {", "                throw new ClassCastException(format(\"List element cannot be cast to %s\", clazz.getName()));"], "defaultValue": ["    private <T> List<T> constructValuesList(final Object key, final Class<T> clazz, final List<T> defaultValue) {", "            return defaultValue;"]}
{"options": ["public static TransactionOptions merge(final TransactionOptions options, final TransactionOptions defaultOptions) {", "        notNull(\"options\", options);", "                .writeConcern(options.getWriteConcern() == null", "                        ? defaultOptions.getWriteConcern() : options.getWriteConcern())", "                .readConcern(options.getReadConcern() == null", "                        ? defaultOptions.getReadConcern() : options.getReadConcern())", "                .readPreference(options.getReadPreference() == null", "                        ? defaultOptions.getReadPreference() : options.getReadPreference())"], "defaultOptions": ["public static TransactionOptions merge(final TransactionOptions options, final TransactionOptions defaultOptions) {", "        notNull(\"defaultOptions\", defaultOptions);", "                        ? defaultOptions.getWriteConcern() : options.getWriteConcern())", "                        ? defaultOptions.getReadConcern() : options.getReadConcern())", "                        ? defaultOptions.getReadPreference() : options.getReadPreference())"]}
{"t": ["    public void release(final T t, final boolean prune) {", "        if (t == null) {", "            close(t);", "            close(t);", "            available.addLast(t);"], "prune": ["    public void release(final T t, final boolean prune) {", "        if (prune) {"]}
{"timeout": ["    public T get(final long timeout, final TimeUnit timeUnit) {", "        if (!acquirePermit(timeout, timeUnit)) {", "            throw new MongoTimeoutException(String.format(\"Timeout waiting for a pooled item after %d %s\", timeout, timeUnit));"], "timeUnit": ["    public T get(final long timeout, final TimeUnit timeUnit) {", "        if (!acquirePermit(timeout, timeUnit)) {", "            throw new MongoTimeoutException(String.format(\"Timeout waiting for a pooled item after %d %s\", timeout, timeUnit));"]}
{"Result": "Method without Parameter"}
{"os": ["public int pipe(final OutputStream os) throws IOException {", "        WritableByteChannel channel = Channels.newChannel(os);", "        return channel.write(getBufferForInternalBytes());"]}
{"methodName": ["protected void throwInvalidContextType(final String methodName, final BsonContextType actualContextType,", "                                methodName, validContextTypesString, actualContextType);"], "actualContextType": ["protected void throwInvalidContextType(final String methodName, final BsonContextType actualContextType,", "        String message = format(\"%s can only be called when ContextType is %s, not when ContextType is %s.\",", "                                methodName, validContextTypesString, actualContextType);", "        throw new BsonInvalidOperationException(message);"]}
{"methodName": ["protected void throwInvalidState(final String methodName, final State... validStates) {", "                                methodName, validStatesString, state);"]}
{"methodName": ["protected void verifyBSONType(final String methodName, final BsonType requiredBsonType) {", "            throwInvalidState(methodName, State.VALUE);", "                                                           methodName, requiredBsonType, currentBsonType));"], "requiredBsonType": ["protected void verifyBSONType(final String methodName, final BsonType requiredBsonType) {", "        if (currentBsonType != requiredBsonType) {", "                                                           methodName, requiredBsonType, currentBsonType));"]}
{"expectedName": ["protected void verifyName(final String expectedName) {", "        if (!actualName.equals(expectedName)) {", "                                                        expectedName, actualName));"]}
{"methodName": ["protected void checkPreconditions(final String methodName, final BsonType type) {", "        verifyBSONType(methodName, type);"], "type": ["protected void checkPreconditions(final String methodName, final BsonType type) {", "        verifyBSONType(methodName, type);"]}
{"value": ["public static Decimal128 parse(final String value) {", "        String lowerCasedValue = value.toLowerCase();", "        return new Decimal128(new BigDecimal(value), value.charAt(0) == '-');"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"hint": ["public AggregateExplainOperation hint(final BsonValue hint) {"]}
{"Result": "Method without Parameter"}
{"file": ["public long writeTo(final File file) throws IOException {", "            out = new FileOutputStream(file);", "            return writeTo(out);", "            if (out != null) {", "                out.close();"]}
{"out": ["public long writeTo(final OutputStream out) throws IOException {", "            out.write(getChunk(i));"]}
{"Result": "Method without Parameter"}
{"sort": ["public PushOptions sort(@Nullable final Integer sort) {"]}
{"sortDocument": ["public PushOptions sortDocument(@Nullable final Bson sortDocument) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"fullDocumentClass": ["public static <TFullDocument> Codec<ChangeStreamDocument<TFullDocument>> createCodec(final Class<TFullDocument> fullDocumentClass,", "        return new ChangeStreamDocumentCodec<TFullDocument>(fullDocumentClass, codecRegistry);"], "codecRegistry": ["                                                                                         final CodecRegistry codecRegistry) {", "        return new ChangeStreamDocumentCodec<TFullDocument>(fullDocumentClass, codecRegistry);"]}
{"options": ["public static Builder builder(final ClientSessionOptions options) {", "        notNull(\"options\", options);", "        builder.causallyConsistent = options.isCausallyConsistent();", "        builder.defaultTransactionOptions = options.getDefaultTransactionOptions();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"serviceName": ["public static String getUserAgent(String serviceName, boolean allowTelemetry) {", "        return String.format(serviceName + \" MacAddressHash:%s\", macAddress);"], "allowTelemetry": ["public static String getUserAgent(String serviceName, boolean allowTelemetry) {", "        if (allowTelemetry) {"]}
{"environment": ["    private void populateProperties(ConfigurableEnvironment environment, VcapPojo[] pojos) {", "        addOrReplace(environment.getPropertySources(), map);"], "pojos": ["    private void populateProperties(ConfigurableEnvironment environment, VcapPojo[] pojos) {", "                findPojoForServiceType(VcapServiceType.AZURE_STORAGE, pojos));", "                findPojoForServiceType(VcapServiceType.AZURE_SERVICEBUS, pojos));", "                findPojoForServiceType(VcapServiceType.AZURE_DOCUMENTDB, pojos));"]}
{"node": ["private boolean isMatchingUserGroupKey(final JsonNode node) {", "        return node.get(aadAuthenticationProperties.getUserGroup().getKey()).asText()"]}
{"groups": ["public Set<GrantedAuthority> convertGroupsToGrantedAuthorities(final List<UserGroup> groups) {", "        final Set<GrantedAuthority> mappedAuthorities = groups.stream().filter(this::isValidUserGroupToGrantAuthority)"]}
{"environment": ["public ServiceEndpoints getServiceEndpoints(String environment) {", "        if (!endpoints.containsKey(environment)) {", "            throw new IllegalArgumentException(environment + \" is not found in the configuration,\" +", "        return endpoints.get(environment);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"path": ["public LiveReload register(final Path path, final String... includes) {", "    if (Files.exists(path)) {", "      paths.add(new Object[]{path, Arrays.asList(includes)});"]}
{"dist": ["public Map<String, List<File>> build(final String dist, final File dir) throws Exception {", "    log.debug(\"{} aggregators: {}\", dist, aggregators);", "    return buildInternal(dist, dir);"], "dir": ["public Map<String, List<File>> build(final String dist, final File dir) throws Exception {", "    return buildInternal(dist, dir);"]}
{"result": ["public String summary(Map<String, List<File>> result, Path outDir, String dist, long duration,", "    int w1 = result.keySet().stream()", "    int w2 = result.values().stream()", "    result.forEach((fileset, files) -> {"], "outDir": ["public String summary(Map<String, List<File>> result, Path outDir, String dist, long duration,", "    buffer.append(\"Output: \").append(outDir).append(\"\\n\");", "        .map(file -> outDir.relativize(file.toPath()).toString())", "        files.forEach(file -> buffer.append(format(mw1, w2, \"\", outDir.relativize(file.toPath()),"], "dist": ["public String summary(Map<String, List<File>> result, Path outDir, String dist, long duration,", "    buffer.append(\"Pipeline: \").append(pipeline(dist)).append(\"\\n\");"], "duration": ["public String summary(Map<String, List<File>> result, Path outDir, String dist, long duration,", "    long seconds = Duration.ofMillis(duration).getSeconds();", "    String took = seconds > 0 ? seconds + \"s\" : duration + \"ms\";"]}
{"dir": ["private void register(final Path dir) throws IOException {", "    WatchKey key = dir.register(watcher, new Kind[]{ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY }, HIGH);", "    keys.put(key, dir);"]}
{"name": ["public RamlType newProperty(String name, String type, boolean required, String... values) {", "      properties.put(required ? name : name + \"?\", ImmutableMap.of(\"enum\", values));", "      properties.put(required ? name : name + \"?\", type);"], "type": ["public RamlType newProperty(String name, String type, boolean required, String... values) {", "      properties.put(required ? name : name + \"?\", type);"], "required": ["public RamlType newProperty(String name, String type, boolean required, String... values) {", "      properties.put(required ? name : name + \"?\", ImmutableMap.of(\"enum\", values));", "      properties.put(required ? name : name + \"?\", type);"]}
{"name": ["public static RamlType valueOf(String name) {", "    switch (name.toLowerCase()) {", "    return new RamlType(\"object\", name);"]}
{"kind": ["public FileEventOptions kind(final WatchEvent.Kind<Path> kind) {"]}
{"callback": ["public Hbs doWith(final Consumer<Handlebars> callback) {", "    requireNonNull(callback, \"Configurer is required.\");", "    return doWith((hbs, conf) -> callback.accept(hbs));"]}
{"configurer": ["public Micrometer doWith(@Nonnull final Consumer<CompositeMeterRegistry> configurer) {", "    return doWith((registry, conf) -> configurer.accept(registry));"]}
{"callback": ["public Thl doWith(final Consumer<TemplateEngine> callback) {", "    requireNonNull(callback, \"Callback required.\");", "    return doWith((e, c) -> callback.accept(e));"]}
{"pattern": ["public Auth form(final String pattern,", "    bindings.put(pattern, (binder, conf) -> {"], "authenticator": ["      final Class<? extends Authenticator<UsernamePasswordCredentials>> authenticator) {", "      binder.bind(usernamePasswordAuthenticator.getRawType()).to(authenticator);"]}
{"pattern": ["public Auth basic(final String pattern,", "    bindings.put(pattern, (binder, config) -> {"], "authenticator": ["      final Class<? extends Authenticator<UsernamePasswordCredentials>> authenticator) {", "      binder.bind(usernamePasswordAuthenticator.getRawType()).to(authenticator);"]}
{"value": ["public void resolve(@Nullable final Object value) {", "    if (value == null) {", "      if (value instanceof Result) {", "        super.set(value);", "        result = (Result) value;", "        super.set(value);", "      handler.handle(result, null);"]}
{"pattern": ["public RamlPath path(String pattern) {", "    RamlPath path = resources.get(pattern);", "    if (path == null) {", "      resources.put(pattern, path);", "    return path;"]}
{"type": ["public RamlType define(Type type) {", "    Type componentType = componentType(type);", "    String typeName = MoreTypes.getRawType(componentType).getSimpleName();", "        Property property = converter.readAsProperty(componentType);", "        for (Map.Entry<String, Model> entry : converter.readAll(componentType).entrySet()) {", "          define(entry.getKey(), entry.getValue());", "        ramlType = define(typeName, PropertyBuilder.toModel(PropertyBuilder.merge(property, args)));", "    return type != componentType ? ramlType.toArray() : ramlType;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"status": ["public RouteResponse status(final Map<Integer, String> status) {"]}
{"mediaType": ["public void setMediaType(final String mediaType, RamlType body) {", "    if (this.mediaType == null) {", "    this.mediaType.put(mediaType, body);"], "body": ["public void setMediaType(final String mediaType, RamlType body) {", "    this.mediaType.put(mediaType, body);"]}
{"Result": "Method without Parameter"}
{"mediaType": ["public void setMediaType(final List<String> mediaType) {", "    this.mediaType = mediaType == null ? null : (mediaType.isEmpty() ? null : mediaType);"]}
{"name": ["public RamlParameter queryParameter(String name) {", "    RamlParameter param = queryParameters.get(name);", "    if (param == null) {", "      param = new RamlParameter(name);", "      queryParameters.put(name, param);", "    return param;"]}
{"name": ["public RamlParameter formParameter(String name) {", "    RamlParameter param = formParameters.get(name);", "    if (param == null) {", "      param = new RamlParameter(name);", "      formParameters.put(name, param);", "    return param;"]}
{"name": ["public RamlParameter headerParameter(String name) {", "    RamlParameter param = headers.get(name);", "    if (param == null) {", "      param = new RamlParameter(name);", "      headers.put(name, param);", "    return param;"]}
{"status": ["public RamlResponse response(Integer status) {", "    RamlResponse response = responses.get(status);", "    if (response == null) {", "      responses.put(status, response);", "    return response;"]}
{"configurer": ["public Hbv doWith(final Consumer<HibernateValidatorConfiguration> configurer) {", "    requireNonNull(configurer, \"Configurer callback is required.\");", "    this.configurer = (hvc, conf) -> configurer.accept(hvc);"]}
{"b": ["  public int read(final byte[] b, int off, int len) throws IOException {", "        encoderOut.get(b, off, c);"], "off": ["  public int read(final byte[] b, int off, int len) throws IOException {", "        encoderOut.get(b, off, c);"], "len": ["  public int read(final byte[] b, int off, int len) throws IOException {", "    while (len > 0) {", "        int c = Math.min(encoderOut.remaining(), len);", "        encoderOut.get(b, off, c);", "        off += c;", "        len -= c;", "        read += c;", "          int c = reader.read(encoderIn.array(), position, encoderIn.remaining());", "          if (c == -1) {", "            encoderIn.position(position + c);", "    return read == 0 && endOfInput ? -1 : read;"]}
{"name": ["public static Requery reactive(final String name, final EntityModel model) {", "    return new Requery(name, ReactiveEntityStore.class, model,"], "model": ["public static Requery reactive(final String name, final EntityModel model) {", "    return new Requery(name, ReactiveEntityStore.class, model,"]}
{"name": ["public static Requery reactor(final String name, final EntityModel model) {", "    return new Requery(name, ReactorEntityStore.class, model,"], "model": ["public static Requery reactor(final String name, final EntityModel model) {", "    return new Requery(name, ReactorEntityStore.class, model,"]}
{"name": ["public static Requery completionStage(final String name, final EntityModel model) {", "    return new Requery(name, CompletionStageEntityStore.class, model,"], "model": ["public static Requery completionStage(final String name, final EntityModel model) {", "    return new Requery(name, CompletionStageEntityStore.class, model,"]}
{"name": ["public static Requery kotlin(final String name, final EntityModel model) {", "    return new Requery(name, KotlinEntityDataStore.class, model,"], "model": ["public static Requery kotlin(final String name, final EntityModel model) {", "    return new Requery(name, KotlinEntityDataStore.class, model,"]}
{"type": ["public XSS js(final JavaScriptEscapeType type, final JavaScriptEscapeLevel level) {", "    this.jstype = requireNonNull(type, \"Type required.\");"], "level": ["public XSS js(final JavaScriptEscapeType type, final JavaScriptEscapeLevel level) {", "    this.jslevel = requireNonNull(level, \"Level required.\");"]}
{"type": ["public XSS html(final HtmlEscapeType type, final HtmlEscapeLevel level) {", "    this.htmltype = requireNonNull(type, \"Type required.\");"], "level": ["public XSS html(final HtmlEscapeType type, final HtmlEscapeLevel level) {", "    this.htmllevel = requireNonNull(level, \"Level required.\");"]}
{"type": ["public XSS json(final JsonEscapeType type, final JsonEscapeLevel level) {", "    this.jsontype = requireNonNull(type, \"Type required.\");"], "level": ["public XSS json(final JsonEscapeType type, final JsonEscapeLevel level) {", "    this.jsonlevel = requireNonNull(level, \"Level required.\");"]}
{"type": ["public XSS css(final CssStringEscapeType type, final CssStringEscapeLevel level) {", "    this.csstype = requireNonNull(type, \"Type required.\");"], "level": ["public XSS css(final CssStringEscapeType type, final CssStringEscapeLevel level) {", "    this.csslevel = requireNonNull(level, \"Level required.\");"]}
{"path": ["private Map<String, Object> attrs(final String path, final String... without) {", "    Map<String, Object> attrs = new LinkedHashMap<>(get(path));", "    Arrays.asList(without).forEach(attrs::remove);", "    return attrs;"]}
{"id": ["private CharSequence css(final String id, final Element svg) {", "    css.append(get(\"css.prefix\").toString()).append(\".\").append(id)"], "svg": ["private CharSequence css(final String id, final Element svg) {", "          String vbox = svg.attr(name);", "    Tuple<Number, String> w = Optional.ofNullable(Strings.emptyToNull(svg.attr(\"width\")))", "    Tuple<Number, String> h = Optional.ofNullable(Strings.emptyToNull(svg.attr(\"height\")))"]}
{"value": ["private Tuple<Number, String> parse(final String value) {", "    Matcher matcher = SIZE.matcher(value);", "    if (matcher.find()) {", "      String number = matcher.group(1);", "      String unit = matcher.group(_3);"]}
{"path": ["private void write(final Path path, final List<CharSequence> sequence) throws IOException {", "    log.debug(\"writing: {}\", path.normalize().toAbsolutePath());", "    path.toFile().getParentFile().mkdirs();", "    Files.write(path, sequence);"], "sequence": ["private void write(final Path path, final List<CharSequence> sequence) throws IOException {", "    Files.write(path, sequence);"]}
{"name": ["public TransactionalRequest handle(String name) {", "    this.handleKey = Key.get(Handle.class, Names.named(name));"]}
{"type": ["private Model doModel(Type type, Model model) {", "      BeanDescription desc = Json.mapper().getSerializationConfig()", "          .introspect(Json.mapper().constructType(type));", "      for (BeanPropertyDefinition beanProperty : desc.findProperties()) {", "        Property property = properties.get(beanProperty.getName());", "        if (property != null) {", "          property.setRequired(beanProperty.isRequired());"], "model": ["private Model doModel(Type type, Model model) {", "    Map<String, Property> properties = model.getProperties();", "    return model;"]}
{"type": ["  public <T> Optional<T> lastEventId(final Class<T> type) {", "    return lastEventId.toOptional(type);"]}
{"data": ["  public CompletableFuture<Optional<Object>> send(final Object data) {", "    return event(data).send();"]}
{"name": ["  public View put(final String name, final Object value) {", "    requireNonNull(name, \"Model name is required.\");", "    model.put(name, value);"], "value": ["  public View put(final String name, final Object value) {", "    model.put(name, value);"]}
{"values": ["  public View put(final Map<String, ?> values) {", "    values.forEach((k, v) -> model.put(k, v));"]}
{"parent": ["public static ClassLoader classLoader(final ClassLoader parent) throws IOException {", "    return classLoader(parent, new File(System.getProperty(\"user.dir\")));"]}
{"parent": ["public static ClassLoader classLoader(final ClassLoader parent, File projectDir) throws IOException {", "    requireNonNull(parent, \"ClassLoader required.\");", "      return new URLClassLoader(new URL[]{publicDir.toURI().toURL()}, parent);", "    return parent;"], "projectDir": ["public static ClassLoader classLoader(final ClassLoader parent, File projectDir) throws IOException {", "    File publicDir = new File(projectDir, \"public\");"]}
{"attributes": ["public RouteMethod attributes(Map<String, Object> attributes) {"]}
{"name": ["public RouteMethod attribute(String name, Object value) {", "    this.attributes.put(name, value);"], "value": ["public RouteMethod attribute(String name, Object value) {", "    this.attributes.put(name, value);"]}
{"name": ["public RouteMethod param(String name, Consumer<RouteParameter> customizer) {", "        .filter(p -> name.equals(p.name()))"], "customizer": ["public RouteMethod param(String name, Consumer<RouteParameter> customizer) {", "        .ifPresent(customizer);"]}
{"statusCode": ["public static Status valueOf(final int statusCode) {", "    Integer key = Integer.valueOf(statusCode);", "    Status status = statusMap.get(key);", "    return status == null? new Status(key, key.toString()) : status;"]}
{"configurer": ["public Jdbi3 doWith(Consumer<Jdbi> configurer) {", "    return doWith((jdbi, conf) -> configurer.accept(jdbi));"]}
{"sql": ["  public RewrittenStatement rewrite(final String sql, final Binding params,", "      final String parsedSql = parseString(sql, stmt, params);"], "params": ["  public RewrittenStatement rewrite(final String sql, final Binding params,", "      final String parsedSql = parseString(sql, stmt, params);", "      return new MyRewrittenStatement(parsedSql, stmt, ctx);"], "ctx": ["      final StatementContext ctx)", "      return new MyRewrittenStatement(parsedSql, stmt, ctx);", "          \"Exception parsing for named parameter replacement\", e, ctx);"]}
{"req": [], "rsp": ["protected void send(final Request req, final Response rsp, final Asset asset) throws Throwable {", "    rsp.send(asset);"], "asset": ["protected void send(final Request req, final Response rsp, final Asset asset) throws Throwable {", "    rsp.send(asset);"]}
{"configurer": ["public Jdbi doWith(Consumer<DBI> configurer) {", "    return doWith((dbi, conf) -> configurer.accept(dbi));"]}
{"configurer": ["public jOOQ doWith(Consumer<Configuration> configurer) {", "    return doWith((configuration, conf) -> configurer.accept(configuration));"]}
{"job": ["public Quartz with(final JobDetail job, final Trigger trigger) {", "    requireNonNull(job, \"Job is required.\");", "    jobMap.put(job, trigger);"], "trigger": ["public Quartz with(final JobDetail job, final Trigger trigger) {", "    requireNonNull(trigger, \"Trigger is required.\");", "    jobMap.put(job, trigger);"]}
{"jobClass": ["public Quartz with(final Class<? extends Job> jobClass,", "    requireNonNull(jobClass, \"Job class is required.\");", "    JobBuilder job = JobBuilder.newJob(jobClass)", "            JobKey.jobKey(jobClass.getSimpleName(), jobClass.getPackage().getName())", "            TriggerKey.triggerKey(jobClass.getSimpleName(), jobClass.getPackage().getName())"], "configurer": ["      final BiConsumer<JobBuilder, TriggerBuilder<Trigger>> configurer) {", "    configurer.accept(job, trigger);"]}
{"iterator": ["private void shutdownGracefully(final Iterator<EventExecutorGroup> iterator) {", "    if (iterator.hasNext()) {", "      EventExecutorGroup group = iterator.next();", "          shutdownGracefully(iterator);"]}
{"configurer": ["public Cassandra doWithCluster(final Consumer<Cluster> configurer) {", "    requireNonNull(configurer, \"Cluster conf callbackrequired.\");", "    return doWithCluster((cc, c) -> configurer.accept(cc));"]}
{"status": ["  public static Result with(final Status status) {", "    requireNonNull(status, \"A HTTP status is required.\");", "    return new Result().status(status);"]}
{"module": ["public Jackson module(final Module module) {"]}
{"provider": ["public Pac4j unauthenticated(Supplier<UserProfile> provider) {", "    requireNonNull(provider, \"Unauthenticated provider required.\");", "    return unauthenticated(req -> provider.get());"]}
{"pattern": ["public Pac4j form(String pattern) {", "    return clientInternal(pattern, conf -> {"]}
{"application": ["public List<RouteMethod> parse(String application) throws Exception {", "    return new BytecodeRouteParser(loader, dir).parse(application).stream()"]}
{"type": ["public Scanner scan(final Class<?> type) {", "    if (type == Named.class || type == com.google.inject.name.Named.class) {", "    } else if (type == Singleton.class || type == com.google.inject.Singleton.class) {", "      serviceTypes.add(type);"]}
{"path": ["public ApiTool swagger(String path, Consumer<Swagger> swagger) {", "    return swagger(new Options(path, options), swagger);"], "swagger": ["public ApiTool swagger(String path, Consumer<Swagger> swagger) {"]}
{"options": ["public ApiTool swagger(Options options, Consumer<Swagger> swagger) {", "    this.swaggerOptions = Objects.requireNonNull(options, \"Options required.\");"], "swagger": ["public ApiTool swagger(Options options, Consumer<Swagger> swagger) {"]}
{"path": ["public ApiTool raml(String path, Consumer<Raml> raml) {", "    return raml(new Options(path, options), raml);"], "raml": ["public ApiTool raml(String path, Consumer<Raml> raml) {"]}
{"options": ["public ApiTool raml(Options options, Consumer<Raml> raml) {", "    this.ramlOptions = Objects.requireNonNull(options, \"Options required.\");"], "raml": ["public ApiTool raml(Options options, Consumer<Raml> raml) {"]}
{"filename": ["public String process(String filename, String source, Config conf) throws Exception {", "    return process(filename, source, conf, getClass().getClassLoader());"], "source": ["public String process(String filename, String source, Config conf) throws Exception {", "    return process(filename, source, conf, getClass().getClassLoader());"], "conf": ["public String process(String filename, String source, Config conf) throws Exception {", "    return process(filename, source, conf, getClass().getClassLoader());"]}
{"result": []}
{"result": []}
{"result": []}
{"result": []}
{"result": []}
{"result": []}
{"factory": ["    private org.apache.axiom.soap.SOAPEnvelope toEnvelope(final org.apache.axiom.soap.SOAPFactory factory) {", "        return factory.getDefaultEnvelope();"]}
{"env": ["private java.util.Map getEnvelopeNamespaces(final org.apache.axiom.soap.SOAPEnvelope env) {\r", "        final java.util.Iterator namespaceIterator = env.getAllDeclaredNamespaces();\r"]}
{"result": []}
{"lote": ["NFLoteEnvio getLoteAssinado(final NFLoteEnvio lote) throws Exception {", "        for (final NFNota nota : lote.getNotas()) {", "            final NFGeraChave geraChave = new NFGeraChave(nota);", "            nota.getInfo().getIdentificacao().setCodigoRandomico(StringUtils.defaultIfBlank(nota.getInfo().getIdentificacao().getCodigoRandomico(), geraChave.geraCodigoRandomico()));", "            nota.getInfo().getIdentificacao().setDigitoVerificador(geraChave.getDV());", "            nota.getInfo().setIdentificador(geraChave.getChaveAcesso());", "        final String documentoAssinado = new AssinaturaDigital(this.config).assinarDocumento(lote.toString());"]}
{"lote": ["public NFLoteEnvioRetornoDados enviaLote(final NFLoteEnvio lote) throws Exception {", "        if (lote.getIndicadorProcessamento().equals(NFLoteIndicadorProcessamento.PROCESSAMENTO_SINCRONO) && lote.getNotas().size() > 1) {", "        } else if (lote.getNotas().size() == 0) {", "        return this.wsLoteEnvio.enviaLote(lote);"]}
{"uf": ["public NFStatusServicoConsultaRetorno consultaStatus(final DFUnidadeFederativa uf, final DFModelo modelo) throws Exception {", "        return this.wsStatusConsulta.consultaStatus(uf, modelo);"], "modelo": ["public NFStatusServicoConsultaRetorno consultaStatus(final DFUnidadeFederativa uf, final DFModelo modelo) throws Exception {", "        return this.wsStatusConsulta.consultaStatus(uf, modelo);"]}
{"chaveDeAcesso": ["public NFEnviaEventoRetorno corrigeNota(final String chaveDeAcesso, final String textoCorrecao, final int numeroSequencialEvento) throws Exception {", "        return this.wsCartaCorrecao.corrigeNota(chaveDeAcesso, textoCorrecao, numeroSequencialEvento);"], "textoCorrecao": ["public NFEnviaEventoRetorno corrigeNota(final String chaveDeAcesso, final String textoCorrecao, final int numeroSequencialEvento) throws Exception {", "        return this.wsCartaCorrecao.corrigeNota(chaveDeAcesso, textoCorrecao, numeroSequencialEvento);"], "numeroSequencialEvento": ["public NFEnviaEventoRetorno corrigeNota(final String chaveDeAcesso, final String textoCorrecao, final int numeroSequencialEvento) throws Exception {", "        return this.wsCartaCorrecao.corrigeNota(chaveDeAcesso, textoCorrecao, numeroSequencialEvento);"]}
{"chave": ["public NFEnviaEventoRetorno cancelaNota(final String chave, final String numeroProtocolo, final String motivo) throws Exception {", "        return this.wsCancelamento.cancelaNota(chave, numeroProtocolo, motivo);"], "numeroProtocolo": ["public NFEnviaEventoRetorno cancelaNota(final String chave, final String numeroProtocolo, final String motivo) throws Exception {", "        return this.wsCancelamento.cancelaNota(chave, numeroProtocolo, motivo);"], "motivo": ["public NFEnviaEventoRetorno cancelaNota(final String chave, final String numeroProtocolo, final String motivo) throws Exception {", "        return this.wsCancelamento.cancelaNota(chave, numeroProtocolo, motivo);"]}
{"anoInutilizacaoNumeracao": ["public NFRetornoEventoInutilizacao inutilizaNota(final int anoInutilizacaoNumeracao, final String cnpjEmitente, final String serie, final String numeroInicial, final String numeroFinal, final String justificativa, final DFModelo modelo) throws Exception {", "        return this.wsInutilizacao.inutilizaNota(anoInutilizacaoNumeracao, cnpjEmitente, serie, numeroInicial, numeroFinal, justificativa, modelo);"], "cnpjEmitente": ["public NFRetornoEventoInutilizacao inutilizaNota(final int anoInutilizacaoNumeracao, final String cnpjEmitente, final String serie, final String numeroInicial, final String numeroFinal, final String justificativa, final DFModelo modelo) throws Exception {", "        return this.wsInutilizacao.inutilizaNota(anoInutilizacaoNumeracao, cnpjEmitente, serie, numeroInicial, numeroFinal, justificativa, modelo);"], "serie": ["public NFRetornoEventoInutilizacao inutilizaNota(final int anoInutilizacaoNumeracao, final String cnpjEmitente, final String serie, final String numeroInicial, final String numeroFinal, final String justificativa, final DFModelo modelo) throws Exception {", "        return this.wsInutilizacao.inutilizaNota(anoInutilizacaoNumeracao, cnpjEmitente, serie, numeroInicial, numeroFinal, justificativa, modelo);"], "numeroInicial": ["public NFRetornoEventoInutilizacao inutilizaNota(final int anoInutilizacaoNumeracao, final String cnpjEmitente, final String serie, final String numeroInicial, final String numeroFinal, final String justificativa, final DFModelo modelo) throws Exception {", "        return this.wsInutilizacao.inutilizaNota(anoInutilizacaoNumeracao, cnpjEmitente, serie, numeroInicial, numeroFinal, justificativa, modelo);"], "numeroFinal": ["public NFRetornoEventoInutilizacao inutilizaNota(final int anoInutilizacaoNumeracao, final String cnpjEmitente, final String serie, final String numeroInicial, final String numeroFinal, final String justificativa, final DFModelo modelo) throws Exception {", "        return this.wsInutilizacao.inutilizaNota(anoInutilizacaoNumeracao, cnpjEmitente, serie, numeroInicial, numeroFinal, justificativa, modelo);"], "justificativa": ["public NFRetornoEventoInutilizacao inutilizaNota(final int anoInutilizacaoNumeracao, final String cnpjEmitente, final String serie, final String numeroInicial, final String numeroFinal, final String justificativa, final DFModelo modelo) throws Exception {", "        return this.wsInutilizacao.inutilizaNota(anoInutilizacaoNumeracao, cnpjEmitente, serie, numeroInicial, numeroFinal, justificativa, modelo);"], "modelo": ["public NFRetornoEventoInutilizacao inutilizaNota(final int anoInutilizacaoNumeracao, final String cnpjEmitente, final String serie, final String numeroInicial, final String numeroFinal, final String justificativa, final DFModelo modelo) throws Exception {", "        return this.wsInutilizacao.inutilizaNota(anoInutilizacaoNumeracao, cnpjEmitente, serie, numeroInicial, numeroFinal, justificativa, modelo);"]}
{"cnpj": ["public NFRetornoConsultaCadastro consultaCadastro(final String cnpj, final DFUnidadeFederativa uf) throws Exception {", "        return this.wsConsultaCadastro.consultaCadastro(cnpj, uf);"], "uf": ["public NFRetornoConsultaCadastro consultaCadastro(final String cnpj, final DFUnidadeFederativa uf) throws Exception {", "        return this.wsConsultaCadastro.consultaCadastro(cnpj, uf);"]}
{"result": []}
{"result": []}
{"chaveAcesso": ["public String getXmlAssinado(final String chaveAcesso, final String textoCorrecao, final int numeroSequencialEvento) throws Exception {", "        final String cartaCorrecaoXML = this.gerarDadosCartaCorrecao(chaveAcesso, textoCorrecao, numeroSequencialEvento).toString();"], "textoCorrecao": ["public String getXmlAssinado(final String chaveAcesso, final String textoCorrecao, final int numeroSequencialEvento) throws Exception {", "        final String cartaCorrecaoXML = this.gerarDadosCartaCorrecao(chaveAcesso, textoCorrecao, numeroSequencialEvento).toString();"], "numeroSequencialEvento": ["public String getXmlAssinado(final String chaveAcesso, final String textoCorrecao, final int numeroSequencialEvento) throws Exception {", "        final String cartaCorrecaoXML = this.gerarDadosCartaCorrecao(chaveAcesso, textoCorrecao, numeroSequencialEvento).toString();"]}
{"result": []}
{"chave": ["public CTeRetornoCancelamento cancelaNota(final String chave, final String numeroProtocolo, final String motivo) throws Exception {", "        return this.wsCancelamento.cancelaNota(chave, numeroProtocolo, motivo);"], "numeroProtocolo": ["public CTeRetornoCancelamento cancelaNota(final String chave, final String numeroProtocolo, final String motivo) throws Exception {", "        return this.wsCancelamento.cancelaNota(chave, numeroProtocolo, motivo);"], "motivo": ["public CTeRetornoCancelamento cancelaNota(final String chave, final String numeroProtocolo, final String motivo) throws Exception {", "        return this.wsCancelamento.cancelaNota(chave, numeroProtocolo, motivo);"]}
{"result": []}
{"result": []}
{"chave": ["public MDFeRetorno cancelaMdfe(final String chave, final String numeroProtocolo, final String motivo) throws Exception {", "        return this.wsCancelamento.cancelaNota(chave, numeroProtocolo, motivo);"], "numeroProtocolo": ["public MDFeRetorno cancelaMdfe(final String chave, final String numeroProtocolo, final String motivo) throws Exception {", "        return this.wsCancelamento.cancelaNota(chave, numeroProtocolo, motivo);"], "motivo": ["public MDFeRetorno cancelaMdfe(final String chave, final String numeroProtocolo, final String motivo) throws Exception {", "        return this.wsCancelamento.cancelaNota(chave, numeroProtocolo, motivo);"]}
{"chaveAcesso": ["public MDFeRetorno encerramento(final String chaveAcesso, final String numeroProtocolo,", "        return this.wsEncerramento.encerraMdfe(chaveAcesso, numeroProtocolo, codigoMunicipio, dataEncerramento, unidadeFederativa);"], "numeroProtocolo": ["public MDFeRetorno encerramento(final String chaveAcesso, final String numeroProtocolo,", "        return this.wsEncerramento.encerraMdfe(chaveAcesso, numeroProtocolo, codigoMunicipio, dataEncerramento, unidadeFederativa);"], "codigoMunicipio": ["            final String codigoMunicipio, final LocalDate dataEncerramento, final DFUnidadeFederativa unidadeFederativa) throws Exception {", "        return this.wsEncerramento.encerraMdfe(chaveAcesso, numeroProtocolo, codigoMunicipio, dataEncerramento, unidadeFederativa);"], "dataEncerramento": ["            final String codigoMunicipio, final LocalDate dataEncerramento, final DFUnidadeFederativa unidadeFederativa) throws Exception {", "        return this.wsEncerramento.encerraMdfe(chaveAcesso, numeroProtocolo, codigoMunicipio, dataEncerramento, unidadeFederativa);"], "unidadeFederativa": ["            final String codigoMunicipio, final LocalDate dataEncerramento, final DFUnidadeFederativa unidadeFederativa) throws Exception {", "        return this.wsEncerramento.encerraMdfe(chaveAcesso, numeroProtocolo, codigoMunicipio, dataEncerramento, unidadeFederativa);"]}
{"chaveAcesso": ["public MDFeRetorno encerramentoAssinado(final String chaveAcesso, final String eventoAssinadoXml) throws Exception {", "        return this.wsEncerramento.encerramentoMdfeAssinado(chaveAcesso, eventoAssinadoXml);"], "eventoAssinadoXml": ["public MDFeRetorno encerramentoAssinado(final String chaveAcesso, final String eventoAssinadoXml) throws Exception {", "        return this.wsEncerramento.encerramentoMdfeAssinado(chaveAcesso, eventoAssinadoXml);"]}
{"result": []}
{"omElement": ["private OMElement efetuaConsultaStatusBahia(final OMElement omElement) throws RemoteException {", "        dados.setExtraElement(omElement);"]}
{"solver": ["public static float[] computeUpdatedXu(Solver solver,", "    double[] dXu = solver.solveDToD(dQuiYi);"], "value": ["                                         double value,", "    double targetQui = computeTargetQui(implicit, value, noXu ? 0.5 : Qui);"], "Xu": ["                                         float[] Xu,", "    boolean noXu = Xu == null;", "    double Qui = noXu ? 0.0 : VectorMath.dot(Xu, Yi);", "    float[] newXu = noXu ? new float[dXu.length] : Xu.clone();"], "Yi": ["                                         float[] Yi,", "    if (Yi == null) {", "    double Qui = noXu ? 0.0 : VectorMath.dot(Xu, Yi);", "    double targetQui = computeTargetQui(implicit, value, noXu ? 0.5 : Qui);", "    if (Double.isNaN(targetQui)) {", "    double dQui = targetQui - Qui;", "    double[] dQuiYi = new double[Yi.length];", "    for (int i = 0; i < dQuiYi.length; i++) {", "      dQuiYi[i] = Yi[i] * dQui;", "    double[] dXu = solver.solveDToD(dQuiYi);", "    float[] newXu = noXu ? new float[dXu.length] : Xu.clone();", "    for (int i = 0; i < newXu.length; i++) {", "      newXu[i] += dXu[i];", "    return newXu;"], "implicit": ["                                         boolean implicit) {", "    double targetQui = computeTargetQui(implicit, value, noXu ? 0.5 : Qui);"]}
{"x": ["public static double cosineSimilarity(float[] x, float[] y, double normY) {", "    int length = x.length;", "      double xi = x[i];", "      totalXSq += xi * xi;", "      dot += xi * y[i];", "    return dot / (Math.sqrt(totalXSq) * normY);"], "y": ["public static double cosineSimilarity(float[] x, float[] y, double normY) {", "      dot += xi * y[i];", "    return dot / (Math.sqrt(totalXSq) * normY);"], "normY": ["public static double cosineSimilarity(float[] x, float[] y, double normY) {", "    return dot / (Math.sqrt(totalXSq) * normY);"]}
{"Result": "Method without Parameter"}
{"rootDir": ["public static void deleteRecursively(Path rootDir) throws IOException {", "    if (rootDir == null || !Files.exists(rootDir)) {", "    Files.walkFileTree(rootDir, new SimpleFileVisitor<Path>() {"]}
{"implClassName": ["public static <T> T loadInstanceOf(String implClassName,", "      Class<? extends T> configClass = loadClass(implClassName, superClass);"], "superClass": ["                                     Class<T> superClass,", "      Class<? extends T> configClass = loadClass(implClassName, superClass);", "      Constructor<? extends T> constructor = configClass.getConstructor(constructorTypes);", "      throw new IllegalArgumentException(\"No valid \" + superClass + \" binding exists\", e);", "      throw new IllegalStateException(\"Could not instantiate \" + superClass + \" due to exception\","], "constructorTypes": ["                                     Class<?>[] constructorTypes,", "      Constructor<? extends T> constructor = configClass.getConstructor(constructorTypes);", "      return constructor.newInstance(constructorArgs);"], "constructorArgs": ["                                     Object[] constructorArgs) {", "      return constructor.newInstance(constructorArgs);"]}
{"sparkContext": [], "pmml": [], "newData": [], "pastData": [], "modelParentPath": [], "modelUpdateTopic": []}
{"context": ["            final Context context,", "        final String packageName = getPackageNameToUse(context);", "        if (packageName != null) {", "                    customTabsIntent.intent.setPackage(packageName);", "                    customTabsIntent.launchUrl(context, uri);", "            CustomTabsClient.bindCustomTabsService(context, packageName, connection);", "            fallback.openUri(context, uri);"], "customTabsIntent": ["            final CustomTabsIntent customTabsIntent,", "                    customTabsIntent.intent.setPackage(packageName);", "                    customTabsIntent.intent.setData(uri);", "                    customTabsIntent.launchUrl(context, uri);"], "uri": ["            final Uri uri,", "                    customTabsIntent.intent.setData(uri);", "                    customTabsIntent.launchUrl(context, uri);", "            fallback.openUri(context, uri);"], "fallback": ["            CustomTabFallback fallback) {", "        } else if (fallback != null) {", "            fallback.openUri(context, uri);"]}
{"context": ["    public String getPackageNameToUse(Context context) {", "        PackageManager pm = context.getPackageManager();", "                && !hasSpecializedHandlerIntents(context, activityIntent)"]}
{"context": ["private boolean hasSpecializedHandlerIntents(Context context, Intent intent) {", "            PackageManager pm = context.getPackageManager();"], "intent": ["private boolean hasSpecializedHandlerIntents(Context context, Intent intent) {", "                    intent,"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"configuration": ["private void validateConfiguration(SessionConfiguration configuration) {", "        checkNotNull(configuration, String.format(nullError, \"SessionConfiguration\"));", "        checkNotNull(configuration.getClientId(), String.format(nullError, \"Client ID\"));", "        checkNotNull(configuration.getRedirectUri(), String.format(nullError, \"Redirect URI\"));", "        checkState(!configuration.getClientId().equals(\"insert_your_client_id_here\"),", "        checkState(!configuration.getRedirectUri().equals(\"insert_your_redirect_uri_here\"),"]}
{"context": ["public static Intent newResponseIntent(Context context, Uri responseUri) {", "        Intent intent = new Intent(context, LoginActivity.class);"], "responseUri": ["public static Intent newResponseIntent(Context context, Uri responseUri) {", "        intent.setData(responseUri);"]}
{"configurationHandler": ["public boolean editMap(ConfigurationHandler configurationHandler) {", "        String method = configurationHandler.getMethod().toUpperCase();", "            configurationHandlerMap.put(Method.valueOf(method), configurationHandler);"]}
{"args": ["public static void main(String[] args) {", "        if(args.length!=1) {", "        final SampleFramework framework = new SampleFramework(taskQueue, args[0], // mesos master location string"]}
{"Result": "Method without Parameter"}
{"taskRequest": [], "targetVM": ["    public Result evaluate(TaskRequest taskRequest, VirtualMachineCurrentState targetVM, TaskTrackerState taskTrackerState) {", "        Collection<TaskRequest> runningTasks = targetVM.getRunningTasks();", "        Collection<TaskAssignmentResult> tasksCurrentlyAssigned = targetVM.getTasksCurrentlyAssigned();"], "taskTrackerState": []}
{"taskRequest": ["    public Result evaluate(TaskRequest taskRequest, VirtualMachineCurrentState targetVM, TaskTrackerState taskTrackerState) {", "        String requiredAttrVal = hostAttributeValueGetter.call(taskRequest.getId());"], "targetVM": ["    public Result evaluate(TaskRequest taskRequest, VirtualMachineCurrentState targetVM, TaskTrackerState taskTrackerState) {", "        String targetHostAttrVal = getAttrValue(targetVM.getCurrAvailableResources());", "            return new Result(false, hostAttributeName + \" attribute unavailable on host \" + targetVM.getCurrAvailableResources().hostname());"], "taskTrackerState": []}
{"taskRequest": ["    public Result evaluate(TaskRequest taskRequest, VirtualMachineCurrentState targetVM, TaskTrackerState taskTrackerState) {", "        Set<String> coTasks = coTasksGetter.call(taskRequest.getId());"], "targetVM": ["    public Result evaluate(TaskRequest taskRequest, VirtualMachineCurrentState targetVM, TaskTrackerState taskTrackerState) {", "        String targetHostAttrVal = AttributeUtilities.getAttrValue(targetVM.getCurrAvailableResources(), hostAttributeName);", "            return new Result(false, hostAttributeName + \" attribute unavailable on host \" + targetVM.getCurrAvailableResources().hostname());"], "taskTrackerState": ["    public Result evaluate(TaskRequest taskRequest, VirtualMachineCurrentState targetVM, TaskTrackerState taskTrackerState) {", "            TaskTracker.ActiveTask activeTask = taskTrackerState.getAllRunningTasks().get(coTask);", "            if(activeTask==null)", "                activeTask = taskTrackerState.getAllCurrentlyAssignedTasks().get(coTask);", "            if(activeTask!=null) {", "                String usedAttrVal = AttributeUtilities.getAttrValue(activeTask.getTotalLease(), hostAttributeName);", "                if(usedAttrVal==null || usedAttrVal.isEmpty())", "                    return new Result(false, hostAttributeName+\" attribute unavailable on host \" + activeTask.getTotalLease().hostname() +", "                if(usedAttrVal.equals(targetHostAttrVal)) {"]}
{"callback": ["public void setAutoscalerCallback(Action1<AutoScaleAction> callback) throws IllegalStateException {\r", "        autoScaler.setCallback(callback);\r"]}
{"hostname": ["public void disableVM(String hostname, long durationMillis) throws IllegalStateException {\r", "        logger.debug(\"Disable VM \" + hostname + \" for \" + durationMillis + \" millis\");\r", "        assignableVMs.disableUntil(hostname, System.currentTimeMillis() + durationMillis);\r"], "durationMillis": ["public void disableVM(String hostname, long durationMillis) throws IllegalStateException {\r", "        logger.debug(\"Disable VM \" + hostname + \" for \" + durationMillis + \" millis\");\r", "        assignableVMs.disableUntil(hostname, System.currentTimeMillis() + durationMillis);\r"]}
{"vmID": ["public boolean disableVMByVMId(String vmID, long durationMillis) throws IllegalStateException {\r", "        final String hostname = assignableVMs.getHostnameFromVMId(vmID);\r", "        if (hostname == null) {\r", "        disableVM(hostname, durationMillis);\r"], "durationMillis": ["public boolean disableVMByVMId(String vmID, long durationMillis) throws IllegalStateException {\r", "        disableVM(hostname, durationMillis);\r"]}
{"hostname": ["public void enableVM(String hostname) throws IllegalStateException {\r", "        logger.debug(\"Enabling VM \" + hostname);\r", "        assignableVMs.enableVM(hostname);\r"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"source": ["public static Demo.CDemoFileInfo infoForSource(final Source source) throws IOException {\r", "        EngineType engineType = source.readEngineType();\r", "        source.setPosition(source.readFixedInt32());\r", "        PacketInstance<GeneratedMessage> pi = engineType.getNextPacketInstance(source);\r", "        return (Demo.CDemoFileInfo) pi.parse();\r"]}
{"stream": ["private static S2DotaMatchMetadata.CDOTAMatchMetadataFile metadataForStream(InputStream stream) throws IOException {\r", "        return Packet.parse(S2DotaMatchMetadata.CDOTAMatchMetadataFile.class, ByteString.readFrom(stream));\r"]}
{"source": ["private byte[] readPacket(Source source) throws IOException {", "        int size = source.readFixedInt32();", "        return packetReader.readFromSource(source, size, false);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"child": ["public ContainerTag with(DomContent child) {", "        if (this == child) {", "        if (child == null) {", "        children.add(child);"]}
{"children": ["public ContainerTag with(Iterable<? extends DomContent> children) {", "        if (children != null) {", "            for (DomContent child : children) {", "                this.with(child);"]}
{"optional": ["    public static <T, U> T iff(Optional<U> optional, Function<U, T> ifFunction) {", "        if (Objects.nonNull(optional) && optional.isPresent()) {", "            return optional.map(ifFunction).orElse(null);"], "ifFunction": ["    public static <T, U> T iff(Optional<U> optional, Function<U, T> ifFunction) {", "            return optional.map(ifFunction).orElse(null);"]}
{"htmlTag": ["public static String document(ContainerTag htmlTag) {", "        if (htmlTag.getTagName().equals(\"html\")) {", "            return document().render() + htmlTag.render();"]}
{"name": ["boolean setAttribute(String name, String value) {", "            return attributes.add(new Attribute(name));", "            if (attribute.getName().equals(name)) {", "        return attributes.add(new Attribute(name, value));"], "value": ["boolean setAttribute(String name, String value) {", "        if (value == null) {", "                attribute.setValue(value); // update with new value", "        return attributes.add(new Attribute(name, value));"]}
{"attribute": ["public T attr(String attribute, Object value) {", "        setAttribute(attribute, value == null ? null : String.valueOf(value));"], "value": ["public T attr(String attribute, Object value) {", "        setAttribute(attribute, value == null ? null : String.valueOf(value));"]}
{"attribute": ["public T attr(Attribute attribute) {", "        String name = attribute.getName();", "        attributes.add(attribute);"]}
{"Result": "Method without Parameter"}
{"code": ["public static String compressJs(String code) {", "        InputStream inStream = new ByteArrayInputStream(code.getBytes());"]}
{"contents": ["private ArrayList<Property> parseProperties(String contents) {", "        for (int i = 0; i < contents.length(); i++) {", "            if (bInsideString) { // If we're inside a string", "                bInsideString = !(contents.charAt(i) == '\"');", "            } else if (bInsideURL) { // If we're inside a URL", "                bInsideURL = !(contents.charAt(i) == ')');", "            } else if (contents.charAt(i) == '\"') {", "            } else if (contents.charAt(i) == '(') {", "                if ((i - 3) > 0 && \"url\".equals(contents.substring(i - 3, i))) {", "            } else if (contents.charAt(i) == ';') {", "                substr = contents.substring(j, i);", "                if (!(substr.trim().equals(\"\"))) {", "                    parts.add(substr);", "        substr = contents.substring(j, contents.length());"]}
{"contents": ["private Part[] parseValues(String contents) {", "        String[] parts = contents.split(\",\");"]}
{"menuItemsWidth": ["private void handleOnVisibleMenuItemsWidthChanged(int menuItemsWidth) {", "        if (menuItemsWidth == 0) {", "            mClearButton.setTranslationX(-menuItemsWidth);", "            int paddingRight = menuItemsWidth;", "            mSearchInput.setPadding(0, 0, paddingRight, 0);"]}
{"color": ["public void setLeftActionIconColor(int color) {", "        mLeftActionIconColor = color;", "        mMenuBtnDrawable.setColor(color);", "        DrawableCompat.setTint(mIconBackArrow, color);", "        DrawableCompat.setTint(mIconSearch, color);"]}
{"color": ["public void setBackgroundColor(int color) {", "        mBackgroundColor = color;", "            mQuerySection.setCardBackgroundColor(color);", "            mSuggestionsList.setBackgroundColor(color);"]}
{"withAnim": ["public void openMenu(boolean withAnim) {", "        openMenuDrawable(mMenuBtnDrawable, withAnim);"]}
{"withAnim": ["public void closeMenu(boolean withAnim) {", "        closeMenuDrawable(mMenuBtnDrawable, withAnim);"]}
{"menuId": ["public void inflateOverflowMenu(int menuId) {", "        mMenuId = menuId;", "        mMenuView.reset(menuId, actionMenuAvailWidth());"]}
{"show": ["public void setShowSearchKey(boolean show) {", "        mShowSearchKey = show;", "        if (show) {"]}
{"enable": ["public void setDismissOnOutsideClick(boolean enable) {", "        mDismissOnOutsideTouch = enable;", "                if (mDismissOnOutsideTouch && mIsFocused) {"]}
{"focused": ["public boolean setSearchFocused(final boolean focused) {", "        boolean updatedToNotFocused = !focused && this.mIsFocused;", "        if ((focused != this.mIsFocused) && mSuggestionSecHeightListener == null) {", "                setSearchFocusedInternal(focused);", "                        setSearchFocusedInternal(focused);"]}
{"newSearchSuggestions": ["                                                           newSearchSuggestions, boolean withAnim) {", "        int visibleSuggestionHeight = calculateSuggestionItemsHeight(newSearchSuggestions,"], "withAnim": ["                                                           newSearchSuggestions, boolean withAnim) {", "        if (withAnim) {"]}
{"suggestions": ["private int calculateSuggestionItemsHeight(List<? extends SearchSuggestion> suggestions, int max) {", "        for (int i = 0; i < suggestions.size() && i < mSuggestionsList.getChildCount(); i++) {"], "max": ["private int calculateSuggestionItemsHeight(List<? extends SearchSuggestion> suggestions, int max) {", "            if (visibleItemsHeight > max) {", "                visibleItemsHeight = max;", "        return visibleItemsHeight;"]}
{"callback": ["public void setOnBindSuggestionCallback(SearchSuggestionsAdapter.OnBindSuggestionCallback callback) {", "        this.mOnBindSuggestionCallback = callback;", "            mSuggestionsAdapter.setOnBindSuggestionCallback(mOnBindSuggestionCallback);"]}
{"filename": ["public static String getMD5Checksum(String filename) {", "           byte[] b = createChecksum(filename);", "           for (int i=0; i < b.length; i++) {", "               result += Integer.toString( ( b[i] & 0xff ) + 0x100, 16).substring( 1 );", "           return result;"]}
{"builder": ["public static OkHttpClient.Builder configureToIgnoreCertificate(OkHttpClient.Builder builder) {", "            builder.sslSocketFactory(sslSocketFactory, (X509TrustManager) trustAllCerts[0]);", "            builder.hostnameVerifier(new HostnameVerifier() {", "        return builder;"]}
{"in": ["  public T read(JsonReader in) throws IOException {", "    ReaderSupplier readerSupplier = readForSupplier(in);", "        return (T) typeAdapter.read(readerSupplier.create());"]}
{"Result": "Method without Parameter"}
{"topLevel": ["private String inPackage(String topLevel, String... nested) {", "    return DOT_JOINER.join(null, topLevel, (Object[]) nested);"]}
{"Result": "Method without Parameter"}
{"gson": [], "type": ["  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {", "    if (ID_TYPE_TOKEN.equals(type)) {", "    if (TIME_INSTANT_TYPE_TOKEN.equals(type)) {", "    if (BINARY_TYPE_TOKEN.equals(type)) {", "    if (PATTERN_TYPE_TOKEN.equals(type)) {", "    if (DECIMAL128_TYPE_TOKEN.equals(type)) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"valueAttribute": ["private static String cachingKey(ValueAttribute valueAttribute) {", "        valueAttribute.containedTypeElement.getQualifiedName(),", "        Joiner.on(\".\").join(valueAttribute.containingType.constitution.style().attributeBuilder()));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"expression": ["public static <T> Predicate<T> of(Expression<T> expression) {", "    if (Expressions.isNil(expression)) {", "    return new InMemoryExpressionEvaluator<>(expression);"]}
{"future": ["public static <V> FluentFuture<V> from(ListenableFuture<V> future) {", "    if (future instanceof FluentFuture<?>) {", "      return (FluentFuture<V>) future;", "    return new WrapingFluentFuture<>(future, MoreExecutors.directExecutor());"]}
{"Result": "Method without Parameter"}
{"input": ["protected String stringify(DeclaredType input, TypevarContext context) {", "    return toTypeElement(input).getQualifiedName().toString();"], "context": []}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"scriptBody": ["public Object execute(String scriptBody, Object[] parameters) {", "      Function function = createInjectedScriptFunction(scriptBody, asyncResult);"], "parameters": ["public Object execute(String scriptBody, Object[] parameters) {", "        page.executeJavaScriptFunction(function, function, parameters,"]}
{"proxy": ["public void setProxySettings(Proxy proxy) {", "    if (proxy == null || proxy.getProxyType() == Proxy.ProxyType.UNSPECIFIED) {", "    switch (proxy.getProxyType()) {", "        String noProxy = proxy.getNoProxy();", "        String httpProxy = proxy.getHttpProxy();", "        String socksProxy = proxy.getSocksProxy();", "        String pac = proxy.getProxyAutoconfigUrl();"]}
{"host": ["public void setHTTPProxy(String host, int port, List<String> noProxyHosts) {", "    proxyConfig.setProxyHost(host);"], "port": ["public void setHTTPProxy(String host, int port, List<String> noProxyHosts) {", "    proxyConfig.setProxyPort(port);"], "noProxyHosts": ["public void setHTTPProxy(String host, int port, List<String> noProxyHosts) {", "    if (noProxyHosts != null && noProxyHosts.size() > 0) {", "      for (String noProxyHost : noProxyHosts) {", "        proxyConfig.addHostsToProxyBypass(noProxyHost);"]}
{"autoProxyUrl": ["public void setAutoProxy(String autoProxyUrl) {", "    proxyConfig.setProxyAutoConfigUrl(autoProxyUrl);"]}
{"userId": ["public static BoxDeveloperEditionAPIConnection userClient(String userId) {", "        if (userId == null) { //   session data has expired", "        System.out.format(\"userClient called with userId %s \\n\\n\", userId);", "                    userId, CLIENT_ID, CLIENT_SECRET, jwtEncryptionPreferences, accessTokenCache);"]}
{"updatingProcessDefinition": ["public void updateModifiedFieldsFromEntity(ProcessDefinitionEntity updatingProcessDefinition) {", "    if (!this.key.equals(updatingProcessDefinition.key) || !this.deploymentId.equals(updatingProcessDefinition.deploymentId)) {", "    this.revision = updatingProcessDefinition.revision;", "    this.suspensionState = updatingProcessDefinition.suspensionState;"]}
{"activity": ["private void addFourEyesTaskListener(ActivityImpl activity) {", "    UserTaskActivityBehavior userTaskActivityBehavior = (UserTaskActivityBehavior) activity.getActivityBehavior();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"processEngine": ["\t\t\tProcessEngine processEngine, String processDefinitionId) {", "\t\treturn getServletContextPath(getProcessApplicationInfo(processEngine, processDefinitionId));"], "processDefinitionId": ["\t\t\tProcessEngine processEngine, String processDefinitionId) {", "\t\treturn getServletContextPath(getProcessApplicationInfo(processEngine, processDefinitionId));"]}
{"processDefinitionId": ["public static String getServletContextPath(String processDefinitionId) {", "\t\tProcessApplicationInfo processApplicationInfo = getProcessApplicationInfo(processDefinitionId);", "\t\tif (processApplicationInfo == null) {", "\t\treturn processApplicationInfo.getProperties().get("]}
{"processEngine": ["\t\t\tProcessEngine processEngine, String processDefinitionId) {", "\t\tProcessDefinition processDefinition = processEngine.getRepositoryService().getProcessDefinition(processDefinitionId);", "\t\tString processApplicationName = processEngine.getManagementService()"], "processDefinitionId": ["\t\t\tProcessEngine processEngine, String processDefinitionId) {", "\t\tProcessDefinition processDefinition = processEngine.getRepositoryService().getProcessDefinition(processDefinitionId);", "\t\t\t\t.getProcessApplicationForDeployment(processDefinition.getDeploymentId());"]}
{"processDefinitionId": ["public static ProcessApplicationInfo getProcessApplicationInfo(String processDefinitionId) {", "\t\t\t\tlong count = processEngineService", "\t\t\t\t\t\t.processDefinitionId(processDefinitionId).count();", "\t\t\t\tif (count > 0) {"]}
{"Result": "Method without Parameter"}
{"value": ["  public static final <T extends Serializable> T castValue(final Object value) {", "    return value != null ? (T) value : null;"]}
{"Result": "Method without Parameter"}
{"execution": ["public static void checkIsSet(final DelegateExecution execution, final String variableName) {", "    final Object variableLocal = execution.getVariableLocal(variableName);", "    final Object variable = execution.getVariable(variableName);", "        format(CONDITION_VIOLATED + \"Variable '%s' is not set.\", execution.getCurrentActivityId(), variableName));"], "variableName": ["public static void checkIsSet(final DelegateExecution execution, final String variableName) {", "    checkArgument(variableName != null, VARIABLE_NAME_MUST_BE_NOT_NULL);", "    final Object variableLocal = execution.getVariableLocal(variableName);", "    final Object variable = execution.getVariable(variableName);", "    checkState(variableLocal != null || variable != null,", "        format(CONDITION_VIOLATED + \"Variable '%s' is not set.\", execution.getCurrentActivityId(), variableName));"]}
{"execution": ["public static void checkIsSetGlobal(final DelegateExecution execution, final String variableName) {", "    final Object variable = execution.getVariable(variableName);", "    checkState(variable != null, format(CONDITION_VIOLATED + \"Global variable '%s' is not set.\", execution.getCurrentActivityId(), variableName));"], "variableName": ["public static void checkIsSetGlobal(final DelegateExecution execution, final String variableName) {", "    checkArgument(variableName != null, VARIABLE_NAME_MUST_BE_NOT_NULL);", "    final Object variable = execution.getVariable(variableName);", "    checkState(variable != null, format(CONDITION_VIOLATED + \"Global variable '%s' is not set.\", execution.getCurrentActivityId(), variableName));"]}
{"animated": ["public void open(boolean animated) {", "        if(animated && animationHandler != null) {"]}
{"animated": ["public void close(boolean animated) {", "        if(animated && animationHandler != null) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"subActionItem": ["protected void restoreSubActionViewAfterAnimation(FloatingActionMenu.Item subActionItem, ActionType actionType) {", "        ViewGroup.LayoutParams params = subActionItem.view.getLayoutParams();", "        subActionItem.view.setTranslationX(0);", "        subActionItem.view.setTranslationY(0);", "        subActionItem.view.setRotation(0);", "        subActionItem.view.setScaleX(1);", "        subActionItem.view.setScaleY(1);", "        subActionItem.view.setAlpha(1);", "                lp.setMargins(subActionItem.x - overlayParams.x, subActionItem.y - overlayParams.y, 0, 0);", "                lp.setMargins(subActionItem.x, subActionItem.y, 0, 0);", "            subActionItem.view.setLayoutParams(lp);", "                lp.setMargins(center.x - overlayParams.x - subActionItem.width / 2, center.y - overlayParams.y - subActionItem.height / 2, 0, 0);", "                lp.setMargins(center.x - subActionItem.width / 2, center.y - subActionItem.height / 2, 0, 0);", "            subActionItem.view.setLayoutParams(lp);", "            menu.removeViewFromCurrentContainer(subActionItem.view);"], "actionType": ["protected void restoreSubActionViewAfterAnimation(FloatingActionMenu.Item subActionItem, ActionType actionType) {", "        if(actionType == ActionType.OPENING) {", "        else if(actionType == ActionType.CLOSING) {"]}
{"contentView": ["public void setContentView(View contentView, FrameLayout.LayoutParams params) {", "        contentView.setClickable(false);", "        this.addView(contentView, params);"], "params": ["public void setContentView(View contentView, FrameLayout.LayoutParams params) {", "        if(params == null) {", "        this.addView(contentView, params);"]}
{"position": ["public void setPosition(int position, ViewGroup.LayoutParams layoutParams) {", "        switch (position) {"], "layoutParams": ["public void setPosition(int position, ViewGroup.LayoutParams layoutParams) {", "                FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) layoutParams;", "                WindowManager.LayoutParams lp = (WindowManager.LayoutParams) layoutParams;"]}
{"layoutParams": ["public void attach(ViewGroup.LayoutParams layoutParams) {", "                getWindowManager().addView(this, layoutParams);", "            ((ViewGroup) getActivityContentView()).addView(this, layoutParams);"]}
{"trigger": ["public StateConfiguration<S, T> permit(T trigger, S destinationState) {", "        return publicPermit(trigger, destinationState);"], "destinationState": ["public StateConfiguration<S, T> permit(T trigger, S destinationState) {", "        enforceNotIdentityTransition(destinationState);", "        return publicPermit(trigger, destinationState);"]}
{"trigger": ["public StateConfiguration<S, T> permitIf(T trigger, S destinationState, FuncBoolean guard) {", "        return publicPermitIf(trigger, destinationState, guard);"], "destinationState": ["public StateConfiguration<S, T> permitIf(T trigger, S destinationState, FuncBoolean guard) {", "        enforceNotIdentityTransition(destinationState);", "        return publicPermitIf(trigger, destinationState, guard);"], "guard": ["public StateConfiguration<S, T> permitIf(T trigger, S destinationState, FuncBoolean guard) {", "        return publicPermitIf(trigger, destinationState, guard);"]}
{"trigger": ["public StateConfiguration<S, T> permitIfOtherwiseIgnore(T trigger, S destinationState, final FuncBoolean guard) {", "        ignoreIf(trigger, new FuncBoolean() {", "        return publicPermitIf(trigger, destinationState, guard);"], "destinationState": ["public StateConfiguration<S, T> permitIfOtherwiseIgnore(T trigger, S destinationState, final FuncBoolean guard) {", "        enforceNotIdentityTransition(destinationState);", "        return publicPermitIf(trigger, destinationState, guard);"], "guard": ["public StateConfiguration<S, T> permitIfOtherwiseIgnore(T trigger, S destinationState, final FuncBoolean guard) {", "                return !guard.call();", "        return publicPermitIf(trigger, destinationState, guard);"]}
{"trigger": ["public StateConfiguration<S, T> ignoreIf(T trigger, FuncBoolean guard) {", "        representation.addTriggerBehaviour(new InternalTriggerBehaviour<S, T>(trigger, guard, NO_ACTION));"], "guard": ["public StateConfiguration<S, T> ignoreIf(T trigger, FuncBoolean guard) {", "        assert guard != null : GUARD_IS_NULL;", "        representation.addTriggerBehaviour(new InternalTriggerBehaviour<S, T>(trigger, guard, NO_ACTION));"]}
{"state": ["private StateRepresentation<TState, TTrigger> getOrCreateRepresentation(TState state) {", "        StateRepresentation<TState, TTrigger> result = stateConfiguration.get(state);", "        if (result == null) {", "            result = new StateRepresentation<>(state);", "            stateConfiguration.put(state, result);", "        return result;"]}
{"instance": ["public void addInstance(Object instance)", "            startInstance(instance);", "            if (methodsMap.get(instance.getClass()).hasFor(PreDestroy.class)) {", "                managedInstances.add(instance);"]}
{"bucket": ["private boolean setOverflow(int bucket, int overflow)", "            if (overflowBuckets[i] == bucket) {"], "overflow": ["private boolean setOverflow(int bucket, int overflow)", "        for (int i = 0; i < overflows; i++) {", "                overflowValues[i] = (byte) overflow;"]}
{"other": ["public DenseHll mergeWith(DenseHll other)", "        if (indexBitLength != other.indexBitLength) {", "                    numberOfBuckets(other.indexBitLength)));", "        int baseline = Math.max(this.baseline, other.baseline);", "            int value = Math.max(getValue(i), other.getValue(i));", "            int delta = value - baseline;", "            if (delta == 0) {", "            else if (delta > MAX_DELTA) {", "                overflowValues = Bytes.ensureCapacity(overflowValues, overflows + 1, OVERFLOW_GROW_INCREMENT);", "                overflowValues[overflows] = (byte) (delta - MAX_DELTA);", "            setDelta(i, delta);", "        this.overflowValues = overflowValues;"]}
{"Result": "Method without Parameter"}
{"sequence": ["public static List<byte[]> decodeSequence(byte[] sequence)", "        checkArgument(sequence[0] == SEQUENCE_TAG, \"Expected sequence tag\");", "        int sequenceDataLength = decodeLength(sequence, index);", "        checkArgument(sequenceDataLength + index == sequence.length, \"Invalid sequence\");", "        while (index < sequence.length) {", "            int elementStart = index;", "            int length = decodeLength(sequence, index);", "            index += encodedLengthSize(length);", "            byte[] data = Arrays.copyOfRange(sequence, elementStart, index + length);", "            elements.add(data);", "            index += length;"]}
{"element": ["public static byte[] decodeSequenceOptionalElement(byte[] element)", "        checkArgument((element[0] & 0xE0) == 0xA0, \"Expected optional sequence element tag\");", "        int length = decodeLength(element, index);", "        checkArgument(length + index == element.length, \"Invalid optional sequence element\");", "        return Arrays.copyOfRange(element, index, index + length);"]}
{"padBits": ["public static byte[] encodeBitString(int padBits, byte[] value)", "        checkArgument(padBits >= 0 && padBits < 8, \"Invalid pad bits\");", "        out.write(padBits);"], "value": ["public static byte[] encodeBitString(int padBits, byte[] value)", "        byte[] lengthEncoded = encodeLength(value.length + 1);", "        ByteArrayDataOutput out = ByteStreams.newDataOutput(2 + lengthEncoded.length + value.length);", "        out.write(value);"]}
{"value": ["public static byte[] encodeOctetString(byte[] value)", "        byte[] lengthEncoded = encodeLength(value.length);", "        ByteArrayDataOutput out = ByteStreams.newDataOutput(2 + lengthEncoded.length + value.length);", "        out.write(value);"]}
{"length": ["public static byte[] encodeLength(int length)", "        if (length < 128) {", "            return new byte[] {(byte) length};", "        int numberOfBits = 32 - Integer.numberOfLeadingZeros(length);", "        int numberOfBytes = (numberOfBits + 7) / 8;", "        for (int i = 0; i < numberOfBytes; i++) {", "            int shiftSize = (byteToEncode - 1) * 8;", "            encoded[i + 1] = (byte) (length >>> shiftSize);", "        return encoded;"]}
{"name": ["public static Logger get(String name)", "        java.util.logging.Logger logger = java.util.logging.Logger.getLogger(name);", "        return new Logger(logger);"]}
{"exception": ["public void debug(Throwable exception, String message)", "        logger.log(FINE, message, exception);"], "message": ["public void debug(Throwable exception, String message)", "        logger.log(FINE, message, exception);"]}
{"exception": ["public void warn(Throwable exception, String message)", "        logger.log(WARNING, message, exception);"], "message": ["public void warn(Throwable exception, String message)", "        logger.log(WARNING, message, exception);"]}
{"exception": ["public void error(Throwable exception, String message)", "        logger.log(SEVERE, message, exception);"], "message": ["public void error(Throwable exception, String message)", "        logger.log(SEVERE, message, exception);"]}
{"path": ["public HttpUriBuilder replacePath(String path)", "        requireNonNull(path, \"path is null\");", "        if (!path.isEmpty() && !path.startsWith(\"/\")) {", "            path = \"/\" + path;", "        this.path = path;"]}
{"encoded": ["private static String percentDecode(String encoded)", "        Preconditions.checkArgument(ascii().matchesAllOf(encoded), \"string must be ASCII\");", "        ByteArrayOutputStream out = new ByteArrayOutputStream(encoded.length());", "        for (int i = 0; i < encoded.length(); i++) {", "            char c = encoded.charAt(i);", "            if (c == '%') {", "                Preconditions.checkArgument(i + 2 < encoded.length(), \"percent encoded value is truncated\");", "                int high = Character.digit(encoded.charAt(i + 1), 16);", "                int low = Character.digit(encoded.charAt(i + 2), 16);", "                Preconditions.checkArgument(high != -1 && low != -1, \"percent encoded value is not a valid hex string: \", encoded.substring(i, i + 2));", "                int value = (high << 4) | (low);", "                out.write(value);", "                out.write((int) c);"]}
{"contentTimestamps": ["    private static DoubleSummaryStats processContentTimestamps(List<Long> contentTimestamps)", "        requireNonNull(contentTimestamps, \"contentTimestamps is null\");", "        if (contentTimestamps.size() == 0 || contentTimestamps.size() == 1) {", "        long previousTimestamp = contentTimestamps.get(0);", "        for (int i = 1; i < contentTimestamps.size(); i++) {", "            long timestamp = contentTimestamps.get(i);", "            statistics.accept(NANOSECONDS.toMillis(timestamp - previousTimestamp));", "            previousTimestamp = timestamp;"]}
{"configurationProvider": ["<T> T build(ConfigurationProvider<T> configurationProvider)", "        requireNonNull(configurationProvider, \"configurationProvider\");", "        registerConfigurationProvider(configurationProvider, Optional.empty());", "        T instance = getCachedInstance(configurationProvider);", "        if (instance != null) {", "            return instance;", "        ConfigurationBinding<T> configurationBinding = configurationProvider.getConfigurationBinding();", "        T existingValue = putCachedInstance(configurationProvider, instance);"]}
{"value": ["public void update(long value, long timestamp)", "                values.put(priority, value);", "                    if (values.putIfAbsent(priority, value) == null) {"], "timestamp": ["public void update(long value, long timestamp)", "            final double priority = weight(timestamp - startTime) / random();"]}
{"bytes": ["public static String base64Encode(byte[] bytes)", "        StringBuilder buf = new StringBuilder(((bytes.length + 2) / 3) * 4);", "        for (int end = bytes.length - 2; i < end; ) {", "            int chunk = ((bytes[i++] & 0xFF) << 16)", "                    | ((bytes[i++] & 0xFF) << 8)", "                    | (bytes[i++] & 0xFF);", "            buf.append(lookup[chunk >> 18]);", "            buf.append(lookup[(chunk >> 12) & 0x3F]);", "            buf.append(lookup[(chunk >> 6) & 0x3F]);", "            buf.append(lookup[chunk & 0x3F]);", "        int len = bytes.length;", "            int chunk = ((bytes[i++] & 0xFF) << 16);", "                chunk |= ((bytes[i] & 0xFF) << 8);"]}
{"encoded": ["public static byte[] base64Decode(String encoded)", "        for (int i = encoded.length() - 1; encoded.charAt(i) == '='; i--) {", "        int length = encoded.length() * 6 / 8 - padding;", "        for (int i = 0, index = 0, n = encoded.length(); i < n; i += 4) {", "            int word = reverseLookup[encoded.charAt(i)] << 18;", "            word += reverseLookup[encoded.charAt(i + 1)] << 12;", "            word += reverseLookup[encoded.charAt(i + 2)] << 6;", "            word += reverseLookup[encoded.charAt(i + 3)];", "            for (int j = 0; j < 3 && index + j < length; j++) {", "                bytes[index + j] = (byte) (word >> (8 * (2 - j)));", "        return bytes;"]}
{"Result": "Method without Parameter"}
{"uri": ["    public String dumpDestination(URI uri)", "        Destination destination = httpClient.getDestination(uri.getScheme(), uri.getHost(), uri.getPort());"]}
{"targetWeight": ["public static double computeAlpha(double targetWeight, long targetAgeInSeconds)", "        checkArgument(targetWeight > 0 && targetWeight < 1, \"targetWeight must be in range (0, 1)\");", "        return -Math.log(targetWeight) / targetAgeInSeconds;"], "targetAgeInSeconds": ["public static double computeAlpha(double targetWeight, long targetAgeInSeconds)", "        checkArgument(targetAgeInSeconds > 0, \"targetAgeInSeconds must be > 0\");", "        return -Math.log(targetWeight) / targetAgeInSeconds;"]}
{"source": ["public static <X, Y> void propagateCancellation(ListenableFuture<? extends X> source, Future<? extends Y> destination, boolean mayInterruptIfRunning)", "        source.addListener(() -> {", "            if (source.isCancelled()) {"], "destination": ["public static <X, Y> void propagateCancellation(ListenableFuture<? extends X> source, Future<? extends Y> destination, boolean mayInterruptIfRunning)", "                destination.cancel(mayInterruptIfRunning);"], "mayInterruptIfRunning": ["public static <X, Y> void propagateCancellation(ListenableFuture<? extends X> source, Future<? extends Y> destination, boolean mayInterruptIfRunning)", "                destination.cancel(mayInterruptIfRunning);"]}
{"future": ["    public static <V> CompletableFuture<V> unmodifiableFuture(CompletableFuture<V> future)", "        return unmodifiableFuture(future, false);"]}
{"future": ["    public static <V> CompletableFuture<V> unmodifiableFuture(CompletableFuture<V> future, boolean propagateCancel)", "        requireNonNull(future, \"future is null\");", "            onCancelFunction = future::cancel;", "        future.whenComplete((value, exception) -> {"], "propagateCancel": ["    public static <V> CompletableFuture<V> unmodifiableFuture(CompletableFuture<V> future, boolean propagateCancel)", "        if (propagateCancel) {"]}
{"throwable": ["    public static <V> CompletableFuture<V> failedFuture(Throwable throwable)", "        requireNonNull(throwable, \"throwable is null\");", "        future.completeExceptionally(throwable);"]}
{"future": ["public static <V, E extends Exception> V getFutureValue(Future<V> future, Class<E> exceptionType)", "        requireNonNull(future, \"future is null\");", "            return future.get();"], "exceptionType": ["public static <V, E extends Exception> V getFutureValue(Future<V> future, Class<E> exceptionType)", "        requireNonNull(exceptionType, \"exceptionType is null\");", "            propagateIfPossible(cause, exceptionType);"]}
{"future": ["public static <T> Optional<T> tryGetFutureValue(Future<T> future)", "        requireNonNull(future, \"future is null\");", "        if (!future.isDone()) {", "        return tryGetFutureValue(future, 0, MILLISECONDS);"]}
{"future": ["public static <V> Optional<V> tryGetFutureValue(Future<V> future, int timeout, TimeUnit timeUnit)", "        return tryGetFutureValue(future, timeout, timeUnit, RuntimeException.class);"], "timeout": ["public static <V> Optional<V> tryGetFutureValue(Future<V> future, int timeout, TimeUnit timeUnit)", "        return tryGetFutureValue(future, timeout, timeUnit, RuntimeException.class);"], "timeUnit": ["public static <V> Optional<V> tryGetFutureValue(Future<V> future, int timeout, TimeUnit timeUnit)", "        return tryGetFutureValue(future, timeout, timeUnit, RuntimeException.class);"]}
{"future": ["public static <V, E extends Exception> Optional<V> tryGetFutureValue(Future<V> future, int timeout, TimeUnit timeUnit, Class<E> exceptionType)", "        requireNonNull(future, \"future is null\");", "            return Optional.ofNullable(future.get(timeout, timeUnit));"], "timeout": ["public static <V, E extends Exception> Optional<V> tryGetFutureValue(Future<V> future, int timeout, TimeUnit timeUnit, Class<E> exceptionType)", "        checkArgument(timeout >= 0, \"timeout is negative\");", "            return Optional.ofNullable(future.get(timeout, timeUnit));"], "timeUnit": ["public static <V, E extends Exception> Optional<V> tryGetFutureValue(Future<V> future, int timeout, TimeUnit timeUnit, Class<E> exceptionType)", "        requireNonNull(timeUnit, \"timeUnit is null\");", "            return Optional.ofNullable(future.get(timeout, timeUnit));"], "exceptionType": ["public static <V, E extends Exception> Optional<V> tryGetFutureValue(Future<V> future, int timeout, TimeUnit timeUnit, Class<E> exceptionType)", "        requireNonNull(exceptionType, \"exceptionType is null\");", "            propagateIfPossible(cause, exceptionType);"]}
{"future": ["public static void checkSuccess(Future<?> future, String errorMessage)", "        requireNonNull(future, \"future is null\");", "        checkArgument(future.isDone(), \"future not done yet\");", "            getFutureValue(future);"], "errorMessage": ["public static void checkSuccess(Future<?> future, String errorMessage)", "        requireNonNull(errorMessage, \"errorMessage is null\");", "            throw new IllegalArgumentException(errorMessage, e);"]}
{"futures": ["public static <V> ListenableFuture<V> whenAnyComplete(Iterable<? extends ListenableFuture<? extends V>> futures)", "        requireNonNull(futures, \"futures is null\");", "        checkArgument(!isEmpty(futures), \"futures is empty\");", "        for (ListenableFuture<? extends V> future : futures) {", "            firstCompletedFuture.setAsync(future);"]}
{"futures": ["    public static <V> CompletableFuture<V> firstCompletedFuture(Iterable<? extends CompletionStage<? extends V>> futures)", "        return firstCompletedFuture(futures, false);"]}
{"futures": ["    public static <V> CompletableFuture<V> firstCompletedFuture(Iterable<? extends CompletionStage<? extends V>> futures, boolean propagateCancel)", "        requireNonNull(futures, \"futures is null\");", "        checkArgument(!isEmpty(futures), \"futures is empty\");", "        for (CompletionStage<? extends V> stage : futures) {", "            stage.whenComplete((value, exception) -> {", "                    for (CompletionStage<? extends V> sourceFuture : futures) {", "                        if (sourceFuture instanceof Future) {", "                            ((Future<?>) sourceFuture).cancel(true);"], "propagateCancel": ["    public static <V> CompletableFuture<V> firstCompletedFuture(Iterable<? extends CompletionStage<? extends V>> futures, boolean propagateCancel)", "        if (propagateCancel) {"]}
{"futures": ["    public static <V> CompletableFuture<List<V>> allAsList(List<CompletableFuture<? extends V>> futures)", "        CompletableFuture<Void> allDoneFuture = CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()]));", "        for (CompletableFuture<? extends V> future : futures) {", "            future.whenComplete((v, throwable) -> {", "                futures.stream()"]}
{"listenableFuture": ["public static <V> CompletableFuture<V> toCompletableFuture(ListenableFuture<V> listenableFuture)", "        requireNonNull(listenableFuture, \"listenableFuture is null\");", "                listenableFuture.cancel(true);", "        Futures.addCallback(listenableFuture, callback, directExecutor());"]}
{"completableFuture": ["public static <V> ListenableFuture<V> toListenableFuture(CompletableFuture<V> completableFuture)", "        requireNonNull(completableFuture, \"completableFuture is null\");", "        propagateCancellation(future, completableFuture, true);", "        completableFuture.whenComplete((value, exception) -> {"]}
{"future": ["public static <T> void addExceptionCallback(ListenableFuture<T> future, Runnable exceptionCallback, Executor executor)", "        addExceptionCallback(future, t -> exceptionCallback.run(), executor);"], "exceptionCallback": ["public static <T> void addExceptionCallback(ListenableFuture<T> future, Runnable exceptionCallback, Executor executor)", "        requireNonNull(exceptionCallback, \"exceptionCallback is null\");", "        addExceptionCallback(future, t -> exceptionCallback.run(), executor);"], "executor": ["public static <T> void addExceptionCallback(ListenableFuture<T> future, Runnable exceptionCallback, Executor executor)", "        addExceptionCallback(future, t -> exceptionCallback.run(), executor);"]}
{"bucketUpperBounds": ["public List<Bucket> getHistogram(List<Long> bucketUpperBounds, MiddleFunction middleFunction)", "        checkArgument(Ordering.natural().isOrdered(bucketUpperBounds), \"buckets must be sorted in increasing order\");", "        PeekingIterator<Long> iterator = Iterators.peekingIterator(bucketUpperBounds.iterator());"], "middleFunction": ["public List<Bucket> getHistogram(List<Long> bucketUpperBounds, MiddleFunction middleFunction)", "            holder.bucketWeightedSum += middleFunction.middle(lowerBound(node), upperBound(node)) * counts[node];"]}
{"node": ["private int tryRemove(int node)", "        checkArgument(node != -1, \"node is -1\");", "        int left = lefts[node];", "        int right = rights[node];", "        if (left == -1 && right == -1) {", "            remove(node);", "        if (left != -1 && right != -1) {", "        remove(node);", "        if (left != -1) {", "            return left;", "            return right;"]}
{"node": ["private double computeMaxPathWeight(int node)", "        if (node == -1 || levels[node] == 0) {", "        double leftMaxWeight = computeMaxPathWeight(lefts[node]);", "        double rightMaxWeight = computeMaxPathWeight(rights[node]);", "        return Math.max(leftMaxWeight, rightMaxWeight) + counts[node];"]}
{"hash": ["public void addHash(long hash)", "        instance.insertHash(hash);"]}
{"path": ["public static Map<String, String> loadPropertiesFrom(String path)", "        try (InputStream inputStream = new FileInputStream(path)) {"]}
{"configClass": ["public <T> void bindConfigGlobalDefaults(Class<T> configClass, ConfigDefaults<T> configDefaults)", "        Key<T> key = Key.get(configClass, GlobalDefaults.class);"], "configDefaults": ["public <T> void bindConfigGlobalDefaults(Class<T> configClass, ConfigDefaults<T> configDefaults)", "        binder.bindConfigDefaults(new ConfigDefaultsHolder<>(key, configDefaults));"]}
{"pollCount": ["public Duration next(int pollCount, Duration previousDuration) {", "        return new Duration(fibonacci(offset + pollCount), timeUnit);"], "previousDuration": []}
{"value": ["private int fib(int value, int current, int previous) {", "        if (value == 0) {", "        } else if (value == 1) {", "        return fib(value - 1, current + previous, current);"], "current": ["private int fib(int value, int current, int previous) {", "            return current;", "        return fib(value - 1, current + previous, current);"], "previous": ["private int fib(int value, int current, int previous) {", "            return previous;", "        return fib(value - 1, current + previous, current);"]}
{"amount": ["public Duration multiply(long amount) {", "        return new Multiply().apply(this, unit == null ? FOREVER : new Duration(amount, unit));"]}
{"amount": ["public Duration divide(long amount) {", "        return new Divide().apply(this, unit == null ? FOREVER : new Duration(amount, unit));"]}
{"strategy": ["private static Field findSingleFieldUsingStrategy(FieldMatcherStrategy strategy, Object object,", "                if (strategy.matches(field) && hasFieldProperModifier(object, field)) {", "                        throw new TooManyFieldsFoundException(\"Two or more fields matching \" + strategy + \".\");", "            strategy.notFound(originalStartClass, !isClass(object));"], "object": ["private static Field findSingleFieldUsingStrategy(FieldMatcherStrategy strategy, Object object,", "        assertObjectInGetInternalStateIsNotNull(object);", "                if (strategy.matches(field) && hasFieldProperModifier(object, field)) {", "            strategy.notFound(originalStartClass, !isClass(object));"], "checkHierarchy": ["                                                      boolean checkHierarchy, Class<?> startClass) {", "            } else if (!checkHierarchy) {"], "startClass": ["                                                      boolean checkHierarchy, Class<?> startClass) {", "        final Class<?> originalStartClass = startClass;", "        while (startClass != null) {", "            final Field[] declaredFields = startClass.getDeclaredFields();", "            for (Field field : declaredFields) {", "                if (strategy.matches(field) && hasFieldProperModifier(object, field)) {", "                    if (foundField != null) {", "                    foundField = field;", "            if (foundField != null) {", "            startClass = startClass.getSuperclass();", "        if (foundField == null) {", "            strategy.notFound(originalStartClass, !isClass(object));", "        foundField.setAccessible(true);", "        return foundField;"]}
{"object": ["private static boolean hasFieldProperModifier(Object object, Field field) {", "        return ((object instanceof Class<?> && Modifier.isStatic(field.getModifiers())) || !(object instanceof Class<?> || Modifier"], "field": ["private static boolean hasFieldProperModifier(Object object, Field field) {", "        return ((object instanceof Class<?> && Modifier.isStatic(field.getModifiers())) || !(object instanceof Class<?> || Modifier", "                .isStatic(field.getModifiers())));"]}
{"type": ["public static void throwExceptionIfFieldWasNotFound(Class<?> type, String fieldName, Field field) {", "                    + type.getName() + \".\");"], "fieldName": ["public static void throwExceptionIfFieldWasNotFound(Class<?> type, String fieldName, Field field) {", "            throw new FieldNotFoundException(\"No field was found with name '\" + fieldName + \"' in class \""], "field": ["public static void throwExceptionIfFieldWasNotFound(Class<?> type, String fieldName, Field field) {", "        if (field == null) {"]}
{"object": ["public static Field getFieldAnnotatedWith(Object object, Class<? extends Annotation> annotationType) {", "        return findSingleFieldUsingStrategy(new FieldAnnotationMatcherStrategy(annotationType), object, true,", "                getType(object));"], "annotationType": ["public static Field getFieldAnnotatedWith(Object object, Class<? extends Annotation> annotationType) {", "        return findSingleFieldUsingStrategy(new FieldAnnotationMatcherStrategy(annotationType), object, true,"]}
{"conditionEvaluationListener": ["public ConditionFactory conditionEvaluationListener(ConditionEvaluationListener conditionEvaluationListener) {"]}
{"executorService": ["public ConditionFactory pollExecutorService(ExecutorService executorService) {", "        if (executorService != null && executorService instanceof ScheduledExecutorService) {", "                exceptionsIgnorer, conditionEvaluationListener, ExecutorLifecycle.withoutCleanup(executorService));"]}
{"atomic": ["public void untilTrue(final AtomicBoolean atomic) {", "        untilAtomic(atomic, anyOf(is(Boolean.TRUE), is(true)));"]}
{"atomic": ["public void untilFalse(final AtomicBoolean atomic) {", "        untilAtomic(atomic, anyOf(is(Boolean.FALSE), is(false)));"]}
{"Result": "Method without Parameter"}
{"timeout": ["public static void setDefaultTimeout(long timeout, TimeUnit unit) {", "        defaultWaitConstraint = defaultWaitConstraint.withMaxWaitTime(new Duration(timeout, unit));"], "unit": ["public static void setDefaultTimeout(long timeout, TimeUnit unit) {", "        defaultWaitConstraint = defaultWaitConstraint.withMaxWaitTime(new Duration(timeout, unit));"]}
{"defaultTimeout": ["public static void setDefaultTimeout(Duration defaultTimeout) {", "        if (defaultTimeout == null) {", "        defaultWaitConstraint = defaultWaitConstraint.withMaxWaitTime(defaultTimeout);"]}
{"arguments": ["public static List<String> tokenize(String arguments, boolean stringify) {", "    int len = arguments.length();", "      char c = arguments.charAt(i);", "        currArg.append(c);", "            if (c == '\\'') {", "              currArg.append(c);", "            if (c == '\"') {", "            else if (c == '\\\\') {", "              char next = arguments.charAt(i);", "              if (next == '\"' || next == '\\\\') {", "                currArg.append(next);", "                currArg.append(c);", "                currArg.append(next);", "              currArg.append(c);", "            switch(c) {", "              if (!Character.isWhitespace(c)) {", "              currArg.append(c);"], "stringify": ["public static List<String> tokenize(String arguments, boolean stringify) {", "    if (stringify) {"]}
{"s": ["protected static String _escapeQuotesAndBackslashes(String s) {", "    final StringBuilder buf = new StringBuilder(s);", "    for (int i = s.length()-1; i >= 0; i--) {", "      char c = s.charAt(i);", "      if ((c == '\\\\') || (c == '\"')) {", "        buf.insert(i, '\\\\');", "      else if (c == '\\n') {", "        buf.deleteCharAt(i);", "        buf.insert(i, \"\\\\n\");", "      else if (c == '\\t') {", "        buf.deleteCharAt(i);", "        buf.insert(i, \"\\\\t\");", "      else if (c == '\\r') {", "        buf.deleteCharAt(i);", "        buf.insert(i, \"\\\\r\");", "      else if (c == '\\b') {", "        buf.deleteCharAt(i);", "        buf.insert(i, \"\\\\b\");", "      else if (c == '\\f') {", "        buf.deleteCharAt(i);", "        buf.insert(i, \"\\\\f\");", "    return buf.toString();"]}
{"Result": "Method without Parameter"}
{"fileOrUrl": ["private PropertiesConfiguration loadLanguageConfiguration(String fileOrUrl) {", "        PropertiesConfiguration configuration = SwissKnife", "                .loadConfigurationInUtf8(fileOrUrl);", "        if (configuration != null && ninjaProperties.isDev()) {", "            configuration.setReloadingStrategy(strategy);", "        return configuration;"]}
{"Result": "Method without Parameter"}
{"logbackConfigurationFile": ["protected static URL getUrlForStringFromClasspathAsFileOrUrl(String logbackConfigurationFile) {", "            url = Resources.getResource(logbackConfigurationFile);", "        if (url == null) {", "                File file = new File(logbackConfigurationFile);", "                if (file.exists()) {", "                    url = new File(logbackConfigurationFile).toURI().toURL();", "        if (url == null) {", "                url = new URL(logbackConfigurationFile);", "        return url;"]}
{"random": ["protected static String generateSecret(Random random) {", "            int charToPoPickFromCharset = random.nextInt(charsetForSecret.length());            ", "            stringBuilder.append(charsetForSecret.charAt(charToPoPickFromCharset));"]}
{"name": ["            String name,", "            name,"], "classNameWithMainToRun": ["            String classNameWithMainToRun,", "            classNameWithMainToRun,"], "classpath": ["            List<String> classpath, ", "            classpath,"], "jvmArguments": [], "mavenBaseDir": ["            File mavenBaseDir) {", "            mavenBaseDir"]}
{"artifacts": ["        List<Artifact> artifacts) {", "        for (Artifact artifact: artifacts) {", "            for (String dependencyTrail: artifact.getDependencyTrail()) {", "                if (dependencyTrail.contains(NinjaMavenPluginConstants.NINJA_STANDALONE_ARTIFACT_ID)) {", "                    resultingArtifacts.add(artifact);"]}
{"Result": "Method without Parameter"}
{"data": ["public String encrypt(String data) {", "        Objects.requireNonNull(data, \"Data to be encrypted\");", "            return data;", "            byte[] encrypted = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));"]}
{"data": ["public String decrypt(String data) {", "        Objects.requireNonNull(data, \"Data to be decrypted\");", "            return data;", "        byte[] decoded = Base64.decodeBase64(data);", "            byte[] decrypted = cipher.doFinal(decoded);", "            return new String(decrypted, StandardCharsets.UTF_8);"]}
{"Result": "Method without Parameter"}
{"path": ["private void register(Path path) throws IOException {", "        WatchKey watchKey = path.register(", "        mapOfWatchKeysToPaths.put(watchKey, path);"]}
{"Result": "Method without Parameter"}
{"mimeType": ["public boolean isValidMimeType(String mimeType) {", "        if (mimeType == null) {", "        } else if (mimeType.indexOf(\";\") != -1) {", "            return mimetypes.contains(mimeType.split(\";\")[0]);", "            return mimetypes.contains(mimeType);"]}
{"injector": ["public Route buildRoute(Injector injector) {", "        allFilters.addAll(calculateGlobalFilters(this.globalFiltersOptional, injector));", "        FilterChain filterChain = buildFilterChain(injector, allFilters);"]}
{"Result": "Method without Parameter"}
{"scheme": ["protected String createServerUrl(String scheme, String host, Integer port) {", "        sb.append(scheme);", "        if ((\"http\".equals(scheme) && port != 80) || (\"https\".equals(scheme) && port != 443)) {"], "host": ["protected String createServerUrl(String scheme, String host, Integer port) {", "        sb.append((host != null ? host : \"localhost\"));"], "port": ["protected String createServerUrl(String scheme, String host, Integer port) {", "        if ((\"http\".equals(scheme) && port != 80) || (\"https\".equals(scheme) && port != 443)) {", "            sb.append(port);"]}
{"router": ["    public void init(Router router) {", "        this.router = router;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"method": ["private boolean allowMethod(Method method) {", "        if (method.isAnnotationPresent(Requires.class)) {", "            String key = method.getAnnotation(Requires.class).value();", "        for (Annotation annotation : method.getAnnotations()) {", "            Class<? extends Annotation> annotationClass = annotation", "            if (annotationClass.isAnnotationPresent(RuntimeMode.class)) {", "                RuntimeMode mode = annotationClass", "                modes.add(mode.value());"]}
{"method": ["private String getHttpMethod(Method method) {", "        for (Annotation annotation : method.getAnnotations()) {", "            Class<? extends Annotation> annotationClass = annotation", "            if (annotationClass.isAnnotationPresent(HttpMethod.class)) {", "                HttpMethod httpMethod = annotationClass", "                return httpMethod.value();", "                        method.getClass().getName(), method.getName()));"]}
{"functionalMethod": ["            Method functionalMethod, ", "        return new ControllerMethodInvoker(functionalMethod, argumentExtractors, useStrictArgumentExtractors);"], "implementationMethod": ["            Method implementationMethod, ", "        final Type[] genericParameterTypes = implementationMethod.getGenericParameterTypes();", "        final Annotation[][] paramAnnotations = implementationMethod", "                        \" in method \" + implementationMethod.getDeclaringClass().getName() + \".\" + implementationMethod.getName() + \"()\", e);", "                            + implementationMethod.getDeclaringClass().getName() + \".\" + implementationMethod.getName() + \"()\\n\""], "injector": ["            Injector injector,", "        for (int i = 0; i < methodParameters.length; i++) {", "                argumentExtractors[i] = getArgumentExtractor(methodParameters[i], paramAnnotations[i],", "                        injector);", "                throw new RoutingException(\"Error building argument extractor for parameter \" + i +", "        for (int i = 0; i < argumentExtractors.length; i++) {", "            if (argumentExtractors[i] == null) {", "        for (int i = 0; i < argumentExtractors.length; i++) {", "            argumentExtractors[i] =", "                            injector,", "                            argumentExtractors[i]);", "        return new ControllerMethodInvoker(functionalMethod, argumentExtractors, useStrictArgumentExtractors);"], "ninjaProperties": ["            NinjaProperties ninjaProperties) {", "        boolean useStrictArgumentExtractors = determineWhetherToUseStrictArgumentExtractorMode(ninjaProperties);", "        return new ControllerMethodInvoker(functionalMethod, argumentExtractors, useStrictArgumentExtractors);"]}
{"object": ["public static String getRealClassNameLowerCamelCase(Object object) {", "        return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, object.getClass().getSimpleName());"]}
{"nameWithPackage": ["public static boolean doesClassExist(String nameWithPackage, Object instanceToGetClassloaderFrom) {", "            Class.forName(nameWithPackage, false, instanceToGetClassloaderFrom.getClass().getClassLoader());"], "instanceToGetClassloaderFrom": ["public static boolean doesClassExist(String nameWithPackage, Object instanceToGetClassloaderFrom) {", "            Class.forName(nameWithPackage, false, instanceToGetClassloaderFrom.getClass().getClassLoader());"]}
{"ste": ["static public String getSourceCodeRelativePathForStackTraceElement(StackTraceElement ste) {", "        String packageName = ste.getClassName();", "                + ste.getFileName();", "                ste.getFileName();"]}
{"key": ["public void add(String key, Object value, String expiration) {", "        cache.add(key, value, TimeUtil.parseDuration(expiration));"], "value": ["public void add(String key, Object value, String expiration) {", "        checkSerializable(value);", "        cache.add(key, value, TimeUtil.parseDuration(expiration));"], "expiration": ["public void add(String key, Object value, String expiration) {", "        cache.add(key, value, TimeUtil.parseDuration(expiration));"]}
{"key": ["    public <T> T get(String key, Class<T> clazz) {", "        return (T) cache.get(key);"], "clazz": []}
{"value": ["void checkSerializable(Object value) {", "        if (value != null && !(value instanceof Serializable)) {", "                            + value.getClass().getName(),", "                    new NotSerializableException(value.getClass().getName()));"]}
{"key": ["public Result render(String key, Object value) {", "        render(new AbstractMap.SimpleEntry<String, Object>(key, value));"], "value": ["public Result render(String key, Object value) {", "        render(new AbstractMap.SimpleEntry<String, Object>(key, value));"]}
{"string": ["    public Result renderRaw(final String string) {", "                    writer.write(string);"]}
{"bytes": ["public Result renderRaw(final byte [] bytes) {", "                    outputStream.write(bytes);"]}
{"cookieName": ["public Cookie getCookie(String cookieName) {", "            if (cookie.getName().equals(cookieName)) {"]}
{"Result": "Method without Parameter"}
{"isProd": ["                                                boolean isProd,", "            if (isProd) {"], "baseDirWithoutTrailingSlash": ["                                                String baseDirWithoutTrailingSlash,                                                ", "                String pathToApplicationConfInSrcDir = baseDirWithoutTrailingSlash + File.separator + \"src\" + File.separator + \"main\" + File.separator + \"java\" + File.separator + NinjaProperties.CONF_FILE_LOCATION_BY_CONVENTION;"], "defaultConfiguration": ["                                                PropertiesConfiguration defaultConfiguration,", "            defaultConfiguration.setProperty(NinjaConstant.applicationSecret, secret);", "                defaultConfiguration.save(pathToApplicationConfInSrcDir);", "                defaultConfiguration.save();"], "compositeConfiguration": ["                                                Configuration compositeConfiguration) {", "        String applicationSecret = compositeConfiguration.getString(NinjaConstant.applicationSecret);", "            compositeConfiguration.setProperty(NinjaConstant.applicationSecret, secret);"]}
{"collection": ["public boolean addAll(@NonNull final Collection<? extends T> collection) {", "        boolean result = mItems.addAll(collection);", "        return result;"]}
{"itemId": ["private int getPositionForId(final long itemId) {", "        View v = getViewForId(itemId);", "        if (v == null) {", "            return mWrapper.getPositionForView(v);"]}
{"switchView": ["private void switchViews(final View switchView, final long switchId, final float translationY) {", "        final int switchViewPosition = mWrapper.getPositionForView(switchView);", "        ((Swappable) mAdapter).swapItems(switchViewPosition - mWrapper.getHeaderViewsCount(), mobileViewPosition - mWrapper.getHeaderViewsCount());", "        mHoverDrawable.shift(switchView.getHeight());"], "switchId": ["private void switchViews(final View switchView, final long switchId, final float translationY) {", "        mSwitchViewAnimator.animateSwitchView(switchId, translationY);"], "translationY": ["private void switchViews(final View switchView, final long switchId, final float translationY) {", "        mSwitchViewAnimator.animateSwitchView(switchId, translationY);"]}
{"index": ["public void removeActiveIndex(final int index) {", "            if (iterator.next().get() == index) {"]}
{"Result": "Method without Parameter"}
{"position": ["    public View getTitleView(final int position) {", "        View parentView = findViewForPosition(position);", "        if (parentView != null) {", "            Object tag = parentView.getTag();"]}
{"position": ["    public View getContentView(final int position) {", "        View parentView = findViewForPosition(position);", "        if (parentView != null) {", "            Object tag = parentView.getTag();"]}
{"position": ["public void expand(final int position) {", "        long itemId = getItemId(position);", "        if (mExpandedIds.contains(itemId)) {", "        toggle(position);"]}
{"position": ["public void collapse(final int position) {", "        long itemId = getItemId(position);", "        if (!mExpandedIds.contains(itemId)) {", "        toggle(position);"]}
{"position": ["    private View getContentParent(final int position) {", "        View parentView = findViewForPosition(position);", "        if (parentView != null) {", "            Object tag = parentView.getTag();"]}
{"view": [], "parent": []}
{"v": ["    static Bitmap getBitmapFromView(@NonNull final View v) {", "        Bitmap bitmap = Bitmap.createBitmap(v.getMeasuredWidth(), v.getMeasuredHeight(), Bitmap.Config.ARGB_8888);", "        v.draw(canvas);"]}
{"position": ["private boolean isDismissable(final int position) {", "            long downId = mListViewWrapper.getAdapter().getItemId(position);", "            return mDismissableManager.isDismissable(downId, position);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"view": ["void cancelExistingAnimation(@NonNull final View view) {", "        int hashCode = view.hashCode();"]}
{"position": ["private void animateView(final int position, @NonNull final View view, @NonNull final Animator[] animators) {", "        set.setStartDelay(calculateAnimationDelay(position));"], "view": ["private void animateView(final int position, @NonNull final View view, @NonNull final Animator[] animators) {", "        ViewHelper.setAlpha(view, 0);", "        mAnimators.put(view.hashCode(), set);"], "animators": ["private void animateView(final int position, @NonNull final View view, @NonNull final Animator[] animators) {", "        set.playTogether(animators);"]}
{"position": ["    private int calculateAnimationDelay(final int position) {", "        int numberOfAnimatedItems = position - 1 - mFirstAnimatedPosition;", "                delay += mAnimationDelayMillis * (position % numColumns);", "            int delaySinceStart = (position - mFirstAnimatedPosition) * mAnimationDelayMillis;"]}
{"childAnimators": ["    public static Animator[] concatAnimators(@NonNull final Animator[] childAnimators, @NonNull final Animator[] animators, @NonNull final Animator alphaAnimator) {", "        Animator[] allAnimators = new Animator[childAnimators.length + animators.length + 1];", "        for (i = 0; i < childAnimators.length; ++i) {", "            allAnimators[i] = childAnimators[i];"], "animators": ["    public static Animator[] concatAnimators(@NonNull final Animator[] childAnimators, @NonNull final Animator[] animators, @NonNull final Animator alphaAnimator) {", "        Animator[] allAnimators = new Animator[childAnimators.length + animators.length + 1];", "        for (Animator animator : animators) {", "            allAnimators[i] = animator;"], "alphaAnimator": ["    public static Animator[] concatAnimators(@NonNull final Animator[] childAnimators, @NonNull final Animator[] animators, @NonNull final Animator alphaAnimator) {", "        allAnimators[allAnimators.length - 1] = alphaAnimator;", "        return allAnimators;"]}
{"request": ["public void handleNonCORS(final HttpServletRequest request,\r", "        filterChain.doFilter(request, response);\r"], "response": ["            final HttpServletResponse response, final FilterChain filterChain)\r", "        filterChain.doFilter(request, response);\r"], "filterChain": ["            final HttpServletResponse response, final FilterChain filterChain)\r", "        filterChain.doFilter(request, response);\r"]}
{"buffer": ["    public void addStreamOfLiteralWords(Buffer buffer, int start, int number) {", "           if(buffer.getWord(x)!=0) throw nonEmptyException;"], "start": ["    public void addStreamOfLiteralWords(Buffer buffer, int start, int number) {", "        for(int x = start; x < start + number ; ++x)"], "number": ["    public void addStreamOfLiteralWords(Buffer buffer, int start, int number) {", "        for(int x = start; x < start + number ; ++x)"]}
{"i": ["public static void materialize(final IteratingRLW i,", "            if (i.getRunningLength() > 0) {", "                c.addStreamOfEmptyWords(i.getRunningBit(), i.getRunningLength());", "            int il = i.getNumberOfLiteralWords();", "            for (int k = 0; k < il ; ++k)", "                c.addWord(i.getLiteralWordAt(k));", "            if (!i.next())"], "c": ["                                   final BitmapStorage c) {", "                c.addStreamOfEmptyWords(i.getRunningBit(), i.getRunningLength());", "                c.addWord(i.getLiteralWordAt(k));"]}
{"Result": "Method without Parameter"}
{"number": ["private void resizeBuffer(int number) {", "        int size = newSizeInWords(number);", "        if (size >= this.buffer.length) {", "            this.buffer = new long[size];", "            System.arraycopy(oldBuffer, 0, this.buffer, 0, oldBuffer.length);"]}
{"number": ["private int newSizeInWords(int number) {", "        int size = this.actualSizeInWords + number;", "        if (size >= this.buffer.length) {", "            if (size < 32768)", "                size = size * 2;", "            else if (size * 3 / 2 < size) // overflow", "                size = size * 3 / 2;", "        return size;"]}
{"Result": "Method without Parameter"}
{"buffer": ["    public void addStreamOfLiteralWords(Buffer32 buffer, int start, int number) {", "            addLiteralWord(buffer.getWord(i));"], "start": ["    public void addStreamOfLiteralWords(Buffer32 buffer, int start, int number) {", "        for (int i = start; i < start + number; i++) {"], "number": ["    public void addStreamOfLiteralWords(Buffer32 buffer, int start, int number) {", "        for (int i = start; i < start + number; i++) {"]}
{"container": ["public final void fillWithLiterals(final List<EWAHPointer32> container) {", "            container.add(this.rw[k]);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"bs": ["public boolean intersects(BitSet bs) {", "      for (int k = 0; k < Math.min(this.data.limit(), bs.data.length); ++k) {", "          if ((this.data.get(k) & bs.data[k]) != 0) return true;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"colorResId": ["public void setMenuBackgroundColor(int colorResId) {", "    backgroundColor = ContextCompat.getColor(getContext(), colorResId);", "    paint.setColor(backgroundColor);"]}
{"url": ["private int[] fetchDatabaseNameRangeIndexFromURLForH2FileMode(String url) {", "    int fileLabelIndex = url.indexOf(FILE_MODE_FLAG);", "    int parameterLabelIndex = url.indexOf(\";\", fileLabelIndex);", "      parameterLabelIndex = url.length();"]}
{"url": ["private int[] fetchDatabaseNameRangeIndexFromURLForH2MemMode(String url) {", "    int fileLabelIndex = url.indexOf(MEMORY_MODE_FLAG);", "    int parameterLabelIndex = url.indexOf(\";\", fileLabelIndex);", "      parameterLabelIndex = url.length();"]}
{"url": ["public static ConnectionInfo parser(String url) {", "    if (null == url) {", "    String lowerCaseUrl = url.toLowerCase();", "      return parser.parse(url);"]}
{"urlPrefix": ["public static void registerConnectionParser(String urlPrefix, ConnectionURLParser parser) {", "    if (null == urlPrefix || parser == null) {", "    parserRegister.put(urlPrefix.toLowerCase(), parser);"], "parser": ["public static void registerConnectionParser(String urlPrefix, ConnectionURLParser parser) {", "    if (null == urlPrefix || parser == null) {", "    parserRegister.put(urlPrefix.toLowerCase(), parser);"]}
{"url": ["protected String fetchDatabaseNameFromURL(String url) {", "    URLLocation hostsLocation = fetchDatabaseNameIndexRange(url);", "    return url.substring(hostsLocation.startIndex(), hostsLocation.endIndex());"]}
{"context": ["public static void run(final Context context, final Class<?> daemonServiceClazz,", "\t\t\t\tCommand.install(context, BIN_DIR_NAME, DAEMON_BIN_NAME);", "\t\t\t\tstart(context, daemonServiceClazz, interval);"], "daemonServiceClazz": ["public static void run(final Context context, final Class<?> daemonServiceClazz,", "\t\t\t\tstart(context, daemonServiceClazz, interval);"], "interval": ["\t                       final int interval) {", "\t\t\t\tstart(context, daemonServiceClazz, interval);"]}
{"file": ["private static void copyFile(File file, InputStream is, String mode)", "\t\tfinal String abspath = file.getAbsolutePath();", "\t\tfinal FileOutputStream out = new FileOutputStream(file);", "\t\t\tout.write(buf, 0, len);", "\t\tout.close();"], "is": ["private static void copyFile(File file, InputStream is, String mode)", "\t\twhile ((len = is.read(buf)) > 0) {", "\t\t\tout.write(buf, 0, len);", "\t\tis.close();"], "mode": ["private static void copyFile(File file, InputStream is, String mode)", "\t\tRuntime.getRuntime().exec(\"chmod \" + mode + \" \" + abspath).waitFor();"]}
{"context": ["public static void copyAssets(Context context, String assetsFilename, File file, String mode)", "\t\tAssetManager manager = context.getAssets();"], "assetsFilename": ["public static void copyAssets(Context context, String assetsFilename, File file, String mode)", "\t\tfinal InputStream is = manager.open(assetsFilename);", "\t\tcopyFile(file, is, mode);"], "file": ["public static void copyAssets(Context context, String assetsFilename, File file, String mode)", "\t\tcopyFile(file, is, mode);"], "mode": ["public static void copyAssets(Context context, String assetsFilename, File file, String mode)", "\t\tcopyFile(file, is, mode);"]}
{"context": ["\tpublic static boolean install(Context context, String destDir, String filename) {", "\t\t\tFile f = new File(context.getDir(destDir, Context.MODE_PRIVATE), filename);", "\t\t\tcopyAssets(context, assetfilename, f, \"0755\");"], "destDir": ["\tpublic static boolean install(Context context, String destDir, String filename) {", "\t\t\tFile f = new File(context.getDir(destDir, Context.MODE_PRIVATE), filename);"], "filename": ["\tpublic static boolean install(Context context, String destDir, String filename) {", "\t\tString assetfilename = binaryDir + File.separator + filename;", "\t\t\tFile f = new File(context.getDir(destDir, Context.MODE_PRIVATE), filename);", "\t\t\tif (f.exists()) {", "\t\t\tcopyAssets(context, assetfilename, f, \"0755\");"]}
{"Result": "Method without Parameter"}
{"c": ["private Object getEnum(Class c, JsonObject jsonObj)", "            return Enum.valueOf(c, (String) jsonObj.get(\"name\"));", "            return Enum.valueOf(c, (String) jsonObj.get(\"java.lang.Enum.name\"));"], "jsonObj": ["private Object getEnum(Class c, JsonObject jsonObj)", "            return Enum.valueOf(c, (String) jsonObj.get(\"name\"));", "            return Enum.valueOf(c, (String) jsonObj.get(\"java.lang.Enum.name\"));"]}
{"Result": "Method without Parameter"}
{"stack": ["public void traverseFields(final Deque<JsonObject<String, Object>> stack, final JsonObject<String, Object> jsonObj)", "                stack.addFirst(jsonArray);", "                    stack.addFirst(jObj);"], "jsonObj": ["public void traverseFields(final Deque<JsonObject<String, Object>> stack, final JsonObject<String, Object> jsonObj)", "        final Object target = jsonObj.target;", "        for (Map.Entry<String, Object> e : jsonObj.entrySet())", "            final String fieldName = e.getKey();", "            final Field field = (target != null) ? MetaUtils.getField(target.getClass(), fieldName) : null;", "            final Object rhs = e.getValue();", "            if (rhs == null)", "                jsonObj.put(fieldName, null);", "            else if (rhs == JsonParser.EMPTY_OBJECT)", "                jsonObj.put(fieldName, new JsonObject());", "            else if (rhs.getClass().isArray())", "                jsonArray.put(\"@items\", rhs);", "                jsonObj.put(fieldName, rhs);", "            else if (rhs instanceof JsonObject)", "                JsonObject<String, Object> jObj = (JsonObject) rhs;", "                if (field != null && MetaUtils.isLogicalPrimitive(field.getType()))", "                    jObj.put(\"value\", MetaUtils.convert(field.getType(), jObj.get(\"value\")));", "                Long refId = jObj.getReferenceId();", "                if (refId != null)", "                    JsonObject refObject = getReferencedObj(refId);", "                    jsonObj.put(fieldName, refObject);    // Update Map-of-Maps reference", "                    stack.addFirst(jObj);", "            else if (field != null)", "                final Class fieldType = field.getType();", "                if (MetaUtils.isPrimitive(fieldType) || BigDecimal.class.equals(fieldType) || BigInteger.class.equals(fieldType) || Date.class.equals(fieldType))", "                    jsonObj.put(fieldName, MetaUtils.convert(fieldType, rhs));", "                else if (rhs instanceof String)", "                    if (fieldType != String.class && fieldType != StringBuilder.class && fieldType != StringBuffer.class)", "                        if (\"\".equals(((String)rhs).trim()))", "                            jsonObj.put(fieldName, null);"]}
{"json": ["public static Object jsonToJava(String json, Map<String, Object> optionalArgs)", "        JsonReader jr = new JsonReader(json, optionalArgs);"], "optionalArgs": ["public static Object jsonToJava(String json, Map<String, Object> optionalArgs)", "        if (optionalArgs == null)", "        if (!optionalArgs.containsKey(USE_MAPS))", "            optionalArgs.put(USE_MAPS, false);", "        JsonReader jr = new JsonReader(json, optionalArgs);", "        Object obj = jr.readObject();", "        jr.close();"]}
{"root": ["public Object jsonObjectsToJava(JsonObject root)", "        return convertParsedMapsToJava(root);"]}
{"stack": ["public void traverseFields(final Deque<JsonObject<String, Object>> stack, final JsonObject<String, Object> jsonObj)", "                assignField(stack, jsonObj, field, rhs);", "                handleMissingField(stack, jsonObj, rhs, key);"], "jsonObj": ["public void traverseFields(final Deque<JsonObject<String, Object>> stack, final JsonObject<String, Object> jsonObj)", "        final Object javaMate = jsonObj.target;", "        final Iterator<Map.Entry<String, Object>> i = jsonObj.entrySet().iterator();", "                assignField(stack, jsonObj, field, rhs);", "                handleMissingField(stack, jsonObj, rhs, key);"]}
{"target": ["private void storeMissingField(Object target, String missingField, Object value)", "        missingFields.add(new Missingfields(target, missingField, value));"], "missingField": ["private void storeMissingField(Object target, String missingField, Object value)", "        missingFields.add(new Missingfields(target, missingField, value));"], "value": ["private void storeMissingField(Object target, String missingField, Object value)", "        missingFields.add(new Missingfields(target, missingField, value));"]}
{"t": ["public static Class getRawType(final Type t)", "        if (t instanceof ParameterizedType)", "            ParameterizedType pType = (ParameterizedType) t;", "            if (pType.getRawType() instanceof Class)", "                return (Class) pType.getRawType();"]}
{"object": ["private Object readArray(JsonObject object) throws IOException", "            final Object o = readValue(object);", "            if (o != EMPTY_ARRAY)", "                array.add(o);"]}
{"c": ["private Number readNumber(int c) throws IOException", "        number.appendCodePoint(c);", "        if (JsonReader.isLenient() && (c == '-' || c == 'N' || c == 'I') ) {", "            final boolean isNeg = (c == '-');", "            if (c == 'I') {", "            } else if ('N' == c) {"]}
{"Result": "Method without Parameter"}
{"c": ["public static Field getField(Class c, String field)", "        return getDeepDeclaredFields(c).get(field);"], "field": ["public static Field getField(Class c, String field)", "        return getDeepDeclaredFields(c).get(field);"]}
{"s": ["static String removeLeadingAndTrailingQuotes(String s)", "        Matcher m = extraQuotes.matcher(s);", "        if (m.find())", "            s = m.group(2);", "        return s;"]}
{"item": ["public static String objectToJson(Object item, Map<String, Object> optionalArgs)", "            writer.write(item);"], "optionalArgs": ["public static String objectToJson(Object item, Map<String, Object> optionalArgs)", "            JsonWriter writer = new JsonWriter(stream, optionalArgs);", "            writer.write(item);", "            writer.close();"]}
{"json": ["public static String formatJson(String json, Map readingArgs, Map writingArgs)", "        Object obj = JsonReader.jsonToJava(json, args);"], "readingArgs": ["public static String formatJson(String json, Map readingArgs, Map writingArgs)", "        if (readingArgs != null)", "            args.putAll(readingArgs);"], "writingArgs": ["public static String formatJson(String json, Map readingArgs, Map writingArgs)", "        if (writingArgs != null)", "            args.putAll(writingArgs);"]}
{"output": ["private void tab(Writer output, int delta) throws IOException", "        output.write(NEW_LINE);", "            output.write(\"  \");"], "delta": ["private void tab(Writer output, int delta) throws IOException", "        depth += delta;", "        for (int i=0; i < depth; i++)"]}
{"arrayComponentClass": ["public boolean writeArrayElementIfMatching(Class arrayComponentClass, Object o, boolean showType, Writer output)", "        if (!o.getClass().isAssignableFrom(arrayComponentClass) || notCustom.contains(o.getClass()))", "            return writeCustom(arrayComponentClass, o, showType, output);"], "o": ["public boolean writeArrayElementIfMatching(Class arrayComponentClass, Object o, boolean showType, Writer output)", "        if (!o.getClass().isAssignableFrom(arrayComponentClass) || notCustom.contains(o.getClass()))", "            return writeCustom(arrayComponentClass, o, showType, output);"], "showType": ["public boolean writeArrayElementIfMatching(Class arrayComponentClass, Object o, boolean showType, Writer output)", "            return writeCustom(arrayComponentClass, o, showType, output);"], "output": ["public boolean writeArrayElementIfMatching(Class arrayComponentClass, Object o, boolean showType, Writer output)", "            return writeCustom(arrayComponentClass, o, showType, output);"]}
{"arrayComponentClass": ["protected boolean writeCustom(Class arrayComponentClass, Object o, boolean showType, Writer output) throws IOException", "\t\tJsonClassWriterBase closestWriter = getCustomWriter(arrayComponentClass);", "        if (closestWriter == null)", "        if (closestWriter instanceof JsonClassWriter)", "            JsonClassWriter writer = (JsonClassWriter) closestWriter;", "            if (writer.hasPrimitiveForm())", "                if ((!referenced && !showType) || closestWriter instanceof Writers.JsonStringWriter)", "                    if (writer instanceof Writers.DateWriter)", "                        ((Writers.DateWriter)writer).writePrimitiveForm(o, output, args);", "                        writer.writePrimitiveForm(o, output);", "        if (closestWriter instanceof JsonClassWriterEx)", "            ((JsonClassWriterEx)closestWriter).write(o, showType || referenced, output, args);", "            ((JsonClassWriter)closestWriter).write(o, showType || referenced, output);"], "o": ["protected boolean writeCustom(Class arrayComponentClass, Object o, boolean showType, Writer output) throws IOException", "        if (writeOptionalReference(o))", "        boolean referenced = objsReferenced.containsKey(o);", "                if ((!referenced && !showType) || closestWriter instanceof Writers.JsonStringWriter)", "                        ((Writers.DateWriter)writer).writePrimitiveForm(o, output, args);", "                        writer.writePrimitiveForm(o, output);", "        if (referenced)", "            writeId(getId(o));", "            writeType(o, output);", "        if (referenced || showType)", "            ((JsonClassWriterEx)closestWriter).write(o, showType || referenced, output, args);", "            ((JsonClassWriter)closestWriter).write(o, showType || referenced, output);"], "showType": ["protected boolean writeCustom(Class arrayComponentClass, Object o, boolean showType, Writer output) throws IOException", "                if ((!referenced && !showType) || closestWriter instanceof Writers.JsonStringWriter)", "            if (showType)", "        if (showType)", "        if (referenced || showType)", "            ((JsonClassWriterEx)closestWriter).write(o, showType || referenced, output, args);", "            ((JsonClassWriter)closestWriter).write(o, showType || referenced, output);"], "output": ["protected boolean writeCustom(Class arrayComponentClass, Object o, boolean showType, Writer output) throws IOException", "                        ((Writers.DateWriter)writer).writePrimitiveForm(o, output, args);", "                        writer.writePrimitiveForm(o, output);", "        output.write('{');", "                output.write(',');", "            writeType(o, output);", "            output.write(',');", "            ((JsonClassWriterEx)closestWriter).write(o, showType || referenced, output, args);", "            ((JsonClassWriter)closestWriter).write(o, showType || referenced, output);", "        output.write('}');"]}
{"c": ["private JsonClassWriterBase forceGetCustomWriter(Class c)", "            if (clz == c)", "            int distance = MetaUtils.getDistance(clz, c);", "            if (distance < minDistance)", "                minDistance = distance;"]}
{"obj": ["public void write(Object obj)", "        traceReferences(obj);", "            writeImpl(obj, true);"]}
{"root": ["protected void traceReferences(Object root)", "        if (root == null)", "        stack.addFirst(root);"]}
{"stack": ["protected void traceFields(final Deque<Object> stack, final Object obj, final Map<Class, List<Field>> fieldSpecifiers)", "                    stack.addFirst(o);"], "obj": ["protected void traceFields(final Deque<Object> stack, final Object obj, final Map<Class, List<Field>> fieldSpecifiers)", "        Collection<Field> fields = getFieldsUsingSpecifier(obj.getClass(), fieldSpecifiers);", "            fields = MetaUtils.getDeepDeclaredFields(obj.getClass()).values();", "                final Object o = field.get(obj);", "                if (o != null && !MetaUtils.isLogicalPrimitive(o.getClass()))", "                    stack.addFirst(o);"], "fieldSpecifiers": ["protected void traceFields(final Deque<Object> stack, final Object obj, final Map<Class, List<Field>> fieldSpecifiers)", "        Collection<Field> fields = getFieldsUsingSpecifier(obj.getClass(), fieldSpecifiers);", "        Collection<Field> fieldsBySpec = fields;", "        if (fields == null)", "        for (final Field field : fields)", "            if ((field.getModifiers() & Modifier.TRANSIENT) != 0)", "                if (fieldsBySpec == null || !fieldsBySpec.contains(field))", "                final Object o = field.get(obj);", "                if (o != null && !MetaUtils.isLogicalPrimitive(o.getClass()))", "                    stack.addFirst(o);"]}
{"map": ["public static boolean ensureJsonPrimitiveKeys(Map map)", "        for (Object o : map.keySet())", "            if (!(o instanceof String))"]}
{"o": ["private void writeCollectionElement(Object o) throws IOException", "        if (o == null)", "        else if (o instanceof Boolean || o instanceof Double)", "            writePrimitive(o, false);", "        else if (o instanceof Long)", "            writePrimitive(o, writeLongsAsStrings);", "        else if (o instanceof String)", "            writeJsonUtf8String((String) o, out);", "        else if (neverShowType && MetaUtils.isPrimitive(o.getClass()))", "            writePrimitive(o, false);", "            writeImpl(o, true);"]}
{"all": ["private static Map<String, String> createMapFromList(final List<String> all) {", "\t\tfor (final String documentElement : all) {", "\t\t\tif (documentElement != null) {", "\t\t\t\tmap.put(documentElement, documentElement);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"legend": ["private static Legend setLegendStyling(final Legend legend) {", "\t\tlegend.setBackground(BACKGROUND_COLOR).setFontFamily(FONT_FAMILY).setTextColor(TEXT_COLOR).setFontSize(LEGEND_FONT_SIZE);", "\t\treturn legend;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"menuBar": ["\tpublic void createCommitteeeRankingMenuBar(final MenuBar menuBar) {", "\t\tinitApplicationMenuBar(menuBar);", "\t\tapplicationMenuItemFactory.addRankingMenu(menuBar);", "\t\tcreateCommitteeRankingTopics(menuBar.addItem(COMMITTEE_RANKING_TEXT, null, null));"]}
{"committeeMenuItem": ["\tpublic void createCommitteeRankingTopics(final MenuItem committeeMenuItem) {", "\t\tcommitteeMenuItem.addItem(OVERVIEW_TEXT, VaadinIcons.GROUP, COMMAND_OVERVIEW);", "\t\tfinal MenuItem listByTopic = committeeMenuItem.addItem(RANKING_LIST_BY_TOPIC_TEXT, VaadinIcons.GROUP, null);", "\t\tfinal MenuItem chartByTopic = committeeMenuItem.addItem(CHART_BY_TOPIC_TEXT, VaadinIcons.GROUP, null);", "\t\tcommitteeMenuItem.addItem(PAGE_VISIT_HISTORY_TEXT, VaadinIcons.GROUP, COMMAND_PAGEVISIT_HISTORY);"]}
{"panelContent": ["\tpublic void createOverviewPage(final VerticalLayout panelContent) {", "\t\tfinal ResponsiveRow grid = RowUtil.createGridLayout(panelContent);", "\t\tcreateButtonLink(grid,POLITICAL_WORK_SUMMARY_TEXT,VaadinIcons.GROUP, COMMAND_DATAGRID, \"Scoreboard over current member size, political days served and total assignments\");", "\t\tcreateButtonLink(grid,CURRENT_COMMITTEES_CURRENT_MEMBERS_TEXT,VaadinIcons.GROUP, COMMAND_CURRENT_COMMITTEES_BY_HEADCOUNT, \"Chart over current committees and member size\");", "\t\tcreateButtonLink(grid,CURRENT_PARTIES_ACTIVE_IN_COMMITTEES_CURRENT_ASSIGNMENTS,VaadinIcons.GROUP, COMMAND_COMMITTEES_BY_PARTY, \"Chart over current parties active in committees and member size\");", "\t\tcreateButtonLink(grid,CURRENT_PARTIES_ACTIVE_IN_COMMITTEES_TOTAL_DAYS_SERVED_IN_COMMITTEES,VaadinIcons.GROUP, COMMAND_CURRENT_COMMITTEES_BY_PARTY_DAYS_SERVED, \"Chart over current parties active in committees days served\");", "\t\tcreateButtonLink(grid,ALL_COMMITTEES_TOTAL_MEMBERS,VaadinIcons.GROUP, COMMAND_ALL_COMMITTEES_BY_HEADCOUNT, \"Chart over all committees and member size\");", "\t\tcreateButtonLink(grid,PAGE_VISIT_HISTORY_TEXT, VaadinIcons.GROUP, COMMAND_PAGEVISIT_HISTORY, \"View history of page visit for this page.\");"]}
{"panelContent": ["private void createOverviewContent(final VerticalLayout panelContent, final PersonData personData,", "\t\tLabelFactory.createHeader2Label(panelContent, OVERVIEW);", "\t\tpanelContent.addComponent(createPoliticianPageLink);", "\t\tpanelContent.addComponent(horizontalLayout);", "\t\tpanelContent.addComponent(overviewLayout);", "\t\tpanelContent.setExpandRatio(overviewLayout, ContentRatio.LARGE_FORM);", "\t\tpanelContent.setExpandRatio(createPoliticianPageLink, ContentRatio.SMALL);", "\t\tpanelContent.setExpandRatio(horizontalLayout, ContentRatio.GRID);"], "personData": ["private void createOverviewContent(final VerticalLayout panelContent, final PersonData personData,", "\t\tfinal Link createPoliticianPageLink = getPageLinkFactory().createPoliticianPageLink(personData);", "\t\tpanelContent.addComponent(createPoliticianPageLink);", "\t\t\t\tnew ExternalResource(personData.getImageUrl192().replace(\"http://\", \"https://\")));", "\t\tpanelContent.setExpandRatio(createPoliticianPageLink, ContentRatio.SMALL);"], "viewRiksdagenPolitician": ["\t\t\tfinal ViewRiksdagenPolitician viewRiksdagenPolitician, final String pageId) {", "\t\tgetFormFactory().addFormPanelTextFields(horizontalLayout, viewRiksdagenPolitician,"], "pageId": ["\t\t\tfinal ViewRiksdagenPolitician viewRiksdagenPolitician, final String pageId) {", "\t\tgetPoliticianMenuItemFactory().createOverviewPage(overviewLayout, pageId);"]}
{"Result": "Method without Parameter"}
{"role": ["private static void configureAuthentication(final String role) {", "\t\tfinal Collection<GrantedAuthority> authorities = AuthorityUtils.createAuthorityList(role);", "\t\tfinal Authentication authentication = new UsernamePasswordAuthenticationToken(\"service.impl.BootstrapDefaultConfig\", \"n/a\", authorities);", "\t\tSecurityContextHolder.getContext().setAuthentication(authentication);"]}
{"list": ["public void setList(final List<ComplianceCheck> list) {", "\t\tthis.list = Collections.unmodifiableList(ListUtils.emptyIfNull(list));"]}
{"statusMap": ["public void setStatusMap(final Map<Status, List<RuleViolation>> statusMap) {", "\t\tthis.statusMap = Collections.unmodifiableMap(MapUtils.emptyIfNull(statusMap));"]}
{"resourceTypeMap": ["public void setResourceTypeMap(final Map<ResourceType, List<RuleViolation>> resourceTypeMap) {", "\t\tthis.resourceTypeMap = Collections.unmodifiableMap(MapUtils.emptyIfNull(resourceTypeMap));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"ballotId": ["private void updateBallot(final String ballotId) {", "\t\t\tupdateService.updateVoteDataData(riksdagenApi.getBallot(ballotId));", "\t\t\tLOGGER.warn(\"Eror loading riksdagen voteData:\" + ballotId + \" errorMessage:\", e);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"dataSeries": ["private static void addPartyData(final DataSeries dataSeries, final SimpleDateFormat simpleDateFormat,", "\t\tdataSeries.newSeries();", "\t\t\t\tdataSeries.add("], "simpleDateFormat": ["private static void addPartyData(final DataSeries dataSeries, final SimpleDateFormat simpleDateFormat,", "\t\t\t\t\t\tsimpleDateFormat"], "list": ["\t\t\tfinal List<ViewRiksdagenVoteDataBallotPartySummaryDaily> list, final Function<ViewRiksdagenVoteDataBallotPartySummaryDaily, Object> t) {", "\t\tfor (final ViewRiksdagenVoteDataBallotPartySummaryDaily viewRiksdagenVoteDataBallotPartySummaryDaily : list) {", "\t\t\tif (viewRiksdagenVoteDataBallotPartySummaryDaily != null) {", "\t\t\t\t\t\t\t\t.format(viewRiksdagenVoteDataBallotPartySummaryDaily.getEmbeddedId().getVoteDate()),", "\t\t\t\t\t\tt.apply(viewRiksdagenVoteDataBallotPartySummaryDaily));"], "t": ["\t\t\tfinal List<ViewRiksdagenVoteDataBallotPartySummaryDaily> list, final Function<ViewRiksdagenVoteDataBallotPartySummaryDaily, Object> t) {", "\t\t\t\t\t\tt.apply(viewRiksdagenVoteDataBallotPartySummaryDaily));"]}
{"content": ["private void createPartyBallotChart(final AbstractOrderedLayout content,final DataValueCalculator dataValueCalculator) {", "\t\taddChart(content,\"Party ballot chart\", new DCharts().setDataSeries(dataSeries).setOptions(getChartOptions().createOptionsXYDateFloatLegendInsideOneColumn(series)).show(), true);"], "dataValueCalculator": ["private void createPartyBallotChart(final AbstractOrderedLayout content,final DataValueCalculator dataValueCalculator) {", "\t\t\t\taddBallotData(dataValueCalculator, dataSeries, simpleDateFormat, series, entry);"]}
{"dataValueCalculator": ["private void addBallotData(final DataValueCalculator dataValueCalculator, final DataSeries dataSeries,", "\t\t\t\t\t\t\t\tdataValueCalculator.getDataValue(viewRiksdagenVoteDataBallotPartySummaryDaily));"], "dataSeries": ["private void addBallotData(final DataValueCalculator dataValueCalculator, final DataSeries dataSeries,", "\t\tdataSeries.newSeries();", "\t\t\t\tdataSeries.add("], "simpleDateFormat": ["\t\t\tfinal SimpleDateFormat simpleDateFormat, final Series series,", "\t\t\t\t\t\tsimpleDateFormat"], "series": ["\t\t\tfinal SimpleDateFormat simpleDateFormat, final Series series,", "\t\tseries.addSeries(new XYseries().setLabel(getPartyName(entry.getKey())));"], "entry": ["\t\t\tfinal Entry<String, List<ViewRiksdagenVoteDataBallotPartySummaryDaily>> entry) {", "\t\tseries.addSeries(new XYseries().setLabel(getPartyName(entry.getKey())));", "\t\tfinal List<ViewRiksdagenVoteDataBallotPartySummaryDaily> list = entry.getValue();"]}
{"data": ["\t\t\tfinal Map<Integer, List<GovernmentBodyAnnualSummary>> data) {", "\t\tfinal Set<Entry<Integer, List<GovernmentBodyAnnualSummary>>> entrySet = data.entrySet();"]}
{"governmentBodyAnnualOutcomeSummary": ["private static void addResultForMonth(final GovernmentBodyAnnualOutcomeSummary governmentBodyAnnualOutcomeSummary, final int month,", "\t\t\tgovernmentBodyAnnualOutcomeSummary.addData(month,Double.valueOf(value.replaceAll(\",\", \".\")));"], "month": ["private static void addResultForMonth(final GovernmentBodyAnnualOutcomeSummary governmentBodyAnnualOutcomeSummary, final int month,", "\t\t\tgovernmentBodyAnnualOutcomeSummary.addData(month,Double.valueOf(value.replaceAll(\",\", \".\")));"], "value": ["\t\t\tfinal String value) {", "\t\tif (value != null && value.length() >0 ) {", "\t\t\tgovernmentBodyAnnualOutcomeSummary.addData(month,Double.valueOf(value.replaceAll(\",\", \".\")));"]}
{"property": ["private static AbstractField<?> createField(final String property) {", "\t\tif (StringUtils.containsIgnoreCase(property,HIDDEN_FIELD_NAME)) {"]}
{"displayProperties": ["private static <T extends Serializable> void createDisplayPropertyConverters(final List<String> displayProperties,", "\t\tfor (final String property : displayProperties) {", "\t\t\tfinal Class<?> typeOfProperty = getTypeOfProperty(propertyDescriptors, property);", "\t\t\tif (typeOfProperty != null) {", "\t\t\t\tfield.setCaption(property);", "\t\t\t\tfinal Converter converter = getConverterForType(typeOfProperty);", "\t\t\t\tif (converter != null) {", "\t\t\t\t\tbinder.forField(field).withConverter(converter).bind(property);", "\t\t\t\t\tbinder.forField(field).bind(property);"], "formContent": ["\t\t\tfinal ComponentContainer formContent, final Binder<T> binder, final PropertyDescriptor[] propertyDescriptors) {", "\t\t\t\tformContent.addComponent(field);"], "binder": ["\t\t\tfinal ComponentContainer formContent, final Binder<T> binder, final PropertyDescriptor[] propertyDescriptors) {", "\t\t\t\t\tbinder.forField(field).withConverter(converter).bind(property);", "\t\t\t\t\tbinder.forField(field).bind(property);"], "propertyDescriptors": ["\t\t\tfinal ComponentContainer formContent, final Binder<T> binder, final PropertyDescriptor[] propertyDescriptors) {", "\t\t\tfinal Class<?> typeOfProperty = getTypeOfProperty(propertyDescriptors, property);", "\t\t\tif (typeOfProperty != null) {", "\t\t\t\tfinal Converter converter = getConverterForType(typeOfProperty);", "\t\t\t\tif (converter != null) {", "\t\t\t\t\tbinder.forField(field).withConverter(converter).bind(property);"]}
{"typeOfProperty": ["private static Converter getConverterForType(final Class<?> typeOfProperty) {", "\t\tif (Date.class.equals(typeOfProperty)) {", "\t\t} else if (Integer.class.equals(typeOfProperty) || \"int\".equalsIgnoreCase(typeOfProperty.getName())) {", "\t\t} else if (Long.class.equals(typeOfProperty) || \"long\".equalsIgnoreCase(typeOfProperty.getName())) {", "\t\t} else if (BigInteger.class.equals(typeOfProperty)) {", "\t\t} else if (BigDecimal.class.equals(typeOfProperty)) {", "\t\t} else if (Boolean.class.equals(typeOfProperty) || \"boolean\".equalsIgnoreCase(typeOfProperty.getName())) {", "\t\t} else if (typeOfProperty.isEnum()) {"]}
{"propertyDescriptors": ["private static Class<?> getTypeOfProperty(final PropertyDescriptor[] propertyDescriptors, final String property) {", "\t\tfor (final PropertyDescriptor propertyDescriptor : propertyDescriptors) {", "\t\t\tif (propertyDescriptor.getName().equalsIgnoreCase(property)) {", "\t\t\t\treturn propertyDescriptor.getPropertyType();"], "property": ["private static Class<?> getTypeOfProperty(final PropertyDescriptor[] propertyDescriptors, final String property) {", "\t\t\tif (propertyDescriptor.getName().equalsIgnoreCase(property)) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"parameters": ["protected final String getPageId(final String parameters) {", "\t\tif (parameters != null) {", "\t\t\tString cleanedString = parameters;", "\t\t\tif (parameters.contains(\"[\")) {", "\t\t\t\tcleanedString = cleanedString.replace(cleanedString.substring(cleanedString.indexOf('[') , cleanedString.lastIndexOf(']')+1), \"\");", "\t\t\treturn cleanedString.substring(cleanedString.lastIndexOf('/') + \"/\".length(), cleanedString.length());"]}
{"parameters": ["protected final int getPageNr(final String parameters) {", "\t\tfinal String cleanedString = parameters;", "\t\tif (cleanedString != null && cleanedString.contains(\"[\") && cleanedString.contains(\"]\")) {", "\t\t\tpageNrValue = cleanedString.substring(cleanedString.indexOf('[') + 1, cleanedString.lastIndexOf(']'));"]}
{"Result": "Method without Parameter"}
{"pageName": ["protected final void createPageVisitHistory(final String pageName, final String pageId,", "\t\t\t\tpageName, pageId);", "\t\t\t\tpageName);"], "pageId": ["protected final void createPageVisitHistory(final String pageName, final String pageId,", "\t\t\t\tpageName, pageId);"], "panelContent": ["\t\t\tfinal VerticalLayout panelContent) {", "\t\tpanelContent.addComponent(tabsheet);", "\t\tpanelContent.setExpandRatio(tabsheet, ContentRatio.LARGE);"]}
{"list": ["private static void addPoliticianIndicatorData(final List<ViewRiksdagenVoteDataBallotPoliticianSummaryDaily> list,", "\t\taddPoliticanData(list, dataSeries, simpleDateFormat, ViewRiksdagenVoteDataBallotPoliticianSummaryDaily::getWonPercentage);", "\t\taddPoliticanData(list, dataSeries, simpleDateFormat, ViewRiksdagenVoteDataBallotPoliticianSummaryDaily::getRebelPercentage);", "\t\taddPoliticanData(list, dataSeries, simpleDateFormat, ViewRiksdagenVoteDataBallotPoliticianSummaryDaily::getPoliticianPercentageAbsent);", "\t\taddPoliticanData(list, dataSeries, simpleDateFormat, ViewRiksdagenVoteDataBallotPoliticianSummaryDaily::getNumberBallots);"], "dataSeries": ["\t\t\tfinal DataSeries dataSeries, final SimpleDateFormat simpleDateFormat) {", "\t\taddPoliticanData(list, dataSeries, simpleDateFormat, ViewRiksdagenVoteDataBallotPoliticianSummaryDaily::getWonPercentage);", "\t\taddPoliticanData(list, dataSeries, simpleDateFormat, ViewRiksdagenVoteDataBallotPoliticianSummaryDaily::getRebelPercentage);", "\t\taddPoliticanData(list, dataSeries, simpleDateFormat, ViewRiksdagenVoteDataBallotPoliticianSummaryDaily::getPoliticianPercentageAbsent);", "\t\taddPoliticanData(list, dataSeries, simpleDateFormat, ViewRiksdagenVoteDataBallotPoliticianSummaryDaily::getNumberBallots);"], "simpleDateFormat": ["\t\t\tfinal DataSeries dataSeries, final SimpleDateFormat simpleDateFormat) {", "\t\taddPoliticanData(list, dataSeries, simpleDateFormat, ViewRiksdagenVoteDataBallotPoliticianSummaryDaily::getWonPercentage);", "\t\taddPoliticanData(list, dataSeries, simpleDateFormat, ViewRiksdagenVoteDataBallotPoliticianSummaryDaily::getRebelPercentage);", "\t\taddPoliticanData(list, dataSeries, simpleDateFormat, ViewRiksdagenVoteDataBallotPoliticianSummaryDaily::getPoliticianPercentageAbsent);", "\t\taddPoliticanData(list, dataSeries, simpleDateFormat, ViewRiksdagenVoteDataBallotPoliticianSummaryDaily::getNumberBallots);"]}
{"list": ["private static void addPoliticanData(final List<ViewRiksdagenVoteDataBallotPoliticianSummaryDaily> list,", "\t\tfor (final ViewRiksdagenVoteDataBallotPoliticianSummaryDaily viewRiksdagenVoteDataBallotPoliticianSummaryDaily : list) {", "\t\t\tif (viewRiksdagenVoteDataBallotPoliticianSummaryDaily != null) {", "\t\t\t\t\t\t\t\tviewRiksdagenVoteDataBallotPoliticianSummaryDaily.getEmbeddedId().getVoteDate()),", "\t\t\t\t\t\tt.apply(viewRiksdagenVoteDataBallotPoliticianSummaryDaily));"], "dataSeries": ["\t\t\tfinal DataSeries dataSeries, final SimpleDateFormat simpleDateFormat, final Function<ViewRiksdagenVoteDataBallotPoliticianSummaryDaily, Object> t) {", "\t\tdataSeries.newSeries();", "\t\t\t\tdataSeries.add("], "simpleDateFormat": ["\t\t\tfinal DataSeries dataSeries, final SimpleDateFormat simpleDateFormat, final Function<ViewRiksdagenVoteDataBallotPoliticianSummaryDaily, Object> t) {", "\t\t\t\t\t\tsimpleDateFormat.format("], "t": ["\t\t\tfinal DataSeries dataSeries, final SimpleDateFormat simpleDateFormat, final Function<ViewRiksdagenVoteDataBallotPoliticianSummaryDaily, Object> t) {", "\t\t\t\t\t\tt.apply(viewRiksdagenVoteDataBallotPoliticianSummaryDaily));"]}
{"googleAuthScratchCodes": ["public void setGoogleAuthScratchCodes(final List<Integer> googleAuthScratchCodes) {", "\t\tif (googleAuthScratchCodes != null) {", "\t\t\tthis.googleAuthScratchCodes = googleAuthScratchCodes.stream().collect(Collectors.toList());"]}
{"roleSummaryLayoutTabsheet": ["public final void createRoleGhant(final AbstractOrderedLayout roleSummaryLayoutTabsheet, final Collection<T> assignmentList) {", "\t\troleSummaryLayoutTabsheet.addComponent(createGantt);", "\t\troleSummaryLayoutTabsheet.setExpandRatio(createGantt, ContentRatio.GRID);"], "assignmentList": ["public final void createRoleGhant(final AbstractOrderedLayout roleSummaryLayoutTabsheet, final Collection<T> assignmentList) {", "\t\tfinal List<T> list = assignmentList.stream().filter("]}
{"assignmentList": ["private Gantt createGenericGantt(final List<T> assignmentList, final Function<T, String> roleMapping,", "\t\tfinal Map<String, List<T>> assignmentListMap = assignmentList.stream()", "\t\tif (!assignmentList.isEmpty()) {", "\t\t\tgantt.setStartDate(stepMapping.getFromDate(assignmentList.get(0)));", "\t\t\t\t\tstripDatesAfterCurrentDate(stepMapping.getToDate(assignmentList.get(assignmentList.size() - 1))));"], "roleMapping": ["private Gantt createGenericGantt(final List<T> assignmentList, final Function<T, String> roleMapping,", "\t\t\t\t.collect(Collectors.groupingBy(roleMapping, TreeMap::new, Collectors.toList()));"], "stepMapping": ["\t\t\tfinal StepMapping<T> stepMapping) {", "\t\t\tgantt.setStartDate(stepMapping.getFromDate(assignmentList.get(0)));", "\t\t\t\t\tstripDatesAfterCurrentDate(stepMapping.getToDate(assignmentList.get(assignmentList.size() - 1))));", "\t\t\tfor (final Entry<String, List<T>> entry : entriesSortedByValues(assignmentListMap, stepMapping)) {", "\t\t\t\tfinal String stepName = entry.getKey();", "\t\t\t\tfinal Step step = new Step(stepName,CaptionMode.HTML);", "\t\t\t\tstep.setDescription(stepName);", "\t\t\t\tfinal List<T> assignments = entry.getValue();", "\t\t\t\tCollections.sort(assignments, getComparator());", "\t\t\t\taddViewGenericRoleMemberToStep(stepName, step, assignments, stepMapping);", "\t\t\t\tgantt.addStep(step);"]}
{"map": ["private SortedSet<Map.Entry<String, List<T>>> entriesSortedByValues(final Map<String, List<T>> map,", "\t\tsortedEntries.addAll(map.entrySet());"], "stepMapping": ["\t\t\tfinal StepMapping<T> stepMapping) {", "\t\t\t\tfinal int compareDate = stepMapping.getFromDate(o11).compareTo(stepMapping.getFromDate(o21));", "\t\t\t\t\tfinal int compareType = stepMapping.getRoleCode(o11).compareTo(stepMapping.getRoleCode(o21));", "\t\t\t\t\t\treturn stepMapping.getOrg(o11).compareTo(stepMapping.getOrg(o21));"]}
{"stepName": ["private void addViewGenericRoleMemberToStep(final String stepName, final Step step, final List<T> assignments,", "\t\t\tfinal SubStep sameRoleSubStep = new SubStep(stepName + '.' + subStepName,CaptionMode.HTML);", "\t\t\tsameRoleSubStep.setDescription(stepName + '.' + subStepName);\t\t\t", "\t\t\tsameRoleSubStep.setBackgroundColor(stepMapping.getBackgroundColor(assignmentData));", "\t\t\tsameRoleSubStep.setStartDate(stepMapping.getFromDate(assignmentData).getTime());", "\t\t\tsameRoleSubStep.setEndDate(stripDatesAfterCurrentDate(stepMapping.getToDate(assignmentData)).getTime());", "\t\t\tstep.addSubStep(sameRoleSubStep);"], "step": ["private void addViewGenericRoleMemberToStep(final String stepName, final Step step, final List<T> assignments,", "\t\t\tstep.addSubStep(sameRoleSubStep);"], "assignments": ["private void addViewGenericRoleMemberToStep(final String stepName, final Step step, final List<T> assignments,", "\t\tfor (final T assignmentData : assignments) {", "\t\t\tif (stepMapping.getRoleCode(assignmentData) != null) {", "\t\t\t\tsubStepName = new StringBuilder().append(stepMapping.getFirstName(assignmentData))", "\t\t\t\t\t\t.append(CONTENT_SEPARATOR).append(stepMapping.getLastName(assignmentData))", "\t\t\t\t\t\t.append(PARTY_START_TAG).append(stepMapping.getParty(assignmentData)).append(PARTY_END_TAG)", "\t\t\tfinal SubStep sameRoleSubStep = new SubStep(stepName + '.' + subStepName,CaptionMode.HTML);", "\t\t\tsameRoleSubStep.setDescription(stepName + '.' + subStepName);\t\t\t", "\t\t\tsameRoleSubStep.setBackgroundColor(stepMapping.getBackgroundColor(assignmentData));", "\t\t\tsameRoleSubStep.setStartDate(stepMapping.getFromDate(assignmentData).getTime());", "\t\t\tsameRoleSubStep.setEndDate(stripDatesAfterCurrentDate(stepMapping.getToDate(assignmentData)).getTime());", "\t\t\tstep.addSubStep(sameRoleSubStep);"], "stepMapping": ["\t\t\tfinal StepMapping<T> stepMapping) {", "\t\t\tif (stepMapping.getRoleCode(assignmentData) != null) {", "\t\t\t\tsubStepName = new StringBuilder().append(stepMapping.getFirstName(assignmentData))", "\t\t\t\t\t\t.append(CONTENT_SEPARATOR).append(stepMapping.getLastName(assignmentData))", "\t\t\t\t\t\t.append(PARTY_START_TAG).append(stepMapping.getParty(assignmentData)).append(PARTY_END_TAG)", "\t\t\tfinal SubStep sameRoleSubStep = new SubStep(stepName + '.' + subStepName,CaptionMode.HTML);", "\t\t\tsameRoleSubStep.setDescription(stepName + '.' + subStepName);\t\t\t", "\t\t\tsameRoleSubStep.setBackgroundColor(stepMapping.getBackgroundColor(assignmentData));", "\t\t\tsameRoleSubStep.setStartDate(stepMapping.getFromDate(assignmentData).getTime());", "\t\t\tsameRoleSubStep.setEndDate(stripDatesAfterCurrentDate(stepMapping.getToDate(assignmentData)).getTime());", "\t\t\tstep.addSubStep(sameRoleSubStep);"]}
{"toDate": ["private static final Date stripDatesAfterCurrentDate(final Date toDate) {", "\t\tif (currentTime.isBefore(toDate.getTime())) {", "\t\t\treturn currentTime.plusDays(1).toDate();", "\t\t\treturn toDate;"]}
{"Result": "Method without Parameter"}
{"totalDays": ["protected final String convertToYearsString(final long totalDays) {", "\t\tfinal long years = totalDays / DAYS_PER_STANDARD_YEAR;", "\t\tfinal long days = totalDays - years * DAYS_PER_STANDARD_YEAR;"]}
{"ref": ["private Object loadSecretXADataSource(final Reference ref) {", "\t\treturn loadBaseDataSource(new SecretPGXADataSource(((SecretReference)ref).getSecretCredentialsManager()), ref);"]}
{"workOrder": ["private void sendMessage(final DataAgentWorkOrder workOrder) {", "\t\tswitch (workOrder.getTarget()) {"]}
{"Result": "Method without Parameter"}
{"chamber": ["private static String cleanupDecision(final String chamber) {", "\t\treturn chamber.toUpperCase(Locale.ENGLISH).replace(\"(UTSKOTTET)\", \"\").replace(\"UTKOTTET\", \"UTSKOTTET\").replace(\"UTBSKOTTET\", \"UTSKOTTET\").replace(\"UBTSKOTTET\", \"UTSKOTTET\").replace(\"(\", \"\").replace(\")\",\"\");"]}
{"document": ["private static String getDocumentName(final DocumentStatusContainer document) {", "\t\tif (\"prop\".equalsIgnoreCase(document.getDocument().getDocumentType())) {", "\t\t} else if (document.getDocument().getSubType() != null && document.getDocument().getSubType().length() > \"motion\".length()) {", "\t\t\treturn document.getDocument().getSubType();"]}
{"proposal": ["private static String getCommittteeShortName(final DocumentProposalData proposal) {", "\t\tfinal String upperCase = proposal.getProcessedIn().replaceAll(\"\\\\d\",\"\").replace(\"/:\",\"\").toUpperCase(Locale.ENGLISH);"]}
{"email": ["private void blockByUserFailedLoginAttempts(final String email, final LoginBlockResultImpl loginBlockResultImpl) {", "\t\tfinal UserAccount userExist = userDAO.findFirstByProperty(UserAccount_.email, email);", "\t\tif (userExist != null) {", "\t\t\t\t\tnew Object[] { email, ApplicationOperationType.AUTHENTICATION, ServiceResult.FAILURE.toString() },"], "loginBlockResultImpl": ["private void blockByUserFailedLoginAttempts(final String email, final LoginBlockResultImpl loginBlockResultImpl) {", "\t\t\t\tloginBlockResultImpl.setBlocked(true);", "\t\t\t\tloginBlockResultImpl.addMessages(BLOCKED_BY_MORE_THAN_5_RECENT_LOGIN_ATTEMPTS_BY_THIS_USER);"]}
{"sessionId": ["private void blockBySessionOrIpFailedLoginAttempts(final String sessionId, final LoginBlockResultImpl loginBlockResultImpl) {", "\t\tfinal ApplicationSession applicationSession = applicationSessionDAO", "\t\t\t\t.findFirstByProperty(ApplicationSession_.sessionId, sessionId);", "\t\tif (applicationSession != null) {", "\t\t\t\t\tnew Object[] { sessionId, ApplicationOperationType.AUTHENTICATION,", "\t\t\t\t\tApplicationActionEvent_.sessionId, ApplicationActionEvent_.applicationOperation,", "\t\t\tif (!(\"0:0:0:0:0:0:0:1\".equals(applicationSession.getIpInformation()) || \"127.0.0.1\".equals(applicationSession.getIpInformation()))) {", "\t\t\t\t\t\t.findListByProperty(ApplicationSession_.ipInformation, applicationSession.getIpInformation());", "\t\t\t\t\t\t.findListByPropertyInList(ApplicationActionEvent_.sessionId,"], "loginBlockResultImpl": ["private void blockBySessionOrIpFailedLoginAttempts(final String sessionId, final LoginBlockResultImpl loginBlockResultImpl) {", "\t\t\t\tloginBlockResultImpl.setBlocked(true);", "\t\t\t\tloginBlockResultImpl.addMessages(BLOCKED_BY_MORE_THAN_5_LOGIN_ATTEMPTS_BY_THIS_SESSION);", "\t\t\t\t\tloginBlockResultImpl.setBlocked(true);", "\t\t\t\t\tloginBlockResultImpl.addMessages(BLOCKED_BY_MORE_THAN_5_RECENT_LOGIN_ATTEMPTS_BY_THIS_IP);"]}
{"violation": ["private static void navigateToPage(final RuleViolation violation) {", "\t\tif (violation.getResourceType() == ResourceType.PARTY) {\t\t\t", "\t\t\tUI.getCurrent().getNavigator().navigateTo(UserViews.PARTY_VIEW_NAME + PAGE_SEPARATOR + violation.getId());", "\t\t\tUI.getCurrent().getNavigator().navigateTo(UserViews.POLITICIAN_VIEW_NAME + PAGE_SEPARATOR + violation.getId());"]}
{"Result": "Method without Parameter"}
{"caption": ["protected void showNotification(final String caption, final String description, final Type type) {", "\t\tNotification.show(caption, description, type);\t\t"], "description": ["protected void showNotification(final String caption, final String description, final Type type) {", "\t\tNotification.show(caption, description, type);\t\t"], "type": ["protected void showNotification(final String caption, final String description, final Type type) {", "\t\tNotification.show(caption, description, type);\t\t"]}
{"Result": "Method without Parameter"}
{"countryIndicators": ["private static void addSourcesAndIndicatorsToMenu(final MenuItem countryIndicators,", "\t\t\tfinal MenuItem sourceItems = countryIndicators.addItem(entry.getKey(), null, null);", "\t\t\t\tfinal MenuItem addItem = sourceItems.addItem(indciatorSummary.getIndicatorName(),", "\t\t\t\taddItem.setStyleName(\"RestrictedHeader\");"], "sourceIndicatorMap": ["\t\t\tfinal Map<String, List<ViewWorldbankIndicatorDataCountrySummary>> sourceIndicatorMap) {", "\t\tfinal Map<String, List<ViewWorldbankIndicatorDataCountrySummary>> sortedIndicatorMap = sourceIndicatorMap"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"typedQuery": ["protected final void addCacheHints(final TypedQuery<?> typedQuery, final String comment) {", "\t\ttypedQuery.setHint(\"org.hibernate.cacheMode\", CacheMode.NORMAL);", "\t\ttypedQuery.setHint(\"org.hibernate.cacheable\", Boolean.TRUE);", "\t\ttypedQuery.setHint(\"org.hibernate.comment\", comment);"], "comment": ["protected final void addCacheHints(final TypedQuery<?> typedQuery, final String comment) {", "\t\ttypedQuery.setHint(\"org.hibernate.comment\", comment);"]}
{"property": ["protected final List<String> getStringIdList(final SingularAttribute<T, String> property) {", "\t\tcriteria.select(getCriteriaBuilder().construct(String.class,root.get(property)));"]}
{"inputStream": ["private static List<String> readUsingZipInputStream(final InputStream inputStream) throws IOException {\t\t", "\t\tfinal BufferedInputStream bis = new BufferedInputStream(inputStream);", "\t\tfinal ZipInputStream is = new ZipInputStream(bis);", "\t\t\twhile ((entry = is.getNextEntry()) != null) {", "\t\t\t\tif (entry.getName().startsWith(\"API_SWE_\")) {\t\t\t\t\t", "\t\t\t\t\tlist.addAll(readCsvContent(is));\t\t\t\t\t", "\t\t\tis.close();"]}
{"content": ["\tpublic void createPagingControls(final AbstractOrderedLayout content, final String name, final String pageId, final Long size, final int pageNr,", "\t\t\t\tcontent.addComponent(pagingControls);", "\t\t\t\tcontent.setExpandRatio(pagingControls, ContentRatio.SMALL2);"], "name": ["\tpublic void createPagingControls(final AbstractOrderedLayout content, final String name, final String pageId, final Long size, final int pageNr,", "\t\t\t\t\taddPagingLink(PREVIOUS_PAGE,name, pageId, pageNr -1L,pagingControls);", "\t\t\t\t\taddPagingLink(NEXT_PAGE,name, pageId, pageNr +1L,pagingControls);", "\t\t\t\t\taddPagingLink(FIRST_PAGE,name, pageId, 1,pagingControls);", "\t\t\t\t\taddPagingLink(LAST_PAGE,name, pageId, maxPages,pagingControls);"], "pageId": ["\tpublic void createPagingControls(final AbstractOrderedLayout content, final String name, final String pageId, final Long size, final int pageNr,", "\t\t\t\t\taddPagingLink(PREVIOUS_PAGE,name, pageId, pageNr -1L,pagingControls);", "\t\t\t\t\taddPagingLink(NEXT_PAGE,name, pageId, pageNr +1L,pagingControls);", "\t\t\t\t\taddPagingLink(FIRST_PAGE,name, pageId, 1,pagingControls);", "\t\t\t\t\taddPagingLink(LAST_PAGE,name, pageId, maxPages,pagingControls);"], "size": ["\tpublic void createPagingControls(final AbstractOrderedLayout content, final String name, final String pageId, final Long size, final int pageNr,", "\t\t\t\tfinal long maxPages = (size +resultPerPage-1) / resultPerPage;", "\t\t\t\t.append(size)"], "pageNr": ["\tpublic void createPagingControls(final AbstractOrderedLayout content, final String name, final String pageId, final Long size, final int pageNr,", "\t\t\t\t.append(pageNr)", "\t\t\t\tif (pageNr > PAGE_ONE) {", "\t\t\t\t\taddPagingLink(PREVIOUS_PAGE,name, pageId, pageNr -1L,pagingControls);", "\t\t\t\tif (maxPages > PAGE_ONE && pageNr < maxPages) {", "\t\t\t\t\taddPagingLink(NEXT_PAGE,name, pageId, pageNr +1L,pagingControls);", "\t\t\t\tif (maxPages > LIMIT_FOR_DISPLAYING_START_END_LINKS && pageNr > PAGE_ONE) {", "\t\t\t\tif (maxPages > LIMIT_FOR_DISPLAYING_START_END_LINKS && pageNr < maxPages) {"], "resultPerPage": ["\t\t\tfinal int resultPerPage) {", "\t\t\t\tfinal long maxPages = (size +resultPerPage-1) / resultPerPage;", "\t\t\t\t.append(maxPages)", "\t\t\t\t.append(resultPerPage)", "\t\t\t\tif (maxPages > PAGE_ONE && pageNr < maxPages) {", "\t\t\t\tif (maxPages > LIMIT_FOR_DISPLAYING_START_END_LINKS && pageNr > PAGE_ONE) {", "\t\t\t\tif (maxPages > LIMIT_FOR_DISPLAYING_START_END_LINKS && pageNr < maxPages) {", "\t\t\t\t\taddPagingLink(LAST_PAGE,name, pageId, maxPages,pagingControls);"]}
{"label": ["private void addPagingLink(final String label, final String name, final String pageId, final long maxPages, final HorizontalLayout pagingControls) {", "\t\tfinal Link previousPageLink = pageLinkFactory.createAdminPagingLink(label,name, pageId, String.valueOf(maxPages));"], "name": ["private void addPagingLink(final String label, final String name, final String pageId, final long maxPages, final HorizontalLayout pagingControls) {", "\t\tfinal Link previousPageLink = pageLinkFactory.createAdminPagingLink(label,name, pageId, String.valueOf(maxPages));"], "pageId": ["private void addPagingLink(final String label, final String name, final String pageId, final long maxPages, final HorizontalLayout pagingControls) {", "\t\tfinal Link previousPageLink = pageLinkFactory.createAdminPagingLink(label,name, pageId, String.valueOf(maxPages));"], "maxPages": ["private void addPagingLink(final String label, final String name, final String pageId, final long maxPages, final HorizontalLayout pagingControls) {", "\t\tfinal Link previousPageLink = pageLinkFactory.createAdminPagingLink(label,name, pageId, String.valueOf(maxPages));", "\t\tpagingControls.addComponent(previousPageLink);", "\t\tpagingControls.setExpandRatio(previousPageLink, ContentRatio.SMALL);"], "pagingControls": ["private void addPagingLink(final String label, final String name, final String pageId, final long maxPages, final HorizontalLayout pagingControls) {", "\t\tpagingControls.addComponent(previousPageLink);", "\t\tpagingControls.setExpandRatio(previousPageLink, ContentRatio.SMALL);"]}
{"ksession": ["private static void insertPolitician(final KieSession ksession, final ViewRiksdagenPolitician politicianData,", "\t\t\t\tksession.insert(politicianComplianceCheckImpl);", "\t\t\tksession.insert(politicianComplianceCheckImpl);"], "politicianData": ["private static void insertPolitician(final KieSession ksession, final ViewRiksdagenPolitician politicianData,", "\t\tif (politicianData.isActiveParliament() && dailyList != null && monthlyList != null && annualList != null) {", "\t\t\t\t\t\tpoliticianData, dailyListFirst.get(), monthlyListFirst.get(), annualListFirst.get(),", "\t\t\t\t\tpoliticianData, null, null, null, new ArrayList<>());"], "dailyList": ["\t\t\tfinal List<ViewRiksdagenVoteDataBallotPoliticianSummaryDaily> dailyList,", "\t\tif (politicianData.isActiveParliament() && dailyList != null && monthlyList != null && annualList != null) {", "\t\t\tCollections.sort(dailyList,", "\t\t\tfinal Optional<ViewRiksdagenVoteDataBallotPoliticianSummaryDaily> dailyListFirst = dailyList.stream()"], "monthlyList": ["\t\t\tfinal List<ViewRiksdagenVoteDataBallotPoliticianSummaryMonthly> monthlyList,", "\t\tif (politicianData.isActiveParliament() && dailyList != null && monthlyList != null && annualList != null) {", "\t\t\tCollections.sort(monthlyList,", "\t\t\tfinal Optional<ViewRiksdagenVoteDataBallotPoliticianSummaryMonthly> monthlyListFirst = monthlyList.stream()"], "annualList": ["\t\t\tfinal List<ViewRiksdagenVoteDataBallotPoliticianSummaryAnnual> annualList,", "\t\tif (politicianData.isActiveParliament() && dailyList != null && monthlyList != null && annualList != null) {", "\t\t\tCollections.sort(annualList,", "\t\t\tfinal Optional<ViewRiksdagenVoteDataBallotPoliticianSummaryAnnual> annualListFirst = annualList.stream()"], "decisionList": ["\t\t\tfinal List<ViewRiksdagenCommitteeBallotDecisionPoliticianSummary> decisionList) {", "\t\t\t\tfinal PoliticianComplianceCheckImpl politicianComplianceCheckImpl = new PoliticianComplianceCheckImpl(", "\t\t\t\t\t\tdecisionList);", "\t\t\t\tksession.insert(politicianComplianceCheckImpl);"]}
{"ksession": ["private static void insertParty(final KieSession ksession, final ViewRiksdagenPartySummary partyData,", "\t\t\t\tksession.insert(politicianComplianceCheckImpl);", "\t\t\tksession.insert(politicianComplianceCheckImpl);"], "partyData": ["private static void insertParty(final KieSession ksession, final ViewRiksdagenPartySummary partyData,", "\t\tif (partyData.isActiveParliament() && dailyList != null && monthlyList != null && annualList != null) {", "\t\t\t\tfinal PartyComplianceCheckImpl politicianComplianceCheckImpl = new PartyComplianceCheckImpl(partyData,", "\t\t\tfinal PartyComplianceCheckImpl politicianComplianceCheckImpl = new PartyComplianceCheckImpl(partyData, null,"], "dailyList": ["\t\t\tfinal List<ViewRiksdagenVoteDataBallotPartySummaryAnnual> dailyList,", "\t\tif (partyData.isActiveParliament() && dailyList != null && monthlyList != null && annualList != null) {", "\t\t\tCollections.sort(dailyList,", "\t\t\tfinal Optional<ViewRiksdagenVoteDataBallotPartySummaryAnnual> dailyListFirst = dailyList.stream()"], "monthlyList": ["\t\t\tfinal List<ViewRiksdagenVoteDataBallotPartySummaryMonthly> monthlyList,", "\t\tif (partyData.isActiveParliament() && dailyList != null && monthlyList != null && annualList != null) {", "\t\t\tCollections.sort(monthlyList,", "\t\t\tfinal Optional<ViewRiksdagenVoteDataBallotPartySummaryMonthly> monthlyListFirst = monthlyList.stream()"], "annualList": ["\t\t\tfinal List<ViewRiksdagenVoteDataBallotPartySummaryDaily> annualList,", "\t\tif (partyData.isActiveParliament() && dailyList != null && monthlyList != null && annualList != null) {", "\t\t\tCollections.sort(annualList,", "\t\t\tfinal Optional<ViewRiksdagenVoteDataBallotPartySummaryDaily> annualListFirst = annualList.stream()"], "ballotDecisions": ["\t\t\tfinal List<ViewRiksdagenCommitteeBallotDecisionPartySummary> ballotDecisions) {", "\t\t\t\tfinal PartyComplianceCheckImpl politicianComplianceCheckImpl = new PartyComplianceCheckImpl(partyData,", "\t\t\t\t\t\tdailyListFirst.get(), monthlyListFirst.get(), annualListFirst.get(), ballotDecisions);", "\t\t\t\tksession.insert(politicianComplianceCheckImpl);"]}
{"Result": "Method without Parameter"}
{"dataSeries": ["private static void addDataSerieValue(final DataSeries dataSeries, final Entry entry,", "\t\t\tdataSeries.add(FIRST_OF_JAN + entry.getKey(), value);"], "entry": ["private static void addDataSerieValue(final DataSeries dataSeries, final Entry entry,", "\t\tif (entry.getKey() != null && value > 0) {", "\t\t\tdataSeries.add(FIRST_OF_JAN + entry.getKey(), value);"], "value": ["\t\t\tfinal int value) {", "\t\tif (entry.getKey() != null && value > 0) {", "\t\t\tdataSeries.add(FIRST_OF_JAN + entry.getKey(), value);"]}
{"report": ["private void addAnnualSummary(final Map<String, List<GovernmentBodyAnnualOutcomeSummary>> report, final VerticalLayout content,", "\t\tfor (final Entry<String, List<GovernmentBodyAnnualOutcomeSummary>> entry : report.entrySet()) {", "\t\t\tfinal List<GovernmentBodyAnnualOutcomeSummary> allValues = entry.getValue();", "\t\t\tif (!allValues.isEmpty()) {", "\t\t\t\taddAnnualSummaryData(dataSeries, series, entry, allValues);"], "content": ["private void addAnnualSummary(final Map<String, List<GovernmentBodyAnnualOutcomeSummary>> report, final VerticalLayout content,", "\t\taddChart(content, label,"], "label": ["\t\t\tfinal String label) {", "\t\taddChart(content, label,"]}
{"dataSeries": ["private static void addAnnualSummaryData(final DataSeries dataSeries, final Series series,", "\t\tdataSeries.newSeries();", "\t\t\t\tdataSeries.add(data.getKey() + FIRST_JAN_DATA_SUFFIX, (int) sum);"], "series": ["private static void addAnnualSummaryData(final DataSeries dataSeries, final Series series,", "\t\tseries.addSeries(new XYseries().setLabel(entry.getKey()).setShowLabel(true));"], "entry": ["\t\t\tfinal Entry<String, List<GovernmentBodyAnnualOutcomeSummary>> entry,", "\t\tseries.addSeries(new XYseries().setLabel(entry.getKey()).setShowLabel(true));"], "allValues": ["\t\t\tfinal List<GovernmentBodyAnnualOutcomeSummary> allValues) {", "\t\tfinal Map<Integer, List<GovernmentBodyAnnualOutcomeSummary>> map = allValues.stream()"]}
{"content": ["private void addAnnualData(final VerticalLayout content, final String name, final String label,", "\t\taddChart(content, name + label,"], "name": ["private void addAnnualData(final VerticalLayout content, final String name, final String label,", "\t\taddChart(content, name + label,"], "label": ["private void addAnnualData(final VerticalLayout content, final String name, final String label,", "\t\taddChart(content, name + label,"], "collect": ["\t\t\tfinal Map<String, List<GovernmentBodyAnnualOutcomeSummary>> collect) {", "\t\tfor (final Entry<String, List<GovernmentBodyAnnualOutcomeSummary>> entry : collect.entrySet()) {", "\t\t\tseries.addSeries(new XYseries().setLabel(entry.getKey()));", "\t\t\taddEntryData(dataSeries, simpleDateFormat, entry);"]}
{"dataSeries": ["private static void addEntryData(final DataSeries dataSeries, final SimpleDateFormat simpleDateFormat,", "\t\t\t\t\tdataSeries.add(simpleDateFormat.format(entryData.getKey()) , entryData.getValue().intValue());"], "simpleDateFormat": ["private static void addEntryData(final DataSeries dataSeries, final SimpleDateFormat simpleDateFormat,", "\t\t\t\t\tdataSeries.add(simpleDateFormat.format(entryData.getKey()) , entryData.getValue().intValue());"], "entry": ["\t\t\tfinal Entry<String, List<GovernmentBodyAnnualOutcomeSummary>> entry) {", "\t\tfor (final GovernmentBodyAnnualOutcomeSummary data : entry.getValue()) {", "\t\t\tfinal Map<Date, Double> valueMap = data.getValueMap();", "\t\t\tfor (final Entry<Date, Double> entryData : valueMap.entrySet()) {", "\t\t\t\tif (entryData.getValue() != null && entryData.getValue().intValue() > 0) {", "\t\t\t\t\tdataSeries.add(simpleDateFormat.format(entryData.getKey()) , entryData.getValue().intValue());"]}
{"content": ["private void createMinistrySummary(final AbstractOrderedLayout content, final String field, final String label) {", "\t\taddChart(content, label,"], "field": ["private void createMinistrySummary(final AbstractOrderedLayout content, final String field, final String label) {", "\t\t\tfinal Map<Integer, Double> annualSummaryMap = entry.getValue().stream().filter(t -> t.getDescriptionFields().get(field) != null).collect(Collectors.groupingBy(GovernmentBodyAnnualOutcomeSummary::getYear,Collectors.summingDouble(GovernmentBodyAnnualOutcomeSummary::getYearTotal)));\t\t\t", "\t\t\tfor (final Entry<Integer, Double> entryData : annualSummaryMap.entrySet()) {", "\t\t\t\tif (entryData.getValue() != null && entryData.getValue().intValue() > 0) {", "\t\t\t\t\tdataSeries.add(entryData.getKey() +1  +\"-01-01\" , entryData.getValue());"], "label": ["private void createMinistrySummary(final AbstractOrderedLayout content, final String field, final String label) {", "\t\taddChart(content, label,"]}
{"roleSummaryLayoutTabsheet": ["private void createRoleList(final VerticalLayout roleSummaryLayoutTabsheet,", "\t\tgetGridFactory().createBasicBeanItemGrid(roleSummaryLayoutTabsheet, AssignmentData.class, assignmentList,"], "assignmentList": ["\t\t\tfinal List<AssignmentData> assignmentList) {", "\t\tCollections.sort(assignmentList, compare);", "\t\tgetGridFactory().createBasicBeanItemGrid(roleSummaryLayoutTabsheet, AssignmentData.class, assignmentList,"]}
{"dokument": ["private static void processAll(final List<DocumentElement> dokument,", "\t\tfor (final DocumentElement documentElement : dokument) {", "\t\t\t\tprocessStrategy.process(documentElement);", "\t\t\t\tLOGGER.warn(ERROR_PROCESSING_DOCUMENT, documentElement.getId(), e);"], "processStrategy": ["\t\t\tfinal ProcessDataStrategy<DocumentElement> processStrategy) {", "\t\t\t\tprocessStrategy.process(documentElement);"]}
{"url": ["private void loadAndProcessDocumentList(final String url,", "\t\t\t\triksdagenDocumentListMarshaller, url, HTTP_DOKUMENTLISTA_RIKSDAGEN_EXTERNAL_MODEL_CIA_HACK23_COM_IMPL,", "\t\t\tfinal DocumentContainerElement otherPagesdokumentLista = ((JAXBElement<DocumentContainerElement>) xmlAgent", "\t\t\t\t\t.unmarshallXml(riksdagenDocumentListMarshaller, url + PAGE_PROPERTY + i,", "\t\t\tresultSize = resultSize + otherPagesdokumentLista.getDokument().size();", "\t\t\tprocessAll(otherPagesdokumentLista.getDokument(), processStrategy);", "\t\t\tLOGGER.info(LOADING_DOCUMENTS, resultSize, dokumentLista.getHits());"], "processStrategy": ["\t\t\tfinal ProcessDataStrategy<DocumentElement> processStrategy) throws XmlAgentException {", "\t\tprocessAll(dokumentLista.getDokument(), processStrategy);", "\t\t\tprocessAll(otherPagesdokumentLista.getDokument(), processStrategy);"]}
{"url": ["private List<DocumentElement> loadDocumentList(final String url, final int maxNumberPages) throws XmlAgentException {", "\t\t\t\triksdagenDocumentListMarshaller, url, HTTP_DOKUMENTLISTA_RIKSDAGEN_EXTERNAL_MODEL_CIA_HACK23_COM_IMPL,"], "maxNumberPages": ["private List<DocumentElement> loadDocumentList(final String url, final int maxNumberPages) throws XmlAgentException {", "\t\tfor (int i = 1; i < pages.intValue() && i < maxNumberPages; i++) {"]}
{"fr": ["private static String readWithStringBuffer(final Reader fr) throws IOException {", "\t\tfinal BufferedReader br = new BufferedReader(fr);", "\t\twhile ((line = br.readLine()) != null) {", "\t\t\tresult.append(line);"]}
{"accessUrl": ["private static String readInputStream(final String accessUrl) throws IOException {", "\t\tfinal URL url = new URL(accessUrl.replace(\" \", \"\"));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"serviceRequest": ["private UserAccount createUserAccount(final RegisterUserRequest serviceRequest) {", "\t\tuserAccount.setCountry(serviceRequest.getCountry());", "\t\tuserAccount.setEmail(serviceRequest.getEmail());", "\t\tuserAccount.setUsername(serviceRequest.getUsername());", "\t\t\t\tpasswordEncoder.encode(userAccount.getUserId() + \".uuid\" + serviceRequest.getUserpassword()));", "\t\tif ( serviceRequest.getUserType() == null) {", "\t\t\tuserAccount.setUserType(serviceRequest.getUserType());"]}
{"row": ["public static void createRowItem(final ResponsiveRow row, final Button button, final String description) {", "\t\trow.addColumn().withDisplayRules(DISPLAY_SIZE_XS_DEVICE, DISPLAYS_SIZE_XM_DEVICE, DISPLAY_SIZE_MD_DEVICE,"], "button": ["public static void createRowItem(final ResponsiveRow row, final Button button, final String description) {", "\t\tbutton.addStyleName(ITEMBOX);", "\t\tbutton.addStyleName(TITLE);", "\t\tResponsive.makeResponsive(button);", "\t\tbutton.setWidth(100, Unit.PERCENTAGE);", "\t\tlayout.addComponent(button);"], "description": ["public static void createRowItem(final ResponsiveRow row, final Button button, final String description) {", "\t\tfinal Label descriptionLabel = new Label(description);", "\t\tdescriptionLabel.addStyleName(ITEMBOX);", "\t\tResponsive.makeResponsive(descriptionLabel);", "\t\tdescriptionLabel.setWidth(100, Unit.PERCENTAGE);", "\t\tlayout.addComponent(descriptionLabel);"]}
{"panelContent": ["public static ResponsiveRow createGridLayout(final AbstractOrderedLayout panelContent) {", "\t\tpanelContent.addComponent(layout);", "\t\tpanelContent.setExpandRatio(layout, ContentRatio.LARGE);"]}
{"currentSaved": ["private void sendCountryIndicatorWorkOrder(final Map<String, String> currentSaved, final List<String> indicators,", "\t\t\t\t\t&& !currentSaved.containsKey(countryIso2Code + '.' + indicator)) {"], "indicators": ["private void sendCountryIndicatorWorkOrder(final Map<String, String> currentSaved, final List<String> indicators,", "\t\tfor (final String indicator : indicators) {", "\t\t\t\t\t&& !currentSaved.containsKey(countryIso2Code + '.' + indicator)) {", "\t\t\t\tload.add(indicator);"], "countryIso2Code": ["\t\t\tfinal String countryIso2Code) {", "\t\t\tif (countryIso2Code != null && countryIso2Code.length() > 0", "\t\t\t\t\t&& !currentSaved.containsKey(countryIso2Code + '.' + indicator)) {", "\t\t\t\tload.add(countryIso2Code);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"dataSeries": ["private static void addDocumentHistoryByPartyData(final DataSeries dataSeries, final Series series,", "\t\t\tdataSeries.newSeries();", "\t\t\t\t\tdataSeries.add(simpleDateFormat.format(item.getEmbeddedId().getPublicDate()), item.getTotal());"], "series": ["private static void addDocumentHistoryByPartyData(final DataSeries dataSeries, final Series series,", "\t\t\tseries.addSeries(new XYseries().setLabel(entry.getKey()));"], "map": ["\t\t\tfinal Map<String, List<ViewRiksdagenPartyDocumentDailySummary>> map) {", "\t\tfor (final Entry<String, List<ViewRiksdagenPartyDocumentDailySummary>> entry : map.entrySet()) {", "\t\t\tseries.addSeries(new XYseries().setLabel(entry.getKey()));", "\t\t\tif (entry.getValue() != null) {", "\t\t\t\tfor (final ViewRiksdagenPartyDocumentDailySummary item : entry.getValue()) {", "\t\t\t\t\tdataSeries.add(simpleDateFormat.format(item.getEmbeddedId().getPublicDate()), item.getTotal());", "\t\t\t\tLOGGER.info(LOG_MSG_MISSING_DATA_FOR_KEY, entry);"]}
{"Result": "Method without Parameter"}
{"stringBuilder": ["private void appendObjectPresentation(final StringBuilder stringBuilder, final Object object) {", "\t\t\t\tstringBuilder.append(beanProperty);", "\t\t\t\taddFallbackValue(stringBuilder, object);", "\t\tstringBuilder.append(CONTENT_SEPARATOR);"], "object": ["private void appendObjectPresentation(final StringBuilder stringBuilder, final Object object) {", "\t\t\tfinal String beanProperty = BeanUtils.getProperty(object, property);", "\t\t\t\taddFallbackValue(stringBuilder, object);", "\t\t\tLOGGER.warn(\"Problem getting property {}, object {} , exception {}\", property, object, e);"]}
{"stringBuilder": ["private void addFallbackValue(final StringBuilder stringBuilder, final Object object)", "\t\t\t\tstringBuilder.append(beanPropertyFallBack);"], "object": ["private void addFallbackValue(final StringBuilder stringBuilder, final Object object)", "\t\t\tfinal String beanPropertyFallBack = BeanUtils.getProperty(object, fallbackColumn);"]}
{"serviceRequest": ["private void reencryptVaultValues(final ChangePasswordRequest serviceRequest, final UserAccount userAccount) {", "\t\tfinal String authKey= vaultManager.getEncryptedValue(serviceRequest.getCurrentPassword(), userAccount);", "\t\t\tencryptedValue.setStorage(vaultManager.encryptValue(serviceRequest.getNewPassword(), userAccount.getUserId(), authKey));"], "userAccount": ["private void reencryptVaultValues(final ChangePasswordRequest serviceRequest, final UserAccount userAccount) {", "\t\tfinal String authKey= vaultManager.getEncryptedValue(serviceRequest.getCurrentPassword(), userAccount);", "\t\tif (authKey != null) {", "\t\t\tfinal EncryptedValue encryptedValue = encryptedValueDAO.findFirstByProperty(EncryptedValue_.userId, userAccount.getUserId());\t\t\t\t\t", "\t\t\tencryptedValue.setStorage(vaultManager.encryptValue(serviceRequest.getNewPassword(), userAccount.getUserId(), authKey));"]}
{"Result": "Method without Parameter"}
{"stringBuilder": ["private static void addCommiteeSummary(final StringBuilder stringBuilder,", "\t\t\tstringBuilder.append('\\n').append(vewRiksdagenCommittee.get().getEmbeddedId().getDetail());", "\t\t\t\t\taddEntry(stringBuilder, entry, docEntry);"], "entry": ["\t\t\tfinal Entry<String, List<ProposalCommitteeeSummary>> entry,", "\t\t\tfinal Map<String, List<ProposalCommitteeeSummary>> docTypeMap = entry.getValue().stream()", "\t\t\t\tif (docEntry.getKey().length() > 0 && entry.getKey().length() > 0) {\t\t\t\t\t", "\t\t\t\t\taddEntry(stringBuilder, entry, docEntry);"], "vewRiksdagenCommittee": ["\t\t\tfinal Optional<ViewRiksdagenCommittee> vewRiksdagenCommittee) {\t\t", "\t\tif (vewRiksdagenCommittee.isPresent()) {", "\t\t\tstringBuilder.append('\\n').append(vewRiksdagenCommittee.get().getEmbeddedId().getDetail());"]}
{"stringBuilder": ["private static void addEntry(final StringBuilder stringBuilder,", "\t\tstringBuilder.append(\"( \").append(docEntry.getValue().size()).append(' ').append(docEntry.getKey()).append(\" -> \"); ", "\t\t\t\tstringBuilder.append(decisionEntry.getValue().size()).append(' ').append(decisionEntry.getKey()).append(' ');", "\t\tstringBuilder.append(')');"], "entry": ["\t\t\tfinal Entry<String, List<ProposalCommitteeeSummary>> entry,", "\t\t\tif (decisionEntry.getKey().length() > 0 && entry.getKey().length() > 0) {\t\t\t\t\t\t\t\t\t"], "docEntry": ["\t\t\tfinal Entry<String, List<ProposalCommitteeeSummary>> docEntry) {", "\t\tstringBuilder.append(\"( \").append(docEntry.getValue().size()).append(' ').append(docEntry.getKey()).append(\" -> \"); ", "\t\tfinal Map<String, List<ProposalCommitteeeSummary>> decisionMap = docEntry.getValue().stream()"]}
{"chart": ["private static void addDecisionDataRows(final SankeyChart chart,", "\t\t\t\tchart.addDataRow(vewRiksdagenCommittee.getEmbeddedId().getDetail(), decisionEntry.getKey(),"], "entry": ["\t\t\tfinal Entry<String, List<ProposalCommitteeeSummary>> entry,", "\t\tfinal Map<String, List<ProposalCommitteeeSummary>> decisionMap = entry.getValue().stream()", "\t\t\tif (decisionEntry.getKey().length() > 0 && entry.getKey().length() > 0) {"], "vewRiksdagenCommittee": ["\t\t\tfinal ViewRiksdagenCommittee vewRiksdagenCommittee) {", "\t\t\t\tchart.addDataRow(vewRiksdagenCommittee.getEmbeddedId().getDetail(), decisionEntry.getKey(),"]}
{"chart": ["private static void addDocTypeDataRows(final SankeyChart chart,", "\t\t\t\tchart.addDataRow(docEntry.getKey(), vewRiksdagenCommittee.getEmbeddedId().getDetail(),"], "entry": ["\t\t\tfinal Entry<String, List<ProposalCommitteeeSummary>> entry,", "\t\tfinal Map<String, List<ProposalCommitteeeSummary>> docTypeMap = entry.getValue().stream()", "\t\t\tif (docEntry.getKey().length() > 0 && entry.getKey().length() > 0) {"], "vewRiksdagenCommittee": ["\t\t\tfinal ViewRiksdagenCommittee vewRiksdagenCommittee) {", "\t\t\t\tchart.addDataRow(docEntry.getKey(), vewRiksdagenCommittee.getEmbeddedId().getDetail(),"]}
{"chart": ["private static void addDocTypeDecisionDataRows(final SankeyChart chart,", "\t\t\t\t\tchart.addDataRow(docEntry.getKey(), decisionEntry.getKey(), decisionEntry.getValue().size());"], "entry": ["\t\t\tfinal Entry<String, List<ProposalCommitteeeSummary>> entry) {", "\t\tfinal Map<String, List<ProposalCommitteeeSummary>> docTypeMap = entry.getValue().stream()", "\t\t\t\tif (decisionEntry.getKey().length() > 0 && entry.getKey().length() > 0) {"]}
{"Result": "Method without Parameter"}
{"current": ["public static String getRequestUrl(final Page current) {", "\t\tif (current != null) {", "\t\t\treturn current.getLocation().toString();"]}
{"role": ["public static boolean allowRoleInSecurityContext(final String role) {", "\t\t\t\tif (role.equalsIgnoreCase(grantedAuthority.getAuthority())) {"]}
{"Result": "Method without Parameter"}
{"page": ["\t\t\tfinal String page) {", "\t\t\t\t\t\tApplicationActionEventPageModePeriodSummaryEmbeddedId_.page, page,"]}
{"page": ["\t\t\tfinal String page, final String elementId) {", "\t\t\t\t.filter(t -> t != null && t.getEmbeddedId().getPage().equals(page)).collect(Collectors.toList());"], "elementId": ["\t\t\tfinal String page, final String elementId) {", "\t\t\t\t\t\tApplicationActionEventPageElementPeriodSummaryEmbeddedId_.elementId, elementId,"]}
{"label": ["private static void addViewApplicationActionEventPageElementDailySummaryValues(final String label,", "\t\tseries.addSeries(new XYseries().setLabel(label));"], "series": ["\t\t\tfinal Series series, final List<ViewApplicationActionEventPageElementDailySummary> list,", "\t\tseries.addSeries(new XYseries().setLabel(label));"], "list": ["\t\t\tfinal Series series, final List<ViewApplicationActionEventPageElementDailySummary> list,", "\t\tfor (final ViewApplicationActionEventPageElementDailySummary item : list) {", "\t\t\tdataSeries.add(simpleDateFormat.format(item.getEmbeddedId().getCreatedDate()), t.applyAsLong(item));"], "dataSeries": ["\t\t\tfinal DataSeries dataSeries, final SimpleDateFormat simpleDateFormat,", "\t\tdataSeries.newSeries();", "\t\t\tdataSeries.add(simpleDateFormat.format(item.getEmbeddedId().getCreatedDate()), t.applyAsLong(item));"], "simpleDateFormat": ["\t\t\tfinal DataSeries dataSeries, final SimpleDateFormat simpleDateFormat,", "\t\t\tdataSeries.add(simpleDateFormat.format(item.getEmbeddedId().getCreatedDate()), t.applyAsLong(item));"], "t": ["\t\t\tfinal ToLongFunction<ViewApplicationActionEventPageElementDailySummary> t) {", "\t\t\tdataSeries.add(simpleDateFormat.format(item.getEmbeddedId().getCreatedDate()), t.applyAsLong(item));"]}
{"exist": ["private static void updatePersonAssignmentData(final PersonAssignmentData exist, final PersonAssignmentData update) {", "\t\t\tupdateAssignmentData(exist.getAssignmentList(), assignmentData);"], "update": ["private static void updatePersonAssignmentData(final PersonAssignmentData exist, final PersonAssignmentData update) {", "\t\tfinal List<AssignmentData> assignmentList = update.getAssignmentList();"]}
{"assignmentList": ["private static void updateAssignmentData(final List<AssignmentData> assignmentList, final AssignmentData assignmentData) {", "\t\tfor (final AssignmentData matchAssignmentData : assignmentList) {", "\t\t\tif (matchAssignmentData.getFromDate().equals(assignmentData.getFromDate())", "\t\t\t\t\t&& matchAssignmentData.getOrgCode().equals(assignmentData.getOrgCode()) && matchAssignmentData.getRoleCode().equals(assignmentData.getRoleCode())) {", "\t\t\t\tmatchAssignmentData.setStatus(assignmentData.getStatus());", "\t\t\t\tmatchAssignmentData.setToDate(assignmentData.getToDate());", "\t\tassignmentList.add(assignmentData);"], "assignmentData": ["private static void updateAssignmentData(final List<AssignmentData> assignmentList, final AssignmentData assignmentData) {", "\t\t\tif (matchAssignmentData.getFromDate().equals(assignmentData.getFromDate())", "\t\t\t\t\t&& matchAssignmentData.getOrgCode().equals(assignmentData.getOrgCode()) && matchAssignmentData.getRoleCode().equals(assignmentData.getRoleCode())) {", "\t\t\t\tmatchAssignmentData.setStatus(assignmentData.getStatus());", "\t\t\t\tmatchAssignmentData.setToDate(assignmentData.getToDate());", "\t\tassignmentList.add(assignmentData);"]}
{"serviceRequest": ["protected final V inputValidation(final T serviceRequest) {", "\t\tfinal Set<ConstraintViolation<T>> validateRequest = validateRequest(serviceRequest);", "\t\tif (!validateRequest.isEmpty()) {", "\t\t\tfinal CreateApplicationEventRequest eventRequest = createApplicationEventForService(serviceRequest);", "\t\t\thandleInputViolations(eventRequest, validateRequest, response);", "\t\t\tcreateApplicationEventService.processService(eventRequest);"]}
{"Result": "Method without Parameter"}
{"request": ["private Set<ConstraintViolation<T>> validateRequest(final T request) {", "        return factory.getValidator().validate( request );"]}
{"requestConstraintViolations": ["private String getHumanMessage(final Set<ConstraintViolation<T>> requestConstraintViolations) {", "\t\treturn requestConstraintViolations.stream()"]}
{"eventRequest": ["private void handleInputViolations(final CreateApplicationEventRequest eventRequest,", "\t\teventRequest.setErrorMessage(errorMessage);"], "requestConstraintViolations": ["\t\t\tfinal Set<ConstraintViolation<T>> requestConstraintViolations,final V response) {", "\t\tfinal String errorMessage = getHumanMessage(requestConstraintViolations);", "\t\t((AbstractResponse) response).setErrorMessage(errorMessage);", "\t\teventRequest.setErrorMessage(errorMessage);"], "response": ["\t\t\tfinal Set<ConstraintViolation<T>> requestConstraintViolations,final V response) {", "\t\t((AbstractResponse) response).setErrorMessage(errorMessage);"]}
{"verticalLayout": ["private void createDataIndicatorSummaryChartPanel(final VerticalLayout verticalLayout,final String indicator) {", "\t\t\tgetFormFactory().addFormPanelTextFields(verticalLayout,", "\t\tchartDataManager.createIndicatorChart(verticalLayout,dataList,indicatorSummaryValue);"], "indicator": ["private void createDataIndicatorSummaryChartPanel(final VerticalLayout verticalLayout,final String indicator) {", "\t\t\t\t.filter(t -> t != null && t.getEmbeddedId().getIndicatorId().equals(indicator)).findFirst();", "\t\tfinal List<WorldBankData> dataList = dataContainer.findListByEmbeddedProperty(WorldBankData.class, WorldBankData_.indicator, Indicator.class, Indicator_.id, indicator);", "\t\tchartDataManager.createIndicatorChart(verticalLayout,dataList,indicatorSummaryValue);"]}
{"menuBar": ["protected final void initApplicationMenuBar(final MenuBar menuBar) {", "\t\tmenuBar.removeItems();", "\t\tmenuBar.setWidth(MENU_BAR_WIDTH);", "\t\tmenuBar.setStyleName(HEADER_STYLE_NAME);", "\t\tfinal MenuItem mainViewItem = menuBar.addItem(APPLICATION, VaadinIcons.SERVER, null);"]}
{"mainViewItem": ["private static void createAdminMenu(final MenuItem mainViewItem) {", "\t\t\tfinal MenuItem adminMenuItem = mainViewItem.addItem(ADMIN_TEXT, VaadinIcons.SERVER, null);"]}
{"row": ["protected final void createButtonLink(final ResponsiveRow row,final String linkText,final Resource icon, final ClickListener command, final String description) {", "\t\trow.addColumn().withDisplayRules(DISPLAY_SIZE_XS_DEVICE,DISPLAYS_SIZE_XM_DEVICE,DISPLAY_SIZE_MD_DEVICE,DISPLAY_SIZE_LG_DEVICE).withComponent(layout);"], "linkText": ["protected final void createButtonLink(final ResponsiveRow row,final String linkText,final Resource icon, final ClickListener command, final String description) {", "\t\tfinal Button button = new Button(linkText);", "\t\tResponsive.makeResponsive(button);", "\t\tbutton.setStyleName(LINK_STYLE_NAME);", "\t\tbutton.addStyleName(\"title\");", "\t\tbutton.addClickListener(command);", "\t\tbutton.setIcon(icon);", "\t\tbutton.setWidth(100, Unit.PERCENTAGE);", "\t\tlayout.addComponent(button);"], "icon": ["protected final void createButtonLink(final ResponsiveRow row,final String linkText,final Resource icon, final ClickListener command, final String description) {", "\t\tbutton.setIcon(icon);"], "command": ["protected final void createButtonLink(final ResponsiveRow row,final String linkText,final Resource icon, final ClickListener command, final String description) {", "\t\tbutton.addClickListener(command);"], "description": ["protected final void createButtonLink(final ResponsiveRow row,final String linkText,final Resource icon, final ClickListener command, final String description) {", "\t\tfinal Label descriptionLabel = new Label(description);", "\t\tdescriptionLabel.addStyleName(\"itembox\");", "\t\tResponsive.makeResponsive(descriptionLabel);", "\t\tdescriptionLabel.setWidth(100, Unit.PERCENTAGE);", "\t\tlayout.addComponent(descriptionLabel);"]}
{"resultElement": ["public void setResultElement(final List<DocumentElement> resultElement) {", "\t\tif (resultElement != null) {", "\t\t\tthis.resultElement = resultElement.stream().collect(Collectors.toList());"]}
{"Result": "Method without Parameter"}
{"txManager": ["\tpublic Javers getJavers(final PlatformTransactionManager txManager) {", "\t\treturn TransactionalJaversBuilder.javers().withTxManager(txManager)"]}
{"javers": ["\tpublic JaversAuditableAspect javersAuditableAspect(final Javers javers, final AuthorProvider authorProvider,", "\t\treturn new JaversAuditableAspect(javers, authorProvider, commitPropertiesProvider);"], "authorProvider": ["\tpublic JaversAuditableAspect javersAuditableAspect(final Javers javers, final AuthorProvider authorProvider,", "\t\treturn new JaversAuditableAspect(javers, authorProvider, commitPropertiesProvider);"], "commitPropertiesProvider": ["\t\t\tfinal CommitPropertiesProvider commitPropertiesProvider) {", "\t\treturn new JaversAuditableAspect(javers, authorProvider, commitPropertiesProvider);"]}
{"Result": "Method without Parameter"}
{"roleSummaryLayoutTabsheet": ["private void createRoleSummary(final VerticalLayout roleSummaryLayoutTabsheet,", "\t\troleSummaryLayoutTabsheet.addComponent(layout);", "\t\troleSummaryLayoutTabsheet.setExpandRatio(layout, ContentRatio.GRID);"], "assignmentList": ["\t\t\tfinal List<AssignmentData> assignmentList, final ViewRiksdagenPolitician viewRiksdagenPolitician) {", "\t\tlayout.addComponent(new Label(TOTAL_ASSIGNMENTS + assignmentList.size()));"], "viewRiksdagenPolitician": ["\t\t\tfinal List<AssignmentData> assignmentList, final ViewRiksdagenPolitician viewRiksdagenPolitician) {", "\t\tif (viewRiksdagenPolitician != null) {", "\t\t\t\t\t+ convertToYearsString(viewRiksdagenPolitician.getTotalDaysServedGovernment())));", "\t\t\t\t\tSPEAKER_EXPERIENCE + convertToYearsString(viewRiksdagenPolitician.getTotalDaysServedSpeaker())));", "\t\t\t\t\t+ convertToYearsString(viewRiksdagenPolitician.getTotalDaysServedCommittee())));", "\t\t\t\t\tnew Label(EU_EXPERIENCE + convertToYearsString(viewRiksdagenPolitician.getTotalDaysServedEu())));", "\t\t\t\t\t+ convertToYearsString(viewRiksdagenPolitician.getTotalDaysServedParliament())));", "\t\t\t\t\tPARTY_EXPERIENCE + convertToYearsString(viewRiksdagenPolitician.getTotalDaysServedParty())));"]}
{"name": ["private static void addMinistryPerYearToMap(final String name,", "\t\t\t\taddGovernmentBodyAnnualSummaryToList(name, year, yearList, rowIterator.next());"], "map": ["\t\t\tfinal Map<Integer, List<GovernmentBodyAnnualSummary>> map, final HSSFSheet mySheet) {", "\t\t\tmap.put(year, yearList);"], "mySheet": ["\t\t\tfinal Map<Integer, List<GovernmentBodyAnnualSummary>> map, final HSSFSheet mySheet) {", "\t\tif (mySheet.getSheetName().chars().allMatch(Character::isDigit)) {", "\t\t\tfinal int year = Integer.parseInt(mySheet.getSheetName());", "\t\t\tfinal Iterator<Row> rowIterator = mySheet.iterator();"]}
{"name": ["private static void addGovernmentBodyAnnualSummaryToList(final String name, final int year,", "\t\t\tif (name == null || name.equalsIgnoreCase(governmentBodyAnnualSummary.getMinistry())) {"], "year": ["private static void addGovernmentBodyAnnualSummaryToList(final String name, final int year,", "\t\t\t\t\tyear, row);"], "yearList": ["\t\t\tfinal List<GovernmentBodyAnnualSummary> yearList, final Row row) {", "\t\t\t\tyearList.add(governmentBodyAnnualSummary);"], "row": ["\t\t\tfinal List<GovernmentBodyAnnualSummary> yearList, final Row row) {", "\t\tif (row.getLastCellNum() >= EXPECTED_COLUMN_LENGTH) {", "\t\t\tfinal GovernmentBodyAnnualSummary governmentBodyAnnualSummary = createGovernmentBodyAnnualSummaryFromRow(", "\t\t\t\t\tyear, row);", "\t\t\tif (name == null || name.equalsIgnoreCase(governmentBodyAnnualSummary.getMinistry())) {", "\t\t\t\tyearList.add(governmentBodyAnnualSummary);"]}
{"str": ["private static int getInteger(final String str) {", "\t\tif (str == null || str.trim().length() == 0) {", "\t\t\treturn Integer.parseInt(str);"]}
{"name": ["private static void addDataForYearToMap(final String name, final Map<Integer, GovernmentBodyAnnualSummary> map,", "\t\t\t\taddGovernmentBodyAnnualSummaryToMap(name, map, year, rowIterator.next());"], "map": ["private static void addDataForYearToMap(final String name, final Map<Integer, GovernmentBodyAnnualSummary> map,", "\t\t\t\taddGovernmentBodyAnnualSummaryToMap(name, map, year, rowIterator.next());"], "mySheet": ["\t\t\tfinal HSSFSheet mySheet) {", "\t\tif (mySheet.getSheetName().chars().allMatch(Character::isDigit)) {", "\t\t\tfinal int year = Integer.parseInt(mySheet.getSheetName());", "\t\t\tfinal Iterator<Row> rowIterator = mySheet.iterator();"]}
{"name": ["private static void addGovernmentBodyAnnualSummaryToMap(final String name, final Map<Integer, GovernmentBodyAnnualSummary> map,", "\t\t\tif (name == null || name.equalsIgnoreCase(governmentBodyAnnualSummary.getName())) {"], "map": ["private static void addGovernmentBodyAnnualSummaryToMap(final String name, final Map<Integer, GovernmentBodyAnnualSummary> map,", "\t\t\t\tmap.put(year, governmentBodyAnnualSummary);"], "year": ["\t\t\tfinal int year, final Row row) {", "\t\t\t\t\tyear, row);", "\t\t\t\tmap.put(year, governmentBodyAnnualSummary);"], "row": ["\t\t\tfinal int year, final Row row) {", "\t\tif (row.getLastCellNum() >= EXPECTED_COLUMN_LENGTH) {", "\t\t\tfinal GovernmentBodyAnnualSummary governmentBodyAnnualSummary = createGovernmentBodyAnnualSummaryFromRow(", "\t\t\t\t\tyear, row);", "\t\t\tif (name == null || name.equalsIgnoreCase(governmentBodyAnnualSummary.getName())) {", "\t\t\t\tmap.put(year, governmentBodyAnnualSummary);"]}
{"year": ["private static GovernmentBodyAnnualSummary createGovernmentBodyAnnualSummaryFromRow(final int year, final Row row) {", "\t\treturn new GovernmentBodyAnnualSummary(year, defaultValueIfNull(row.getCell(NAME_CELL)), getInteger(defaultValueIfNull(row.getCell(CONSECUTIVE_NUMBER_CELL))),"], "row": ["private static GovernmentBodyAnnualSummary createGovernmentBodyAnnualSummaryFromRow(final int year, final Row row) {", "\t\treturn new GovernmentBodyAnnualSummary(year, defaultValueIfNull(row.getCell(NAME_CELL)), getInteger(defaultValueIfNull(row.getCell(CONSECUTIVE_NUMBER_CELL))),", "\t\t\t\tdefaultValueIfNull(row.getCell(GOVERNMENT_BODY_ID_CELL)), defaultValueIfNull(row.getCell(MCODE_CELL)), defaultValueIfNull(row.getCell(MINISTRY_CELL)),", "\t\t\t\tdefaultValueIfNull(row.getCell(ORG_NUMBER_CELL)), getInteger(defaultValueIfNull(row.getCell(HEADCOUNT_CELL))), getInteger(defaultValueIfNull(row.getCell(ANNUAL_HEADCOUNT_CELL))),", "\t\t\t\tdefaultValueIfNull(row.getCell(VAT_CELL)), defaultValueIfNull(row.getCell(COMMENT_CELL)));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"simpleDateFormat": ["private static void addDecisionTypeByOrgData(final SimpleDateFormat simpleDateFormat, final DataSeries dataSeries,", "\t\t\t\t\t\tdataSeries.add(simpleDateFormat.format(item.getEmbeddedId().getDecisionDate()),"], "dataSeries": ["private static void addDecisionTypeByOrgData(final SimpleDateFormat simpleDateFormat, final DataSeries dataSeries,", "\t\t\t\tdataSeries.newSeries();", "\t\t\t\t\t\tdataSeries.add(simpleDateFormat.format(item.getEmbeddedId().getDecisionDate()),"], "series": ["\t\t\tfinal Series series, final Map<String, List<ViewRiksdagenCommitteeDecisionTypeOrgDailySummary>> map) {", "\t\t\t\tseries.addSeries(label);"], "map": ["\t\t\tfinal Series series, final Map<String, List<ViewRiksdagenCommitteeDecisionTypeOrgDailySummary>> map) {", "\t\tfor (final Entry<String, List<ViewRiksdagenCommitteeDecisionTypeOrgDailySummary>> entry : map.entrySet()) {", "\t\t\tif (!EMPTY_STRING.equals(entry.getKey())) {", "\t\t\t\tlabel.setLabel(entry.getKey());", "\t\t\t\tfor (final ViewRiksdagenCommitteeDecisionTypeOrgDailySummary item : entry.getValue()) {", "\t\t\t\t\t\tdataSeries.add(simpleDateFormat.format(item.getEmbeddedId().getDecisionDate()),", "\t\t\t\t\t\t\t\titem.getTotal());"]}
{"panelContent": ["private static void displayDocumentAttachements(final VerticalLayout panelContent,", "\t\t\t\tpanelContent.addComponent(wtPdfViewer);", "\t\t\t\tpanelContent.setExpandRatio(wtPdfViewer, ContentRatio.LARGE);", "\t\t\t\tpanelContent.addComponent(verticalLayout);", "\t\t\t\tpanelContent.setExpandRatio(verticalLayout, ContentRatio.SMALL);"], "documentAttachmentList": ["\t\t\tfinal List<DocumentAttachment> documentAttachmentList) {", "\t\tfor (final DocumentAttachment documentAttachment : documentAttachmentList) {", "\t\t\tif (PDF.equalsIgnoreCase(documentAttachment.getFileType())) {", "\t\t\t\twtPdfViewer.setResource(new StreamResource(new StreamSourceImplementation(documentAttachment.getFileUrl()), documentAttachment.getFileName()));", "\t\t\t\tfinal ExternalAttachmentDownloadLink link = new ExternalAttachmentDownloadLink(", "\t\t\t\t\t\tdocumentAttachment.getFileName(), documentAttachment.getFileType(),", "\t\t\t\t\t\tdocumentAttachment.getFileUrl());", "\t\t\t\tverticalLayout.addComponent(link);"]}
{"panel": ["public static void createHeader2Label(final AbstractOrderedLayout panel,final String content) {", "\t\tpanel.addComponent(label);", "\t\tpanel.setExpandRatio(label,ContentRatio.SMALL);"], "content": ["public static void createHeader2Label(final AbstractOrderedLayout panel,final String content) {", "\t\tfinal Label label = new Label(content);", "\t\tlabel.setStyleName(\"Level2Header\");", "\t\tpanel.addComponent(label);", "\t\tpanel.setExpandRatio(label,ContentRatio.SMALL);"]}
{"userid": ["private static Key buildKey(final String userid, final String password) {", "\t\t\t\tnew SHA3.Digest512().digest((userid + \".uuid\" + password).getBytes(StandardCharsets.UTF_8)), KEY_SIZE_IN_BYTES),"], "password": ["private static Key buildKey(final String userid, final String password) {", "\t\t\t\tnew SHA3.Digest512().digest((userid + \".uuid\" + password).getBytes(StandardCharsets.UTF_8)), KEY_SIZE_IN_BYTES),"]}
{"Result": "Method without Parameter"}
{"status": ["public final void addViolation(final Status status,final String ruleName,final String ruleGroup,final String ruleDescription,final String positive) {\t", "\t\tif (currentRuleViolation == null || status.ordinal() > currentRuleViolation.getStatus().ordinal()) {\t\t", "\t\t\truleViolationMap.put(ruleName, new RuleViolation(getId(),getName(),resourceType,ruleName,ruleDescription,ruleGroup,status,positive));"], "ruleName": ["public final void addViolation(final Status status,final String ruleName,final String ruleGroup,final String ruleDescription,final String positive) {\t", "\t\tfinal RuleViolation currentRuleViolation = ruleViolationMap.get(ruleName);", "\t\tif (currentRuleViolation == null || status.ordinal() > currentRuleViolation.getStatus().ordinal()) {\t\t", "\t\t\truleViolationMap.put(ruleName, new RuleViolation(getId(),getName(),resourceType,ruleName,ruleDescription,ruleGroup,status,positive));"], "ruleGroup": ["public final void addViolation(final Status status,final String ruleName,final String ruleGroup,final String ruleDescription,final String positive) {\t", "\t\t\truleViolationMap.put(ruleName, new RuleViolation(getId(),getName(),resourceType,ruleName,ruleDescription,ruleGroup,status,positive));"], "ruleDescription": ["public final void addViolation(final Status status,final String ruleName,final String ruleGroup,final String ruleDescription,final String positive) {\t", "\t\t\truleViolationMap.put(ruleName, new RuleViolation(getId(),getName(),resourceType,ruleName,ruleDescription,ruleGroup,status,positive));"], "positive": ["public final void addViolation(final Status status,final String ruleName,final String ruleGroup,final String ruleDescription,final String positive) {\t", "\t\t\truleViolationMap.put(ruleName, new RuleViolation(getId(),getName(),resourceType,ruleName,ruleDescription,ruleGroup,status,positive));"]}
{"list": ["private static Map<String, String> createMapFromListVote(final List<VoteDataEmbeddedId> list) {", "\t\tfor (final VoteDataEmbeddedId documentElement : list) {", "\t\t\tmap.put(documentElement.getBallotId(), documentElement.getBallotId());"]}
{"after": ["private static boolean checkIncludeDate(final Date after, final List<String> documentTypeValues,", "\t\t\t\treturn getDate(documentElement.getMadePublicDate()).after(after)", "\t\t\t\treturn getDate(documentElement.getCreatedDate()).after(after)"], "documentTypeValues": ["private static boolean checkIncludeDate(final Date after, final List<String> documentTypeValues,", "\t\t\t\t\t\t&& documentTypeValues.contains(documentElement.getDocumentType());", "\t\t\t\t\t\t&& documentTypeValues.contains(documentElement.getDocumentType());\t\t\t\t"], "documentElement": ["\t\t\tfinal DocumentElement documentElement) {", "\t\t\tif (documentElement.getMadePublicDate() != null && documentElement.getMadePublicDate().length() > 0) {", "\t\t\t\treturn getDate(documentElement.getMadePublicDate()).after(after)", "\t\t\t\t\t\t&& documentTypeValues.contains(documentElement.getDocumentType());", "\t\t\t\treturn getDate(documentElement.getCreatedDate()).after(after)", "\t\t\t\t\t\t&& documentTypeValues.contains(documentElement.getDocumentType());\t\t\t\t", "\t\t\tLOGGER.warn(\"Problem getting date from{} : exception:{}\", documentElement, e);"]}
{"date": ["private static Date getDate(final String date) throws ParseException {", "\t\tif (RIKSDAGEN_JAVA_SIMPLE_DATE_FORMAT.length() > date.length()) {", "\t\t\treturn new SimpleDateFormat(RIKSDAGEN_JAVA_SIMPLE_DATE_TIME_FORMAT, Locale.ENGLISH).parse(date);", "\t\t\treturn new SimpleDateFormat(RIKSDAGEN_JAVA_SIMPLE_DATE_FORMAT, Locale.ENGLISH).parse(date);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"ballotContainer": ["private static Date bestGuessVoteDate(final BallotContainer ballotContainer) throws ParseException {", "\t\tfinal com.hack23.cia.model.external.riksdagen.votering.impl.BallotDocumentElement ballotDocumentElement = ballotContainer.getBallotDocumentElement();", "\t\tfinal String createdDate=ballotContainer.getBallotDocumentElement().getCreatedDate();"]}
{"voteList": ["private static Date checkSameDate(final List<VoteDataDto> voteList) throws ParseException {", "\t\tfor (final VoteDataDto voteData : voteList) {", "\t\t\tfinal String voteDate = voteData.getVoteDate();", "\t\t\tif (voteDate !=null && voteDate.length() >= YYYY_MM_DD.length()) {", "\t\t\t\tset.add(voteData.getVoteDate());"]}
{"ballotContainer": ["public Date tryToFindValidVoteDate(final BallotContainer ballotContainer, final List<VoteDataDto> voteDataList)", "\t\t\tballotDate = bestGuessVoteDate(ballotContainer);", "\t\treturn ballotDate;"], "voteDataList": ["public Date tryToFindValidVoteDate(final BallotContainer ballotContainer, final List<VoteDataDto> voteDataList)", "\t\tfinal Date sameDate = checkSameDate(voteDataList);", "\t\tif (sameDate != null) {", "\t\t\tballotDate = sameDate;", "\t\treturn ballotDate;"]}
{"webBrowser": ["public static String getIpInformation(final WebBrowser webBrowser) {", "\t\tString ipInformation=webBrowser.getAddress();"]}
{"webBrowser": ["public static String getOperatingSystem(final WebBrowser webBrowser) {", "\t\t\tfinal UserAgent userAgent = USER_AGENT_ANALYZER.parse(webBrowser.getBrowserApplication());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"dataSeries": ["private static void addDocumentHistoryByOrgData(final DataSeries dataSeries, final Series series,", "\t\t\taddNewDataSerie(dataSeries, series, simpleDateFormat, parseIncomingDateFormat, entry);"], "series": ["private static void addDocumentHistoryByOrgData(final DataSeries dataSeries, final Series series,", "\t\t\taddNewDataSerie(dataSeries, series, simpleDateFormat, parseIncomingDateFormat, entry);"], "itemList": ["\t\t\tfinal List<ViewRiksdagenOrgDocumentDailySummary> itemList) {", "\t\tfinal Map<String, List<ViewRiksdagenOrgDocumentDailySummary>> map = itemList.parallelStream()"]}
{"dataSeries": ["private static void addNewDataSerie(final DataSeries dataSeries, final Series series,", "\t\tdataSeries.newSeries();", "\t\t\t\taddDataItem(dataSeries, simpleDateFormat, parseIncomingDateFormat, item);"], "series": ["private static void addNewDataSerie(final DataSeries dataSeries, final Series series,", "\t\tseries.addSeries(new XYseries().setLabel(entry.getKey()));"], "simpleDateFormat": ["\t\t\tfinal SimpleDateFormat simpleDateFormat, final SimpleDateFormat parseIncomingDateFormat,", "\t\t\t\taddDataItem(dataSeries, simpleDateFormat, parseIncomingDateFormat, item);"], "parseIncomingDateFormat": ["\t\t\tfinal SimpleDateFormat simpleDateFormat, final SimpleDateFormat parseIncomingDateFormat,", "\t\t\t\taddDataItem(dataSeries, simpleDateFormat, parseIncomingDateFormat, item);"], "entry": ["\t\t\tfinal Entry<String, List<ViewRiksdagenOrgDocumentDailySummary>> entry) {", "\t\tseries.addSeries(new XYseries().setLabel(entry.getKey()));", "\t\tif (entry.getValue() != null) {", "\t\t\tfor (final ViewRiksdagenOrgDocumentDailySummary item : entry.getValue()) {", "\t\t\t\taddDataItem(dataSeries, simpleDateFormat, parseIncomingDateFormat, item);"]}
{"dataSeries": ["private static void addDataItem(final DataSeries dataSeries, final SimpleDateFormat simpleDateFormat,", "\t\t\t\tdataSeries.add("], "simpleDateFormat": ["private static void addDataItem(final DataSeries dataSeries, final SimpleDateFormat simpleDateFormat,", "\t\t\t\t\t\tsimpleDateFormat"], "parseIncomingDateFormat": ["\t\t\tfinal SimpleDateFormat parseIncomingDateFormat, final ViewRiksdagenOrgDocumentDailySummary item) {", "\t\t\t\t\t\t\t\t.format(parseIncomingDateFormat.parse(item.getEmbeddedId().getPublicDate())),"], "item": ["\t\t\tfinal SimpleDateFormat parseIncomingDateFormat, final ViewRiksdagenOrgDocumentDailySummary item) {", "\t\tif (item != null && item.getEmbeddedId().getPublicDate().length() > 0) {", "\t\t\t\t\t\t\t\t.format(parseIncomingDateFormat.parse(item.getEmbeddedId().getPublicDate())),", "\t\t\t\t\t\titem.getTotal());", "\t\t\t\tLOGGER.warn(\"Problem parsing date:{}\", item.getEmbeddedId().getPublicDate());"]}
{"Result": "Method without Parameter"}
{"serviceRequest": ["private ManageUserAccountResponse performOperation(final ManageUserAccountRequest serviceRequest,", "\t\teventRequest.setElementId(serviceRequest.getUserAcountId());", "\t\teventRequest.setApplicationMessage(serviceRequest.getAccountOperation().toString());", "\t\t\t\tserviceRequest.getUserAcountId());", "\t\tfinal UserCommand userCommand = userCommandMap.get(serviceRequest.getAccountOperation());\t\t\t"], "eventRequest": ["\t\t\tfinal CreateApplicationEventRequest eventRequest) {", "\t\teventRequest.setElementId(serviceRequest.getUserAcountId());", "\t\teventRequest.setApplicationMessage(serviceRequest.getAccountOperation().toString());", "\t\teventRequest.setApplicationMessage(response.getResult().toString());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"columnOrder": ["private static void configureColumnOrdersAndHiddenFields(final String[] columnOrder, final String[] hideColumns,", "\t\tif (columnOrder != null) {", "\t\t\tgrid.setColumnOrder(columnOrder);"], "hideColumns": ["private static void configureColumnOrdersAndHiddenFields(final String[] columnOrder, final String[] hideColumns,", "\t\tif (hideColumns != null) {", "\t\t\tfor (final String o : hideColumns) {", "\t\t\t\tgrid.removeColumn(o);"], "grid": ["\t\t\tfinal Grid grid) {", "\t\t\tgrid.setColumnOrder(columnOrder);", "\t\t\t\tgrid.removeColumn(o);"]}
{"listener": ["private static void configureListeners(final SelectionListener listener, final Grid grid) {", "\t\tif (listener != null) {", "\t\t\tgrid.addSelectionListener(listener);"], "grid": ["private static void configureListeners(final SelectionListener listener, final Grid grid) {", "\t\t\tgrid.addSelectionListener(listener);"]}
{"columnOrder": ["private static void createGridCellFilter(final String[] columnOrder, final Grid grid, final Class dataType) {", "\t\tif (columnOrder != null) {", "\t\t\tfor (final String column : columnOrder) {", "\t\t\t\tif (grid.getColumn(column) != null) {", "\t\t\t\t\tfilter.setTextFilter(column, true, true);"], "grid": ["private static void createGridCellFilter(final String[] columnOrder, final Grid grid, final Class dataType) {", "\t\t\tfinal GridCellFilter filter = new GridCellFilter(grid, dataType);", "\t\t\t\tif (grid.getColumn(column) != null) {"], "dataType": ["private static void createGridCellFilter(final String[] columnOrder, final Grid grid, final Class dataType) {", "\t\t\tfinal GridCellFilter filter = new GridCellFilter(grid, dataType);", "\t\t\t\t\tfilter.setTextFilter(column, true, true);"]}
{"collectionPropertyConverter": ["private static void setColumnConverters(final ListPropertyConverter[] collectionPropertyConverter,", "\t\tif (collectionPropertyConverter != null) {", "\t\t\tfor (final ListPropertyConverter converter : collectionPropertyConverter) {", "\t\t\t\tgrid.removeColumn(converter.getColumn());", "\t\t\t\tfinal Column column = grid.addColumn(converter);", "\t\t\t\tcolumn.setCaption(WordUtils.capitalize(converter.getColumn()));", "\t\t\t\tcolumn.setId(converter.getColumn());"], "grid": ["\t\t\tfinal Grid grid) {", "\t\t\t\tgrid.removeColumn(converter.getColumn());", "\t\t\t\tfinal Column column = grid.addColumn(converter);", "\t\t\t\tcolumn.setCaption(WordUtils.capitalize(converter.getColumn()));", "\t\t\t\tcolumn.setId(converter.getColumn());"]}
{"Result": "Method without Parameter"}
{"simpleDateFormat": ["private static void addDataSeries(final SimpleDateFormat simpleDateFormat,", "\t\t\t\t\tdataSeries.add(simpleDateFormat.format(parseInputDateFormat.parse(item.getEmbeddedId().getPublicDate())), item.getTotal());"], "parseInputDateFormat": ["\t\t\tfinal SimpleDateFormat parseInputDateFormat, final DataSeries dataSeries, final Series series,", "\t\t\t\t\tdataSeries.add(simpleDateFormat.format(parseInputDateFormat.parse(item.getEmbeddedId().getPublicDate())), item.getTotal());"], "dataSeries": ["\t\t\tfinal SimpleDateFormat parseInputDateFormat, final DataSeries dataSeries, final Series series,", "\t\tdataSeries.newSeries();", "\t\t\t\t\tdataSeries.add(simpleDateFormat.format(parseInputDateFormat.parse(item.getEmbeddedId().getPublicDate())), item.getTotal());"], "series": ["\t\t\tfinal SimpleDateFormat parseInputDateFormat, final DataSeries dataSeries, final Series series,", "\t\tseries.addSeries(new XYseries().setLabel(entry.getKey()));"], "entry": ["\t\t\tfinal Entry<String, List<ViewRiksdagenDocumentTypeDailySummary>> entry) {", "\t\tseries.addSeries(new XYseries().setLabel(entry.getKey()));", "\t\tfor (final ViewRiksdagenDocumentTypeDailySummary item : entry.getValue()) {", "\t\t\tif (item != null && item.getEmbeddedId().getPublicDate().length() > 0) {", "\t\t\t\t\tdataSeries.add(simpleDateFormat.format(parseInputDateFormat.parse(item.getEmbeddedId().getPublicDate())), item.getTotal());", "\t\t\t\t\tLOGGER.warn(\"Problem parsing date:{}\", item.getEmbeddedId().getPublicDate());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"args": ["public static void main(String[] args) {", "\t\tif (args.length == EXPECTED_NUMBER_ARGS) {", "\t\t\tfinal String encryptValue = new EncryptProperty().encryptValue(args[0], args[1]);"]}
{"symmetricKey": ["public String encryptValue(final String symmetricKey,final String value) {", "\t\treturn getEncryptor(symmetricKey).encrypt(value);"], "value": ["public String encryptValue(final String symmetricKey,final String value) {", "\t\treturn getEncryptor(symmetricKey).encrypt(value);"]}
{"symmetricKey": ["private static StandardPBEStringEncryptor getEncryptor(final String symmetricKey) {", "\t\tmySecondEncryptor.setPassword(symmetricKey);"]}
{"symmetricKey": ["public String decryptValue(final String symmetricKey,final String value) {", "\t\treturn getEncryptor(symmetricKey).decrypt(value);"], "value": ["public String decryptValue(final String symmetricKey,final String value) {", "\t\treturn getEncryptor(symmetricKey).decrypt(value);"]}
{"Result": "Method without Parameter"}
{"jobContext": ["protected final JobContextHolder getJobContextHolder(final JobExecutionContext jobContext) {", "\t\tfinal Scheduler scheduler = jobContext.getScheduler();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"panelName": ["protected final void createBasicLayoutWithPanelAndFooter(final String panelName) {", "\t\tpanel = new Panel(panelName);", "\t\tpanel.addStyleName(\"v-panel-page-panel\");", "\t\tpanel.setSizeFull();", "\t\tpageModeContent.addComponent(panel);", "\t\tpageModeContent.setExpandRatio(panel, ContentRatio.FULL_SIZE);"]}
{"Result": "Method without Parameter"}
{"margin": ["private static VerticalLayout createFullSizeVerticalLayout(final boolean margin, final boolean spacing) {", "\t\tlayout.setMargin(margin);"], "spacing": ["private static VerticalLayout createFullSizeVerticalLayout(final boolean margin, final boolean spacing) {", "\t\tlayout.setSpacing(spacing);"]}
{"topHeader": ["private static void addLogoToHeader(final HorizontalLayout topHeader) {", "\t\ttopHeader.addComponent(ciaLogoImage);", "\t\ttopHeader.setComponentAlignment(ciaLogoImage, Alignment.MIDDLE_LEFT);", "\t\ttopHeader.setExpandRatio(ciaLogoImage, ContentRatio.SMALL);"]}
{"topHeader": ["private static void createTopTitleHeader(final HorizontalLayout topHeader) {", "\t\ttopHeader.addComponent(topTitleHeadertPanel);", "\t\ttopHeader.setComponentAlignment(topTitleHeadertPanel, Alignment.MIDDLE_LEFT);", "\t\ttopHeader.setExpandRatio(topTitleHeadertPanel, ContentRatio.GRID);"]}
{"Result": "Method without Parameter"}
{"smtpPort": ["private static int getSmtpPort(final ApplicationConfiguration smtpPort) {", "\t\tif (StringUtils.isNumeric(smtpPort.getPropertyValue())) {", "\t\t\treturn Integer.parseInt(smtpPort.getPropertyValue());"]}
{"locale": ["private LanguageData findLanguage(final String locale) {", "\t\t\tif (languageData.getLanguageCode().equalsIgnoreCase(locale)) {"]}
{"Result": "Method without Parameter"}
{"partyBallotList": ["private static Map<String,List<ViewRiksdagenVoteDataBallotPartySummary>> createIssueConcernMap(final List<ViewRiksdagenVoteDataBallotPartySummary> partyBallotList) {", "\t\tfor (final ViewRiksdagenVoteDataBallotPartySummary partySummary: partyBallotList) {", "\t\t\tif (partySummary.getEmbeddedId().getIssue() !=null || partySummary.getEmbeddedId().getConcern() != null ) {", "\t\t\t\tfinal String key = partySummary.getEmbeddedId().getIssue() + partySummary.getEmbeddedId().getConcern();", "\t\t\t\tfinal List<ViewRiksdagenVoteDataBallotPartySummary> partySummarList = concernIssuePartyBallotSummaryMap.computeIfAbsent(key, k -> new ArrayList<>());\t\t\t\t", "\t\t\t\tpartySummarList.add(partySummary);"]}
{"in": ["public static Source setNameSpaceOnXmlStream(final InputStream in, final String nameSpace)", "\t\tfinal Document doc = sb.build(in);", "\t\tdoc.getRootElement().setNamespace(Namespace.getNamespace(nameSpace));", "\t\treturn new JDOMSource(doc);"], "nameSpace": ["public static Source setNameSpaceOnXmlStream(final InputStream in, final String nameSpace)", "\t\tdoc.getRootElement().setNamespace(Namespace.getNamespace(nameSpace));"]}
{"content": ["protected final void addChart(final AbstractOrderedLayout content,final String caption, final DCharts chart, final boolean fullPage) {", "\t\tcontent.addComponent(formPanel);", "\t\tcontent.setExpandRatio(formPanel, ContentRatio.LARGE);"], "caption": ["protected final void addChart(final AbstractOrderedLayout content,final String caption, final DCharts chart, final boolean fullPage) {", "\t\tformPanel.setCaption(caption);", "\t\tchart.setCaption(caption);"], "chart": ["protected final void addChart(final AbstractOrderedLayout content,final String caption, final DCharts chart, final boolean fullPage) {", "\t\tchart.setWidth(100, Unit.PERCENTAGE);", "\t\tchart.setHeight(100, Unit.PERCENTAGE);", "\t\tchart.setMarginRight(CHART_RIGHT_MARGIN);", "\t\tchart.setMarginLeft(CHART_LEFT_MARGIN);", "\t\tchart.setMarginBottom(CHART_BOTTOM_MARGIN_SIZE);", "\t\tchart.setMarginTop(CHART_TOP_MARGIN_SIZE);", "\t\thorizontalLayout.addComponent(chart);", "\t\tchart.setCaption(caption);"], "fullPage": ["protected final void addChart(final AbstractOrderedLayout content,final String caption, final DCharts chart, final boolean fullPage) {", "\t\tfinal int browserWindowHeight = getChartWindowHeight(fullPage);", "\t\thorizontalLayout.setHeight(browserWindowHeight, Unit.PIXELS);"]}
{"fullPage": ["private static int getChartWindowHeight(final boolean fullPage) {", "\t\tif (fullPage) {"]}
{"party": ["protected final String getPartyName(final String party) {", "\t\t\t    filter((final ViewRiksdagenParty p) -> p.getPartyId().equalsIgnoreCase(party)).", "\t\t\treturn party;"]}
{"Result": "Method without Parameter"}
{"username": ["    public UserIdentity login(String username, Object password, ServletRequest request)", "        UserIdentity user = super.login(username,password,request);"], "password": ["    public UserIdentity login(String username, Object password, ServletRequest request)", "        UserIdentity user = super.login(username,password,request);", "            Authentication cached=new SessionAuthentication(getAuthMethod(),user,password);", "            session.setAttribute(SessionAuthentication.__J_AUTHENTICATED, cached);"], "request": ["    public UserIdentity login(String username, Object password, ServletRequest request)", "        UserIdentity user = super.login(username,password,request);", "        if (user!=null)", "            HttpSession session = ((HttpServletRequest)request).getSession(true);", "            Authentication cached=new SessionAuthentication(getAuthMethod(),user,password);", "        return user;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"androidDebugBridge": ["void unlockEmulator( AndroidDebugBridge androidDebugBridge )", "            IDevice myEmulator = findExistingEmulator( Arrays.asList( androidDebugBridge.getDevices() ) );"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"device": ["private void stopEmulator( IDevice device )", "        int devicePort = extractPortFromDevice( device );", "        if ( devicePort == -1 )", "            getLog().info( \"Unable to retrieve port to stop emulator \" + DeviceHelper.getDescriptiveName( device ) );", "            getLog().info( \"Stopping emulator \" + DeviceHelper.getDescriptiveName( device ) );", "            sendEmulatorCommand( devicePort, \"avd stop\" );", "            boolean killed = sendEmulatorCommand( devicePort, \"kill\" );", "                getLog().info( \"Emulator failed to stop \" + DeviceHelper.getDescriptiveName( device ) );", "                getLog().info( \"Emulator stopped successfully \" + DeviceHelper.getDescriptiveName( device ) );"]}
{"port": ["            final int port, final String command )", "                    socket = new Socket( \"127.0.0.1\", port );", "                    out = new PrintWriter( socket.getOutputStream(), true );", "                    in = new BufferedReader( new InputStreamReader( socket.getInputStream() ) );", "                        socket.close();"], "command": ["            final int port, final String command )", "                    out.write( command );", "            getLog().error( String.format( \"Failed to execute emulator command '%s': %s\", command, e ) );"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"jarFile": ["public static void unjar( JarFile jarFile, File outputDirectory, UnjarListener unjarListener ) throws IOException", "        for ( Enumeration en = jarFile.entries(); en.hasMoreElements(); )", "            JarEntry entry = ( JarEntry ) en.nextElement();", "            File entryFile = new File( outputDirectory, entry.getName() );", "            if ( unjarListener.include( entry ) )", "                if ( ! entryFile.getParentFile().exists() )", "                    if ( ! entryFile.getParentFile().mkdirs() )", "                        throw new IOException( \"Error creating output directory: \" + entryFile.getParentFile() );", "                if ( ! entry.isDirectory() )", "                    final InputStream in = jarFile.getInputStream( entry );", "                        final OutputStream out = new FileOutputStream( entryFile );", "                            IOUtil.copy( in, out );", "                            IOUtils.closeQuietly( out );", "                        IOUtils.closeQuietly( in );"], "outputDirectory": ["public static void unjar( JarFile jarFile, File outputDirectory, UnjarListener unjarListener ) throws IOException", "            File entryFile = new File( outputDirectory, entry.getName() );", "                if ( ! entryFile.getParentFile().exists() )", "                    if ( ! entryFile.getParentFile().mkdirs() )", "                        throw new IOException( \"Error creating output directory: \" + entryFile.getParentFile() );", "                        final OutputStream out = new FileOutputStream( entryFile );", "                            IOUtil.copy( in, out );", "                            IOUtils.closeQuietly( out );"], "unjarListener": ["public static void unjar( JarFile jarFile, File outputDirectory, UnjarListener unjarListener ) throws IOException", "            if ( unjarListener.include( entry ) )"]}
{"Result": "Method without Parameter"}
{"node": ["public void visit( DependencyNode node, boolean collecting )", "            dependencies.add( node.getArtifact() );", "        if ( matchesTarget( node.getArtifact() ) )", "            log.debug( \"Found target. Collecting dependencies after \" + node.getArtifact() );", "        for ( final DependencyNode child : node.getChildren() )", "            visit( child, collecting );"], "collecting": ["public void visit( DependencyNode node, boolean collecting )", "        if ( collecting )", "            visit( child, collecting );"]}
{"artifact": ["private Artifact resolveArtifact( Artifact artifact ) throws MojoExecutionException", "        artifactResolutionRequest.setArtifact( artifact );", "        log.debug( \"Resolving : \" + artifact );", "            throw new MojoExecutionException( \"Could not resolve artifact \" + artifact", "            throw new MojoExecutionException( \"Could not resolve artifact \" + artifact"]}
{"adb": ["private void waitUntilConnected( AndroidDebugBridge adb )", "            if ( adb.isConnected() )"]}
{"androidDebugBridge": ["protected void waitForInitialDeviceList( final AndroidDebugBridge androidDebugBridge ) throws MojoExecutionException", "        if ( ! androidDebugBridge.hasInitialDeviceList() )", "            while ( ! androidDebugBridge.hasInitialDeviceList() && ( System.currentTimeMillis() < limitTime ) )", "            if ( ! androidDebugBridge.hasInitialDeviceList() )"]}
{"apkFile": ["protected void deployApk( final File apkFile ) throws MojoExecutionException, MojoFailureException", "            undeployApk( apkFile );", "                    device.installPackage( apkFile.getAbsolutePath(), true );", "                    getLog().info( deviceLogLinePrefix + \"Successfully installed \" + apkFile.getAbsolutePath() ); ", "                    throw new MojoExecutionException( deviceLogLinePrefix + \"Install of \" + apkFile.getAbsolutePath()"]}
{"Result": "Method without Parameter"}
{"apkFile": ["protected boolean undeployApk( File apkFile ) throws MojoExecutionException, MojoFailureException", "        packageName = extractPackageNameFromApk( apkFile );", "        return undeployApk( packageName );"]}
{"packageName": ["protected boolean undeployApk( final String packageName ) throws MojoExecutionException, MojoFailureException", "                    device.uninstallPackage( packageName );", "                    getLog().info( deviceLogLinePrefix + \"Successfully uninstalled \" + packageName );", "                    throw new MojoExecutionException( deviceLogLinePrefix + \"Uninstall of \" + packageName"]}
{"apkFile": ["protected String extractPackageNameFromApk( File apkFile ) throws MojoExecutionException", "                .setPathToApk( apkFile.getAbsolutePath() )", "                    \"Error while trying to figure out package name from inside apk file \" + apkFile );"]}
{"artifact": ["protected String extractPackageNameFromAndroidArtifact( Artifact artifact ) throws MojoExecutionException", "        final File unpackedLibFolder = getUnpackedLibFolder( artifact );", "        final File manifest = new File( unpackedLibFolder, \"AndroidManifest.xml\" );", "                    \"AndroidManifest.xml file wasn't found in next place: \" + unpackedLibFolder );"]}
{"manifestFile": ["protected String extractInstrumentationRunnerFromAndroidManifest( File manifestFile )", "            xmlURL = manifestFile.toURI().toURL();", "                            + manifestFile, e );"]}
{"libraries": ["public void generateLibraryRs( final Set<Artifact> libraries )", "        final List<SymbolTable> symbolTables = new ArrayList<>( libraries.size() );", "        for ( final Artifact lib : libraries )", "            final File unpackedLibDirectory = mojo.getUnpackedLibFolder( lib );", "            final File rFile = new File( unpackedLibDirectory, \"R.txt\" );", "            if ( rFile.isFile() )", "                final File libManifestFile = new File( unpackedLibDirectory, \"AndroidManifest.xml\" );", "                final String packageName = new DefaultManifestParser( libManifestFile ).getPackage();", "                if ( rJavaAlreadyExists( packageName ) )", "                    log.info( \"Not creating R for \" + packageName + \" as it already exists\" );", "                log.info( \"Generating R for \" + packageName + \" at \" + rFile );", "                SymbolTable libSymbols = SymbolIo.read( rFile );", "                libSymbols = libSymbols.rename( packageName, libSymbols.getTableName() );", "                symbolTables.add( libSymbols );"]}
{"Result": "Method without Parameter"}
{"in": ["private static void copyStreamWithoutClosing( InputStream in, OutputStream out ) throws IOException", "        while ( ( n = in.read( b ) ) != - 1 )", "            out.write( b, 0, n );"], "out": ["private static void copyStreamWithoutClosing( InputStream in, OutputStream out ) throws IOException", "            out.write( b, 0, n );"]}
{"destinationDirectory": ["private void copyGdbServer( File destinationDirectory, String architecture ) throws MojoExecutionException", "            final File destDir = new File( destinationDirectory, architecture );"], "architecture": ["private void copyGdbServer( File destinationDirectory, String architecture ) throws MojoExecutionException", "            final File destDir = new File( destinationDirectory, architecture );", "            if ( destDir.exists() )", "                final File gdbServerFile = getAndroidNdk().getGdbServer( architecture );", "                final File destFile = new File( destDir, \"gdbserver\" );", "                    FileUtils.copyFile( gdbServerFile, destFile );"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"apklibArtifact": ["private void extractApklib( Artifact apklibArtifact ) throws MojoExecutionException", "        getUnpackedLibHelper().extractApklib( apklibArtifact );", "        copyFolder( getUnpackedLibAssetsFolder( apklibArtifact ), combinedAssets );", "        final File apklibSourceFolder = getUnpackedApkLibSourceFolder( apklibArtifact );", "        projectHelper.addResource( project, apklibSourceFolder.getAbsolutePath(), null, resourceExclusions );", "        project.addCompileSourceRoot( apklibSourceFolder.getAbsolutePath() );"]}
{"aarArtifact": ["private void extractAarLib( Artifact aarArtifact ) throws MojoExecutionException", "        getUnpackedLibHelper().extractAarLib( aarArtifact );", "            copyFolder( getUnpackedLibAssetsFolder( aarArtifact ), combinedAssets );", "            getLog().debug( \"Not adding AAR resources to resource classpath : \" + aarArtifact );"]}
{"Result": "Method without Parameter"}
{"dependencyArtifacts": ["Map<String, Set<Artifact>> getPackageCompareMap( Set<Artifact> dependencyArtifacts ) throws MojoExecutionException", "        if ( dependencyArtifacts == null )", "        for ( Artifact artifact : dependencyArtifacts )", "            String libPackage = extractPackageNameFromAndroidArtifact( artifact );", "            Set<Artifact> artifacts = packageCompareMap.get( libPackage );", "            if ( artifacts == null )", "                packageCompareMap.put( libPackage, artifacts );", "            artifacts.add( artifact );"]}
{"resourceGenerator": ["private void generateCorrectRJavaForApklibDependencies( ResourceClassGenerator resourceGenerator )", "            resourceGenerator.generateLibraryRs( apklibDependencies );"]}
{"resourceGenerator": ["private void generateCorrectRJavaForAarDependencies( ResourceClassGenerator resourceGenerator )", "            resourceGenerator.generateLibraryRs( aarLibraries );"]}
{"apklibArtifact": ["private void generateRForApkLibDependency( Artifact apklibArtifact ) throws MojoExecutionException", "        final File unpackDir = getUnpackedLibFolder( apklibArtifact );", "        getLog().debug( \"Generating incomplete R file for apklib: \" + apklibArtifact.getGroupId()", "                + \":\" + apklibArtifact.getArtifactId() );", "        final File apklibManifest = new File( unpackDir, \"AndroidManifest.xml\" );", "        final File apklibResDir = new File( unpackDir, \"res\" );", "        final Set<Artifact> apklibDeps = getDependencyResolver()", "                .getLibraryDependenciesFor( this.session, this.repositorySystem, apklibArtifact );", "        getLog().debug( \"apklib=\" + apklibArtifact + \"  dependencies=\" + apklibDeps );", "        for ( Artifact dependency : apklibDeps )", "            final String extension = dependency.getType();", "            final File dependencyResDir = getUnpackedLibResourceFolder( dependency );", "            if ( ( extension.equals( APKLIB ) || extension.equals( AAR ) ) && dependencyResDir.exists() )", "                dependenciesResDirectories.add( dependencyResDir );", "        final File apklibCombAssets = new File( getUnpackedLibFolder( apklibArtifact ), \"combined-assets\" );", "        for ( Artifact dependency : apklibDeps )", "            final String extension = dependency.getType();", "            final File dependencyAssetsDir = getUnpackedLibAssetsFolder( dependency );", "            if ( ( extension.equals( APKLIB ) || extension.equals( AAR ) ) )", "                copyFolder( dependencyAssetsDir, apklibCombAssets );", "        final File apkLibAssetsDir = getUnpackedLibAssetsFolder( apklibArtifact );", "        copyFolder( apkLibAssetsDir, apklibCombAssets );", "        final AaptCommandBuilder commandBuilder = AaptCommandBuilder", "                .generateRTextFile( unpackDir );", "        getLog().debug( getAndroidSdk().getAaptPath() + \" \" + commandBuilder.toString() );", "            final List<String> commands = commandBuilder.build();"]}
{"artifact": ["private boolean isBuildConfigPresent( Artifact artifact ) throws MojoExecutionException", "        String depPackageName = extractPackageNameFromAndroidArtifact( artifact );", "        return isBuildConfigPresent( artifact, depPackageName );"]}
{"artifact": ["private boolean isBuildConfigPresent( Artifact artifact, String packageName ) throws MojoExecutionException", "            JarFile jar = new JarFile( getUnpackedAarClassesJar( artifact ) );", "            JarEntry entry = jar.getJarEntry( packageName.replace( '.', '/' ) + \"/BuildConfig.class\" );"], "packageName": ["private boolean isBuildConfigPresent( Artifact artifact, String packageName ) throws MojoExecutionException", "            JarEntry entry = jar.getJarEntry( packageName.replace( '.', '/' ) + \"/BuildConfig.class\" );"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"clientSecrets": ["private static void checkClientSecretsFile( GoogleClientSecrets clientSecrets )", "        if ( clientSecrets.getDetails().getClientId().startsWith( \"[[INSERT\" )", "                || clientSecrets.getDetails().getClientSecret().startsWith( \"[[INSERT\" ) )"]}
{"helper": ["private void addLibsJarsToClassPath( UnpackedLibHelper helper, MavenProject project, Artifact artifact )", "             final File unpackLibFolder = helper.getUnpackedLibFolder( artifact );", "             final File artifactFile = helper.getArtifactToFile( artifact );"], "project": ["private void addLibsJarsToClassPath( UnpackedLibHelper helper, MavenProject project, Artifact artifact )", "                     project.getModel().addDependency( dependency );"], "artifact": ["private void addLibsJarsToClassPath( UnpackedLibHelper helper, MavenProject project, Artifact artifact )", "             final File unpackLibFolder = helper.getUnpackedLibFolder( artifact );", "             final File artifactFile = helper.getArtifactToFile( artifact );", "             ZipFile zipFile = new ZipFile( artifactFile );", "             Enumeration enumeration = zipFile.entries();", "                     final File libsJarFile = new File( unpackLibFolder, entryName );", "                     log.warn( \"Adding jar from libs folder to classpath: \" + libsJarFile );", "                     if ( !libsJarFile.getParentFile().exists() )", "                         libsJarFile.getParentFile().mkdirs();", "                     libsJarFile.createNewFile();", "                     final Dependency dependency =", "                            createSystemScopeDependency( artifact, libsJarFile, libsJarFile.getName() );", "                     project.getModel().addDependency( dependency );"]}
{"helper": ["private void addClassesToClasspath( UnpackedLibHelper helper, MavenProject project, Artifact artifact )", "        final File classesJar = helper.getUnpackedClassesJar( artifact );"], "project": ["private void addClassesToClasspath( UnpackedLibHelper helper, MavenProject project, Artifact artifact )", "        final Dependency providedJar = findProvidedDependencies( dependency, project );", "        if ( providedJar != null ) ", "            project.getModel().removeDependency( providedJar );", "        project.getModel().addDependency( dependency );"], "artifact": ["private void addClassesToClasspath( UnpackedLibHelper helper, MavenProject project, Artifact artifact )", "        final File classesJar = helper.getUnpackedClassesJar( artifact );", "        log.debug( \"Adding to classpath : \" + classesJar );", "        if ( !classesJar.exists() )", "            classesJar.getParentFile().mkdirs();", "                final ZipOutputStream zipOutputStream = new ZipOutputStream( new FileOutputStream( classesJar ) );", "                zipOutputStream.putNextEntry( new ZipEntry( \"dummy\" ) );", "                zipOutputStream.close();", "                log.debug( \"Created dummy \" + classesJar.getName() + \" exist=\" + classesJar.exists() );", "                throw new MavenExecutionException( \"Could not add \" + classesJar.getName() + \" as dependency\", e );", "        final Dependency dependency = createSystemScopeDependency( artifact, classesJar, null );"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"commands": ["private void collectJvmArguments( List< String > commands )", "                commands.add( jvmArgument );"]}
{"fileName": ["private File getJVMLibrary( String fileName )", "        File libFile = new File( getJavaLibDir(), fileName );", "        if ( !libFile.exists() )", "            libFile = new File( getAltJavaLibDir(), fileName );", "            if ( !libFile.exists() )", "        return libFile;"]}
{"file": ["public String getToolchain( File file ) throws MojoExecutionException", "        String ndkArchitecture = file.getParentFile().getName();"]}
{"Result": "Method without Parameter"}
{"manifestFile": ["private Document readManifest( File manifestFile ) throws IOException, ParserConfigurationException, SAXException", "        Document doc = db.parse( manifestFile );", "        return doc;"]}
{"manifestFile": ["private void writeManifest( File manifestFile, Document doc ) throws IOException, TransformerException", "            manifestFile.getParentFile().mkdirs();", "            writer = new OutputStreamWriter( new FileOutputStream( manifestFile, false ), encoding );"], "doc": ["private void writeManifest( File manifestFile, Document doc ) throws IOException, TransformerException", "        Source source = new DOMSource( doc );", "            String encoding = doc.getXmlEncoding() != null ? doc.getXmlEncoding() : \"UTF-8\";", "            if ( doc.getXmlEncoding() != null && doc.getXmlVersion() != null )", "                    .format( \"<?xml version=\\\"%s\\\" encoding=\\\"%s\\\"?>%n\", doc.getXmlVersion(), doc.getXmlEncoding() );", "            xformer.transform( source, result );"]}
{"Result": "Method without Parameter"}
{"manifestElement": ["private void performVersionCodeUpdateFromVersion( Element manifestElement ) throws MojoExecutionException", "        manifestElement.setAttribute( ATTR_VERSION_CODE, verCode );"]}
{"artifact": ["public static String extractArchitectureFromArtifact( Artifact artifact, final String defaultArchitecture )", "        String classifier = artifact.getClassifier();"], "defaultArchitecture": ["public static String extractArchitectureFromArtifact( Artifact artifact, final String defaultArchitecture )", "        return defaultArchitecture;"]}
{"baseDirectory": ["public String[] getFileNames( File baseDirectory )", "        if ( !baseDirectory.exists() )", "        directoryScanner.setBasedir( baseDirectory );"]}
{"data": ["public static String encrypt(String data, String key) {", "            return Hex.encodeHexString(c.doFinal(data.getBytes()));"], "key": ["public static String encrypt(String data, String key) {", "            c.init(Cipher.ENCRYPT_MODE, SecretKeyFactory.getInstance(\"DES\").generateSecret(new DESKeySpec(key.getBytes())));"]}
{"data": ["public static String decrypt(String data, String key) {", "            return new String(c.doFinal(Hex.decodeHex(data.toCharArray())), Charset.defaultCharset());"], "key": ["public static String decrypt(String data, String key) {", "            c.init(Cipher.DECRYPT_MODE, SecretKeyFactory.getInstance(\"DES\").generateSecret(new DESKeySpec(key.getBytes())));"]}
{"data": ["            byte data[],", "        int c = data[offset] & 0xff;", "            c = ((c & 0x3f) << 8) + (data[offset + 1] & 0xff);", "            return readName(data, c, jumps);", "        String s = new String(data, offset + 1, c);", "        String t = readName(data, offset + 1 + c, jumps);"], "offset": ["            int offset,", "        int c = data[offset] & 0xff;", "            c = ((c & 0x3f) << 8) + (data[offset + 1] & 0xff);", "        String s = new String(data, offset + 1, c);", "        String t = readName(data, offset + 1 + c, jumps);"], "jumps": ["            HashSet<Integer> jumps", "            if (jumps.contains(c)) {", "            jumps.add(c);", "            return readName(data, c, jumps);", "        String t = readName(data, offset + 1 + c, jumps);", "        if (t.length() > 0) {", "            s = s + \".\" + t;", "        return s;"]}
{"ch": ["protected static int toDigit(final char ch, final int index) throws HexDecodeException {", "        final int digit = Character.digit(ch, 16);", "            throw new HexDecodeException(\"Illegal hexadecimal character \" + ch + \" at index \" + index);"], "index": ["protected static int toDigit(final char ch, final int index) throws HexDecodeException {", "            throw new HexDecodeException(\"Illegal hexadecimal character \" + ch + \" at index \" + index);"]}
{"deltaY": ["private boolean tryToMove(float deltaY) {", "        if ((deltaY > 0 && mCurrentPos == 0)) {", "        if ((deltaY < 0 && mCurrentPos == -mHeaderHeight)) {", "        int to = mCurrentPos + (int) deltaY;", "        if (to < -mHeaderHeight) {", "        if (to > 0) {", "        return moveTo(to);"]}
{"context": ["public synchronized void startListening(Context context) {", "            mContext = context;", "            context.registerReceiver(mReceiver, filter);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"name": ["public void addFormField(String name, String value) {", "        mWriter.append(\"Content-Disposition: form-data; name=\\\"\" + name + \"\\\"\")"], "value": ["public void addFormField(String name, String value) {", "        mWriter.append(value).append(LINE_FEED);"]}
{"fieldName": ["public void addFilePart(String fieldName, File uploadFile, String fileName) throws IOException {", "                \"Content-Disposition: form-data; name=\\\"\" + fieldName"], "uploadFile": ["public void addFilePart(String fieldName, File uploadFile, String fileName) throws IOException {", "            fileName = uploadFile.getName();", "        FileInputStream inputStream = new FileInputStream(uploadFile);", "        while ((bytesRead = inputStream.read(buffer)) != -1) {", "            mOutputStream.write(buffer, 0, bytesRead);", "        inputStream.close();"], "fileName": ["public void addFilePart(String fieldName, File uploadFile, String fileName) throws IOException {", "        if (TextUtils.isEmpty(fileName)) {", "                        + \"\\\"; filename=\\\"\" + fileName + \"\\\"\")", "                \"Content-Type: \" + URLConnection.guessContentTypeFromName(fileName))"]}
{"resources": ["public BitmapDrawable createBitmapDrawable(Resources resources, Bitmap bitmap) {", "                drawable = new BitmapDrawable(resources, bitmap);", "                drawable = new RecyclingBitmapDrawable(resources, bitmap);"], "bitmap": ["public BitmapDrawable createBitmapDrawable(Resources resources, Bitmap bitmap) {", "        if (bitmap == null) {", "        if (bitmap != null) {", "                drawable = new BitmapDrawable(resources, bitmap);", "                drawable = new RecyclingBitmapDrawable(resources, bitmap);", "        return drawable;"]}
{"urls": ["public void preLoadImages(String[] urls) {", "        int len = urls.length;", "            ImageLoadRequest request = new ImageLoadRequest(urls[i]);", "            final ImageTask imageTask = createImageTask(request);", "            imageTask.setIsPreLoad();", "            addImageTask(imageTask, null);"]}
{"imageTask": ["public void detachImageViewFromImageTask(ImageTask imageTask, CubeImageView imageView) {", "        imageTask.removeImageView(imageView);", "        if (imageTask.isLoading()) {", "            if (!imageTask.isPreLoad() && !imageTask.stillHasRelatedImageView()) {", "                LoadImageTask task = mLoadWorkList.get(imageTask.getIdentityKey());", "                    CLog.d(LOG_TAG, \"%s previous work is cancelled.\", imageTask);", "        if (!imageTask.stillHasRelatedImageView()) {", "            imageTask.tryToRecycle();"], "imageView": ["public void detachImageViewFromImageTask(ImageTask imageTask, CubeImageView imageView) {", "        imageTask.removeImageView(imageView);"]}
{"imageTask": ["public void addImageTask(ImageTask imageTask, CubeImageView imageView) {", "        LoadImageTask runningTask = mLoadWorkList.get(imageTask.getIdentityKey());", "                    CLog.d(LOG_TAG, MSG_ATTACK_TO_RUNNING_TASK, imageTask, runningTask.getImageTask());", "            imageTask.addImageView(imageView);", "        imageTask.onLoading(mImageLoadHandler);", "        LoadImageTask loadImageTask = createLoadImageTask(imageTask);", "        mLoadWorkList.put(imageTask.getIdentityKey(), loadImageTask);", "        mImageTaskExecutor.execute(loadImageTask);"], "imageView": ["public void addImageTask(ImageTask imageTask, CubeImageView imageView) {", "            if (imageView != null) {", "                runningTask.getImageTask().addImageView(imageView);", "                runningTask.getImageTask().notifyLoading(mImageLoadHandler, imageView);", "            imageTask.addImageView(imageView);"]}
{"imageTask": ["public boolean queryCache(ImageTask imageTask, CubeImageView imageView) {", "        BitmapDrawable drawable = mImageProvider.getBitmapFromMemCache(imageTask);", "        if (imageTask.getStatistics() != null) {", "            imageTask.getStatistics().s0_afterCheckMemoryCache(drawable != null);", "        if (drawable == null) {", "            CLog.d(LOG_TAG, MSG_HIT_CACHE, imageTask, drawable.getIntrinsicWidth(), drawable.getIntrinsicHeight());", "        imageTask.addImageView(imageView);", "        imageTask.onLoadTaskFinish(drawable, mImageLoadHandler);"], "imageView": ["public boolean queryCache(ImageTask imageTask, CubeImageView imageView) {", "        imageTask.addImageView(imageView);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"fragment": ["public ImageLoader attachToCubeFragment(CubeFragment fragment) {", "        if (fragment != null) {", "            if (LifeCycleComponentManager.tryAddComponentToContainer(this, fragment, true)) {"]}
{"key": ["public void invalidateCache(String key) {", "            CLog.d(LOG_TAG, \"key: %s, invalidateCache\", key);", "            mFileCache.getDiskCache().delete(key);", "        mMemoryCache.remove(key);"]}
{"Result": "Method without Parameter"}
{"newCapacity": ["private SimpleHashSetEntry<T>[] makeTable(int newCapacity) {", "        SimpleHashSetEntry<T>[] newTable = (SimpleHashSetEntry<T>[]) new SimpleHashSetEntry[newCapacity];", "        mTable = newTable;", "        threshold = (newCapacity >> 1) + (newCapacity >> 2); // 3/4 capacity", "        return newTable;"]}
{"Result": "Method without Parameter"}
{"key": ["public void write(String key, Bitmap bitmap) {", "        if (key == null || bitmap == null) {", "            CacheEntry cacheEntry = mDiskCache.beginEdit(key);", "            if (cacheEntry != null) {", "                out = cacheEntry.newOutputStream();", "                cacheEntry.commit();"], "bitmap": ["public void write(String key, Bitmap bitmap) {", "        if (key == null || bitmap == null) {", "                bitmap.compress(DEFAULT_COMPRESS_FORMAT, DEFAULT_COMPRESS_QUALITY, out);"]}
{"Result": "Method without Parameter"}
{"value": ["public CacheEntry setString(String value) throws IOException {", "            writer.write(value);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"fieldName": ["    public RequestData addFile(String fieldName, String uploadFile, String fileName) {", "        addFile(fieldName, new File(uploadFile), fileName);"], "uploadFile": ["    public RequestData addFile(String fieldName, String uploadFile, String fileName) {", "        addFile(fieldName, new File(uploadFile), fileName);"], "fileName": ["    public RequestData addFile(String fieldName, String uploadFile, String fileName) {", "        addFile(fieldName, new File(uploadFile), fileName);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"emptyResult": ["    public void loadMoreFinish(boolean emptyResult, boolean hasMore) {", "        mListEmpty = emptyResult;", "            mLoadMoreUIHandler.onLoadFinish(this, emptyResult, hasMore);"], "hasMore": ["    public void loadMoreFinish(boolean emptyResult, boolean hasMore) {", "        mHasMore = hasMore;", "            mLoadMoreUIHandler.onLoadFinish(this, emptyResult, hasMore);"]}
{"thisSize": ["public ImageReuseInfo create(String thisSize) {", "            if (!canBeReused && thisSize.equals(size)) {", "            if (canBeReused && !thisSize.equals(size)) {", "            return new ImageReuseInfo(thisSize, null);", "            return new ImageReuseInfo(thisSize, sizeList);"]}
{"Result": "Method without Parameter"}
{"type": ["private void notifyRequestFinish(ResultType type, T cacheData, boolean outOfDate) {", "            CLog.d(LOG_TAG, \"%s, notifyRequestFinish: %s, %s\", getCacheKey(), type, outOfDate);", "        mHandler.onCacheAbleRequestFinish(cacheData, type, outOfDate);"], "cacheData": ["private void notifyRequestFinish(ResultType type, T cacheData, boolean outOfDate) {", "        mHandler.onCacheAbleRequestFinish(cacheData, type, outOfDate);"], "outOfDate": ["private void notifyRequestFinish(ResultType type, T cacheData, boolean outOfDate) {", "            CLog.d(LOG_TAG, \"%s, notifyRequestFinish: %s, %s\", getCacheKey(), type, outOfDate);", "        mHandler.onCacheAbleRequestFinish(cacheData, type, outOfDate);"]}
{"sb": ["public void getResponse(StringBuilder sb) throws IOException {", "                sb.append(buffer, 0, bufferLength);"]}
{"loadingBitmap": ["public void setLoadingBitmap(Bitmap loadingBitmap) {", "            mLoadingDrawable = new BitmapDrawable(mContext.getResources(), loadingBitmap);"]}
{"view": ["public void setCustomizedRightView(View view) {", "        RelativeLayout.LayoutParams lp = makeLayoutParams(view);", "        lp.addRule(CENTER_VERTICAL);", "        lp.addRule(ALIGN_PARENT_RIGHT);", "        getRightViewContainer().addView(view, lp);"]}
{"imageTask": [], "urlString": ["public boolean downloadToStream(ImageTask imageTask, String urlString, OutputStream outputStream, ProgressUpdateHandler progressUpdateHandler) {", "            final URL url = new URL(urlString);", "            urlConnection = (HttpURLConnection) url.openConnection();"], "outputStream": ["public boolean downloadToStream(ImageTask imageTask, String urlString, OutputStream outputStream, ProgressUpdateHandler progressUpdateHandler) {", "            out = new BufferedOutputStream(outputStream, IO_BUFFER_SIZE);"], "progressUpdateHandler": ["public boolean downloadToStream(ImageTask imageTask, String urlString, OutputStream outputStream, ProgressUpdateHandler progressUpdateHandler) {", "                if (progressUpdateHandler != null) {", "                    progressUpdateHandler.onProgressUpdate(total, len);"]}
{"imageView": ["public void addImageView(CubeImageView imageView) {", "        if (null == imageView) {", "            mFirstImageViewHolder = new ImageViewHolder(imageView);", "        ImageViewHolder holder = mFirstImageViewHolder;", "        for (; ; holder = holder.mNext) {", "            if (holder.contains(imageView)) {", "            if (holder.mNext == null) {", "        ImageViewHolder newHolder = new ImageViewHolder(imageView);", "        newHolder.mPrev = holder;", "        holder.mNext = newHolder;"]}
{"imageView": ["public void removeImageView(CubeImageView imageView) {", "        if (null == imageView || null == mFirstImageViewHolder) {", "            if (holder.contains(imageView)) {"]}
{"handler": ["public void onLoading(ImageLoadHandler handler) {", "        if (null == handler) {", "            handler.onLoading(this, null);", "                    handler.onLoading(this, imageView);"]}
{"drawable": ["public void onLoadTaskFinish(BitmapDrawable drawable, ImageLoadHandler handler) {", "            handler.onLoadFinish(this, null, drawable);", "                    handler.onLoadFinish(this, imageView, drawable);", "            mImageTaskStatistics.s6_afterShow(ImageProvider.getBitmapSize(drawable));"], "handler": ["public void onLoadTaskFinish(BitmapDrawable drawable, ImageLoadHandler handler) {", "        if (null == handler) {", "            onLoadError(errorCode, handler);", "            handler.onLoadFinish(this, null, drawable);", "                    handler.onLoadFinish(this, imageView, drawable);"]}
{"key": ["public static String joinSizeInfoToKey(String key, int w, int h) {", "            return new StringBuilder(key).append(SIZE_SP).append(w).append(SIZE_SP).append(h).toString();", "        return key;"], "w": ["public static String joinSizeInfoToKey(String key, int w, int h) {", "        if (w > 0 && h != Integer.MAX_VALUE && h > 0 && h != Integer.MAX_VALUE) {", "            return new StringBuilder(key).append(SIZE_SP).append(w).append(SIZE_SP).append(h).toString();"], "h": ["public static String joinSizeInfoToKey(String key, int w, int h) {", "        if (w > 0 && h != Integer.MAX_VALUE && h > 0 && h != Integer.MAX_VALUE) {", "            return new StringBuilder(key).append(SIZE_SP).append(w).append(SIZE_SP).append(h).toString();"]}
{"key": ["public static String joinSizeTagToKey(String key, String tag) {", "        return new StringBuilder(key).append(SIZE_SP).append(tag).toString();"], "tag": ["public static String joinSizeTagToKey(String key, String tag) {", "        return new StringBuilder(key).append(SIZE_SP).append(tag).toString();"]}
{"Result": "Method without Parameter"}
{"delay": ["public void flushDiskCacheAsyncWithDelay(int delay) {", "            CLog.d(LOG_TAG, \"%s, flushDiskCacheAsyncWithDelay\", delay);", "        new FileCacheTask(TASK_FLUSH_CACHE).executeAfter(delay);"]}
{"Result": "Method without Parameter"}
{"dir": ["public static void deleteDirectoryQuickly(File dir) throws IOException {", "        if (!dir.exists()) {", "        final File to = new File(dir.getAbsolutePath() + System.currentTimeMillis());", "        dir.renameTo(to);", "        if (!dir.exists()) {", "            dir.mkdirs();"]}
{"context": ["    public static File getExternalCacheDir(Context context) {", "            File path = context.getExternalCacheDir();", "        final String cacheDir = \"/Android/data/\" + context.getPackageName() + \"/cache/\";"]}
{"path": ["    public static long getUsableSpace(File path) {", "        if (path == null) {", "            return path.getUsableSpace();", "            if (!path.exists()) {", "                final StatFs stats = new StatFs(path.getPath());"]}
{"drawable": ["private static void notifyDrawable(Drawable drawable, final boolean isDisplayed) {", "        if (drawable instanceof RecyclingBitmapDrawable) {", "            ((RecyclingBitmapDrawable) drawable).setIsDisplayed(isDisplayed);", "        } else if (drawable instanceof LayerDrawable) {", "            LayerDrawable layerDrawable = (LayerDrawable) drawable;", "            for (int i = 0, z = layerDrawable.getNumberOfLayers(); i < z; i++) {", "                notifyDrawable(layerDrawable.getDrawable(i), isDisplayed);"], "isDisplayed": ["private static void notifyDrawable(Drawable drawable, final boolean isDisplayed) {", "            ((RecyclingBitmapDrawable) drawable).setIsDisplayed(isDisplayed);", "                notifyDrawable(layerDrawable.getDrawable(i), isDisplayed);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"fab": ["public void alignSheetWithFab(View fab) {", "\t\tfab.getLocationOnScreen(fabCoords);", "\t\tint rightDiff = (sheetCoords[0] + sheet.getWidth()) - (fabCoords[0] + fab.getWidth());", "\t\tint bottomDiff = (sheetCoords[1] + sheet.getHeight()) - (fabCoords[1] + fab.getHeight());"]}
{"fab": ["public void morphFromFab(View fab, long showSheetDuration, long showSheetColorDuration,", "\t\trevealSheetWithFab(fab, getFabRevealRadius(fab), getSheetRevealRadius(), showSheetDuration,"], "showSheetDuration": ["public void morphFromFab(View fab, long showSheetDuration, long showSheetColorDuration,", "\t\trevealSheetWithFab(fab, getFabRevealRadius(fab), getSheetRevealRadius(), showSheetDuration,"], "showSheetColorDuration": ["public void morphFromFab(View fab, long showSheetDuration, long showSheetColorDuration,", "\t\t\t\tfabColor, sheetColor, showSheetColorDuration, listener);"], "listener": ["\t\t\tAnimationListener listener) {", "\t\t\t\tfabColor, sheetColor, showSheetColorDuration, listener);"]}
{"fab": ["public void morphIntoFab(View fab, long hideSheetDuration, long hideSheetColorDuration,", "\t\trevealSheetWithFab(fab, getSheetRevealRadius(), getFabRevealRadius(fab), hideSheetDuration,"], "hideSheetDuration": ["public void morphIntoFab(View fab, long hideSheetDuration, long hideSheetColorDuration,", "\t\trevealSheetWithFab(fab, getSheetRevealRadius(), getFabRevealRadius(fab), hideSheetDuration,"], "hideSheetColorDuration": ["public void morphIntoFab(View fab, long hideSheetDuration, long hideSheetColorDuration,", "\t\t\t\tsheetColor, fabColor, hideSheetColorDuration, listener);"], "listener": ["\t\t\tAnimationListener listener) {", "\t\t\t\tsheetColor, fabColor, hideSheetColorDuration, listener);"]}
{"duration": ["public void hide(long duration, final AnimationListener listener) {", "\t\toverlay.animate().alpha(0).setDuration(duration).setInterpolator(interpolator)"], "listener": ["public void hide(long duration, final AnimationListener listener) {", "\t\t\t\t\t\tif (listener != null) {", "\t\t\t\t\t\t\tlistener.onStart();", "\t\t\t\t\t\tif (listener != null) {", "\t\t\t\t\t\t\tlistener.onEnd();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"selectedPage": ["private void updateFab(int selectedPage) {", "\t\tswitch (selectedPage) {"]}
{"selectedPage": ["private void updateSnackbar(int selectedPage) {", "\t\tswitch (selectedPage) {"]}
{"endX": ["public void morphIntoSheet(int endX, int endY, Side side, int arcDegrees, float scaleFactor,", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"], "endY": ["public void morphIntoSheet(int endX, int endY, Side side, int arcDegrees, float scaleFactor,", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"], "side": ["public void morphIntoSheet(int endX, int endY, Side side, int arcDegrees, float scaleFactor,", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"], "arcDegrees": ["public void morphIntoSheet(int endX, int endY, Side side, int arcDegrees, float scaleFactor,", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"], "scaleFactor": ["public void morphIntoSheet(int endX, int endY, Side side, int arcDegrees, float scaleFactor,", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"], "duration": ["\t\t\tlong duration, AnimationListener listener) {", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"], "listener": ["\t\t\tlong duration, AnimationListener listener) {", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"]}
{"endX": ["public void morphFromSheet(int endX, int endY, Side side, int arcDegrees, float scaleFactor,", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"], "endY": ["public void morphFromSheet(int endX, int endY, Side side, int arcDegrees, float scaleFactor,", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"], "side": ["public void morphFromSheet(int endX, int endY, Side side, int arcDegrees, float scaleFactor,", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"], "arcDegrees": ["public void morphFromSheet(int endX, int endY, Side side, int arcDegrees, float scaleFactor,", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"], "scaleFactor": ["public void morphFromSheet(int endX, int endY, Side side, int arcDegrees, float scaleFactor,", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"], "duration": ["\t\t\tlong duration, AnimationListener listener) {", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"], "listener": ["\t\t\tlong duration, AnimationListener listener) {", "\t\tmorph(endX, endY, side, arcDegrees, scaleFactor, duration, listener);"]}
{"currentQuery": ["private void hideSuggestionsIfNecessary(final @NonNull QueryToken currentQuery,", "        String queryTS = currentQuery.getTokenString();", "        if (!isWaitingForResults(currentQuery) && queryTS != null && queryTS.equals(currentTS)) {"], "source": ["                                            final @NonNull TokenSource source) {", "        String currentTS = source.getCurrentTokenString();"]}
{"queryToken": ["public List<T> getSuggestions(QueryToken queryToken) {", "        String prefix = queryToken.getKeywords().toLowerCase();"]}
{"input": ["public boolean containsExplicitChar(final @NonNull CharSequence input) {", "        if (!TextUtils.isEmpty(input)) {", "            for (int i = 0; i < input.length(); i++) {", "                char c = input.charAt(i);", "                if (isExplicitChar(c)) {"]}
{"input": ["public boolean containsWordBreakingChar(final @NonNull CharSequence input) {", "        if (!TextUtils.isEmpty(input)) {", "            for (int i = 0; i < input.length(); i++) {", "                char c = input.charAt(i);", "                if (isWordBreakingChar(c)) {"]}
{"input": ["public boolean onlyLettersOrDigits(final @NonNull CharSequence input, final int numCharsToCheck, final int start) {", "        if (start < 0 || start > input.length()) {", "            if (positionToCheck >= input.length()) {", "            char charToCheck = input.charAt(positionToCheck);", "            if (!Character.isLetterOrDigit(charToCheck)) {"], "numCharsToCheck": ["public boolean onlyLettersOrDigits(final @NonNull CharSequence input, final int numCharsToCheck, final int start) {", "        for (int i = 0; i < numCharsToCheck; i++) {"], "start": ["public boolean onlyLettersOrDigits(final @NonNull CharSequence input, final int numCharsToCheck, final int start) {", "        if (start < 0 || start > input.length()) {", "            int positionToCheck = start + i;", "            if (positionToCheck >= input.length()) {", "            char charToCheck = input.charAt(positionToCheck);", "            if (!Character.isLetterOrDigit(charToCheck)) {"]}
{"text": ["protected int getSearchStartIndex(final @NonNull Spanned text, int cursor) {", "        if (cursor < 0 || cursor > text.length()) {", "        MentionSpan[] spans = text.getSpans(0, text.length(), MentionSpan.class);", "            int end = text.getSpanEnd(span);", "            if (end > closestToCursor && end <= cursor) {", "                closestToCursor = end;", "        String textString = text.toString().substring(0, cursor);", "        return Math.max(closestToCursor, lineStartIndex);"], "cursor": ["protected int getSearchStartIndex(final @NonNull Spanned text, int cursor) {", "        if (cursor < 0 || cursor > text.length()) {", "            if (end > closestToCursor && end <= cursor) {", "        String textString = text.toString().substring(0, cursor);", "        if (textString.contains(mConfig.LINE_SEPARATOR)) {", "            lineStartIndex = textString.lastIndexOf(mConfig.LINE_SEPARATOR) + 1;"]}
{"text": ["protected int getSearchEndIndex(final @NonNull Spanned text, int cursor) {", "        if (cursor < 0 || cursor > text.length()) {", "        MentionSpan[] spans = text.getSpans(0, text.length(), MentionSpan.class);", "        int closestAfterCursor = text.length();", "            int start = text.getSpanStart(span);", "            if (start < closestAfterCursor && start >= cursor) {", "                closestAfterCursor = start;", "        String textString = text.toString().substring(cursor, text.length());", "        int lineEndIndex = text.length();", "        return Math.min(closestAfterCursor, lineEndIndex);"], "cursor": ["protected int getSearchEndIndex(final @NonNull Spanned text, int cursor) {", "        if (cursor < 0 || cursor > text.length()) {", "            if (start < closestAfterCursor && start >= cursor) {", "        String textString = text.toString().substring(cursor, text.length());", "            lineEndIndex = cursor + textString.indexOf(mConfig.LINE_SEPARATOR);"]}
{"display": ["public void displayTextCounter(boolean display) {", "        if (display) {"]}
{"disable": ["private void disableSpellingSuggestions(boolean disable) {", "        if (disable) {", "        mMentionsEditText.setRawInputType(disable ? InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS : mOriginalInputType);"]}
{"Result": "Method without Parameter"}
{"factory": ["public void setMentionSpanFactory(@NonNull final MentionsEditText.MentionSpanFactory factory) {", "            mMentionsEditText.setMentionSpanFactory(factory);"]}
{"start": ["private void copy(@IntRange(from = 0) int start, @IntRange(from = 0) int end) {", "        SpannableStringBuilder copiedText = (SpannableStringBuilder) text.subSequence(start, end);", "        MentionSpan[] spans = text.getSpans(start, end, MentionSpan.class);"], "end": ["private void copy(@IntRange(from = 0) int start, @IntRange(from = 0) int end) {", "        SpannableStringBuilder copiedText = (SpannableStringBuilder) text.subSequence(start, end);", "        MentionSpan[] spans = text.getSpans(start, end, MentionSpan.class);", "            for (int i = 0; i < spans.length; i++) {", "                spanStart[i] = copiedText.getSpanStart(spans[i]);", "            intent.putExtra(KEY_MENTION_SPAN_STARTS, spanStart);", "        saveToClipboard(copiedText, intent);"]}
{"min": ["private void paste(@IntRange(from = 0) int min, @IntRange(from = 0) int max) {", "            pasteHoneycombImpl(min, max);"], "max": ["private void paste(@IntRange(from = 0) int min, @IntRange(from = 0) int max) {", "            pasteHoneycombImpl(min, max);"]}
{"min": ["    private void pasteHoneycombImpl(@IntRange(from = 0) int min, @IntRange(from = 0) int max) {", "                MentionSpan[] spans = text.getSpans(min, max, MentionSpan.class);", "                for (MentionSpan span : spans) {", "                    if (text.getSpanEnd(span) == min) {", "                    text.removeSpan(span);", "                    text.replace(min, max, selectedText);", "                    text.replace(min, max, selectedText);", "                    text.replace(min, max, selectedText);", "                text.replace(min, max, s);"], "max": ["    private void pasteHoneycombImpl(@IntRange(from = 0) int min, @IntRange(from = 0) int max) {", "                MentionSpan[] spans = text.getSpans(min, max, MentionSpan.class);", "                for (MentionSpan span : spans) {", "                    if (text.getSpanEnd(span) == min) {", "                    text.removeSpan(span);", "                    text.replace(min, max, selectedText);", "                    text.replace(min, max, selectedText);", "                    text.replace(min, max, selectedText);", "                text.replace(min, max, s);"]}
{"selStart": ["private void updateSelectionIfRequired(final int selStart, final int selEnd) {", "        MentionSpan startMentionSpan = text.getMentionSpanAtOffset(selStart);", "        int start = selStart;", "        if (text.getSpanStart(startMentionSpan) < selStart && selStart < text.getSpanEnd(startMentionSpan)) {", "            start = text.getSpanStart(startMentionSpan);", "            setSelection(start, end);"], "selEnd": ["private void updateSelectionIfRequired(final int selStart, final int selEnd) {", "        MentionSpan endMentionSpan = text.getMentionSpanAtOffset(selEnd);", "        int end = selEnd;", "        if (text.getSpanStart(endMentionSpan) < selEnd && selEnd < text.getSpanEnd(endMentionSpan)) {", "            end = text.getSpanEnd(endMentionSpan);", "            setSelection(start, end);"]}
{"index": ["private boolean onCursorChanged(final int index) {", "            if (span.isSelected() && (index < text.getSpanStart(span) || index > text.getSpanEnd(span))) {", "        MentionSpan[] currentSpans = text.getSpans(index, index, MentionSpan.class);", "            if (index > start && index < end) {"]}
{"Result": "Method without Parameter"}
{"duration": ["public static long parseDuration(String duration) {", "        if (duration == null || duration.isEmpty()) {", "        if (days.matcher(duration).matches()) {", "            Matcher matcher = days.matcher(duration);", "            matcher.matches();", "            toAdd = Long.parseLong(matcher.group(1)) * 60 * 60 * 24 * 1000;", "        } else if (hours.matcher(duration).matches()) {", "            Matcher matcher = hours.matcher(duration);", "            matcher.matches();", "            toAdd = Long.parseLong(matcher.group(1)) * 60 * 60 * 1000;", "        } else if (minutes.matcher(duration).matches()) {", "            Matcher matcher = minutes.matcher(duration);", "            matcher.matches();", "            toAdd = Long.parseLong(matcher.group(1)) * 60 * 1000;", "        } else if (seconds.matcher(duration).matches()) {", "            Matcher matcher = seconds.matcher(duration);", "            matcher.matches();", "            toAdd = Long.parseLong(matcher.group(1)) * 1000;", "        } else if (milliseconds.matcher(duration).matches()) {", "            Matcher matcher = milliseconds.matcher(duration);", "            matcher.matches();", "            toAdd = Long.parseLong(matcher.group(1));", "            throw new IllegalArgumentException(\"Invalid duration pattern : \" + duration);"]}
{"source": ["public static String escapeForXML(String source) {", "        Args.nullNotPermitted(source, \"source\");", "        for (int i = 0; i < source.length(); i++) {", "            char c = source.charAt(i);", "            switch (c) {", "                    String next = source.substring(i, Math.min(i + 6, ", "                            source.length()));", "                    if (next.startsWith(\"&lt;\") || next.startsWith(\"&gt;\") ", "                            || next.startsWith(\"&amp;\") ", "                            || next.startsWith(\"&apos;\")", "                            || next.startsWith(\"&quot;\")) {", "                        sb.append(c); ", "                default : sb.append(c);"]}
{"file": ["public static void writeToHTML(File file, String title, String svgElement) ", "            FileOutputStream fos = new FileOutputStream(file);", "            OutputStreamWriter osw = new OutputStreamWriter(fos, \"UTF-8\");"], "title": ["public static void writeToHTML(File file, String title, String svgElement) ", "            writer.write(\"<title>\" + title + \"</title>\\n\");"], "svgElement": ["public static void writeToHTML(File file, String title, String svgElement) ", "            writer.write(svgElement + \"\\n\");"]}
{"width": ["    public BufferedImage createCompatibleImage(int width, int height) {", "        WritableRaster raster = model.createCompatibleWritableRaster(width, "], "height": ["    public BufferedImage createCompatibleImage(int width, int height) {", "        WritableRaster raster = model.createCompatibleWritableRaster(width, ", "                height);", "        return new BufferedImage(model, raster, model.isAlphaPremultiplied(), "]}
{"width": ["    public VolatileImage createCompatibleVolatileImage(int width, int height, ", "        return gc.createCompatibleVolatileImage(width, height, caps, "], "height": ["    public VolatileImage createCompatibleVolatileImage(int width, int height, ", "        return gc.createCompatibleVolatileImage(width, height, caps, "], "caps": ["            ImageCapabilities caps, int transparency) throws AWTException {", "        return gc.createCompatibleVolatileImage(width, height, caps, "], "transparency": ["            ImageCapabilities caps, int transparency) throws AWTException {", "                transparency);"]}
{"Result": "Method without Parameter"}
{"family": ["    public String mapFont(String family) {", "        Args.nullNotPermitted(family, \"family\");", "        String alternate = this.alternates.get(family);", "        if (alternate != null) {", "            return alternate;", "        return family;"]}
{"value": ["public void setShapeRendering(String value) {", "        if (!value.equals(\"auto\") && !value.equals(\"crispEdges\") ", "                && !value.equals(\"geometricPrecision\") ", "                && !value.equals(\"optimizeSpeed\")) {", "            throw new IllegalArgumentException(\"Unrecognised value: \" + value);", "        this.shapeRendering = value;"]}
{"value": ["public void setTextRendering(String value) {", "        if (!value.equals(\"auto\") && !value.equals(\"optimizeSpeed\") ", "                && !value.equals(\"optimizeLegibility\") ", "                && !value.equals(\"geometricPrecision\")) {", "            throw new IllegalArgumentException(\"Unrecognised value: \" + value);", "        this.textRendering = value;"]}
{"sb": ["private void appendOptionalElementIDFromHint(StringBuilder sb) {", "            this.sb.append(\"id=\\\"\").append(elementID).append(\"\\\" \");"]}
{"path": ["private String getSVGPathData(Path2D path) {", "        PathIterator iterator = path.getPathIterator(null);"]}
{"c": ["private String rgbColorStr(Color c) {", "        b.append(c.getRed()).append(\",\").append(c.getGreen()).append(\",\")", "                .append(c.getBlue()).append(\")\");"]}
{"c": ["private String rgbaColorStr(Color c) {", "        double alphaPercent = c.getAlpha() / 255.0;", "        b.append(c.getRed()).append(\",\").append(c.getGreen()).append(\",\")", "                .append(c.getBlue());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"f": ["    public FontMetrics getFontMetrics(Font f) {", "        return this.fmImageG2D.getFontMetrics(f);"]}
{"sx": ["    public void scale(double sx, double sy) {", "        t.scale(sx, sy);"], "sy": ["    public void scale(double sx, double sy) {", "        t.scale(sx, sy);"]}
{"t": ["    public void transform(AffineTransform t) {", "        tx.concatenate(t);"]}
{"t": ["    public void setTransform(AffineTransform t) {", "        if (t == null) {", "            this.transform = new AffineTransform(t);"]}
{"shape": ["    public void setClip(Shape shape) {", "        this.clip = this.transform.createTransformedShape(shape);"]}
{"clip": ["private String registerClip(Shape clip) {", "        if (clip == null) {", "        String pathStr = getSVGPathData(new Path2D.Double(clip));", "        int index = this.clipPaths.indexOf(pathStr);", "        if (index < 0) {", "            this.clipPaths.add(pathStr);", "        return this.defsKeyPrefix + CLIP_KEY_PREFIX + index;"]}
{"s": ["    public void clip(Shape s) {", "        if (s instanceof Line2D) {", "            s = s.getBounds2D();", "            setClip(s);", "        Shape ts = this.transform.createTransformedShape(s);", "        if (!ts.intersects(this.clip.getBounds2D())) {", "          Area a1 = new Area(ts);", "          a1.intersect(a2);", "          this.clip = new Path2D.Double(a1);"]}
{"x": ["    public void clipRect(int x, int y, int width, int height) {", "        setRect(x, y, width, height);"], "y": ["    public void clipRect(int x, int y, int width, int height) {", "        setRect(x, y, width, height);"], "width": ["    public void clipRect(int x, int y, int width, int height) {", "        setRect(x, y, width, height);"], "height": ["    public void clipRect(int x, int y, int width, int height) {", "        setRect(x, y, width, height);"]}
{"x": ["    public void setClip(int x, int y, int width, int height) {", "        setRect(x, y, width, height);"], "y": ["    public void setClip(int x, int y, int width, int height) {", "        setRect(x, y, width, height);"], "width": ["    public void setClip(int x, int y, int width, int height) {", "        setRect(x, y, width, height);"], "height": ["    public void setClip(int x, int y, int width, int height) {", "        setRect(x, y, width, height);"]}
{"img": ["private byte[] getPNGBytes(Image img) {", "        if (img instanceof RenderedImage) {", "            ri = (RenderedImage) img;", "            BufferedImage bi = new BufferedImage(img.getWidth(null), ", "                    img.getHeight(null), BufferedImage.TYPE_INT_ARGB);", "            g2.drawImage(img, 0, 0, null);", "            ImageIO.write(ri, \"png\", baos);"]}
{"img": ["    public void drawRenderedImage(RenderedImage img, AffineTransform xform) {", "        BufferedImage bi = GraphicsUtils.convertRenderedImage(img);", "        drawImage(bi, xform, null);"], "xform": ["    public void drawRenderedImage(RenderedImage img, AffineTransform xform) {", "        drawImage(bi, xform, null);"]}
{"img": ["    public void drawRenderableImage(RenderableImage img, ", "        RenderedImage ri = img.createDefaultRendering();"], "xform": ["            AffineTransform xform) {", "        drawRenderedImage(ri, xform);"]}
{"id": ["private String getRadialGradientElement(String id, RadialGradientPaint rgp) {", "        StringBuilder b = new StringBuilder(\"<radialGradient id=\\\"\").append(id)"], "rgp": ["private String getRadialGradientElement(String id, RadialGradientPaint rgp) {", "        Point2D center = rgp.getCenterPoint();", "        Point2D focus = rgp.getFocusPoint();", "        float radius = rgp.getRadius();", "        Color[] colors = rgp.getColors();", "        float[] fractions = rgp.getFractions();"]}
{"Result": "Method without Parameter"}
{"string": ["public static List<String> getParts(String string, final String... regexpList) {", "      final Matcher matcher = pattern.matcher(string);", "      final boolean found = matcher.find();", "      if (!found) {", "      final String part = matcher.group(1).trim();", "      parts.add(part);", "      string = string.replaceFirst(quote(matcher.group()), \"\").trim();"]}
{"statKey": ["protected void recordLevel(final String statKey, final long level) {", "        final String longKey = getActualStatKey(statKey);", "        statsCollector.recordLevel(longKey, level);"], "level": ["protected void recordLevel(final String statKey, final long level) {", "        statsCollector.recordLevel(longKey, level);"]}
{"statKey": ["protected void recordTiming(String statKey, long timeSpan) {", "        final String longKey = getActualStatKey(statKey);", "        statsCollector.recordTiming(longKey, timeSpan);"], "timeSpan": ["protected void recordTiming(String statKey, long timeSpan) {", "        statsCollector.recordTiming(longKey, timeSpan);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"clientRequest": ["    public void handleRequest(final HttpRequest clientRequest) {", "            httpRequestHolderList.add(new HttpRequestHolder(clientRequest, time));", "        if (httpClientRequestPredicate.test(clientRequest)) {", "            createBackEndRequestPopulateAndForward(clientRequest);"]}
{"clientRequest": ["private void createBackEndRequestPopulateAndForward(final HttpRequest clientRequest) {", "                handleHttpClientErrorsForBackend(clientRequest, new HttpClientClosedConnectionException(\"Not connected\"));", "                    .copyRequest(clientRequest).setBinaryReceiver(new HttpBinaryReceiver() {", "                            handleBackendClientResponses(clientRequest, code, contentType, body, headers);", "                    }).setErrorHandler(e -> handleHttpClientErrorsForBackend(clientRequest, e));", "            handleHttpClientErrorsForBackend(clientRequest, httpClientClosedConnectionException);", "            handleHttpClientErrorsForBackend(clientRequest, ex);"]}
{"clientRequest": ["private void handleHttpClientErrorsForBackend(final HttpRequest clientRequest, final Exception e) {", "                clientRequest.address());", "        if (!clientRequest.isHandled()) {", "            clientRequest.handled();", "            clientRequest.getReceiver().error(String.format(\"\\\"%s\\\"\", errorMessage));"], "e": ["private void handleHttpClientErrorsForBackend(final HttpRequest clientRequest, final Exception e) {", "        errorHandler.accept(e);", "        logger.error(errorMessage, e);"]}
{"clientRequest": ["private void handleBackendClientResponses(final HttpRequest clientRequest,", "        if (!clientRequest.isHandled()) {", "            clientRequest.handled();", "            clientRequest.getReceiver().response(code, contentType, body, headers);"], "code": ["                                              final int code,", "            clientRequest.getReceiver().response(code, contentType, body, headers);"], "contentType": ["                                              final String contentType,", "            clientRequest.getReceiver().response(code, contentType, body, headers);"], "body": ["                                              final byte[] body,", "            clientRequest.getReceiver().response(code, contentType, body, headers);"], "headers": ["                                              final MultiMap<String, String> headers) {", "            clientRequest.getReceiver().response(code, contentType, body, headers);"]}
{"Result": "Method without Parameter"}
{"configs": ["public static ServiceDiscovery createLokateServiceDiscovery(final List<URI> configs) {", "                                DiscoveryService.create(configs)))"]}
{"methodCall": ["private void doCall(MethodCall<Object> methodCall) {", "                    methodCall.name(),", "                    methodCall.address(),", "                    \"\\n\", methodCall);", "            if (methodCall.hasCallback()) {", "                callbackManager.registerCallbacks(methodCall);", "            methodCall = handleBeforeMethodCall(methodCall, continueFlag);"]}
{"methodCall": ["    public void call(final MethodCall<Object> methodCall) {", "                    methodCall.name() + \" \" + \" \" +", "                    methodCall.address() +", "                    \"\\n\" + methodCall);", "        methodSendQueue.send(methodCall);"]}
{"serviceInterface": ["    public <T> T createLocalProxy(final Class<T> serviceInterface, final String myService) {", "        return factory.createLocalProxy(serviceInterface, myService, this, beforeMethodSent);"], "myService": ["    public <T> T createLocalProxy(final Class<T> serviceInterface, final String myService) {", "        final Consumer<MethodCall<Object>> callConsumer = this.serviceMapping.get(myService);", "        if (callConsumer == null) {", "            logger.error(\"Service requested does not exist \" + myService);", "        return factory.createLocalProxy(serviceInterface, myService, this, beforeMethodSent);"]}
{"methodCall": ["private MethodCall<Object> beforeMethodCall(MethodCall<Object> methodCall, boolean[] continueCall) {", "        if (this.beforeMethodCall.before(methodCall)) {", "            methodCall = transformBeforeMethodCall(methodCall);", "            continueCall[0] = this.beforeMethodCallAfterTransform.before(methodCall);", "            return methodCall;", "        return methodCall;"], "continueCall": []}
{"methodCall": ["private MethodCall<Object> transformBeforeMethodCall(MethodCall<Object> methodCall) {", "            return methodCall;", "        Object arg = this.argTransformer.transform(methodCall);", "        return MethodCallBuilder.transformed(methodCall, arg);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"dnsServiceName": ["public String findServiceName(final String dnsServiceName) {", "        String serviceName = dnsServiceNameToServiceName.get(dnsServiceName);", "        serviceName = serviceName == null ? dnsServiceName : serviceName;", "        if (debug) logger.debug(\"FindServiceName dnsServiceName={} serviceName={}\", dnsServiceName, serviceName);", "        return serviceName;"]}
{"callback": ["public void loadServiceEndpointsByServiceName(final Callback<List<EndpointDefinition>> callback,", "        loadServiceEndpointsByDNSService(callback, findDnsServiceName(serviceName));"], "serviceName": ["                                                  final String serviceName) {", "        loadServiceEndpointsByDNSService(callback, findDnsServiceName(serviceName));"]}
{"srvRecord": ["private EndpointDefinition convertSrvRecordToEndpointDefinition(final SrvRecord srvRecord) {", "        return new EndpointDefinition(findServiceName(srvRecord.service()), srvRecord.target(),", "                srvRecord.port());"]}
{"request": ["protected CORSRequestType checkRequestType(final HttpRequestHolder request) {", "        if (request == null) {", "        String originHeader = request.getHeaders().get(REQUEST_HEADER_ORIGIN);", "            } else if (isLocalOrigin(request, originHeader)) {", "                String method = request.getMethod();", "                                request.getHeaders().get(", "                        String mediaType = request.getContentType();"]}
{"request": ["private void handleHttpRequest(final HttpServerRequest request) {", "            setupMetrics(request);", "            logger.debug(\"HttpServerVertx::handleHttpRequest::{}:{}\", request.method(), request.uri());", "        switch (request.method().toString()) {", "                handleRequestWithBody(request);", "                handleRequestWithNoBody(request);", "                throw new IllegalStateException(\"method not supported yet \" + request.method());"]}
{"methodCall": ["private boolean doHandleMethodCall(MethodCall<Object> methodCall,", "            logger.debug(\"ServiceImpl::doHandleMethodCall() METHOD CALL\" + methodCall);", "            if (methodCall.hasCallback() && serviceMethodHandler.couldHaveCallback(methodCall.name())) {", "                callbackManager.registerCallbacks(methodCall);", "        methodCall = beforeMethodProcessing(methodCall, continueFlag);"], "serviceMethodHandler": ["                                       final ServiceMethodHandler serviceMethodHandler) {", "            if (methodCall.hasCallback() && serviceMethodHandler.couldHaveCallback(methodCall.name())) {", "        Response<Object> response = serviceMethodHandler.receiveMethodCall(methodCall);"]}
{"host": ["public static Consul consul(final String host, final int port) {", "            return new Consul(new URL(\"http\", host, port, \"\").toString());"], "port": ["public static Consul consul(final String host, final int port) {", "            return new Consul(new URL(\"http\", host, port, \"\").toString());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"promise": ["public static <T> Callback<T> convertPromise(final Promise<T> promise) {", "        return convertPromiseToCallback(promise, CallbackBuilder.callbackBuilder());"]}
{"reactor": ["public static <T> Callback<T> convertPromise(final Reactor reactor, final Promise<T> promise) {", "        return convertPromiseToCallback(promise, reactor.callbackBuilder());"], "promise": ["public static <T> Callback<T> convertPromise(final Reactor reactor, final Promise<T> promise) {", "        return convertPromiseToCallback(promise, reactor.callbackBuilder());"]}
{"promiseConsumer": ["public <T> Callback<T> callback(final Consumer<Promise<T>> promiseConsumer) {", "        promiseConsumer.accept(promise);"]}
{"Result": "Method without Parameter"}
{"serviceNameToFetch": ["private void doFailOverHealthServicesLoad(final String serviceNameToFetch, Exception ex) {", "                    \" services for \" + serviceNameToFetch, ex);", "            final List<EndpointDefinition> healthyServices = backupProvider.loadServices(serviceNameToFetch);", "            populateServiceMap(serviceNameToFetch, healthyServices);", "            serviceNamesBeingLoaded.remove(serviceNameToFetch);", "                    \" services for \" + serviceNameToFetch, ex);"], "ex": ["private void doFailOverHealthServicesLoad(final String serviceNameToFetch, Exception ex) {", "                    \" services for \" + serviceNameToFetch, ex);", "                    \" services for \" + serviceNameToFetch, ex);"]}
{"Result": "Method without Parameter"}
{"fireAfter": ["public void addOneShotAfterTask(final long fireAfter, final TimeUnit timeUnit, final Runnable task) {", "        fireOnceAfterTasks.add(new FireOnceTask(task, timeUnit, fireAfter));"], "timeUnit": ["public void addOneShotAfterTask(final long fireAfter, final TimeUnit timeUnit, final Runnable task) {", "        fireOnceAfterTasks.add(new FireOnceTask(task, timeUnit, fireAfter));"], "task": ["public void addOneShotAfterTask(final long fireAfter, final TimeUnit timeUnit, final Runnable task) {", "        fireOnceAfterTasks.add(new FireOnceTask(task, timeUnit, fireAfter));"]}
{"Result": "Method without Parameter"}
{"asyncFutureCallback": ["public <T> AsyncFutureCallback<T> removeFuture(AsyncFutureCallback<T> asyncFutureCallback) {", "        this.removeFutureQueue.offer(asyncFutureCallback);", "        return asyncFutureCallback;"]}
{"coordinator": ["public CallbackCoordinator coordinateWithTimeout(final CallbackCoordinator coordinator,", "                if (coordinator.checkComplete()) {", "                return coordinator.timeOutDuration() == -1 ? timeoutDurationMS : coordinator.timeOutDuration();", "                return coordinator.startTime() == -1 ? theStartTime : coordinator.startTime();", "                coordinator.finished();", "                coordinator.cancel();"], "startTime": ["                                                     final long startTime,", "        final long theStartTime = startTime == -1 ? currentTime : startTime;", "                if (startTime() == -1 || timeOutDuration() == -1) {", "                if ((now - startTime()) > timeOutDuration()) {", "            public long startTime() {", "                return coordinator.startTime() == -1 ? theStartTime : coordinator.startTime();"], "timeoutDuration": ["                                                     final long timeoutDuration,", "        final long timeoutDurationMS = timeUnit.toMillis(timeoutDuration);", "                return coordinator.timeOutDuration() == -1 ? timeoutDurationMS : coordinator.timeOutDuration();"], "timeUnit": ["                                                     final TimeUnit timeUnit,", "        final long timeoutDurationMS = timeUnit.toMillis(timeoutDuration);"], "timeOutHandler": ["                                                     final Runnable timeOutHandler,", "                        timeOutHandler.run();"], "finishedHandler": ["                                                     final Runnable finishedHandler) {", "                if (finishedHandler != null) {", "                    finishedHandler.run();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"operationDescription": ["            final String operationDescription,", "                    logger.debug(\"{} returned {}\", operationDescription, t);", "            logger.error(String.format(\"ERROR calling %s\", operationDescription), error);", "            logger.error(\"TIMEOUT calling {}\", operationDescription);"], "callback": ["            final Callback<T> callback,", "                callback.resolve(t);", "            callback.onError(error);", "            callback.onTimeout();"], "logger": ["            final Logger logger,", "                if (logger.isDebugEnabled()) {", "                    logger.debug(\"{} returned {}\", operationDescription, t);", "            logger.error(String.format(\"ERROR calling %s\", operationDescription), error);", "            logger.error(\"TIMEOUT calling {}\", operationDescription);"], "timeUnit": ["            final TimeUnit timeUnit,", "        }).setTimeoutTimeUnit(timeUnit).setTimeoutDuration(timeoutDuration)"], "timeoutDuration": ["            final long timeoutDuration) {", "        }).setTimeoutTimeUnit(timeUnit).setTimeoutDuration(timeoutDuration)"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"webSocketMessage": ["public void handleWebSocketCall(final WebSocketMessage webSocketMessage) {", "        if (debug) logger.debug(\"WebSocket message: \" + webSocketMessage);", "        WebSocketDelegate webSocketDelegate = webSocketDelegateMap.get(webSocketMessage.getRemoteAddress());", "            webSocketDelegate = new WebSocketDelegate(protocolBatchSize, webSocketMessage);", "            webSocketDelegateMap.put(webSocketMessage.getRemoteAddress(), webSocketDelegate);", "                final List<MethodCall<Object>> methodCallListToBeParsedFromBody =", "                        createMethodCallListToBeParsedFromBody(webSocketMessage.getRemoteAddress(),", "                                webSocketMessage.getMessage(), webSocketMessage);", "                if (methodCallListToBeParsedFromBody.size() > 0) {", "                    methodCallSendQueue.sendBatch(methodCallListToBeParsedFromBody);"]}
{"Result": "Method without Parameter"}
{"eventListener": ["public void add(final EventListener<T> eventListener) {", "        if (eventListener.subscriber()) {", "            if (debug) logger.debug(\"subscription to channel <> from <> \", name, eventListener);", "            listeners.add(eventListener);", "            if (debug) logger.debug(\"consumer to channel <> from <> \", name, eventListener);", "            consumer = eventListener;"]}
{"Result": "Method without Parameter"}
{"json": ["    public <T> T fromJson(String json, Class<T> cls) {", "        return parser.get().parse(cls, json);"], "cls": ["    public <T> T fromJson(String json, Class<T> cls) {", "        return parser.get().parse(cls, json);"]}
{"json": ["    public <T> List<T> fromJsonArray(String json, Class<T> componentClass) {", "        return parser.get().parseList(componentClass, json);"], "componentClass": ["    public <T> List<T> fromJsonArray(String json, Class<T> componentClass) {", "        return parser.get().parseList(componentClass, json);"]}
{"object": ["    public String toJson(Object object) {", "        return serializer.get().serialize(object).toString();"]}
{"json": ["    public <K, V> Map<K, V> fromJsonMap(String json, Class<K> componentClassKey, Class<V> componentClassValue) {", "        Map map = (Map) parser.get().parse(json);", "        return extractMap(componentClassKey, componentClassValue, map, mapper);"], "componentClassKey": ["    public <K, V> Map<K, V> fromJsonMap(String json, Class<K> componentClassKey, Class<V> componentClassValue) {", "        return extractMap(componentClassKey, componentClassValue, map, mapper);"], "componentClassValue": ["    public <K, V> Map<K, V> fromJsonMap(String json, Class<K> componentClassKey, Class<V> componentClassValue) {", "        return extractMap(componentClassKey, componentClassValue, map, mapper);"]}
{"valueMap": ["private <V> V convertToMap(ValueMap valueMap) {", "        final Map<String, Object> map = new LinkedHashMap<>(valueMap.size());", "        valueMap.entrySet().forEach(new Consumer<Map.Entry<String, Object>>() {"]}
{"name": ["public boolean couldHaveCallback(final String name) {", "        final Boolean has = hasHandlerMap.get(name);", "        if (has == null) {", "        return has;"]}
{"returnType": ["public <T> CallbackBuilder setCallback(final Class<T> returnType, final Callback<T> callback) {", "        return withCallback(returnType, callback);"], "callback": ["public <T> CallbackBuilder setCallback(final Class<T> returnType, final Callback<T> callback) {", "        return withCallback(returnType, callback);"]}
{"callback": ["public <T> CallbackBuilder wrap(final Callback<T> callback) {", "        this.withErrorHandler(callback::onError);", "        this.withTimeoutHandler(callback::onTimeout);", "        this.withCallback(callback);"]}
{"componentClass": [], "callback": ["                                                final Callback<List<T>> callback) {", "        this.callback = callback;"]}
{"componentClass": [], "callback": ["                                               final Callback<Set<T>> callback) {", "        this.callback = callback;"]}
{"componentClass": [], "callback": ["                                                      final Callback<Collection<T>> callback) {", "        this.callback = callback;"]}
{"keyClass": [], "valueClass": [], "callback": ["                                                  final Callback<Map<K, V>> callback) {", "        this.callback = callback;"]}
{"cls": [], "callback": ["public <T> CallbackBuilder withOptionalCallback(final Class<T> cls, final Callback<Optional<T>> callback) {", "        this.callback = callback;"]}
{"name": ["public HttpResponseBuilder addHeader(final String name, final String value) {", "        getHeaders().put(name, value);"], "value": ["public HttpResponseBuilder addHeader(final String name, final String value) {", "        getHeaders().put(name, value);"]}
{"serviceId": ["public boolean isServiceRegistered(final String serviceId) {", "        return serviceIdToService.containsKey(serviceId);"]}
{"Result": "Method without Parameter"}
{"registration": ["public void register(final Registration registration) {", "        HTTP.Response response = HTTP.jsonRestCallViaPUT(uri.toString(), toJson(registration));", "        if (response.status() != 200) {", "            die(\"Error registering service with Consul\", uri, registration, response.payloadAsString());"]}
{"serviceId": ["public void deregister(final String serviceId) {", "        final URI uri = createURI(\"/service/deregister/\" + serviceId);", "        HTTP.Response response = HTTP.getResponse(uri.toString());", "                    uri, serviceId, response.status(), response.payloadAsString());"]}
{"checkId": ["public void deregisterCheck(String checkId) {", "        final URI uri = createURI(\"/check/deregister/\" + checkId);", "        HTTP.Response response = HTTP.getResponse(uri.toString());", "                    uri, checkId, response.status(), response.statusMessageAsString(),"]}
{"checkId": ["public void check(String checkId, Status status, String note) {", "        final URI uri = createURI(\"/check/\" + status.getUri() + \"/\" + checkId);", "        final HTTP.Response httpResponse = Str.isEmpty(note) ? HTTP.getResponse(uri.toString()) :", "                HTTP.getResponse(uri.toString() + \"?note=\" + note);", "            notRegistered(\"Unable to perform check\", uri, httpResponse.code(), httpResponse.statusMessageAsString(),"], "status": ["public void check(String checkId, Status status, String note) {", "        final URI uri = createURI(\"/check/\" + status.getUri() + \"/\" + checkId);"], "note": ["public void check(String checkId, Status status, String note) {", "        final HTTP.Response httpResponse = Str.isEmpty(note) ? HTTP.getResponse(uri.toString()) :", "                HTTP.getResponse(uri.toString() + \"?note=\" + note);", "        if (httpResponse.code() != 200) {", "            notRegistered(\"Unable to perform check\", uri, httpResponse.code(), httpResponse.statusMessageAsString(),", "                    httpResponse.body());"]}
{"checkId": ["public void pass(String checkId, @SuppressWarnings(\"SameParameterValue\") String note) throws NotRegisteredException {", "        checkTtl(checkId, Status.PASS, note);"], "note": ["public void pass(String checkId, @SuppressWarnings(\"SameParameterValue\") String note) throws NotRegisteredException {", "        checkTtl(checkId, Status.PASS, note);"]}
{"checkId": ["public void warn(String checkId, String note) throws NotRegisteredException {", "        checkTtl(checkId, Status.WARN, note);"], "note": ["public void warn(String checkId, String note) throws NotRegisteredException {", "        checkTtl(checkId, Status.WARN, note);"]}
{"Result": "Method without Parameter"}
{"response": ["private void handleAsyncCallback(final Response<Object> response, final Callback<Object> handler) {", "        if (response.wasErrors()) {", "            handler.onError(new Exception(response.body().toString()));", "            handler.accept(response.body());"], "handler": ["private void handleAsyncCallback(final Response<Object> response, final Callback<Object> handler) {", "            handler.onError(new Exception(response.body().toString()));", "            handler.accept(response.body());"]}
{"serviceName": ["private void send(final String serviceName, final String message, final Consumer<Exception> exceptionConsumer) {", "            if (serviceName.startsWith(uri)) {", "                webSocketURI = serviceName;", "                webSocketURI = Str.add(uri, \"/\", serviceName);", "            this.webSocket = httpServerProxy.createWebSocket(webSocketURI);", "            wireWebSocket(serviceName, message);", "            if (webSocket.isClosed() && connected()) {", "                this.webSocket.openAndNotify(netSocket -> {", "                    webSocket.sendText(message, exceptionConsumer);", "                webSocket.sendText(message);"], "message": ["private void send(final String serviceName, final String message, final Consumer<Exception> exceptionConsumer) {", "            wireWebSocket(serviceName, message);", "                    webSocket.sendText(message, exceptionConsumer);", "                webSocket.sendText(message);"], "exceptionConsumer": ["private void send(final String serviceName, final String message, final Consumer<Exception> exceptionConsumer) {", "                    webSocket.sendText(message, exceptionConsumer);", "                }, exceptionConsumer);"]}
{"serviceInterface": ["public <T> T createProxy(final Class<T> serviceInterface, final String serviceName) {", "        return createProxy(serviceInterface, serviceName, Str.join('-', uri, serviceName, UUID.randomUUID().toString()));"], "serviceName": ["public <T> T createProxy(final Class<T> serviceInterface, final String serviceName) {", "        return createProxy(serviceInterface, serviceName, Str.join('-', uri, serviceName, UUID.randomUUID().toString()));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"sendQueue": ["private SendQueue<T> createJsonSendQueue(final SendQueue<String> sendQueue) {", "                sendQueue.send(toJsonFunction.apply(item));", "                sendQueue.sendAndFlush(toJsonFunction.apply(item));", "                    sendQueue.send(toJsonFunction.apply(item));", "                    sendQueue.send(toJsonFunction.apply(item));", "                    sendQueue.send(toJsonFunction.apply(item));", "                return sendQueue.shouldBatch();", "                sendQueue.flushSends();", "                return sendQueue.size();", "                return sendQueue.name();", "                sendQueue.stop();"]}
{"listener": ["    public void startListener(final ReceiveQueueListener<T> listener) {", "        queue.startListener(item -> listener.receive(fromJsonFunction.apply(item)));"]}
{"Result": "Method without Parameter"}
{"name": ["    public void checkInOk(final String name) {", "        if (debug) logger.debug(\"HealthService::checkInOk() {} \", name);", "        final NodeHealthStat nodeHealthStat = getServiceHealthStat(name);", "        nodeHealthStat.setLastCheckIn(super.time);", "        nodeHealthStat.setReason(null);", "        nodeHealthStat.setStatus(HealthStatus.PASS);", "        onCheckIn.ifPresent(checkIn -> checkIn.accept(BeanUtils.copy(nodeHealthStat)));"]}
{"name": ["    public void failWithError(final String name, final Throwable error) {", "        logger.error(\"HealthService::fail() {}\", name);", "        final NodeHealthStat nodeHealthStat = getServiceHealthStat(name);", "        nodeHealthStat.setStatus(HealthStatus.FAIL);", "        nodeHealthStat.setReason(HealthFailReason.ERROR);", "        nodeHealthStat.setLastCheckIn(super.time);", "        nodeHealthStat.setError(error);", "        onFail.ifPresent(checkIn -> checkIn.accept(BeanUtils.copy(nodeHealthStat)));"], "error": ["    public void failWithError(final String name, final Throwable error) {", "        logger.error(\"HealthService::fail() {}\", name);", "        nodeHealthStat.setError(error);"]}
{"requestHeaders": ["public ManagedServiceBuilder enableLoggingMappedDiagnosticContext(final Set<String> requestHeaders) {", "        this.requestHeadersToTrackForMappedDiagnosticContext = Collections.unmodifiableSet(requestHeaders);"]}
{"dataCenter": ["public ManagedServiceBuilder enableConsulServiceDiscovery(final String dataCenter) {", "        consulServiceDiscoveryBuilder.setDatacenter(dataCenter);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"endpointService": ["            final Object endpointService, final ServiceManagementBundle serviceManagementBundle) {", "        addEndpointServiceWithAliasAndQueueHandlerCallbacks(null, endpointService, new QueueCallBackHandler() {"], "serviceManagementBundle": ["            final Object endpointService, final ServiceManagementBundle serviceManagementBundle) {", "                serviceManagementBundle.process();"]}
{"alias": ["            final String alias,", "        addEndpointServiceWithAliasAndQueueHandlerCallbacks(alias, endpointService, new QueueCallBackHandler() {"], "endpointService": ["            final Object endpointService, final ServiceManagementBundle serviceManagementBundle) {", "        addEndpointServiceWithAliasAndQueueHandlerCallbacks(alias, endpointService, new QueueCallBackHandler() {"], "serviceManagementBundle": ["            final Object endpointService, final ServiceManagementBundle serviceManagementBundle) {", "                serviceManagementBundle.process();"]}
{"endpointService": ["public ManagedServiceBuilder addEndpointService(final Object endpointService) {", "        getContextMetaBuilder().addService(endpointService.getClass());", "        getEndpointServices().add(endpointService);"]}
{"alias": ["public ManagedServiceBuilder addEndpointService(final String alias, final Object endpointService) {", "        getContextMetaBuilder().addService(alias, endpointService.getClass());", "        getEndpointServiceMapWithAlias().put(alias, endpointService);"], "endpointService": ["public ManagedServiceBuilder addEndpointService(final String alias, final Object endpointService) {", "        getContextMetaBuilder().addService(alias, endpointService.getClass());", "        getEndpointServiceMapWithAlias().put(alias, endpointService);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"sessionId": ["public boolean destroy(final String sessionId, final Session session, final String datacenter) {", "        final URI uri = createURI(\"/destroy/\" + sessionId);", "        HTTP.Response httpResponse = HTTP.jsonRestCallViaPUT(uri.toString() + \"?\" + httpRequestBuilder.paramString(),", "            die(\"Unable destroy the session\", sessionId, uri, httpResponse);"], "session": ["public boolean destroy(final String sessionId, final Session session, final String datacenter) {", "        HTTP.Response httpResponse = HTTP.jsonRestCallViaPUT(uri.toString() + \"?\" + httpRequestBuilder.paramString(),", "                toJson(session));", "        if (httpResponse == null || httpResponse.code() != 200) {", "            die(\"Unable destroy the session\", sessionId, uri, httpResponse);", "        return httpResponse.code() == 200;"], "datacenter": ["public boolean destroy(final String sessionId, final Session session, final String datacenter) {", "                .getHttpRequestBuilder(datacenter, null, null, \"\");"]}
{"serviceName": ["    public List<EndpointDefinition> loadServices(final String serviceName) {", "        if (debug) logger.debug(\"Loading Service {}\", serviceName);", "                .build(), serviceName);"]}
{"key": ["private void delete(String key, Map<String, String> params) {", "        final URI uri = createURI(\"/\" + key);", "        final HTTP.Response httpResponse = HTTP.deleteResponse(uri.toString() + \"?\" + httpRequestBuilder.paramString());", "            die(\"Unable to delete key\", uri, key, httpResponse.code(), httpResponse.body());"], "params": ["private void delete(String key, Map<String, String> params) {", "        final Set<Map.Entry<String, String>> entries = params.entrySet();"]}
{"request": ["public void handleRequest(final HttpRequest request) {", "            System.out.println(\"HttpServer::handleRequest \" + request);", "            logger.debug(\"HttpServer::handleRequest\" + request);", "        if (shouldContinueHttpRequest.test(request)) {", "            httpRequestConsumer.accept(request);"]}
{"Result": "Method without Parameter"}
{"item": ["private void sendToEventManager(T item) {", "            logger.debug(\"EventBusQueueAdapter::sendToEventManager({})\", item);", "                eventManager.sendArguments(channel, item);", "                eventManager.sendArguments(channel, item);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"eventConnector": ["public void remove(final EventConnector eventConnector) {", "        if (eventConnector != null) {", "                if (eventConnector instanceof RemoteTCPClientProxy) {", "                    final RemoteTCPClientProxy remoteTCPClientProxy = (RemoteTCPClientProxy) eventConnector;", "                            remoteTCPClientProxy.host(), \" port \", remoteTCPClientProxy.port(),", "                            \"connected \", remoteTCPClientProxy.connected()));", "                    remoteTCPClientProxy.silentClose();", "                this.eventConnectors.remove(eventConnector);"]}
{"event": ["    public void forwardEvent(final EventTransferObject<Object> event) {", "        if (debug) logger.debug(\"forwardEvent \" + event.channel() + \" size \" + eventConnectors.size());", "                eventConnector.forwardEvent(event);", "        if (debug) logger.debug(\"forwardEvent done \" + event.channel());"]}
{"Result": "Method without Parameter"}
{"serviceName": ["public static MicroserviceConfig readConfig(final String serviceName) {", "                    qbitEnv != null && !qbitEnv.isEmpty() ? serviceName + \"_\" + qbitEnv + \".json\" :", "                            serviceName + \".json\";"]}
{"methodCall": ["private void registerHandlerCallbackForClient(final MethodCall<Object> methodCall,", "        final HandlerKey handlerKey = new HandlerKey(methodCall.returnAddress(), methodCall.address(),", "                methodCall.id(), methodCall.timestamp());"], "handler": ["                                                  final Callback<Object> handler) {", "        handlers.put(handlerKey, handler);"]}
{"methodCall": ["    public boolean before(final MethodCall methodCall) {", "        final Optional<HttpRequest> httpRequest = findHttpRequest(methodCall);", "        if (httpRequest.isPresent()) {", "            extractRequestInfoAndPutItIntoMappedDiagnosticContext(httpRequest.get());"]}
{"httpRequest": ["private void extractRequestInfoAndPutItIntoMappedDiagnosticContext(final HttpRequest httpRequest) {", "        MDC.put(REQUEST_URI, httpRequest.getUri());", "        MDC.put(REQUEST_REMOTE_ADDRESS, httpRequest.getRemoteAddress());", "        MDC.put(REQUEST_HTTP_METHOD, httpRequest.getMethod());", "        MDC.put(REQUEST_ID, Long.toString(httpRequest.getMessageId()));", "        extractHeaders(httpRequest);"]}
{"httpRequest": ["private void extractHeaders(final HttpRequest httpRequest) {", "            final MultiMap<String, String> headers = httpRequest.getHeaders();"]}
{"request": ["    public void handleRestCall(final HttpRequest request) {", "        final MethodCall<Object> methodCall = standardRequestTransformer.transform(request, errorList);", "            if (!addRequestToCheckForTimeouts(request)) {", "                handleOverflow(request);", "            if (!request.isHandled()) {", "                handleErrorConverting(request, errorList, methodCall);", "                .get(RequestMethod.valueOf(request.getMethod())).get(request.address());", "            request.handled();", "            writeResponse(request.getReceiver(), responseCode == -1 ? HttpStatus.ACCEPTED : responseCode,"]}
{"response": ["    public void handleResponseFromServiceToHttpResponse(final Response<Object> response, final HttpRequest originatingRequest) {", "        if (response.wasErrors()) {", "            handleError(response, originatingRequest);", "            if (response.body() instanceof HttpResponse) {", "                writeHttpResponse(originatingRequest.getReceiver(), ((HttpResponse) response.body()));", "                MultiMap<String, String> headers = response.headers();", "                    if (response.headers() == MultiMap.EMPTY) {", "                        headers = response.headers();", "                        jsonMapper.toJson(response.body()),"], "originatingRequest": ["    public void handleResponseFromServiceToHttpResponse(final Response<Object> response, final HttpRequest originatingRequest) {", "        final String key = Str.add(\"\" + originatingRequest.id(), \"|\", originatingRequest.returnAddress());", "            handleError(response, originatingRequest);", "                writeHttpResponse(originatingRequest.getReceiver(), ((HttpResponse) response.body()));", "                        .get(RequestMethod.valueOf(originatingRequest.getMethod())).get(originatingRequest.address());", "                writeResponse(originatingRequest.getReceiver(),"]}
{"request": ["private boolean addRequestToCheckForTimeouts(final Request<Object> request) {", "        String key = Str.add(\"\" + request.id(), \"|\", request.returnAddress());", "        this.outstandingRequestMap.put(key, request);"]}
{"integer": ["    public boolean add(Long integer) {", "        values[end] = integer;"]}
{"integer": ["    public StatList add(int integer) {", "        values[end] = integer;"]}
{"Result": "Method without Parameter"}
{"index": ["    public Long set(int index, Long element) {", "        long oldValue = values[index];", "        return oldValue;"], "element": ["    public Long set(int index, Long element) {", "        values[index] = element;"]}
{"function": ["public long reduceBy(Object function, String name) {", "        return Lng.reduceBy(values, end, function, name);"], "name": ["public long reduceBy(Object function, String name) {", "        return Lng.reduceBy(values, end, function, name);"]}
{"methodBuilder": ["    public void beforeMethodSent(final MethodCallBuilder methodBuilder) {", "        if (methodBuilder.getOriginatingRequest() == null) {", "                methodBuilder.setOriginatingRequest(request.get());"]}
{"changeNotification": ["private void notifyListener(ChangeNotification<T> changeNotification, boolean newListener) {", "      checkNotNull(changeNotification, \"changeNotification\");", "            listener.onChange(changeNotification);"], "newListener": ["private void notifyListener(ChangeNotification<T> changeNotification, boolean newListener) {", "          if (!(newListener && notified)) {"]}
{"kryo": ["public static Kryo addDefaultSerializers(Kryo kryo) {", "        ArrayListSubListSerializer.addDefaultSerializer(kryo);", "        AbstractListSubListSerializer.addDefaultSerializer(kryo);", "        JavaUtilSubListSerializer.addDefaultSerializer(kryo);", "        return kryo;"]}
{"type": ["private Method getParseFromMethod(Class<? extends T> type) throws NoSuchMethodException {", "            parseFromMethod = type.getMethod(\"parseFrom\", byte[].class);"]}
{"Result": "Method without Parameter"}
{"i": ["protected String _parseUnquotedFieldName(int i)", "        boolean firstOk = IdentifierUtils.isIdStartLenient(i);", "        if (!firstOk) {", "            _reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or single-quote (for quoted) to start field name\");"]}
{"i": ["protected JsonToken _handleUnexpectedValue(int i)", "        switch (i) {", "        _reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");"]}
{"Result": "Method without Parameter"}
{"matchStr": ["protected void _matchToken(String matchStr, int i)", "        final int len = matchStr.length();", "            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {", "                _reportInvalidToken(matchStr.substring(0, i), \"'null', 'true', 'false' or NaN\");", "            _reportInvalidToken(matchStr.substring(0, i), \"'null', 'true', 'false' or NaN\");"], "i": ["protected void _matchToken(String matchStr, int i)", "            if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {", "                _reportInvalidToken(matchStr.substring(0, i), \"'null', 'true', 'false' or NaN\");"]}
{"b64variant": ["protected byte[] _decodeBase64(Base64Variant b64variant)", "            int bits = b64variant.decodeBase64Char(ch);", "            if (bits < 0) {", "                bits = _decodeBase64Escape2(b64variant, ch, 0);", "                if (bits < 0) { // white space to skip", "            int decodedData = bits;", "            bits = b64variant.decodeBase64Char(ch);", "            if (bits < 0) {", "                bits = _decodeBase64Escape2(b64variant, ch, 1);", "            decodedData = (decodedData << 6) | bits;", "            bits = b64variant.decodeBase64Char(ch);", "            if (bits < 0) {", "                if (bits != Base64Variant.BASE64_VALUE_PADDING) {", "                    if (ch == INT_APOSTROPHE && !b64variant.usesPadding()) {", "                    bits = _decodeBase64Escape2(b64variant, ch, 2);", "                if (bits == Base64Variant.BASE64_VALUE_PADDING) {", "                    if (!b64variant.usesPaddingChar(ch)) {", "                        throw reportInvalidBase64Char(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");", "            decodedData = (decodedData << 6) | bits;", "            bits = b64variant.decodeBase64Char(ch);", "            if (bits < 0) {", "                if (bits != Base64Variant.BASE64_VALUE_PADDING) {", "                    if (ch == INT_APOSTROPHE && !b64variant.usesPadding()) {", "                    bits = _decodeBase64Escape2(b64variant, ch, 3);", "                if (bits == Base64Variant.BASE64_VALUE_PADDING) {", "            decodedData = (decodedData << 6) | bits;", "            builder.appendThreeBytes(decodedData);"]}
{"string": ["public static boolean isIdStrict(String string) {", "        int len = string.length();", "        if (!isIdStartStrict(string.charAt(0))) {", "            if (!isIdCharStrict(string.charAt(i))) {"]}
{"chars": ["public static boolean isIdStrict(char[] chars, int offset, int len) {", "        if (!isIdStartStrict(chars[offset++])) {", "            if (!isIdCharStrict(chars[offset++])) {"], "offset": ["public static boolean isIdStrict(char[] chars, int offset, int len) {", "        int end = offset + len;", "        while (offset < end) {"], "len": ["public static boolean isIdStrict(char[] chars, int offset, int len) {", "        if (len == 0) {", "        int end = offset + len;", "        while (offset < end) {"]}
{"text": ["private void _writeString(char[] text, int offset, int len)", "                char c = text[offset];", "                if (c == '!' || c == '\\'') {", "                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);", "                _writer.write(text, start, newAmount);", "            char c = text[offset++];", "            _appendCharacterEscape('!', c);"], "offset": ["private void _writeString(char[] text, int offset, int len)", "        len += offset; // -> len marks the end from now on", "        while (offset < len) {", "            int start = offset;", "                char c = text[offset];", "                if (c == '!' || c == '\\'') {", "                if (++offset >= len) {", "            int newAmount = offset - start;", "            if (newAmount < SHORT_WRITE) {", "                if ((_outputTail + newAmount) > _outputEnd) {", "                if (newAmount > 0) {", "                    System.arraycopy(text, start, _outputBuffer, _outputTail, newAmount);", "                    _outputTail += newAmount;", "                _writer.write(text, start, newAmount);", "            if (offset >= len) { // yup"], "len": []}
{"buffer": [], "ptr": ["private int _prependOrWrite(char[] buffer, int ptr, char esc)", "        if (ptr > 0) { // fits, just prepend", "        return ptr;"], "esc": ["private int _prependOrWrite(char[] buffer, int ptr, char esc)", "            buffer[--ptr] = esc;", "            _writer.write(esc);", "        return ptr;"]}
{"esc": ["private void _appendCharacterEscape(char esc, char ch)", "        _outputBuffer[_outputTail++] = esc;"], "ch": ["private void _appendCharacterEscape(char esc, char ch)", "        _outputBuffer[_outputTail++] = ch;"]}
{"conf": ["public static void setConversionProperties(Configuration conf) {", "    if (conf != null) {", "      useEnumId = conf.getBoolean(USE_ENUM_ID_CONF_KEY, false);"]}
{"thriftClass": ["public static String toPigScript(Class<? extends TBase<?, ?>> thriftClass,", "      .append(thriftClass.getName())", "      stringifySchema(sb, toSchema(thriftClass), DataType.TUPLE, prefix);"], "pigLoader": ["                                   Class<? extends LoadFunc> pigLoader) {", "      .append(pigLoader.getName())"]}
{"sb": ["public static void stringifySchema(StringBuilder sb,", "          sb.append(\"(\") ;", "          sb.append(\"{\") ;", "      sb.append(\"\\n\").append(prefix);", "          sb.append(\"null\") ;", "                  sb.append(\",\\n\").append(prefix);", "                  sb.append(\"null\");", "                  sb.append(fs.alias);", "                  sb.append(\": \");", "                  sb.append(DataType.findTypeName(fs.type)) ;", "                      stringifySchema(sb, fs.schema, fs.type, prefix) ;", "                sb.append(DataType.findTypeName(fs.type) + \"[\");", "                    stringifySchema(sb, fs.schema, fs.type, prefix);", "                sb.append(\"]\");", "                  sb.append(DataType.findTypeName(fs.type)) ;", "      sb.append(\"\\n\").append(prefix);", "          sb.append(\")\") ;", "          sb.append(\"}\") ;"], "schema": ["                                     Schema schema,", "      if (schema == null) {", "          for (int i=0; i< schema.size() ;i++) {", "              FieldSchema fs = schema.getField(i) ;", "              if(fs == null) {", "              if (fs.alias != null) {", "                  sb.append(fs.alias);", "              if (DataType.isAtomic(fs.type)) {", "                  sb.append(DataType.findTypeName(fs.type)) ;", "              else if ( (fs.type == DataType.TUPLE) ||", "                        (fs.type == DataType.BAG) ) {", "                  if (schema != fs.schema) {", "                      stringifySchema(sb, fs.schema, fs.type, prefix) ;", "              } else if (fs.type == DataType.MAP) {", "                sb.append(DataType.findTypeName(fs.type) + \"[\");", "                if (fs.schema!=null)", "                    stringifySchema(sb, fs.schema, fs.type, prefix);", "                  sb.append(DataType.findTypeName(fs.type)) ;"], "type": ["                                     byte type,", "      if (type == DataType.TUPLE) {", "      else if (type == DataType.BAG) {", "              if (DataType.isAtomic(fs.type)) {", "                  sb.append(DataType.findTypeName(fs.type)) ;", "              else if ( (fs.type == DataType.TUPLE) ||", "                        (fs.type == DataType.BAG) ) {", "                      stringifySchema(sb, fs.schema, fs.type, prefix) ;", "              } else if (fs.type == DataType.MAP) {", "                sb.append(DataType.findTypeName(fs.type) + \"[\");", "                    stringifySchema(sb, fs.schema, fs.type, prefix);", "                  sb.append(DataType.findTypeName(fs.type)) ;", "      if (type == DataType.TUPLE) {", "      else if (type == DataType.BAG) {"], "prefix": ["                                     StringBuilder prefix)", "      prefix.append(\"  \");", "      sb.append(\"\\n\").append(prefix);", "                  sb.append(\",\\n\").append(prefix);", "                      stringifySchema(sb, fs.schema, fs.type, prefix) ;", "                    stringifySchema(sb, fs.schema, fs.type, prefix);", "      prefix.setLength(prefix.length()-2);", "      sb.append(\"\\n\").append(prefix);"]}
{"path": ["protected IndexReader openIndex(Path path, Configuration conf) throws IOException {", "    return DirectoryReader.open(new LuceneHdfsDirectory(path, path.getFileSystem(conf)));"], "conf": ["protected IndexReader openIndex(Path path, Configuration conf) throws IOException {", "    return DirectoryReader.open(new LuceneHdfsDirectory(path, path.getFileSystem(conf)));"]}
{"Result": "Method without Parameter"}
{"msg": ["public Tuple toTuple(Message msg) {", "    if (msg == null) {", "    Descriptor msgDescriptor = msg.getDescriptorForType();", "        Object fieldValue = msg.getField(fieldDescriptor);", "          tuple.set(curField++, messageToTuple(fieldDescriptor, fieldValue));", "          tuple.set(curField++, singleFieldToTuple(fieldDescriptor, fieldValue));", "      LOG.warn(\"Could not convert msg \" + msg + \" to tuple\", e);"]}
{"fieldDescriptor": ["  protected Object messageToTuple(FieldDescriptor fieldDescriptor, Object fieldValue) {", "    assert fieldDescriptor.getType() == FieldDescriptor.Type.MESSAGE : \"messageToTuple called with field of type \" + fieldDescriptor.getType();", "    if (fieldDescriptor.isRepeated()) {"], "fieldValue": ["  protected Object messageToTuple(FieldDescriptor fieldDescriptor, Object fieldValue) {", "    if (fieldValue == null) {", "      List<Message> messageList = (List<Message>) (fieldValue != null ? fieldValue : Lists.newArrayList());", "      return new ProtobufTuple((Message)fieldValue);"]}
{"fieldDescriptor": ["  protected Object singleFieldToTuple(FieldDescriptor fieldDescriptor, Object fieldValue) {", "    assert fieldDescriptor.getType() != FieldDescriptor.Type.MESSAGE : \"messageToFieldSchema called with field of type \" + fieldDescriptor.getType();", "    if (fieldDescriptor.isRepeated()) {", "        Object nonEnumFieldValue = coerceToPigTypes(fieldDescriptor, singleFieldValue);", "          innerTuple.set(0, nonEnumFieldValue);", "      return coerceToPigTypes(fieldDescriptor, fieldValue);"], "fieldValue": ["  protected Object singleFieldToTuple(FieldDescriptor fieldDescriptor, Object fieldValue) {", "      List<Object> fieldValueList = (List<Object>) (fieldValue != null ? fieldValue : Collections.emptyList());", "      return coerceToPigTypes(fieldDescriptor, fieldValue);"]}
{"fieldDescriptor": ["private Object coerceToPigTypes(FieldDescriptor fieldDescriptor, Object fieldValue) {", "    if (fieldDescriptor.getType() == FieldDescriptor.Type.ENUM && fieldValue != null) {", "    } else if (fieldDescriptor.getType() == FieldDescriptor.Type.BOOL && fieldValue != null) {", "    } else if (fieldDescriptor.getType() == FieldDescriptor.Type.BYTES && fieldValue != null) {"], "fieldValue": ["private Object coerceToPigTypes(FieldDescriptor fieldDescriptor, Object fieldValue) {", "    if (fieldDescriptor.getType() == FieldDescriptor.Type.ENUM && fieldValue != null) {", "      EnumValueDescriptor enumValueDescriptor = (EnumValueDescriptor)fieldValue;", "      return enumValueDescriptor.getName();", "    } else if (fieldDescriptor.getType() == FieldDescriptor.Type.BOOL && fieldValue != null) {", "      Boolean boolValue = (Boolean)fieldValue;", "      return new Integer(boolValue ? 1 : 0);", "    } else if (fieldDescriptor.getType() == FieldDescriptor.Type.BYTES && fieldValue != null) {", "      ByteString bsValue = (ByteString)fieldValue;", "      return new DataByteArray(bsValue.toByteArray());", "    return fieldValue;"]}
{"msgDescriptor": ["public Schema toSchema(Descriptor msgDescriptor) {", "      for (FieldDescriptor fieldDescriptor : msgDescriptor.getFields()) {", "        if (fieldDescriptor.getType() == FieldDescriptor.Type.MESSAGE) {", "          schema.add(messageToFieldSchema(fieldDescriptor));", "          schema.add(singleFieldToFieldSchema(fieldDescriptor));", "      LOG.warn(\"Could not convert descriptor \" + msgDescriptor + \" to schema\", e);"]}
{"fieldDescriptor": ["private FieldSchema messageToFieldSchema(FieldDescriptor fieldDescriptor) throws FrontendException {", "    assert fieldDescriptor.getType() == FieldDescriptor.Type.MESSAGE : \"messageToFieldSchema called with field of type \" + fieldDescriptor.getType();", "    Schema innerSchema = toSchema(fieldDescriptor.getMessageType());", "    if (fieldDescriptor.isRepeated()) {", "      tupleSchema.add(new FieldSchema(fieldDescriptor.getName() + \"_tuple\", innerSchema, DataType.TUPLE));", "      return new FieldSchema(fieldDescriptor.getName(), tupleSchema, DataType.BAG);", "      return new FieldSchema(fieldDescriptor.getName(), innerSchema, DataType.TUPLE);"]}
{"fieldDescriptor": ["private FieldSchema singleFieldToFieldSchema(FieldDescriptor fieldDescriptor) throws FrontendException {", "    assert fieldDescriptor.getType() != FieldDescriptor.Type.MESSAGE : \"singleFieldToFieldSchema called with field of type \" + fieldDescriptor.getType();", "    if (fieldDescriptor.isRepeated()) {", "      itemSchema.add(new FieldSchema(fieldDescriptor.getName(), null, getPigDataType(fieldDescriptor)));", "      itemTupleSchema.add(new FieldSchema(fieldDescriptor.getName() + \"_tuple\", itemSchema, DataType.TUPLE));", "      return new FieldSchema(fieldDescriptor.getName() + \"_bag\", itemTupleSchema, DataType.BAG);", "      return new FieldSchema(fieldDescriptor.getName(), null, getPigDataType(fieldDescriptor));"]}
{"msgDescriptor": ["public String toPigScript(Descriptor msgDescriptor, String loaderClassName) {", "    sb.append(toPigScriptInternal(msgDescriptor, initialTabOffset));"], "loaderClassName": ["public String toPigScript(Descriptor msgDescriptor, String loaderClassName) {", "    sb.append(\"raw_data = load '$INPUT_FILES' using \" + loaderClassName + \"()\").append(\"\\n\");"]}
{"msgDescriptor": ["private StringBuffer toPigScriptInternal(Descriptor msgDescriptor, int numTabs) {", "      for (FieldDescriptor fieldDescriptor : msgDescriptor.getFields()) {", "        boolean isLast = (fieldDescriptor == msgDescriptor.getFields().get(msgDescriptor.getFields().size() - 1));", "        if (fieldDescriptor.getType() == FieldDescriptor.Type.MESSAGE) {", "          sb.append(messageToPigScript(fieldDescriptor, numTabs + 1, isLast));", "          sb.append(singleFieldToPigScript(fieldDescriptor, numTabs + 1, isLast));", "      LOG.warn(\"Could not convert descriptor \" + msgDescriptor + \" to pig script\", e);"], "numTabs": ["private StringBuffer toPigScriptInternal(Descriptor msgDescriptor, int numTabs) {", "          sb.append(messageToPigScript(fieldDescriptor, numTabs + 1, isLast));", "          sb.append(singleFieldToPigScript(fieldDescriptor, numTabs + 1, isLast));"]}
{"fieldDescriptor": ["private StringBuffer messageToPigScript(FieldDescriptor fieldDescriptor, int numTabs, boolean isLast) throws FrontendException {", "    assert fieldDescriptor.getType() == FieldDescriptor.Type.MESSAGE : \"messageToPigScript called with field of type \" + fieldDescriptor.getType();", "    if (fieldDescriptor.isRepeated()) {", "      return new StringBuffer().append(tabs(numTabs)).append(fieldDescriptor.getName()).append(\": bag {\").append(\"\\n\")", "          .append(tabs(numTabs + 1)).append(fieldDescriptor.getName()).append(\"_tuple: tuple (\").append(\"\\n\")", "          .append(toPigScriptInternal(fieldDescriptor.getMessageType(), numTabs + 2))", "      return new StringBuffer().append(tabs(numTabs)).append(fieldDescriptor.getName()).append(\": tuple (\").append(\"\\n\")", "          .append(toPigScriptInternal(fieldDescriptor.getMessageType(), numTabs + 1))"], "numTabs": ["private StringBuffer messageToPigScript(FieldDescriptor fieldDescriptor, int numTabs, boolean isLast) throws FrontendException {", "      return new StringBuffer().append(tabs(numTabs)).append(fieldDescriptor.getName()).append(\": bag {\").append(\"\\n\")", "          .append(tabs(numTabs + 1)).append(fieldDescriptor.getName()).append(\"_tuple: tuple (\").append(\"\\n\")", "          .append(toPigScriptInternal(fieldDescriptor.getMessageType(), numTabs + 2))", "          .append(tabs(numTabs + 1)).append(\")\").append(\"\\n\")", "          .append(tabs(numTabs)).append(\"}\").append(isLast ? \"\" : \",\").append(\"\\n\");", "      return new StringBuffer().append(tabs(numTabs)).append(fieldDescriptor.getName()).append(\": tuple (\").append(\"\\n\")", "          .append(toPigScriptInternal(fieldDescriptor.getMessageType(), numTabs + 1))", "          .append(tabs(numTabs)).append(\")\").append(isLast ? \"\" : \",\").append(\"\\n\");"], "isLast": ["private StringBuffer messageToPigScript(FieldDescriptor fieldDescriptor, int numTabs, boolean isLast) throws FrontendException {", "          .append(tabs(numTabs)).append(\"}\").append(isLast ? \"\" : \",\").append(\"\\n\");", "          .append(tabs(numTabs)).append(\")\").append(isLast ? \"\" : \",\").append(\"\\n\");"]}
{"fieldDescriptor": ["private StringBuffer singleFieldToPigScript(FieldDescriptor fieldDescriptor, int numTabs, boolean isLast) throws FrontendException {", "    assert fieldDescriptor.getType() != FieldDescriptor.Type.MESSAGE : \"singleFieldToPigScript called with field of type \" + fieldDescriptor.getType();", "    if (fieldDescriptor.isRepeated()) {", "      return new StringBuffer().append(tabs(numTabs)).append(fieldDescriptor.getName()).append(\"_bag: bag {\").append(\"\\n\")", "          .append(tabs(numTabs + 1)).append(fieldDescriptor.getName()).append(\"_tuple: tuple (\").append(\"\\n\")", "          .append(tabs(numTabs + 2)).append(fieldDescriptor.getName()).append(\": \").append(getPigScriptDataType(fieldDescriptor)).append(\"\\n\")", "      return new StringBuffer().append(tabs(numTabs)).append(fieldDescriptor.getName()).append(\": \")", "          .append(getPigScriptDataType(fieldDescriptor)).append(isLast ? \"\" : \",\").append(\"\\n\");"], "numTabs": ["private StringBuffer singleFieldToPigScript(FieldDescriptor fieldDescriptor, int numTabs, boolean isLast) throws FrontendException {", "      return new StringBuffer().append(tabs(numTabs)).append(fieldDescriptor.getName()).append(\"_bag: bag {\").append(\"\\n\")", "          .append(tabs(numTabs + 1)).append(fieldDescriptor.getName()).append(\"_tuple: tuple (\").append(\"\\n\")", "          .append(tabs(numTabs + 2)).append(fieldDescriptor.getName()).append(\": \").append(getPigScriptDataType(fieldDescriptor)).append(\"\\n\")", "          .append(tabs(numTabs + 1)).append(\")\").append(\"\\n\")", "          .append(tabs(numTabs)).append(\"}\").append(isLast ? \"\" : \",\").append(\"\\n\");", "      return new StringBuffer().append(tabs(numTabs)).append(fieldDescriptor.getName()).append(\": \")"], "isLast": ["private StringBuffer singleFieldToPigScript(FieldDescriptor fieldDescriptor, int numTabs, boolean isLast) throws FrontendException {", "          .append(tabs(numTabs)).append(\"}\").append(isLast ? \"\" : \",\").append(\"\\n\");", "          .append(getPigScriptDataType(fieldDescriptor)).append(isLast ? \"\" : \",\").append(\"\\n\");"]}
{"tClass": ["public static TStructDescriptor getInstance(Class<? extends TBase<?, ?>> tClass) {", "      TStructDescriptor desc = structMap.get(tClass);", "      if (desc == null) {", "        desc.tClass = tClass;", "        structMap.put(tClass, desc);", "        desc.build(tClass);", "      return desc;"]}
{"enumClass": ["static private Map<String, TEnum> extractEnumMap(Class<? extends TEnum> enumClass) {", "    for(TEnum e : enumClass.getEnumConstants()) {", "      builder.put(e.toString(), e);"]}
{"conf": ["public static PathFilter newIndexDirFilter(Configuration conf) {", "      PathFilters.newExcludeFilesFilter(conf),"]}
{"protoClass": ["public static boolean useDynamicProtoMessage(Class<?> protoClass) {", "    return protoClass == null || protoClass.getCanonicalName().equals(DynamicMessage.class.getCanonicalName());"]}
{"protoClassName": ["public static<M extends Message> TypeRef<M> getTypeRef(String protoClassName) {", "    return new TypeRef<M>(getProtobufClass(protoClassName)){};"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"realInputFormatClass": ["public static void setInputFormat(Class<?> realInputFormatClass, Configuration conf) {", "    HadoopUtils.setClassConf(conf, CLASS_CONF_KEY, realInputFormatClass);"], "conf": ["public static void setInputFormat(Class<?> realInputFormatClass, Configuration conf) {", "    conf.setClass(\"mapred.input.format.class\", DeprecatedInputFormatWrapper.class, org.apache.hadoop.mapred.InputFormat.class);", "    HadoopUtils.setClassConf(conf, CLASS_CONF_KEY, realInputFormatClass);"]}
{"conf": ["public static void setClassConf(Configuration  conf,", "    String existingClass = conf.get(configKey);", "      conf.set(configKey, className);"], "configKey": ["                                  String         configKey,", "    String existingClass = conf.get(configKey);", "    if (existingClass != null && !existingClass.equals(className)) {", "            + configKey", "            + \". old: \" + existingClass", "      conf.set(configKey, className);"], "clazz": ["                                  Class<?>       clazz) {", "    String className = clazz.getName();"]}
{"key": ["public static void writeStringListToConfAsJson(String key,", "    conf.set(key, JSONArray.toJSONString(list));"], "list": ["                                                 List<String> list,", "    Preconditions.checkNotNull(list);", "    conf.set(key, JSONArray.toJSONString(list));"], "conf": ["                                                 Configuration conf) {", "    conf.set(key, JSONArray.toJSONString(list));"]}
{"key": ["  public static List<String> readStringListFromConfAsJson(String key, Configuration conf) {", "    String json = conf.get(key);", "    if (json == null) {", "    return Lists.<String>newArrayList(((JSONArray) JSONValue.parse(json)));"], "conf": ["  public static List<String> readStringListFromConfAsJson(String key, Configuration conf) {", "    String json = conf.get(key);"]}
{"key": ["public static void writeStringListToConfAsBase64(String key, List<String> list, Configuration", "    conf.set(key, sb.toString());"], "list": ["public static void writeStringListToConfAsBase64(String key, List<String> list, Configuration", "    Preconditions.checkNotNull(list);", "    Iterator<String> iter = list.iterator();"], "conf": ["    conf) {", "    conf.set(key, sb.toString());"]}
{"key": ["  public static List<String> readStringListFromConfAsBase64(String key, Configuration conf) {", "    String b64List = conf.get(key);", "    if (b64List == null) {", "    for (String b64 : COMMA_SPLITTER.split(b64List)) {", "      byte[] bytes = Base64.decodeBase64(b64.getBytes(Charsets.UTF_8));", "      strings.add(new String(bytes, Charsets.UTF_8));"], "conf": ["  public static List<String> readStringListFromConfAsBase64(String key, Configuration conf) {", "    String b64List = conf.get(key);"]}
{"tClass": ["private static void verifyAncestry(Class<?> tClass) {", "    if (!TBase.class.isAssignableFrom(tClass)) {", "      Utils.ensureClassLoaderConsistency(TBase.class, tClass.getClassLoader());", "      throw new ClassCastException(tClass.getName() + \" is not a Thrift class\");"]}
{"containingObject": ["public static <M> M getFieldValue(Object containingObject, String fieldName, Class<M> fieldClass) {", "    return getFieldValue(containingObject.getClass(), containingObject, fieldName, fieldClass);"], "fieldName": ["public static <M> M getFieldValue(Object containingObject, String fieldName, Class<M> fieldClass) {", "    return getFieldValue(containingObject.getClass(), containingObject, fieldName, fieldClass);"], "fieldClass": ["public static <M> M getFieldValue(Object containingObject, String fieldName, Class<M> fieldClass) {", "    return getFieldValue(containingObject.getClass(), containingObject, fieldName, fieldClass);"]}
{"containingClass": ["public static <M> M getFieldValue(Class<?> containingClass, String fieldName, Class<M> fieldClass) {", "    return getFieldValue(containingClass, null, fieldName, fieldClass);"], "fieldName": ["public static <M> M getFieldValue(Class<?> containingClass, String fieldName, Class<M> fieldClass) {", "    return getFieldValue(containingClass, null, fieldName, fieldClass);"], "fieldClass": ["public static <M> M getFieldValue(Class<?> containingClass, String fieldName, Class<M> fieldClass) {", "    return getFieldValue(containingClass, null, fieldName, fieldClass);"]}
{"field": ["public static Class<?> getFieldValueType(Field field) {", "    switch (field.getType()) {", "        return field.getEnumClass();", "        return field.gettStructDescriptor().getThriftClass();"]}
{"proto": ["public static void writeFieldNoTag(TProtocol proto,", "      writeSingleFieldNoTag(proto, field, value);", "      proto.writeByte(innerField.getType());", "      proto.writeByte(valueField.getType());", "      proto.writeI32(map.size());", "        writeSingleFieldNoTag(proto, innerField, entry.getKey());", "        writeSingleFieldNoTag(proto, valueField, entry.getValue());", "      proto.writeByte(innerField.getType());", "      proto.writeI32(coll.size());", "        writeSingleFieldNoTag(proto, innerField, v);"], "field": ["                                     Field field,", "    switch (field.getType()) {", "      innerField = field.getListElemField();    break;", "      innerField = field.getSetElemField();     break;", "      innerField = field.getMapKeyField();      break;", "      writeSingleFieldNoTag(proto, field, value);", "    if (field.getType() == TType.MAP) {", "      Field valueField = field.getMapValueField();"], "value": ["                                     Object value) throws TException {", "    if (value == null) {", "      writeSingleFieldNoTag(proto, field, value);", "      Map<?, ?> map = (Map<?, ?>)value;", "      proto.writeI32(map.size());", "      for(Entry<?, ?> entry : map.entrySet()) {", "        writeSingleFieldNoTag(proto, innerField, entry.getKey());", "        writeSingleFieldNoTag(proto, valueField, entry.getValue());", "      Collection<?> coll = (Collection<?>)value;", "      proto.writeI32(coll.size());", "      for(Object v : coll) {", "        writeSingleFieldNoTag(proto, innerField, v);"]}
{"builder": ["public static Message tupleToMessage(Builder builder, Tuple tuple) {", "    return tupleToMessage(builder, builder.getDescriptorForType().getFields(), tuple);"], "tuple": ["public static Message tupleToMessage(Builder builder, Tuple tuple) {", "    return tupleToMessage(builder, builder.getDescriptorForType().getFields(), tuple);"]}
{"fieldDescriptor": ["private static Object tupleFieldToSingleField(FieldDescriptor fieldDescriptor, Object tupleField) {", "    switch (fieldDescriptor.getType()) {", "      return toEnumValueDescriptor(fieldDescriptor, (String) tupleField);"], "tupleField": ["private static Object tupleFieldToSingleField(FieldDescriptor fieldDescriptor, Object tupleField) {", "      return toEnumValueDescriptor(fieldDescriptor, (String) tupleField);", "      return Boolean.valueOf((Integer)tupleField != 0);", "      return ByteString.copyFrom(((DataByteArray)tupleField).get());", "      return tupleField;"]}
{"builder": ["private static void addField(DescriptorProto.Builder builder, String name, int fieldId, Type type) {", "    builder.addField(fdBuilder.build());"], "name": ["private static void addField(DescriptorProto.Builder builder, String name, int fieldId, Type type) {", "      .setName(name)"], "fieldId": ["private static void addField(DescriptorProto.Builder builder, String name, int fieldId, Type type) {", "      .setNumber(fieldId)"], "type": ["private static void addField(DescriptorProto.Builder builder, String name, int fieldId, Type type) {", "    FieldDescriptorProto.Builder fdBuilder = FieldDescriptorProto.newBuilder()", "      .setType(type);", "    builder.addField(fdBuilder.build());"]}
{"pigTypeId": ["private static Type pigTypeToProtoType(byte pigTypeId) {", "    switch(pigTypeId) {", "          throw new IllegalArgumentException(\"Unsupported Pig type passed (\" + pigTypeId +"]}
{"tDesc": ["  private static TBase<?, ?> toThrift(TStructDescriptor tDesc, Tuple tuple) {", "    int size = tDesc.getFields().size();", "    TBase tObj = newTInstance(tDesc.getThriftClass());", "        Field field = tDesc.getFieldAt(i);", "          tObj.setFieldValue(field.getFieldIdEnum(), toThriftValue(field, pObj));", "              field.getName(), value, type, i), e);"], "tuple": ["  private static TBase<?, ?> toThrift(TStructDescriptor tDesc, Tuple tuple) {", "    int tupleSize = tuple.size();", "        pObj = tuple.get(i);", "      if (pObj != null) {", "          tObj.setFieldValue(field.getFieldIdEnum(), toThriftValue(field, pObj));"]}
{"thriftField": ["  public static Object toThriftValue(Field thriftField, Object pigValue) {", "      switch (thriftField.getType()) {", "        return toThrift(thriftField.gettStructDescriptor(), (Tuple)pigValue);", "        return toThriftMap(thriftField, (Map<String, Object>)pigValue);", "        return toThriftSet(thriftField.getSetElemField(), (DataBag) pigValue);", "        return toThriftList(thriftField.getListElemField(), (DataBag)pigValue);", "        return toThriftEnum(thriftField, (String) pigValue);", "          thriftField.getName(), ThriftUtils.getFieldValueType(thriftField).getName(),"], "pigValue": ["  public static Object toThriftValue(Field thriftField, Object pigValue) {", "        return Boolean.valueOf(((Integer)pigValue) != 0);", "        return ((Integer)pigValue).byteValue();", "        return Short.valueOf(((Integer)pigValue).shortValue());", "        return toStringType(pigValue);", "        return toThrift(thriftField.gettStructDescriptor(), (Tuple)pigValue);", "        return toThriftMap(thriftField, (Map<String, Object>)pigValue);", "        return toThriftSet(thriftField.getSetElemField(), (DataBag) pigValue);", "        return toThriftList(thriftField.getListElemField(), (DataBag)pigValue);", "        return toThriftEnum(thriftField, (String) pigValue);", "        return pigValue;", "          pigValue, pigValue.getClass().getName()), e);"]}
{"tClass": ["private static TBase<?, ?> newTInstance(Class<?> tClass) {", "      return (TBase<?, ?>) tClass.newInstance();"]}
{"conf": ["public static void setCombinedInputFormatDelegate(Configuration conf, Class<? extends InputFormat> clazz) {", "    HadoopUtils.setClassConf(conf, COMBINED_INPUT_FORMAT_DELEGATE, clazz);"], "clazz": ["public static void setCombinedInputFormatDelegate(Configuration conf, Class<? extends InputFormat> clazz) {", "    HadoopUtils.setClassConf(conf, COMBINED_INPUT_FORMAT_DELEGATE, clazz);"]}
{"conf": ["protected PriorityQueue<LuceneIndexInputSplit> findSplits(Configuration conf) throws IOException {", "      HdfsUtils.collectPaths(path, path.getFileSystem(conf), indexDirPathFilter, indexDirs);", "      long size = HdfsUtils.getDirectorySize(indexDir, indexDir.getFileSystem(conf));", "      splits.add(new LuceneIndexInputSplit(Lists.newLinkedList(Arrays.asList(indexDir)), size));"]}
{"paths": ["public static void setInputPaths(List<Path> paths, Configuration conf) throws IOException {", "    Preconditions.checkNotNull(paths);", "    Preconditions.checkArgument(!paths.isEmpty());", "    String[] pathStrs = new String[paths.size()];", "    for (Path p : paths) {", "      FileSystem fs = p.getFileSystem(conf);", "      pathStrs[i++] = fs.makeQualified(p).toString();", "    conf.setStrings(INPUT_PATHS_KEY, pathStrs);"], "conf": ["public static void setInputPaths(List<Path> paths, Configuration conf) throws IOException {", "      FileSystem fs = p.getFileSystem(conf);", "      pathStrs[i++] = fs.makeQualified(p).toString();", "    conf.setStrings(INPUT_PATHS_KEY, pathStrs);"]}
{"conf": ["public static Path[] getInputPaths(Configuration conf) {", "    String[] pathStrs = Preconditions.checkNotNull(conf.getStrings(INPUT_PATHS_KEY),"]}
{"split": ["public void add(InputSplit split) throws IOException, InterruptedException {", "    splits.add(split);", "    totalSplitSizes += split.getLength();"]}
{"Result": "Method without Parameter"}
{"inputDelimiter": ["public static byte evaluateDelimiter(String inputDelimiter) {", "    if (inputDelimiter.length() == 1) {", "      return inputDelimiter.getBytes()[0];", "    } else if (inputDelimiter.length() > 1 && inputDelimiter.charAt(0) == '\\\\') {", "      switch (inputDelimiter.charAt(1)) {", "        return Integer.valueOf(inputDelimiter.substring(2)).byteValue();", "        throw new IllegalArgumentException(\"Unknown delimiter \" + inputDelimiter);"]}
{"field": ["public static ResourceFieldSchema createResourceFieldSchema(RequiredField field)", "        new ResourceFieldSchema().setName(field.getAlias()).setType(field.getType());", "    List<RequiredField> subFields = field.getSubFields();"]}
{"in": ["public static void readFully(InputStream in, ByteArrayOutputStream out, byte[] buffer) {", "      while ((numRead = in.read(buffer, 0, buffer.length)) != -1) {", "        out.write(buffer, 0, numRead);"], "out": ["public static void readFully(InputStream in, ByteArrayOutputStream out, byte[] buffer) {", "        out.write(buffer, 0, numRead);", "      out.flush();"], "buffer": ["public static void readFully(InputStream in, ByteArrayOutputStream out, byte[] buffer) {", "      while ((numRead = in.read(buffer, 0, buffer.length)) != -1) {", "        out.write(buffer, 0, numRead);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"protoClass": ["public static <M extends Message> ProtobufConverter<M> newInstance(Class<M> protoClass) {", "    return new ProtobufConverter<M>(new TypeRef<M>(protoClass){});"]}
{"writable": ["public boolean readNext(BinaryWritable<M> writable) throws IOException {", "      writable.set(protoConverter_.fromBytes(blob));"]}
{"Result": "Method without Parameter"}
{"writable": ["public boolean readNextProtoBytes(BytesWritable writable) throws IOException {", "      writable.set(blob, 0, blob.length);"]}
{"conf": ["                            Configuration conf, TaskAttemptID taskAttemptId) {", "        newInstance(TASK_CONTEXT_CONSTRUCTOR, conf, taskAttemptId);"], "taskAttemptId": ["                            Configuration conf, TaskAttemptID taskAttemptId) {", "        newInstance(TASK_CONTEXT_CONSTRUCTOR, conf, taskAttemptId);"]}
{"conf": ["public static MapContext newMapContext(Configuration conf,", "        conf, taskAttemptID, recordReader, recordWriter, outputCommitter,"], "taskAttemptID": ["                                         TaskAttemptID taskAttemptID,", "        conf, taskAttemptID, recordReader, recordWriter, outputCommitter,"], "recordReader": ["                                         RecordReader recordReader,", "        conf, taskAttemptID, recordReader, recordWriter, outputCommitter,"], "recordWriter": ["                                         RecordWriter recordWriter,", "        conf, taskAttemptID, recordReader, recordWriter, outputCommitter,"], "outputCommitter": ["                                         OutputCommitter outputCommitter,", "        conf, taskAttemptID, recordReader, recordWriter, outputCommitter,"], "statusReporter": ["                                         StatusReporter statusReporter,", "        statusReporter, inputSplit);"], "inputSplit": ["                                         InputSplit inputSplit) {", "        statusReporter, inputSplit);"]}
{"tClass": ["public static <M extends TBase<?, ?>> ThriftWritable<M> newInstance(Class<M> tClass) {", "    return new ThriftWritable<M>(new TypeRef<M>(tClass){});"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"thriftClass": ["public Message.Builder getBuilder(Class<? extends TBase<?, ?>> thriftClass) {", "    return messageBuilderMap.get(protoMessageType(thriftClass)).clone();"]}
{"descriptor": ["private Message.Builder mapEntryProtoBuilder(TStructDescriptor descriptor, Field field) {", "    return messageBuilderMap.get(mapProtoMessageType(descriptor, field)).clone();"], "field": ["private Message.Builder mapEntryProtoBuilder(TStructDescriptor descriptor, Field field) {", "    return messageBuilderMap.get(mapProtoMessageType(descriptor, field)).clone();"]}
{"field": ["    Field field, String typeName) throws DescriptorValidationException {", "    Field keyField = field.getMapKeyField();", "    Field valueField = field.getMapValueField();"], "typeName": ["    Field field, String typeName) throws DescriptorValidationException {", "    DescriptorProtos.DescriptorProto.Builder mapBuilder =", "      DescriptorProtos.DescriptorProto.newBuilder().setName(typeName);", "    mapBuilder.addField(keyBuilder.build());", "    mapBuilder.addField(valueBuilder.build());", "    return mapBuilder;"]}
{"descriptor": ["private String resolveMessageTypeName(TStructDescriptor descriptor)", "    String typeName = protoMessageType(descriptor.getThriftClass());", "      doSchemaMapping(builder, descriptor);"]}
{"thriftObj": ["  public Message convert(T thriftObj) {", "                     Preconditions.checkNotNull(thriftObj, \"Can not convert a null object\"));"]}
{"thriftObj": ["  public <F extends TFieldIdEnum> Message doConvert(TBase<?, F> thriftObj) {", "    if (thriftObj == null) { return null; }", "    Class<TBase<?, F>> clazz = (Class<TBase<?, F>>) thriftObj.getClass();", "      if (!thriftObj.isSet((F) tField.getFieldIdEnum())", "        TBase<?, ?> fieldValue = (TBase<?, ?>) fieldDesc.getFieldValue(fieldId++, thriftObj);", "        Message message = doConvert(fieldValue);", "        if (message != null) {", "          builder.setField(protoFieldDesc, message);", "        fieldId = convertField(thriftObj, builder, fieldDesc, fieldId, tField);"]}
{"mapBuilder": ["private Message buildMapEntryMessage(Message.Builder mapBuilder, Field field,", "      mapBuilder.getDescriptorForType().findFieldByName(MAP_KEY_FIELD_NAME);", "      mapBuilder.getDescriptorForType().findFieldByName(MAP_VALUE_FIELD_NAME);", "    mapBuilder.setField(keyFieldDescriptor, convertedKey);", "    mapBuilder.setField(valueFieldDescriptor, convertedValue);", "    return mapBuilder.build();"], "field": ["private Message buildMapEntryMessage(Message.Builder mapBuilder, Field field,", "    boolean isKeyStruct = field.getMapKeyField().isStruct();", "    boolean isValueStruct = field.getMapValueField().isStruct();", "      convertedKey = sanitizeRawValue(mapKey, field.getMapKeyField());", "      convertedValue = sanitizeRawValue(mapValue, field.getMapValueField());"], "mapKey": ["                                       Object mapKey, Object mapValue) {", "      convertedKey = doConvert((TBase<?, ?>) mapKey);", "      convertedKey = sanitizeRawValue(mapKey, field.getMapKeyField());", "    mapBuilder.setField(keyFieldDescriptor, convertedKey);"], "mapValue": ["                                       Object mapKey, Object mapValue) {", "      convertedValue = doConvert((TBase<?, ?>) mapValue);", "      convertedValue = sanitizeRawValue(mapValue, field.getMapValueField());", "    mapBuilder.setField(valueFieldDescriptor, convertedValue);"]}
{"descriptor": ["private String mapProtoMessageType(TStructDescriptor descriptor, Field field) {", "    return String.format(\"%s_%s\", protoMessageType(descriptor.getThriftClass()), field.getName());"], "field": ["private String mapProtoMessageType(TStructDescriptor descriptor, Field field) {", "    return String.format(\"%s_%s\", protoMessageType(descriptor.getThriftClass()), field.getName());"]}
{"path": ["public static void walkPath(Path path,", "    FileStatus fileStatus = fs.getFileStatus(path);", "    if (filter.accept(path)) {", "      visitor.visit(fileStatus);", "    if (fileStatus.isDir()) {", "      FileStatus[] children = fs.listStatus(path);", "      for (FileStatus childStatus : children) {", "        walkPath(childStatus.getPath(), fs, filter, visitor);"], "fs": ["                              FileSystem fs,", "    FileStatus fileStatus = fs.getFileStatus(path);", "      FileStatus[] children = fs.listStatus(path);", "        walkPath(childStatus.getPath(), fs, filter, visitor);"], "filter": ["                              PathFilter filter,", "    if (filter.accept(path)) {", "        walkPath(childStatus.getPath(), fs, filter, visitor);"], "visitor": ["                              PathVisitor visitor) throws IOException {", "      visitor.visit(fileStatus);", "        walkPath(childStatus.getPath(), fs, filter, visitor);"]}
{"path": ["public static void collectPaths(Path path,", "    walkPath(path, fs, filter, new PathVisitor() {"], "fs": ["                                  FileSystem fs,", "    walkPath(path, fs, filter, new PathVisitor() {"], "filter": ["                                  PathFilter filter,", "    walkPath(path, fs, filter, new PathVisitor() {"], "accumulator": ["                                  final List<Path> accumulator) throws IOException {", "        accumulator.add(fileStatus.getPath());"]}
{"path": ["public static long getDirectorySize(Path path, FileSystem fs, PathFilter filter)", "    walkPath(path, fs, composite, visitor);"], "fs": ["public static long getDirectorySize(Path path, FileSystem fs, PathFilter filter)", "      PathFilters.newExcludeDirectoriesFilter(fs.getConf()),", "    walkPath(path, fs, composite, visitor);"], "filter": ["public static long getDirectorySize(Path path, FileSystem fs, PathFilter filter)", "    PathFilter composite = new PathFilters.CompositePathFilter(", "      filter);", "    walkPath(path, fs, composite, visitor);"]}
{"conf": ["public static void setColumnNumber(Configuration conf, int columnNum) {", "    conf.setInt(RCFile.COLUMN_NUMBER_CONF_STR, columnNum);"], "columnNum": ["public static void setColumnNumber(Configuration conf, int columnNum) {", "    assert columnNum > 0;", "    conf.setInt(RCFile.COLUMN_NUMBER_CONF_STR, columnNum);"]}
{"conf": ["private static void updateJobConfForLocalSettings(JobConf conf) {", "    String localSetCompressionEnabled = conf.get(COMPRESS_ENABLE);", "      conf.set(MR_COMPRESS_ENABLE, localSetCompressionEnabled);", "    String localSetCompressionType = conf.get(COMPRESS_TYPE);", "      conf.set(MR_COMPRESS_TYPE, localSetCompressionType);", "    String localSetCompressionCodec = conf.get(COMPRESS_CODEC);", "      conf.set(MR_COMPRESS_CODEC, localSetCompressionCodec);"]}
{"klass": ["public static Method parseMethodFor(Class<Message> klass) {", "      return klass.getMethod(\"parseDelimitedFrom\", new Class[] {InputStream.class });"]}
{"parseMethod": ["public static Message parseMessage(Method parseMethod, InputStream in) {", "      return (Message) parseMethod.invoke(null, in);"], "in": ["public static Message parseMessage(Method parseMethod, InputStream in) {", "      return (Message) parseMethod.invoke(null, in);"]}
{"klass": ["public static Message parseMessage(Class<Message> klass, InputStream in) {", "    Method parseMethod = parseMethodFor(klass);", "    return parseMessage(parseMethod, in);"], "in": ["public static Message parseMessage(Class<Message> klass, InputStream in) {", "    return parseMessage(parseMethod, in);"]}
{"tuple": ["  public void putNext(Tuple tuple) throws IOException {", "    if (tuple != null && tuple.size() >= 1) {", "      Map<String, Object> map = (Map<String, Object>) tuple.get(0);"]}
{"protoClass": ["  void setClassConf(Class<M> protoClass, Configuration jobConf) {", "                           protoClass);"], "jobConf": ["  void setClassConf(Class<M> protoClass, Configuration jobConf) {", "    Protobufs.setClassConf(jobConf,"]}
{"conf": ["private void setTypeRef(Configuration conf) {", "    String className = conf.get(CLASS_CONF_KEY);", "      clazz = conf.getClassByName(className);"]}
{"size": ["protected void checkContainerSize(int size) throws TProtocolException {", "    if (size < 0) {", "      throw new TProtocolException(\"Negative container size: \" + size);", "    if (checkReadLength_ && (readLength_ - size) < 0) {", "              + \" but container size in underlying TTransport is set to at least: \" + size);"]}
{"pattern": ["public void setPattern(byte[] pattern) {", "    pattern_ = Arrays.copyOf(pattern, pattern.length);"]}
{"word": ["public static String underscore(String word) {", "    word = word.replaceAll(\"\\\\.\", \"/\");"]}
{"n": ["public static String ordinalize(int n) {", "    int mod100 = n % 100;", "      return String.valueOf(n) + \"th\";", "    switch (n % 10) {", "        return String.valueOf(n) + \"st\";", "        return String.valueOf(n) + \"nd\";", "        return String.valueOf(n) + \"rd\";", "        return String.valueOf(n) + \"th\";"]}
{"tClass": ["public static <M extends Message> ProtobufWritable<M> newInstance(Class<M> tClass) {", "    return new ProtobufWritable<M>(new TypeRef<M>(tClass){});"]}
{"fieldDefinitionFile": ["public static LzoW3CLogInputFormat newInstance(final String fieldDefinitionFile) {", "        RecordReader<LongWritable, MapWritable> reader = new LzoW3CLogRecordReader() {", "            return fieldDefinitionFile;", "        reader.initialize(split, context);", "        return reader;"]}
{"realOutputFormatClass": ["public static void setOutputFormat(Class<?> realOutputFormatClass, Configuration conf) {", "    HadoopUtils.setClassConf(conf, CLASS_CONF_KEY, realOutputFormatClass);"], "conf": ["public static void setOutputFormat(Class<?> realOutputFormatClass, Configuration conf) {", "    conf.setClass(\"mapred.output.format.class\", DeprecatedOutputFormatWrapper.class, org.apache.hadoop.mapred.OutputFormat.class);", "    HadoopUtils.setClassConf(conf, CLASS_CONF_KEY, realOutputFormatClass);"]}
{"word": ["public boolean match(String word) {", "    return Pattern.compile(pattern_, flags).matcher(word).find();"]}
{"word": ["public String replace(String word) {", "    return Pattern.compile(pattern_, flags).matcher(word).replaceAll(replacement_);"]}
{"word": ["public static String pluralize(String word) {", "    if (isUncountable(word)) {", "      return word;", "        if (inflection.match(word)) {", "          return inflection.replace(word);", "      return word;"]}
{"word": ["public static boolean isUncountable(String word) {", "      if (w.equalsIgnoreCase(word)) {"]}
{"job": ["protected DataOutputStream getOutputStream(TaskAttemptContext job)", "                      HadoopCompat.getConfiguration(job),", "                      getDefaultWorkFile(job, LzopCodec.DEFAULT_LZO_EXTENSION));"]}
{"writableClass": ["private static <W extends Writable> void verifyWritableClass(Class<W> writableClass,", "    Preconditions.checkNotNull(writableClass, \"%s Writable class is undefined;\""], "isKeyClass": ["      boolean isKeyClass, WritableConverter<W> writableConverter) {", "        + \" and no type was specified by user\", isKeyClass ? \"Key\" : \"Value\", writableConverter"], "writableConverter": ["      boolean isKeyClass, WritableConverter<W> writableConverter) {", "        + \" and no type was specified by user\", isKeyClass ? \"Key\" : \"Value\", writableConverter"]}
{"tClass": ["public static <M extends TBase<?, ?>> ThriftConverter<M> newInstance(Class<M> tClass) {", "    return new ThriftConverter<M>(new TypeRef<M>(tClass){});"]}
{"className": ["public static Class<?> getClass(String className) {", "      return PigContext.resolveClassName(className);", "      throw new RuntimeException(\"Could not instantiate \" + className, e);"]}
{"thriftClassName": ["public static<T extends TBase<?,?>> TypeRef<T> getThriftTypeRef(String thriftClassName) {", "    return ThriftUtils.getTypeRef(getClass(thriftClassName));"]}
{"conf": ["                                         Configuration      conf,", "    String reqFieldStr = conf.get(RCFileUtil.REQUIRED_FIELD_INDICES_CONF, \"\");"], "currFieldIds": ["                                         List<Integer>      currFieldIds,", "    int numKnownFields = currFieldIds.size();", "        requiredFieldIds.add(currFieldIds.get(i));", "        requiredFieldIds.add(currFieldIds.get(idx));"], "storedInfo": ["                                         ColumnarMetadata   storedInfo)", "    List<Integer> storedFieldIds = storedInfo.getFieldIdList();", "        storedInfo.getFieldIdList().size(),"]}
{"thriftClass": ["  void setClassConf(Class<M> thriftClass, Configuration jobConf) {", "                             thriftClass);"], "jobConf": ["  void setClassConf(Class<M> thriftClass, Configuration jobConf) {", "    ThriftUtils.setClassConf(jobConf,"]}
{"request": ["private String executeHttpRequest(HttpUriRequest request) {", "            HttpResponse response = httpClient.execute(request);", "            if (response != null) {", "                return EntityUtils.toString(response.getEntity(), \"UTF-8\");"]}
{"request": ["private void addAuthorization(HttpRequest request, RedditToken rToken) {", "        request.addHeader(\"Authorization\", rToken.getTokenType() + \" \" + rToken.getAccessToken());"], "rToken": ["private void addAuthorization(HttpRequest request, RedditToken rToken) {", "        request.addHeader(\"Authorization\", rToken.getTokenType() + \" \" + rToken.getAccessToken());"]}
{"response": ["public void validate(Object response) throws RedditParseException {", "        if (response == null) {", "        if (!(response instanceof JSONObject)) {", "        JSONObject jsonResponse = ((JSONObject) response);", "        if (jsonResponse.get(\"error\") != null) {", "            throw new RedditParseException(JsonUtils.safeJsonToInteger(jsonResponse.get(\"error\")));", "        if (jsonResponse.get(\"data\") == null && jsonResponse.get(\"json\") == null) {"]}
{"kind": ["private Thing parseThing(Kind kind, JSONObject data) {", "        if (kind == Kind.COMMENT) { ", "        } else if (kind == Kind.LINK) {", "        } else if (kind == Kind.SUBREDDIT) { ", "        } else if (kind == Kind.MORE) { "], "data": ["private Thing parseThing(Kind kind, JSONObject data) {", "            return new Comment(data);", "            return new Submission(data);", "            return new Subreddit(data);", "            return new More(data);"]}
{"jsonText": ["public List<MixedListingElement> parse(String jsonText) throws RedditParseException {", "        List<Thing> things = this.parseGeneric(jsonText);", "        for (Thing t : things) {", "            if (t instanceof Comment) {", "                mixedElements.add((Comment) t);", "            } else if (t instanceof Submission) {", "                mixedElements.add((Submission) t);", "                LOGGER.warn(\"Encountered an unexpected reddit thing (\" + t.getKind().value() + \"), skipping it.\");"]}
{"list": ["public static String formatCommaSeparatedList(List<String> list) {", "        for (int i = 0; i < list.size(); i++) {", "            builder.append(list.get(i));"]}
{"Result": "Method without Parameter"}
{"request": ["private void addBasicAuthentication(OAuthClientRequest request, RedditApp app) {", "        request.addHeader(HEADER_AUTHORIZATION, \"Basic \" + authStringEnc);"], "app": ["private void addBasicAuthentication(OAuthClientRequest request, RedditApp app) {", "        String authString = app.getClientID() + \":\" + app.getClientSecret();"]}
{"token": ["public void refresh(OAuthJSONAccessTokenResponse token) {", "        this.accessToken = token.getAccessToken();", "        this.expiration = currentTimeSeconds() + token.getExpiresIn();", "        this.expirationSpan = token.getExpiresIn();", "        this.scopes = new RedditTokenCompleteScope(token.getScope());", "        this.tokenType = token.getParam(PARAM_TOKEN_TYPE);"]}
{"cs": ["public static String printCommentTree(List<CommentTreeElement> cs) {", "        for (CommentTreeElement c : cs) {", "            builder.append(printCommentTree(c, 0));"]}
{"obj": ["public static Integer safeJsonToInteger(Object obj) {", "            String str = safeJsonToString(obj);", "            intValue = str != null ? Integer.parseInt(str) : null;"]}
{"obj": ["public static Double safeJsonToDouble(Object obj) {", "            String str = safeJsonToString(obj);", "            doubleValue = str != null ? Double.parseDouble(str) : null;"]}
{"obj": ["public static Boolean safeJsonToBoolean(Object obj) {", "        String str = safeJsonToString(obj);", "        Boolean booleanValue = str != null ? Boolean.parseBoolean(str) : null;"]}
{"obj": ["public static Long safeJsonToLong(Object obj) {", "            String str = safeJsonToString(obj);", "            longValue = str != null ? Long.parseLong(str) : null;"]}
{"main": ["class main {", "protected List<CommentTreeElement> parseRecursive(JSONObject main) throws RedditParseException {"]}
{"jsonText": ["public List<Subreddit> parse(String jsonText) throws RedditParseException {", "        List<Thing> things = this.parseGeneric(jsonText);", "        for (Thing t : things) {", "            if (t instanceof Subreddit) {", "                subreddits.add((Subreddit) t);", "                LOGGER.warn(\"Encountered an unexpected reddit thing (\" + t.getKind().value() + \"), skipping it.\");"]}
{"endpoint": ["public static String signature(String endpoint, Map<String, String> params, String clientSecret) throws InstagramException {", "        String sig = String.format(\"%s|%s\", endpoint, StringUtils.join(values, '|'));"], "params": ["public static String signature(String endpoint, Map<String, String> params, String clientSecret) throws InstagramException {", "        List<String> values = new ArrayList<String>(params.size());", "        for (String key : MapUtils.getSortedKeys(params)) {", "            values.add(String.format(\"%s=%s\", key, params.get(key)));"], "clientSecret": ["public static String signature(String endpoint, Map<String, String> params, String clientSecret) throws InstagramException {", "        SecretKeySpec keySpec = new SecretKeySpec(clientSecret.getBytes(UTF_8), HMAC_SHA256);", "            throw new InstagramException(\"Invalid key: \" + clientSecret, e);"]}
{"map": ["public static Map<String, String> sort(Map<String, String> map) {", "        Preconditions.checkNotNull(map, \"Cannot sort a null object.\");", "        for (String key : getSortedKeys(map)) {", "            sorted.put(key, map.get(key));"]}
{"url": ["public OembedInformation getOembedInformation(String url) throws InstagramException {", "        String apiMethod = String.format(Methods.OEMBED_INFORMATION, url);", "        return createInstagramObject(Verbs.GET, OembedInformation.class, apiMethod, null);"]}
{"verbs": ["private static <T> T createInstagramObject(Verbs verbs, Class<T> clazz, String methodName, Map<String, String> params)", "            response = getApiResponse(verbs, methodName, params);"], "clazz": ["private static <T> T createInstagramObject(Verbs verbs, Class<T> clazz, String methodName, Map<String, String> params)", "            return createObjectFromResponse(clazz, response.getBody());"], "methodName": ["private static <T> T createInstagramObject(Verbs verbs, Class<T> clazz, String methodName, Map<String, String> params)", "            response = getApiResponse(verbs, methodName, params);"], "params": ["private static <T> T createInstagramObject(Verbs verbs, Class<T> clazz, String methodName, Map<String, String> params)", "            response = getApiResponse(verbs, methodName, params);", "        if (response.getCode() >= 200 && response.getCode() < 300) {", "            return createObjectFromResponse(clazz, response.getBody());", "        throw handleInstagramError(response);"]}
{"clazz": ["private static <T> T createObjectFromResponse(Class<T> clazz, final String response) throws InstagramException {", "            object = gson.fromJson(response, clazz);", "            throw new InstagramException(\"Error parsing json to object type \" + clazz.getName(), e);", "        return object;"], "response": ["private static <T> T createObjectFromResponse(Class<T> clazz, final String response) throws InstagramException {", "            object = gson.fromJson(response, clazz);"]}
{"object1": ["public static void checkBothNotNull(Object object1, Object object2, String errorMsg) {", "\t\tcheck(!(object1 == null && object2 == null), errorMsg);"], "object2": ["public static void checkBothNotNull(Object object1, Object object2, String errorMsg) {", "\t\tcheck(!(object1 == null && object2 == null), errorMsg);"], "errorMsg": ["public static void checkBothNotNull(Object object1, Object object2, String errorMsg) {", "\t\tcheck(!(object1 == null && object2 == null), errorMsg);"]}
{"string": ["public static void checkEmptyString(String string, String errorMsg) {", "\t\tcheck(StringUtils.isNotBlank(string), errorMsg);"], "errorMsg": ["public static void checkEmptyString(String string, String errorMsg) {", "\t\tcheck(StringUtils.isNotBlank(string), errorMsg);"]}
{"url": ["public static void checkValidUrl(String url, String errorMsg) {", "\t\tcheckEmptyString(url, errorMsg);", "\t\tcheck(isUrl(url), errorMsg);"], "errorMsg": ["public static void checkValidUrl(String url, String errorMsg) {", "\t\tcheckEmptyString(url, errorMsg);", "\t\tcheck(isUrl(url), errorMsg);"]}
{"url": ["public static void checkValidOAuthCallback(String url, String errorMsg) {", "\t\tcheckEmptyString(url, errorMsg);", "\t\tif (url.toLowerCase().compareToIgnoreCase(OAuthConstants.OUT_OF_BAND) != 0) {", "\t\t\tcheck(isUrl(url), errorMsg);"], "errorMsg": ["public static void checkValidOAuthCallback(String url, String errorMsg) {", "\t\tcheckEmptyString(url, errorMsg);", "\t\t\tcheck(isUrl(url), errorMsg);"]}
{"accessToken": ["\tpublic InstagramClient getSignedHeaderInstagram(Token accessToken, String ipAddress) {", "\t\treturn new Instagram(accessToken.getToken(), config.getApiSecret(), ipAddress);"], "ipAddress": ["\tpublic InstagramClient getSignedHeaderInstagram(Token accessToken, String ipAddress) {", "\t\treturn new Instagram(accessToken.getToken(), config.getApiSecret(), ipAddress);"]}
{"request": ["public static void configureConnectionSettings(final Request request, final InstagramConfig config) {", "        request.setConnectTimeout(config.getConnectionTimeoutMills(), TimeUnit.MILLISECONDS);", "        request.setReadTimeout(config.getReadTimeoutMills(), TimeUnit.MILLISECONDS);", "        request.setConnectionKeepAlive(config.isConnectionKeepAlive());"], "config": ["public static void configureConnectionSettings(final Request request, final InstagramConfig config) {", "        request.setConnectTimeout(config.getConnectionTimeoutMills(), TimeUnit.MILLISECONDS);", "        request.setReadTimeout(config.getReadTimeoutMills(), TimeUnit.MILLISECONDS);", "        request.setConnectionKeepAlive(config.isConnectionKeepAlive());"]}
{"Result": "Method without Parameter"}
{"logger": ["public static void prettyPrintJSONResponse(Logger logger, String jsonString) {", "        if(logger.isDebugEnabled()) {", "            logger.debug(\"Received JSON response from Instagram - \" + s);"], "jsonString": ["public static void prettyPrintJSONResponse(Logger logger, String jsonString) {", "                final JsonElement element = new JsonParser().parse(jsonString);", "                s = new GsonBuilder().setPrettyPrinting().create().toJson(element);", "                s = jsonString;", "            logger.debug(\"Received JSON response from Instagram - \" + s);"]}
{"callback": ["public InstagramSubscription callback(String callback) {"]}
{"clientId": ["public InstagramSubscription clientId(String clientId) {"]}
{"clientSecret": ["public InstagramSubscription clientSecret(String clientSecret) {"]}
{"type": ["public InstagramSubscription object(SubscriptionType type) {", "\t\tthis.params.put(Constants.SUBSCRIPTION_TYPE, type.toString());"]}
{"verifyToken": ["public InstagramSubscription verifyToken(String verifyToken) {"]}
{"aspect": ["public InstagramSubscription aspect(String aspect) {"]}
{"latitude": ["public InstagramSubscription latitute(String latitude){", "\t\tPreconditions.checkValidLatLong(latitude, \"Invalid 'lat' key\");", "\t\tthis.params.put(Constants.LATITUDE, latitude);"]}
{"longitude": ["public InstagramSubscription longitude(String longitude){"]}
{"radius": ["public InstagramSubscription radius(String radius){"]}
{"id": ["public SubscriptionResponse deleteSubscription(String id) throws InstagramException {", "        request.addQuerystringParameter(\"id\", id);", "            throw new InstagramException(\"Failed to delete subscription with id [\"+id+\"]\", e);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"map": ["public static String formURLEncodeMap(Map<String, String> map) {", "        Preconditions.checkNotNull(map, \"Cannot url-encode a null object\");", "        return (map.size() <= 0) ? EMPTY_STRING : doFormUrlEncode(map);"]}
{"string": ["public static String percentEncode(String string) {", "        String encoded = formURLEncode(string);", "            encoded = rule.apply(encoded);", "        return encoded;"]}
{"url": ["public static String appendParametersToQueryString(String url, Map<String, String> params) {", "        Preconditions.checkNotNull(url, \"Cannot append to null URL\");", "            return url;", "            url += (url.indexOf(QUERY_STRING_SEPARATOR) != -1) ? PARAM_SEPARATOR : QUERY_STRING_SEPARATOR;"], "params": ["public static String appendParametersToQueryString(String url, Map<String, String> params) {", "        String queryString = URLUtils.formURLEncodeMap(params);", "        if (queryString.equals(EMPTY_STRING)) {", "            url += queryString;", "            return url;"]}
{"params": ["public static String concatSortedPercentEncodedParams(Map<String, String> params) {", "        for (Map.Entry<String, String> entry : params.entrySet()) {", "            result.append(entry.getKey()).append(PAIR_SEPARATOR);", "            result.append(entry.getValue()).append(PARAM_SEPARATOR);"]}
{"queryString": ["public static Map<String, String> queryStringToMap(String queryString) {", "        if ((queryString != null) && (queryString.length() > 0)) {", "            for (String param : queryString.split(PARAM_SEPARATOR)) {", "                String pair[] = param.split(PAIR_SEPARATOR);", "                String key = formURLDecode(pair[0]);", "                String value = (pair.length > 1) ? formURLDecode(pair[1]) : EMPTY_STRING;", "                result.put(key, value);"]}
{"Result": "Method without Parameter"}
{"tradeVolume": ["public void addTrade(Decimal tradeVolume, Decimal tradePrice) {", "        volume = volume.plus(tradeVolume);", "        amount = amount.plus(tradeVolume.multipliedBy(tradePrice));"], "tradePrice": ["public void addTrade(Decimal tradeVolume, Decimal tradePrice) {", "            openPrice = tradePrice;", "        closePrice = tradePrice;", "            maxPrice = tradePrice;", "            maxPrice = maxPrice.isLessThan(tradePrice) ? tradePrice : maxPrice;", "            minPrice = tradePrice;", "            minPrice = minPrice.isGreaterThan(tradePrice) ? tradePrice : minPrice;", "        amount = amount.plus(tradeVolume.multipliedBy(tradePrice));"]}
{"index": ["private void increaseLengthTo(int index, int maxLength) {", "            int newResultsCount = Math.min(index-highestResultIndex, maxLength);", "            results.addAll(Collections.<T> nCopies(Math.min(index+1, maxLength), null));"], "maxLength": ["private void increaseLengthTo(int index, int maxLength) {", "            int newResultsCount = Math.min(index-highestResultIndex, maxLength);", "            if (newResultsCount == maxLength) {", "                results.addAll(Collections.<T> nCopies(maxLength, null));", "            } else if (newResultsCount > 0) {", "                results.addAll(Collections.<T> nCopies(newResultsCount, null));", "                removeExceedingResults(maxLength);", "            results.addAll(Collections.<T> nCopies(Math.min(index+1, maxLength), null));"]}
{"series": ["private Decimal calculateMaximumDrawdown(TimeSeries series, CashFlow cashFlow) {", "        if (!series.isEmpty()) {", "\t        for (int i = series.getBeginIndex(); i <= series.getEndIndex(); i++) {"], "cashFlow": ["private Decimal calculateMaximumDrawdown(TimeSeries series, CashFlow cashFlow) {", "\t            Decimal value = cashFlow.getValue(i);", "\t            if (value.isGreaterThan(maxPeak)) {", "\t                maxPeak = value;", "\t            Decimal drawdown = maxPeak.minus(value).dividedBy(maxPeak);", "\t            if (drawdown.isGreaterThan(maximumDrawdown)) {", "\t                maximumDrawdown = drawdown;", "        return maximumDrawdown;"]}
{"series": ["public static List<Integer> getSplitBeginIndexes(TimeSeries series, Duration splitDuration) {", "        int beginIndex = series.getBeginIndex();", "        int endIndex = series.getEndIndex();", "        ZonedDateTime beginInterval = series.getFirstTick().getEndTime();", "            ZonedDateTime tickTime = series.getTick(i).getEndTime();", "            if (tickTime.isBefore(beginInterval) || !tickTime.isBefore(endInterval)) {", "                if (!endInterval.isAfter(tickTime)) {", "                beginInterval = endInterval.isBefore(tickTime) ? tickTime : endInterval;", "                endInterval = beginInterval.plus(splitDuration);"], "splitDuration": ["public static List<Integer> getSplitBeginIndexes(TimeSeries series, Duration splitDuration) {", "        ZonedDateTime endInterval = beginInterval.plus(splitDuration);", "            if (tickTime.isBefore(beginInterval) || !tickTime.isBefore(endInterval)) {", "                if (!endInterval.isAfter(tickTime)) {", "                beginInterval = endInterval.isBefore(tickTime) ? tickTime : endInterval;", "                endInterval = beginInterval.plus(splitDuration);"]}
{"startIndex": ["private void calculateRegressionLine(int startIndex, int endIndex) {", "        for (int i = startIndex; i <= endIndex; i++) {", "        Decimal nbObservations = Decimal.valueOf(endIndex - startIndex + 1);", "        for (int i = startIndex; i <= endIndex; i++) {"], "endIndex": ["private void calculateRegressionLine(int startIndex, int endIndex) {", "        for (int i = startIndex; i <= endIndex; i++) {", "        Decimal nbObservations = Decimal.valueOf(endIndex - startIndex + 1);", "        for (int i = startIndex; i <= endIndex; i++) {"]}
{"index": ["public Order operate(int index, Decimal price, Decimal amount) {", "            order = new Order(index, startingType, price, amount);", "            if (index < entry.getIndex()) {", "            order = new Order(index, startingType.complementType(), price, amount);"], "price": ["public Order operate(int index, Decimal price, Decimal amount) {", "            order = new Order(index, startingType, price, amount);", "            order = new Order(index, startingType.complementType(), price, amount);"], "amount": ["public Order operate(int index, Decimal price, Decimal amount) {", "            order = new Order(index, startingType, price, amount);", "            entry = order;", "            order = new Order(index, startingType.complementType(), price, amount);", "            exit = order;", "        return order;"]}
{"tickSeries": ["private static org.jfree.data.time.TimeSeries buildChartTimeSeries(TimeSeries tickSeries, Indicator<Decimal> indicator, String name) {", "        for (int i = 0; i < tickSeries.getTickCount(); i++) {", "            Tick tick = tickSeries.getTick(i);", "            chartTimeSeries.add(new Minute(Date.from(tick.getEndTime().toInstant())), indicator.getValue(i).toDouble());"], "indicator": ["private static org.jfree.data.time.TimeSeries buildChartTimeSeries(TimeSeries tickSeries, Indicator<Decimal> indicator, String name) {", "            chartTimeSeries.add(new Minute(Date.from(tick.getEndTime().toInstant())), indicator.getValue(i).toDouble());"], "name": ["private static org.jfree.data.time.TimeSeries buildChartTimeSeries(TimeSeries tickSeries, Indicator<Decimal> indicator, String name) {", "        org.jfree.data.time.TimeSeries chartTimeSeries = new org.jfree.data.time.TimeSeries(name);", "            chartTimeSeries.add(new Minute(Date.from(tick.getEndTime().toInstant())), indicator.getValue(i).toDouble());", "        return chartTimeSeries;"]}
{"min": ["private static Decimal randDecimal(Decimal min, Decimal max) {\r", "        if (min != null && max != null && min.isLessThan(max)) {\r", "            randomDecimal = max.minus(min).multipliedBy(Decimal.valueOf(Math.random())).plus(min);\r", "        return randomDecimal;\r"], "max": ["private static Decimal randDecimal(Decimal min, Decimal max) {\r", "        if (min != null && max != null && min.isLessThan(max)) {\r", "            randomDecimal = max.minus(min).multipliedBy(Decimal.valueOf(Math.random())).plus(min);\r"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"index": ["private Decimal calculateSar(int index) {", "        Decimal previousSar = getValue(index - 1);"]}
{"trade": ["private void calculate(Trade trade) {", "        final int entryIndex = trade.getEntry().getIndex();", "        int end = trade.getExit().getIndex();", "            if (trade.getEntry().isBuy()) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"series": ["private static OHLCDataset createOHLCDataset(TimeSeries series) {", "        final int nbTicks = series.getTickCount();", "        for (int i = 0; i < nbTicks; i++) {", "            Tick tick = series.getTick(i);", "            dates[i] = new Date(tick.getEndTime().toEpochSecond() * 1000);", "            opens[i] = tick.getOpenPrice().toDouble();", "            highs[i] = tick.getMaxPrice().toDouble();", "            lows[i] = tick.getMinPrice().toDouble();", "            closes[i] = tick.getClosePrice().toDouble();", "            volumes[i] = tick.getVolume().toDouble();", "        OHLCDataset dataset = new DefaultHighLowDataset(\"btc\", dates, highs, lows, opens, closes, volumes);", "        return dataset;"]}
{"series": ["private static TimeSeriesCollection createAdditionalDataset(TimeSeries series) {", "        ClosePriceIndicator indicator = new ClosePriceIndicator(series);", "        for (int i = 0; i < series.getTickCount(); i++) {", "            Tick tick = series.getTick(i);", "            chartTimeSeries.add(new Second(new Date(tick.getEndTime().toEpochSecond() * 1000)), indicator.getValue(i).toDouble());"]}
{"plot": ["private static void addCashFlowAxis(XYPlot plot, TimeSeriesCollection dataset) {", "        plot.setRangeAxis(1, cashAxis);", "        plot.setDataset(1, dataset);", "        plot.mapDatasetToRangeAxis(1, 1);", "        plot.setRenderer(1, cashFlowRenderer);"], "dataset": ["private static void addCashFlowAxis(XYPlot plot, TimeSeriesCollection dataset) {", "        plot.setDataset(1, dataset);"]}
{"chart": ["private static void displayChart(JFreeChart chart) {", "        ChartPanel panel = new ChartPanel(chart);", "        panel.setFillZoomRectangle(true);", "        panel.setMouseWheelEnabled(true);", "        panel.setPreferredSize(new Dimension(1024, 400));", "        frame.setContentPane(panel);"]}
{"Result": "Method without Parameter"}
{"beginTime": ["private static List<Tick> buildEmptyTicks(ZonedDateTime beginTime, ZonedDateTime endTime, int duration) {", "        ZonedDateTime tickEndTime = beginTime;", "            tickEndTime = tickEndTime.plus(tickDuration);"], "endTime": ["private static List<Tick> buildEmptyTicks(ZonedDateTime beginTime, ZonedDateTime endTime, int duration) {", "        } while (tickEndTime.isBefore(endTime));"], "duration": ["private static List<Tick> buildEmptyTicks(ZonedDateTime beginTime, ZonedDateTime endTime, int duration) {", "        Duration tickDuration = Duration.ofSeconds(duration);", "            tickEndTime = tickEndTime.plus(tickDuration);", "            emptyTicks.add(new BaseTick(tickDuration, tickEndTime));", "        } while (tickEndTime.isBefore(endTime));"]}
{"Result": "Method without Parameter"}
{"outState": ["public void onSaveInstanceState(Bundle outState) {", "    outState.putParcelable(KEY_STATE, new State(observableManager.id(), group.id()));"]}
{"kind": ["final void signalEvent(WatchEvent.Kind<Path> kind, Path context) {", "    post(new Event<>(kind, 1, context));"], "context": ["final void signalEvent(WatchEvent.Kind<Path> kind, Path context) {", "    post(new Event<>(kind, 1, context));"]}
{"executor": ["public CompletableFuture<Void> watchAsync(Executor executor) {", "        executor);"]}
{"directory": ["private void register(Path directory, boolean useFileTreeModifier) throws IOException {", "    logger.debug(\"Registering [{}].\", directory);", "    Watchable watchable = isMac ? new WatchablePath(directory) : directory;", "    WatchKey watchKey = watchable.register(watchService, kinds, modifiers);", "    keyRoots.put(watchKey, directory);"], "useFileTreeModifier": ["private void register(Path directory, boolean useFileTreeModifier) throws IOException {", "        useFileTreeModifier"]}
{"Result": "Method without Parameter"}
{"path": ["private void addRelevantPluginDependenciesToClasspath( List<Path> path )", "            path.add( classPathElement.getFile().toPath() );"]}
{"path": ["private void addRelevantProjectDependenciesToClasspath( List<Path> path )", "                path.add( classpathFile );", "                path.add( classPathElement.getFile().toPath() );"]}
{"executablePomArtifact": ["private Set<Artifact> resolveExecutableDependencies( Artifact executablePomArtifact )", "                this.projectBuilder.build( executablePomArtifact, buildingRequest ).getProject();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"distanceMeters": ["private boolean checkDistanceAndTime (double distanceMeters, double travelTimeSeconds, StopTime stopTime) {", "        if (distanceMeters == 0) {"], "travelTimeSeconds": ["private boolean checkDistanceAndTime (double distanceMeters, double travelTimeSeconds, StopTime stopTime) {", "        if (travelTimeSeconds < 0) {", "            registerError(stopTime, TRAVEL_TIME_NEGATIVE, travelTimeSeconds);", "        } else if (travelTimeSeconds == 0) {"], "stopTime": ["private boolean checkDistanceAndTime (double distanceMeters, double travelTimeSeconds, StopTime stopTime) {", "            registerError(stopTime, TRAVEL_DISTANCE_ZERO);", "            registerError(stopTime, TRAVEL_TIME_NEGATIVE, travelTimeSeconds);", "            if (!allTravelTimesAreRounded) registerError(stopTime, TRAVEL_TIME_ZERO);", "            else travelTimeZeroErrors.add(createUnregisteredError(stopTime, TRAVEL_TIME_ZERO));"]}
{"table": ["private TableLoadResult load (Table table) {", "            tableLoadResult.rowCount = loadInternal(table);", "            tableLoadResult.fileSize = getTableSize(table);", "            LOG.info(String.format(\"loaded in %d %s records\", tableLoadResult.rowCount, table.name));"]}
{"table": ["private int getTableSize(Table table) {", "        ZipEntry zipEntry = zip.getEntry(table.name + \".txt\");"]}
{"postgresText": ["private void setFieldToNull(boolean postgresText, String[] transformedStrings, int fieldIndex, Field field) {", "        if (postgresText) transformedStrings[fieldIndex + 1] = POSTGRES_NULL_TEXT;"], "transformedStrings": [], "fieldIndex": ["private void setFieldToNull(boolean postgresText, String[] transformedStrings, int fieldIndex, Field field) {", "            field.setNull(insertStatement, fieldIndex + 2);"], "field": ["private void setFieldToNull(boolean postgresText, String[] transformedStrings, int fieldIndex, Field field) {", "            field.setNull(insertStatement, fieldIndex + 2);"]}
{"Result": "Method without Parameter"}
{"namespace": ["private boolean tableExists(String namespace, String tableName) {", "        if (namespace == null || tableName == null) return false;", "            tableExistsStatement.setString(1, namespace);"], "tableName": ["private boolean tableExists(String namespace, String tableName) {", "        if (namespace == null || tableName == null) return false;", "            tableExistsStatement.setString(2, tableName);"]}
{"connection": ["private void addEditorSpecificFields(Connection connection, String tablePrefix, Table table) throws SQLException {", "        Statement statement = connection.createStatement();"], "tablePrefix": ["private void addEditorSpecificFields(Connection connection, String tablePrefix, Table table) throws SQLException {", "        LOG.info(\"Adding any missing columns for {}\", tablePrefix + table.name);", "            String addColumnSql = String.format(\"ALTER TABLE %s ADD COLUMN IF NOT EXISTS %s %s\",", "                    tablePrefix + table.name,", "            LOG.info(addColumnSql);", "            statement.execute(addColumnSql);"], "table": ["private void addEditorSpecificFields(Connection connection, String tablePrefix, Table table) throws SQLException {", "        LOG.info(\"Adding any missing columns for {}\", tablePrefix + table.name);", "        for (Field field : table.editorFields()) {", "            String addColumnSql = String.format(\"ALTER TABLE %s ADD COLUMN IF NOT EXISTS %s %s\",", "                    tablePrefix + table.name,", "                    field.name,", "                    field.getSqlTypeName());", "            LOG.info(addColumnSql);", "            statement.execute(addColumnSql);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"table": ["private TableLoadResult export (Table table, String filterSql) {", "            String textFileName = table.name + \".txt\";", "            LOG.info(\"Copied {} {} in {} ms.\", tableLoadResult.rowCount, table.name, System.currentTimeMillis() - startTime);"], "filterSql": ["private TableLoadResult export (Table table, String filterSql) {", "            if (filterSql == null) {", "                filterSql = String.format(\"(%s)\", filterSql);", "            String copySql = String.format(\"copy %s to STDOUT DELIMITER ',' CSV HEADER\", filterSql);", "            LOG.info(copySql);", "            tableLoadResult.rowCount = (int) copyManager.copyOut(copySql, protectedOut);"]}
{"entity": ["public void registerError(Entity entity, NewGTFSErrorType errorType) {", "        errorStorage.storeError(NewGTFSError.forEntity(entity, errorType));"], "errorType": ["public void registerError(Entity entity, NewGTFSErrorType errorType) {", "        errorStorage.storeError(NewGTFSError.forEntity(entity, errorType));"]}
{"entity": ["public void registerError(Entity entity, NewGTFSErrorType errorType, Object badValue) {", "        errorStorage.storeError(NewGTFSError.forEntity(entity, errorType).setBadValue(badValue.toString()));"], "errorType": ["public void registerError(Entity entity, NewGTFSErrorType errorType, Object badValue) {", "        errorStorage.storeError(NewGTFSError.forEntity(entity, errorType).setBadValue(badValue.toString()));"], "badValue": ["public void registerError(Entity entity, NewGTFSErrorType errorType, Object badValue) {", "        errorStorage.storeError(NewGTFSError.forEntity(entity, errorType).setBadValue(badValue.toString()));"]}
{"feedId": ["public static FeedLoadResult export (String feedId, String outFile, DataSource dataSource, boolean fromEditor) {", "        JdbcGtfsExporter exporter = new JdbcGtfsExporter(feedId, outFile, dataSource, fromEditor);"], "outFile": ["public static FeedLoadResult export (String feedId, String outFile, DataSource dataSource, boolean fromEditor) {", "        JdbcGtfsExporter exporter = new JdbcGtfsExporter(feedId, outFile, dataSource, fromEditor);"], "dataSource": ["public static FeedLoadResult export (String feedId, String outFile, DataSource dataSource, boolean fromEditor) {", "        JdbcGtfsExporter exporter = new JdbcGtfsExporter(feedId, outFile, dataSource, fromEditor);"], "fromEditor": ["public static FeedLoadResult export (String feedId, String outFile, DataSource dataSource, boolean fromEditor) {", "        JdbcGtfsExporter exporter = new JdbcGtfsExporter(feedId, outFile, dataSource, fromEditor);", "        FeedLoadResult result = exporter.exportTables();"]}
{"filePath": ["public static FeedLoadResult load (String filePath, DataSource dataSource) {", "        JdbcGtfsLoader loader = new JdbcGtfsLoader(filePath, dataSource);"], "dataSource": ["public static FeedLoadResult load (String filePath, DataSource dataSource) {", "        JdbcGtfsLoader loader = new JdbcGtfsLoader(filePath, dataSource);", "        FeedLoadResult result = loader.loadTables();"]}
{"feedId": ["public static ValidationResult validate (String feedId, DataSource dataSource) {", "        Feed feed = new Feed(dataSource, feedId);", "        ValidationResult result = feed.validate();"], "dataSource": ["public static ValidationResult validate (String feedId, DataSource dataSource) {", "        Feed feed = new Feed(dataSource, feedId);"]}
{"feedId": ["public static void delete (String feedId, DataSource dataSource) throws SQLException, InvalidNamespaceException {", "        LOG.info(\"Deleting all tables (dropping schema) for {} feed namespace.\", feedId);", "            ensureValidNamespace(feedId);", "            deleteFeedStatement.setString(1, feedId);", "            String dropSchemaSql = String.format(\"DROP SCHEMA %s CASCADE\", feedId);", "            statement.executeUpdate(dropSchemaSql);", "            LOG.error(String.format(\"Could not drop feed for namespace %s\", feedId), e);"], "dataSource": ["public static void delete (String feedId, DataSource dataSource) throws SQLException, InvalidNamespaceException {", "            connection = dataSource.getConnection();"]}
{"url": ["public static DataSource createDataSource (String url, String username, String password) {", "        ConnectionFactory connectionFactory = new DriverManagerConnectionFactory(url, username, password);"], "username": ["public static DataSource createDataSource (String url, String username, String password) {", "        ConnectionFactory connectionFactory = new DriverManagerConnectionFactory(url, username, password);"], "password": ["public static DataSource createDataSource (String url, String username, String password) {", "        ConnectionFactory connectionFactory = new DriverManagerConnectionFactory(url, username, password);", "        PoolableConnectionFactory poolableConnectionFactory = new PoolableConnectionFactory(connectionFactory, null);"]}
{"key": ["public NewGTFSError addInfo (String key, String value) {", "        errorInfo.put(key, value);"], "value": ["public NewGTFSError addInfo (String key, String value) {", "        errorInfo.put(key, value);"]}
{"table": ["public static NewGTFSError forLine (Table table, int lineNumber, NewGTFSErrorType errorType, String badValue) {", "        NewGTFSError error = new NewGTFSError(table.getEntityClass(), errorType);"], "lineNumber": ["public static NewGTFSError forLine (Table table, int lineNumber, NewGTFSErrorType errorType, String badValue) {", "        error.lineNumber = lineNumber;"], "errorType": ["public static NewGTFSError forLine (Table table, int lineNumber, NewGTFSErrorType errorType, String badValue) {", "        NewGTFSError error = new NewGTFSError(table.getEntityClass(), errorType);"], "badValue": ["public static NewGTFSError forLine (Table table, int lineNumber, NewGTFSErrorType errorType, String badValue) {", "        error.badValue = badValue;", "        return error;"]}
{"entity": ["public static NewGTFSError forEntity(Entity entity, NewGTFSErrorType errorType) {", "        NewGTFSError error = new NewGTFSError(entity.getClass(), errorType);", "        error.lineNumber = entity.id;", "        error.entityId = entity.getId();", "        error.entitySequenceNumber = entity.getSequenceNumber();"], "errorType": ["public static NewGTFSError forEntity(Entity entity, NewGTFSErrorType errorType) {", "        NewGTFSError error = new NewGTFSError(entity.getClass(), errorType);"]}
{"errorType": ["public static NewGTFSError forFeed (NewGTFSErrorType errorType, String badValue) {", "        return new NewGTFSError(null, errorType).setBadValue(badValue);"], "badValue": ["public static NewGTFSError forFeed (NewGTFSErrorType errorType, String badValue) {", "        return new NewGTFSError(null, errorType).setBadValue(badValue);"]}
{"pattern_id": ["public double getPatternSpeed (String pattern_id, LocalDate date, LocalTime from, LocalTime to) {", "        List<Trip> trips = getTripsForDate(pattern_id, date);"], "date": ["public double getPatternSpeed (String pattern_id, LocalDate date, LocalTime from, LocalTime to) {", "        List<Trip> trips = getTripsForDate(pattern_id, date);", "        return getAverageSpeedForTrips(trips, from, to);"], "from": ["public double getPatternSpeed (String pattern_id, LocalDate date, LocalTime from, LocalTime to) {", "        return getAverageSpeedForTrips(trips, from, to);"], "to": ["public double getPatternSpeed (String pattern_id, LocalDate date, LocalTime from, LocalTime to) {", "        return getAverageSpeedForTrips(trips, from, to);"]}
{"trips": ["public double getAverageSpeedForTrips (Collection<Trip> trips, LocalTime from, LocalTime to) {", "        for (Trip trip : trips) {", "            StopTime firstStopTime = feed.stop_times.ceilingEntry(Fun.t2(trip.trip_id, null)).getValue();", "            LocalTime tripBeginTime = LocalTime.ofSecondOfDay(firstStopTime.departure_time % 86399); // convert 24hr+ seconds to 0 - 86399", "            if (tripBeginTime.isAfter(to) || tripBeginTime.isBefore(from)) {", "            double speed = feed.getTripSpeed(trip.trip_id, true);", "            if (!Double.isNaN(speed)) {", "                speeds.add(speed);"], "from": ["public double getAverageSpeedForTrips (Collection<Trip> trips, LocalTime from, LocalTime to) {", "            if (tripBeginTime.isAfter(to) || tripBeginTime.isBefore(from)) {"], "to": ["public double getAverageSpeedForTrips (Collection<Trip> trips, LocalTime from, LocalTime to) {", "            if (tripBeginTime.isAfter(to) || tripBeginTime.isBefore(from)) {"]}
{"trips": ["public LocalTime getStartTimeForTrips (Collection<Trip> trips) {", "        for (Trip trip : trips) {", "            StopTime st = feed.getOrderedStopTimesForTrip(trip.trip_id).iterator().next();", "            int dep = st.departure_time;", "            if (dep > 86399) {", "                dep = dep % 86399;", "            if (dep <= earliestDeparture) {", "                earliestDeparture = dep;", "        return LocalTime.ofSecondOfDay(earliestDeparture);"]}
{"trips": ["public LocalTime getEndTimeForTrips (Collection<Trip> trips) {", "        for (Trip trip : trips) {", "            StopTime st = feed.getOrderedStopTimesForTrip(trip.trip_id).iterator().next();", "            if (st.arrival_time >= latestArrival) {", "                latestArrival = st.arrival_time;", "        return LocalTime.ofSecondOfDay(latestArrival % 86399);"]}
{"pattern_id": ["public double getPatternDistance (String pattern_id) {", "        Pattern pattern = feed.patterns.get(pattern_id);", "        return feed.getTripDistance(pattern.associatedTrips.iterator().next(), false);"]}
{"pattern_id": ["public double getAverageStopSpacing (String pattern_id) {", "        Pattern pattern = feed.patterns.get(pattern_id);", "        return getPatternDistance(pattern_id) / pattern.orderedStops.size();"]}
{"entities": ["private <E extends Entity> void copyEntityToSql(Iterable<E> entities, Table table) throws SQLException {", "        for (E entity : entities) {", "            entity.setStatementParameters(insertStatement, true);"], "table": ["private <E extends Entity> void copyEntityToSql(Iterable<E> entities, Table table) throws SQLException {", "        table.createSqlTable(connection, namespace, true);", "        String entityInsertSql = table.generateInsertSql(namespace, true);", "        LOG.info(\"Inserted {} {}\", count, table.name);", "        table.createIndexes(connection, namespace);"]}
{"result": ["public static ValidateFieldResult<String> from(ValidateFieldResult result) {", "        stringResult.clean = String.valueOf(result.clean);", "        stringResult.errors.addAll(result.errors);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"hhmmss": ["    public ValidateFieldResult<String> validateAndConvert(String hhmmss) {", "        return ValidateFieldResult.from(getSeconds(hhmmss));"]}
{"o": ["    public int compareTo (GTFSError o) {", "        int compare = super.compareTo(o);", "        if (compare != 0) return compare;", "        return this.badReference.compareTo((((ReferentialIntegrityError) o).badReference));"]}
{"tripGeometry": ["public static double getDistance(LineString tripGeometry) {", "      for (int i = 0; i < tripGeometry.getNumPoints() - 1; i++) {", "          distance += JTS.orthodromicDistance(tripGeometry.getCoordinateN(i), tripGeometry.getCoordinateN(i + 1), DefaultGeographicCRS.WGS84);", "      return distance;"]}
{"fieldName": ["public static GraphQLFieldDefinition field (String fieldName, String tableName) {", "                .name(fieldName)"], "tableName": ["public static GraphQLFieldDefinition field (String fieldName, String tableName) {", "                .dataFetcher(new RowCountFetcher(tableName))"]}
{"tableName": ["public static GraphQLFieldDefinition groupedField(String tableName, String groupByColumn) {", "                .dataFetcher(new RowCountFetcher(tableName, null, groupByColumn))"], "groupByColumn": ["public static GraphQLFieldDefinition groupedField(String tableName, String groupByColumn) {", "                .name(groupByColumn)", "                .dataFetcher(new RowCountFetcher(tableName, null, groupByColumn))"]}
{"original": ["public int[] deduplicateIntArray(int[] original) {", "        if (original == null) return null;", "        IntArray intArray = new IntArray(original);", "        IntArray canonical = canonicalIntArrays.get(intArray);", "        if (canonical == null) {", "            canonical = intArray;", "            canonicalIntArrays.put(canonical, canonical);", "        return canonical.array;"]}
{"stop_id": ["public List<Trip> getTripsForDate (String stop_id, LocalDate date) {", "        return feed.getDistinctTripsForStop(stop_id).stream()"], "date": ["public List<Trip> getTripsForDate (String stop_id, LocalDate date) {", "        List<String> tripIds = stats.getTripsForDate(date).stream()"]}
{"stop_id": ["public int getAverageHeadwayForStop (String stop_id, LocalDate date, LocalTime from, LocalTime to) {", "        List<Trip> tripsForStop = getTripsForDate(stop_id, date);", "        return getStopHeadwayForTrips(stop_id, tripsForStop, from, to);"], "date": ["public int getAverageHeadwayForStop (String stop_id, LocalDate date, LocalTime from, LocalTime to) {", "        List<Trip> tripsForStop = getTripsForDate(stop_id, date);", "        return getStopHeadwayForTrips(stop_id, tripsForStop, from, to);"], "from": ["public int getAverageHeadwayForStop (String stop_id, LocalDate date, LocalTime from, LocalTime to) {", "        return getStopHeadwayForTrips(stop_id, tripsForStop, from, to);"], "to": ["public int getAverageHeadwayForStop (String stop_id, LocalDate date, LocalTime from, LocalTime to) {", "        return getStopHeadwayForTrips(stop_id, tripsForStop, from, to);"]}
{"stop_id": ["public Map<String, Integer> getRouteHeadwaysForStop (String stop_id, LocalDate date, LocalTime from, LocalTime to) {", "                .filter(p -> p.orderedStops.contains(stop_id))", "            routeHeadwayMap.put(route.route_id, getHeadwayForStopByRoute(stop_id, route.route_id, date, from, to));"], "date": ["public Map<String, Integer> getRouteHeadwaysForStop (String stop_id, LocalDate date, LocalTime from, LocalTime to) {", "            routeHeadwayMap.put(route.route_id, getHeadwayForStopByRoute(stop_id, route.route_id, date, from, to));"], "from": ["public Map<String, Integer> getRouteHeadwaysForStop (String stop_id, LocalDate date, LocalTime from, LocalTime to) {", "            routeHeadwayMap.put(route.route_id, getHeadwayForStopByRoute(stop_id, route.route_id, date, from, to));"], "to": ["public Map<String, Integer> getRouteHeadwaysForStop (String stop_id, LocalDate date, LocalTime from, LocalTime to) {", "            routeHeadwayMap.put(route.route_id, getHeadwayForStopByRoute(stop_id, route.route_id, date, from, to));"]}
{"stop_id": ["public int getHeadwayForStopByRoute (String stop_id, String route_id, LocalDate date, LocalTime from, LocalTime to) {", "        List<Trip> tripsForStop = feed.getDistinctTripsForStop(stop_id).stream()", "        return getStopHeadwayForTrips(stop_id, tripsForStop, from, to);"], "route_id": ["public int getHeadwayForStopByRoute (String stop_id, String route_id, LocalDate date, LocalTime from, LocalTime to) {", "                .filter(trip -> feed.trips.get(trip.trip_id).route_id.equals(route_id))"], "date": ["public int getHeadwayForStopByRoute (String stop_id, String route_id, LocalDate date, LocalTime from, LocalTime to) {", "                .filter(trip -> feed.services.get(trip.service_id).activeOn(date))"], "from": ["public int getHeadwayForStopByRoute (String stop_id, String route_id, LocalDate date, LocalTime from, LocalTime to) {", "        return getStopHeadwayForTrips(stop_id, tripsForStop, from, to);"], "to": ["public int getHeadwayForStopByRoute (String stop_id, String route_id, LocalDate date, LocalTime from, LocalTime to) {", "        return getStopHeadwayForTrips(stop_id, tripsForStop, from, to);"]}
{"json": ["private static JsonNode getJsonNode (String json) throws IOException {", "            return mapper.readTree(json);"]}
{"json": ["    public String create(String json, boolean autoCommit) throws SQLException, IOException {", "        return update(null, json, autoCommit);"], "autoCommit": ["    public String create(String json, boolean autoCommit) throws SQLException, IOException {", "        return update(null, json, autoCommit);"]}
{"patternStop": ["private int updateStopTimesForPatternStop(ObjectNode patternStop, int previousTravelTime) throws SQLException {", "        int travelTime = patternStop.get(\"default_travel_time\").asInt();", "        int dwellTime = patternStop.get(\"default_dwell_time\").asInt();", "        statement.setString(oneBasedIndex++, patternStop.get(\"pattern_id\").asText());", "        statement.setInt(oneBasedIndex++, patternStop.get(\"stop_sequence\").asInt());"], "previousTravelTime": ["private int updateStopTimesForPatternStop(ObjectNode patternStop, int previousTravelTime) throws SQLException {", "        int arrivalTime = previousTravelTime + travelTime;"]}
{"referringTableName": ["private void verifyReferencesExist(String referringTableName, Multimap<Table, String> referencesPerTable) throws SQLException {", "            LOG.info(\"Checking {} references to {}\", referringTableName, referencedTable.name);", "                                referringTableName,"], "referencesPerTable": ["private void verifyReferencesExist(String referringTableName, Multimap<Table, String> referencesPerTable) throws SQLException {", "        for (Table referencedTable: referencesPerTable.keySet()) {", "            LOG.info(\"Checking {} references to {}\", referringTableName, referencedTable.name);", "            Collection<String> referenceStrings = referencesPerTable.get(referencedTable);", "            String referenceFieldName = referencedTable.getKeyFieldName();", "            String questionMarks = String.join(\", \", Collections.nCopies(referenceStrings.size(), \"?\"));", "            String checkCountSql = String.format(", "                    referenceFieldName,", "                    referencedTable.name,", "                    referenceFieldName,", "                    questionMarks);", "            PreparedStatement preparedStatement = connection.prepareStatement(checkCountSql);", "            for (String ref : referenceStrings) {", "                preparedStatement.setString(oneBasedIndex++, ref);", "            LOG.info(preparedStatement.toString());", "            ResultSet resultSet = preparedStatement.executeQuery();", "            while (resultSet.next()) {", "                String referenceValue = resultSet.getString(1);", "                foundReferences.add(referenceValue);", "            referenceStrings.removeAll(foundReferences);", "            if (referenceStrings.size() > 0) {", "                                referenceFieldName,", "                                String.join(\", \", referenceStrings)));", "                LOG.info(\"All {} {} {} references are valid.\", foundReferences.size(), referencedTable.name, referenceFieldName);"]}
{"originalStopIds": ["        List<String> originalStopIds,", "            String originalStopId = originalStopIds.get(shiftedIndex);", "            if (!newStopId.equals(originalStopId)) {"], "newStops": ["        List<PatternStop> newStops,", "        List<String> newStopIds = newStops.stream().map(s -> s.stop_id).collect(Collectors.toList());"], "firstDifferentIndex": ["        int firstDifferentIndex,", "        int beginRegion = movedRight ? firstDifferentIndex : firstDifferentIndex + 1;"], "lastDifferentIndex": ["        int lastDifferentIndex,", "        int endRegion = movedRight ? lastDifferentIndex - 1 : lastDifferentIndex;", "        for (int i = beginRegion; i <= endRegion; i++) {"], "movedRight": ["        boolean movedRight", "        int beginRegion = movedRight ? firstDifferentIndex : firstDifferentIndex + 1;", "        int endRegion = movedRight ? lastDifferentIndex - 1 : lastDifferentIndex;", "            int shiftedIndex = movedRight ? i + 1 : i - 1;", "            String originalStopId = originalStopIds.get(shiftedIndex);", "            if (!newStopId.equals(originalStopId)) {"]}
{"tripIds": ["        List<String> tripIds,", "        if (tripIds.isEmpty()) {", "            for (String tripId : tripIds) {", "                stopTime.trip_id = tripId;", "                stopTime.setStatementParameters(insertStatement, true);"], "newStops": ["        List<PatternStop> newStops,", "            PatternStop patternStop = newStops.get(i);", "            stopTime.stop_id = patternStop.stop_id;", "            stopTime.drop_off_type = patternStop.drop_off_type;", "            stopTime.pickup_type = patternStop.pickup_type;", "            stopTime.timepoint = patternStop.timepoint;", "            stopTime.shape_dist_traveled = patternStop.shape_dist_traveled;"], "startingStopSequence": ["        int startingStopSequence,", "        for (int i = startingStopSequence; i < stopTimesToAdd + startingStopSequence; i++) {"], "stopTimesToAdd": ["        int stopTimesToAdd,", "        for (int i = startingStopSequence; i < stopTimesToAdd + startingStopSequence; i++) {"], "connection": ["        Connection connection", "        PreparedStatement insertStatement = connection.prepareStatement(insertSql);"]}
{"id": ["    public int delete(Integer id, boolean autoCommit) throws SQLException {", "            deleteFromReferencingTables(tablePrefix, specTable, id);", "            statement.setInt(1, id);", "                LOG.error(\"Could not delete {} entity with id: {}\", specTable.name, id);", "            LOG.error(\"Could not delete {} entity with id: {}\", specTable.name, id);"], "autoCommit": ["    public int delete(Integer id, boolean autoCommit) throws SQLException {", "            if (autoCommit) connection.commit();", "            if (autoCommit) connection.close();"]}
{"statement": ["private static long handleStatementExecution(PreparedStatement statement, boolean isCreating) throws SQLException {", "        LOG.info(statement.toString());", "        int affectedRows = statement.executeUpdate();", "        try (ResultSet generatedKeys = statement.getGeneratedKeys()) {"], "isCreating": ["private static long handleStatementExecution(PreparedStatement statement, boolean isCreating) throws SQLException {", "        String messageAction = isCreating ? \"Creating\" : \"Updating\";"]}
{"tableName": ["private static int getRowCount(String tableName, Connection connection) throws SQLException {", "        String rowCountSql = String.format(\"SELECT COUNT(*) FROM %s\", tableName);", "        LOG.info(rowCountSql);", "        ResultSet resultSet = statement.executeQuery(rowCountSql);", "        if (resultSet.next()) return resultSet.getInt(1);"], "connection": ["private static int getRowCount(String tableName, Connection connection) throws SQLException {", "        Statement statement = connection.createStatement();"]}
{"table": ["private static Set<Table> getReferencingTables(Table table) {", "            if (table.name.equals(gtfsTable.name)) continue;", "                if (field.isForeignReference() && field.referenceTable.name.equals(table.name)) {"]}
{"id": ["private static String getValueForId(int id, String fieldName, String namespace, Table table, Connection connection) throws SQLException {", "        String selectIdSql = String.format(\"select %s from %s where id = %d\", fieldName, tableName, id);", "        LOG.info(selectIdSql);", "        ResultSet selectResults = selectIdStatement.executeQuery(selectIdSql);", "        while (selectResults.next()) {", "            value = selectResults.getString(1);", "        return value;"], "fieldName": ["private static String getValueForId(int id, String fieldName, String namespace, Table table, Connection connection) throws SQLException {", "        String selectIdSql = String.format(\"select %s from %s where id = %d\", fieldName, tableName, id);"], "namespace": ["private static String getValueForId(int id, String fieldName, String namespace, Table table, Connection connection) throws SQLException {", "        String tableName = String.join(\".\", namespace, table.name);"], "table": ["private static String getValueForId(int id, String fieldName, String namespace, Table table, Connection connection) throws SQLException {", "        String tableName = String.join(\".\", namespace, table.name);"], "connection": ["private static String getValueForId(int id, String fieldName, String namespace, Table table, Connection connection) throws SQLException {", "        Statement selectIdStatement = connection.createStatement();"]}
{"id": ["public T put (String id, File feedFile) throws Exception {", "        return put(id, feedFile, null);"], "feedFile": ["public T put (String id, File feedFile) throws Exception {", "        return put(id, feedFile, null);"]}
{"idGenerator": ["public T put (Function<GTFSFeed, String> idGenerator, File feedFile) throws Exception {", "        return put(null, feedFile, idGenerator);"], "feedFile": ["public T put (Function<GTFSFeed, String> idGenerator, File feedFile) throws Exception {", "        return put(null, feedFile, idGenerator);"]}
{"date": ["public boolean activeOn (LocalDate date) {", "        CalendarDate exception = calendar_dates.get(date);", "        if (exception != null)", "            return exception.exception_type == 1;", "            boolean outsideValidityRange = date.isAfter(calendar.end_date) || date.isBefore(calendar.start_date);", "            switch (date.getDayOfWeek()) {"]}
{"dataSource": ["public static void initialize (DataSource dataSource) {", "        GTFSGraphQL.dataSource = dataSource;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"connection": ["public boolean createSqlTable (Connection connection, String namespace, boolean makeIdSerial, String[] primaryKeyFields) {", "            Statement statement = connection.createStatement();"], "namespace": ["public boolean createSqlTable (Connection connection, String namespace, boolean makeIdSerial, String[] primaryKeyFields) {", "        String tableName = namespace != null ? String.join(\".\", namespace, name) : name;"], "makeIdSerial": ["public boolean createSqlTable (Connection connection, String namespace, boolean makeIdSerial, String[] primaryKeyFields) {", "        String idFieldType = makeIdSerial ? \"serial\" : \"bigint\";"], "primaryKeyFields": ["public boolean createSqlTable (Connection connection, String namespace, boolean makeIdSerial, String[] primaryKeyFields) {", "        if (primaryKeyFields != null) {", "            fieldDeclarations += String.format(\", primary key (%s)\", String.join(\", \", primaryKeyFields));", "        String createSql = String.format(\"create table %s (id %s not null, %s)\", tableName, idFieldType, fieldDeclarations);", "            LOG.info(createSql);", "            return statement.execute(createSql);"]}
{"namespace": ["public String generateInsertSql (String namespace, boolean setDefaultId) {", "        String tableName = namespace == null", "                : String.join(\".\", namespace, name);"], "setDefaultId": ["public String generateInsertSql (String namespace, boolean setDefaultId) {", "        String idValue = setDefaultId ? \"DEFAULT\" : \"?\";"]}
{"fieldsToJoin": ["public static String commaSeparatedNames(List<Field> fieldsToJoin, String prefix, boolean csvOutput) {", "        return fieldsToJoin.stream()"], "prefix": ["public static String commaSeparatedNames(List<Field> fieldsToJoin, String prefix, boolean csvOutput) {", "                .map(f -> f.getColumnExpression(prefix, csvOutput))"], "csvOutput": ["public static String commaSeparatedNames(List<Field> fieldsToJoin, String prefix, boolean csvOutput) {", "                .map(f -> f.getColumnExpression(prefix, csvOutput))"]}
{"namespace": ["public String generateUpdateSql (String namespace, int id) {", "        String tableName = namespace == null ? name : String.join(\".\", namespace, name);"], "id": ["public String generateUpdateSql (String namespace, int id) {", "        return String.format(\"update %s set %s where id = %d\", tableName, joinedFieldNames, id);"]}
{"namespace": ["public String generateSelectSql (String namespace, Requirement minimumRequirement) {", "        String tableName = String.join(\".\", namespace, name);"], "minimumRequirement": ["public String generateSelectSql (String namespace, Requirement minimumRequirement) {", "        if (minimumRequirement.equals(EDITOR)) {", "        } else if (minimumRequirement.equals(OPTIONAL)) {", "        } else if (minimumRequirement.equals(REQUIRED)) {"]}
{"connection": ["public String generateSelectAllExistingFieldsSql(Connection connection, String namespace) throws SQLException {", "        PreparedStatement statement = connection.prepareStatement("], "namespace": ["public String generateSelectAllExistingFieldsSql(Connection connection, String namespace) throws SQLException {", "        statement.setString(1, namespace);", "        String tableName = String.join(\".\", namespace, name);"]}
{"namespace": ["public String generateDeleteSql (String namespace, String fieldName) {", "        return String.format(\"delete from %s where %s = ?\", String.join(\".\", namespace, name), whereField);"], "fieldName": ["public String generateDeleteSql (String namespace, String fieldName) {", "        String whereField = fieldName == null ? \"id\" : fieldName;", "        return String.format(\"delete from %s where %s = ?\", String.join(\".\", namespace, name), whereField);"]}
{"connection": ["public boolean createSqlTableFrom(Connection connection, String tableToClone) {", "            Statement statement = connection.createStatement();", "                connection.rollback();", "                createSqlTable(connection, true);"], "tableToClone": ["public boolean createSqlTableFrom(Connection connection, String tableToClone) {", "            if (tableToClone.endsWith(\"stop_times\")) {", "                normalizeAndCloneStopTimes(statement, name, tableToClone);", "                String createTableAsSql = String.format(\"create table %s as table %s\", name, tableToClone);", "                LOG.info(createTableAsSql);", "                statement.execute(createTableAsSql);", "            LOG.info(\"Cloned table {} as {} in {} ms\", tableToClone, name, System.currentTimeMillis() - startTime);"]}
{"statement": ["private void normalizeAndCloneStopTimes(Statement statement, String name, String tableToClone) throws SQLException {", "        statement.execute(createTableLikeSql);", "        ResultSet resultSet = statement.executeQuery(String.format(\"select * from %s limit 1\", tableToClone));", "        statement.execute(insertAllSql);"], "name": ["private void normalizeAndCloneStopTimes(Statement statement, String name, String tableToClone) throws SQLException {", "        String createTableLikeSql = String.format(\"create table %s (like %s)\", name, tableToClone);", "        String insertAllSql = String.format(\"insert into %s (select %s from %s)\", name, String.join(\", \", columns), tableToClone);"], "tableToClone": ["private void normalizeAndCloneStopTimes(Statement statement, String name, String tableToClone) throws SQLException {", "        String createTableLikeSql = String.format(\"create table %s (like %s)\", name, tableToClone);", "        LOG.info(createTableLikeSql);", "        statement.execute(createTableLikeSql);", "        ResultSet resultSet = statement.executeQuery(String.format(\"select * from %s limit 1\", tableToClone));", "        ResultSetMetaData metadata = resultSet.getMetaData();", "        String insertAllSql = String.format(\"insert into %s (select %s from %s)\", name, String.join(\", \", columns), tableToClone);", "        LOG.info(insertAllSql);", "        statement.execute(insertAllSql);"]}
{"fields": ["public int getKeyFieldIndex(Field[] fields) {", "        return Field.getFieldIndex(fields, keyField);"]}
{"namespace": ["public static void ensureValidNamespace(String namespace) throws InvalidNamespaceException {", "        Matcher matcher = pattern.matcher(namespace);", "        if (matcher.find()) {"]}
{"fields": ["public static int getFieldIndex (Field[] fields, String name) {", "        for (int i = 0; i < fields.length; i++) if (fields[i].name.equals(name)) return i;"], "name": ["public static int getFieldIndex (Field[] fields, String name) {", "        for (int i = 0; i < fields.length; i++) if (fields[i].name.equals(name)) return i;"]}
{"Result": "Method without Parameter"}
{"file": ["public static GTFSFeed fromFile(String file, String feedId) {", "            zip = new ZipFile(file);", "                feed.loadFromFile(zip);", "                feed.loadFromFile(zip, feedId);", "            zip.close();"], "feedId": ["public static GTFSFeed fromFile(String file, String feedId) {", "            if (feedId == null) {", "                feed.loadFromFile(zip, feedId);"]}
{"Result": "Method without Parameter"}
{"trip_id": ["public double getTripDistance (String trip_id, boolean straightLine) {", "                ? GeoUtils.getDistance(this.getStraightLineForStops(trip_id))", "                : GeoUtils.getDistance(this.getTripGeometry(trip_id));"], "straightLine": ["public double getTripDistance (String trip_id, boolean straightLine) {", "        return straightLine"]}
{"trip_id": ["public double getTripSpeed (String trip_id, boolean straightLine) {", "        StopTime firstStopTime = this.stop_times.ceilingEntry(Fun.t2(trip_id, null)).getValue();", "        StopTime lastStopTime = this.stop_times.floorEntry(Fun.t2(trip_id, Fun.HI)).getValue();", "        if (!firstStopTime.trip_id.equals(trip_id) || !lastStopTime.trip_id.equals(trip_id)) {", "        double distance = getTripDistance(trip_id, straightLine);"], "straightLine": ["public double getTripSpeed (String trip_id, boolean straightLine) {", "        double distance = getTripDistance(trip_id, straightLine);", "        return distance / time; // meters per second"]}
{"stop_id": ["public List<StopTime> getStopTimesForStop (String stop_id) {", "                .subSet(new Tuple2<>(stop_id, null), new Tuple2(stop_id, Fun.HI));"]}
{"date": ["public List<Service> getServicesForDate (LocalDate date) {", "        String dateString = date.format(dateFormatter);"]}
{"stop_id": ["public ZoneId getAgencyTimeZoneForStop (String stop_id) {", "        StopTime stopTime = getStopTimesForStop(stop_id).iterator().next();"]}
{"stopById": ["public Map<TripPatternKey, Pattern> createPatternObjects(Map<String, Stop> stopById, SQLErrorStorage errorStorage) {", "        renamePatterns(patterns.values(), stopById);"], "errorStorage": ["public Map<TripPatternKey, Pattern> createPatternObjects(Map<String, Stop> stopById, SQLErrorStorage errorStorage) {", "            if (pattern.associatedShapes.size() > 1 && errorStorage != null) {", "                errorStorage.storeError(NewGTFSError.forEntity("]}
{"context": ["private static void setAnywayTimer(Context context) {", "        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);", "        Intent intent = new Intent(context, IdleReceiver.class);", "        PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0);"]}
{"context": ["public static void enableReceiver(Context context) {", "        context.getApplicationContext().registerReceiver(sReceiver, filter);"]}
{"context": ["void reportNewIdleState(Context context, boolean isIdle) {", "        JobStore jobStore = JobStore.initAndGet(context);", "        synchronized (jobStore) {", "            ArraySet<JobStatus> jobs = jobStore.getJobs();", "        startWakefulService(context, JobServiceCompat.maybeRunJobs(context));"], "isIdle": ["void reportNewIdleState(Context context, boolean isIdle) {", "                ts.idleConstraintSatisfied.set(isIdle);"]}
{"jobStatus": ["public boolean add(JobStatus jobStatus) {", "        boolean replaced = mJobSet.remove(jobStatus);", "        mJobSet.add(jobStatus);", "        if (!jobStatus.isPersisted()) {", "            markForBootSession(jobStatus);", "        return replaced;"]}
{"jobId": ["public boolean containsJobId(int jobId) {", "            if (ts.matches(jobId)) {"]}
{"jobStatus": ["public boolean remove(JobStatus jobStatus) {", "        boolean removed = mJobSet.remove(jobStatus);", "        if (!removed) {", "        if (!jobStatus.isPersisted()) {", "            unmarkForBootSession(jobStatus);", "        return removed;"]}
{"job": ["private JobStatus rescheduleFailedJob(JobStatus job) {", "        if (job.hasIdleConstraint()) {", "            return job;", "        final JobInfo jobInfo = job.getJob();", "        final int backoffAttemps = job.getNumFailures() + 1;", "        switch (job.getJob().getBackoffPolicy()) {", "        return new JobStatus(job, elapsedNowMillis + delayMillis, JobStatus.NO_LATEST_RUNTIME, backoffAttemps);"]}
{"Result": "Method without Parameter"}
{"params": ["public void onReceivedStartJob(JobParameters params) {", "        mParamsTextView.setText(\"Executing: \" + params.getJobId() + \" \" + params.getExtras());"]}
{"Result": "Method without Parameter"}
{"job": ["private static boolean canStopTrackingJob(JobStatus job) {", "        return (!job.hasTimingDelayConstraint() ||", "                job.timeDelayConstraintSatisfied.get()) &&", "                (!job.hasDeadlineConstraint() ||", "                        job.deadlineConstraintSatisfied.get());"]}
{"key": ["public void putString(String key, String value) {", "        PersistableBundleCompat.putString(bundle, key, value);"], "value": ["public void putString(String key, String value) {", "        PersistableBundleCompat.putString(bundle, key, value);"]}
{"key": ["public void putStringArray(String key, String[] value) {", "        PersistableBundleCompat.putStringArray(bundle, key, value);"], "value": ["public void putStringArray(String key, String[] value) {", "        PersistableBundleCompat.putStringArray(bundle, key, value);"]}
{"key": ["public String getString(String key, String defaultValue) {", "        return PersistableBundleCompat.getString(bundle, key, defaultValue);"], "defaultValue": ["public String getString(String key, String defaultValue) {", "        return PersistableBundleCompat.getString(bundle, key, defaultValue);"]}
{"key": ["public void putPersistableBundle(String key, PersistableBundle value) {", "        PersistableBundleCompat.putPersistableBundle(bundle, key, value.bundle);"], "value": ["public void putPersistableBundle(String key, PersistableBundle value) {", "        PersistableBundleCompat.putPersistableBundle(bundle, key, value.bundle);"]}
{"out": ["public void writeToParcel(Parcel out, int flags) {", "        out.writeString(mMessage);", "        out.writeString(mActionMessage);", "        out.writeInt(mActionIcon);", "        out.writeParcelable(mToken, 0);", "        out.writeInt((int) mDuration);", "        out.writeParcelable(mBtnTextColor, 0);", "        out.writeParcelable(mBackgroundColor, 0);", "        out.writeInt(mHeight);", "        out.writeValue(mTypeface);"], "flags": []}
{"Result": "Method without Parameter"}
{"str": ["public static void dPrint(String str) {", "            System.out.println(str);", "        M_log.fine(str);"]}
{"postProp": ["public static boolean checkProperties(Properties postProp, String url,", "        return checkProperties(convertToMap(postProp), url, method,"], "url": ["public static boolean checkProperties(Properties postProp, String url,", "        return checkProperties(convertToMap(postProp), url, method,"], "method": ["            String method, String oauth_consumer_key, String oauth_consumer_secret) {", "        return checkProperties(convertToMap(postProp), url, method,"], "oauth_consumer_key": ["            String method, String oauth_consumer_key, String oauth_consumer_secret) {", "                oauth_consumer_key, oauth_consumer_secret);"], "oauth_consumer_secret": ["            String method, String oauth_consumer_key, String oauth_consumer_secret) {", "                oauth_consumer_key, oauth_consumer_secret);"]}
{"postProp": ["            Map<String, String> postProp, String url, String method,", "        OAuthMessage oam = new OAuthMessage(method, url, postProp.entrySet());"], "url": ["            Map<String, String> postProp, String url, String method,", "        OAuthMessage oam = new OAuthMessage(method, url, postProp.entrySet());"], "method": ["            Map<String, String> postProp, String url, String method,", "        OAuthMessage oam = new OAuthMessage(method, url, postProp.entrySet());"], "oauth_consumer_key": ["            String oauth_consumer_key, String oauth_consumer_secret) {", "        OAuthConsumer cons = new OAuthConsumer(\"about:blank\", oauth_consumer_key,"], "oauth_consumer_secret": ["            String oauth_consumer_key, String oauth_consumer_secret) {", "                oauth_consumer_secret, null);"]}
{"descriptor": ["public static String prepareForExport(String descriptor) {", "            tm = XMLMap.getFullMap(descriptor.trim());"]}
{"props": ["public static void setProperty(Properties props, String key, String value) {", "        props.setProperty(key, value);"], "key": ["public static void setProperty(Properties props, String key, String value) {", "        props.setProperty(key, value);"], "value": ["public static void setProperty(Properties props, String key, String value) {", "        if (value == null) {", "        if (value.trim().length() < 1) {", "        props.setProperty(key, value);"]}
{"input": ["public static String htmlspecialchars(String input) {", "        if (input == null) {", "        String retval = input.replace(\"&\", \"&amp;\");"]}
{"servletUrl": ["static public String getRealPath(String servletUrl, String extUrl) {", "        String retval = pat.matcher(servletUrl).replaceFirst(extUrl);"], "extUrl": ["static public String getRealPath(String servletUrl, String extUrl) {", "        Matcher m = pat.matcher(extUrl);", "        if (m.find()) {", "            extUrl = m.group(0);", "        String retval = pat.matcher(servletUrl).replaceFirst(extUrl);", "        return retval;"]}
{"request": ["    public LtiVerificationResult verify(HttpServletRequest request, String secret) throws LtiVerificationException {", "        OAuthMessage oam = OAuthServlet.getMessage(request, OAuthServlet.getRequestURL(request));", "            oauth_consumer_key = oam.getConsumerKey();", "            oav.validateMessage(oam, acc);", "        return new LtiVerificationResult(true, new LtiLaunch(request));"], "secret": ["    public LtiVerificationResult verify(HttpServletRequest request, String secret) throws LtiVerificationException {", "        OAuthConsumer cons = new OAuthConsumer(null, oauth_consumer_key, secret, null);"]}
{"parameters": ["    public LtiVerificationResult verifyParameters(Map<String, String> parameters, String url, String method, String secret) throws LtiVerificationException {", "        OAuthMessage oam = new OAuthMessage(method, url, parameters.entrySet());", "        OAuthConsumer cons = new OAuthConsumer(null, parameters.get(OAUTH_KEY_PARAMETER), secret, null);", "            return new LtiVerificationResult(false, LtiError.BAD_REQUEST, \"Failed to validate: \" + e.getLocalizedMessage() + \", Parameters: \" + Arrays.toString(parameters.entrySet().toArray()));", "        return new LtiVerificationResult(true, new LtiLaunch(parameters));"], "url": ["    public LtiVerificationResult verifyParameters(Map<String, String> parameters, String url, String method, String secret) throws LtiVerificationException {", "        OAuthMessage oam = new OAuthMessage(method, url, parameters.entrySet());"], "method": ["    public LtiVerificationResult verifyParameters(Map<String, String> parameters, String url, String method, String secret) throws LtiVerificationException {", "        OAuthMessage oam = new OAuthMessage(method, url, parameters.entrySet());"], "secret": ["    public LtiVerificationResult verifyParameters(Map<String, String> parameters, String url, String method, String secret) throws LtiVerificationException {", "        OAuthConsumer cons = new OAuthConsumer(null, parameters.get(OAUTH_KEY_PARAMETER), secret, null);"]}
{"oauth_consumer_key": ["public void validateRequest(String oauth_consumer_key, String oauth_secret, HttpServletRequest request) ", "\t\tvalidateRequest(oauth_consumer_key, oauth_secret, request, null) ;"], "oauth_secret": ["public void validateRequest(String oauth_consumer_key, String oauth_secret, HttpServletRequest request) ", "\t\tvalidateRequest(oauth_consumer_key, oauth_secret, request, null) ;"], "request": ["public void validateRequest(String oauth_consumer_key, String oauth_secret, HttpServletRequest request) ", "\t\tvalidateRequest(oauth_consumer_key, oauth_secret, request, null) ;"]}
{"request": ["\tprotected void doLaunch(HttpServletRequest request, HttpServletResponse response)", "\t\t\tString settings_url = getServiceURL(request) + SVC_Settings + \"/\";", "\t\t\tlti2subst.setProperty(\"Result.url\", getServiceURL(request) + SVC_Result + \"/\""], "response": ["\tprotected void doLaunch(HttpServletRequest request, HttpServletResponse response)", "\t\tresponse.setContentType(\"text/html\");", "\t\t\tPrintWriter out = response.getWriter();"]}
{"request": ["protected ToolConsumer buildToolConsumerProfile(HttpServletRequest request, Map<String, Object> deploy, String profile_id)", "\t\tToolConsumer consumer = new ToolConsumer(profile_id, \"LTI-2p0\", getServiceURL(request), cnf);", "\t\tservices.add(StandardServices.LTI2Registration(getServiceURL(request) +", "\t\tservices.add(StandardServices.LTI2ResultItem(getServiceURL(request) +", "\t\tservices.add(StandardServices.LTI2LtiLinkSettings(getServiceURL(request) +", "\t\tservices.add(StandardServices.LTI2ToolProxySettings(getServiceURL(request) +", "\t\tservices.add(StandardServices.LTI2ToolProxySettings(getServiceURL(request) +"], "deploy": [], "profile_id": ["protected ToolConsumer buildToolConsumerProfile(HttpServletRequest request, Map<String, Object> deploy, String profile_id)", "\t\tToolConsumer consumer = new ToolConsumer(profile_id, \"LTI-2p0\", getServiceURL(request), cnf);", "\t\t\tSVC_tc_registration + \"/\" + profile_id));"]}
{"consumer": ["public static String validateServices(ToolConsumer consumer, JSONObject providerProfile) ", "\t\t\tList<ServiceOffered> services_offered = consumer.getService_offered();"], "providerProfile": ["public static String validateServices(ToolConsumer consumer, JSONObject providerProfile) ", "\t\t\tJSONObject security_contract = (JSONObject) providerProfile.get(LTI2Constants.SECURITY_CONTRACT);"]}
{"consumer": ["public static String validateCapabilities(ToolConsumer consumer, JSONObject providerProfile) ", "\t\t\tList<String> capabilities = consumer.getCapability_offered();"], "providerProfile": ["public static String validateCapabilities(ToolConsumer consumer, JSONObject providerProfile) ", "\t\t\tString retval = parseToolProfile(theTools, info, providerProfile);", "\t\t\tif ( retval != null )  return retval;"]}
{"ltiProps": ["public static void addCustomToLaunch(Properties ltiProps, Properties custom) ", "            setProperty(ltiProps,\"custom_\"+keyStr,value);"], "custom": ["public static void addCustomToLaunch(Properties ltiProps, Properties custom) ", "        Enumeration<?> e = custom.propertyNames();", "            String value =  custom.getProperty(keyStr);", "            setProperty(ltiProps,\"custom_\"+keyStr,value);"]}
{"v": ["private void toogleListView(View v) {", "        if (mLastViewTouchId != v.getId()) {"]}
{"view": ["    public void onListScroll(View view, float deltaY) {", "        if (view.getId() == mListViewLeft.getId() && !isLeftListEnabled) {", "        } else if (view.getId() == mListViewRight.getId() && !isRightListEnabled) {"], "deltaY": ["    public void onListScroll(View view, float deltaY) {", "            speed = getSpeed(false, deltaY);", "            mListViewRight.smoothScrollBy(speed, 0);", "            speed = getSpeed(true, deltaY);", "            mListViewLeft.smoothScrollBy(speed, 0);"]}
{"url": ["public static SafeUrlProto toProto(SafeUrl url) {", "        .setPrivateDoNotAccessOrElseSafeUrlWrappedValue(url.getSafeUrlString())"]}
{"style": ["public static SafeStyleProto toProto(SafeStyle style) {", "        .setPrivateDoNotAccessOrElseSafeStyleWrappedValue(style.getSafeStyleString()).build();"]}
{"script": ["public static SafeScriptProto toProto(SafeScript script) {", "        .setPrivateDoNotAccessOrElseSafeScriptWrappedValue(script.getSafeScriptString()).build();"]}
{"style": ["public static SafeStyleSheetProto toProto(SafeStyleSheet style) {", "            style.getSafeStyleSheetString())"]}
{"url": ["public static TrustedResourceUrlProto toProto(TrustedResourceUrl url) {", "            url.getTrustedResourceUrlString())"]}
{"safeHtml": ["public static SafeHtmlProto toProto(SafeHtml safeHtml) {", "        safeHtml.getSafeHtmlString()).build();"]}
{"angle": []}
{"input": ["public static double round(double input, int decimals) {", "        return Math.round(input * p) / p;"], "decimals": ["public static double round(double input, int decimals) {", "        final double p = Math.pow(10, decimals);", "        return Math.round(input * p) / p;"]}
{"x": ["public static double lerp(double x, double x1, double x2, double q0, double q1) {", "        return ((x2 - x) / (x2 - x1)) * q0 + ((x - x1) / (x2 - x1)) * q1;"], "x1": ["public static double lerp(double x, double x1, double x2, double q0, double q1) {", "        return ((x2 - x) / (x2 - x1)) * q0 + ((x - x1) / (x2 - x1)) * q1;"], "x2": ["public static double lerp(double x, double x1, double x2, double q0, double q1) {", "        return ((x2 - x) / (x2 - x1)) * q0 + ((x - x1) / (x2 - x1)) * q1;"], "q0": ["public static double lerp(double x, double x1, double x2, double q0, double q1) {", "        return ((x2 - x) / (x2 - x1)) * q0 + ((x - x1) / (x2 - x1)) * q1;"], "q1": ["public static double lerp(double x, double x1, double x2, double q0, double q1) {", "        return ((x2 - x) / (x2 - x1)) * q0 + ((x - x1) / (x2 - x1)) * q1;"]}
{"a": ["public static Quaternionf slerp(Quaternionf a, Quaternionf b, float percent) {", "        float cosineTheta = a.dot(b);", "            return a.mul(1 - percent).add(b.mul(percent * inverted));", "        return a.mul(coefficient1).add(b.mul(coefficient2));"], "b": ["public static Quaternionf slerp(Quaternionf a, Quaternionf b, float percent) {", "        float cosineTheta = a.dot(b);", "        if (cosineTheta < 0) {", "            cosineTheta = -cosineTheta;", "        if (1 - cosineTheta < GenericMath.FLT_EPSILON) {", "            return a.mul(1 - percent).add(b.mul(percent * inverted));", "        final float theta = (float) TrigMath.acos(cosineTheta);", "        final float sineTheta = TrigMath.sin(theta);", "        final float coefficient1 = TrigMath.sin((1 - percent) * theta) / sineTheta;", "        final float coefficient2 = TrigMath.sin(percent * theta) / sineTheta * inverted;", "        return a.mul(coefficient1).add(b.mul(coefficient2));"], "percent": ["public static Quaternionf slerp(Quaternionf a, Quaternionf b, float percent) {", "            return a.mul(1 - percent).add(b.mul(percent * inverted));", "        final float coefficient1 = TrigMath.sin((1 - percent) * theta) / sineTheta;", "        final float coefficient2 = TrigMath.sin(percent * theta) / sineTheta * inverted;"]}
{"x": ["public static double biLerp(double x, double y, double q00, double q01,", "        double q0 = lerp(x, x1, x2, q00, q10);", "        double q1 = lerp(x, x1, x2, q01, q11);"], "y": ["public static double biLerp(double x, double y, double q00, double q01,", "        return lerp(y, y1, y2, q0, q1);"], "q00": ["public static double biLerp(double x, double y, double q00, double q01,", "        double q0 = lerp(x, x1, x2, q00, q10);"], "q01": ["public static double biLerp(double x, double y, double q00, double q01,", "        double q1 = lerp(x, x1, x2, q01, q11);"], "q10": ["                                double q10, double q11, double x1, double x2, double y1, double y2) {", "        double q0 = lerp(x, x1, x2, q00, q10);", "        return lerp(y, y1, y2, q0, q1);"], "q11": ["                                double q10, double q11, double x1, double x2, double y1, double y2) {", "        double q1 = lerp(x, x1, x2, q01, q11);", "        return lerp(y, y1, y2, q0, q1);"], "x1": ["                                double q10, double q11, double x1, double x2, double y1, double y2) {", "        double q0 = lerp(x, x1, x2, q00, q10);", "        double q1 = lerp(x, x1, x2, q01, q11);"], "x2": ["                                double q10, double q11, double x1, double x2, double y1, double y2) {", "        double q0 = lerp(x, x1, x2, q00, q10);", "        double q1 = lerp(x, x1, x2, q01, q11);"], "y1": ["                                double q10, double q11, double x1, double x2, double y1, double y2) {", "        return lerp(y, y1, y2, q0, q1);"], "y2": ["                                double q10, double q11, double x1, double x2, double y1, double y2) {", "        return lerp(y, y1, y2, q0, q1);"]}
{"x": ["public static double triLerp(double x, double y, double z, double q000, double q001,", "        double q00 = lerp(x, x1, x2, q000, q100);", "        double q01 = lerp(x, x1, x2, q010, q110);", "        double q10 = lerp(x, x1, x2, q001, q101);", "        double q11 = lerp(x, x1, x2, q011, q111);"], "y": ["public static double triLerp(double x, double y, double z, double q000, double q001,", "        double q0 = lerp(y, y1, y2, q00, q10);", "        double q1 = lerp(y, y1, y2, q01, q11);"], "z": ["public static double triLerp(double x, double y, double z, double q000, double q001,", "        return lerp(z, z1, z2, q0, q1);"], "q000": ["public static double triLerp(double x, double y, double z, double q000, double q001,", "        double q00 = lerp(x, x1, x2, q000, q100);"], "q001": ["public static double triLerp(double x, double y, double z, double q000, double q001,", "        double q10 = lerp(x, x1, x2, q001, q101);"], "q010": ["                                 double q010, double q011, double q100, double q101, double q110, double q111,", "        double q01 = lerp(x, x1, x2, q010, q110);"], "q011": ["                                 double q010, double q011, double q100, double q101, double q110, double q111,", "        double q11 = lerp(x, x1, x2, q011, q111);"], "q100": ["                                 double q010, double q011, double q100, double q101, double q110, double q111,", "        double q00 = lerp(x, x1, x2, q000, q100);", "        double q0 = lerp(y, y1, y2, q00, q10);"], "q101": ["                                 double q010, double q011, double q100, double q101, double q110, double q111,", "        double q10 = lerp(x, x1, x2, q001, q101);", "        double q0 = lerp(y, y1, y2, q00, q10);", "        return lerp(z, z1, z2, q0, q1);"], "q110": ["                                 double q010, double q011, double q100, double q101, double q110, double q111,", "        double q01 = lerp(x, x1, x2, q010, q110);", "        double q1 = lerp(y, y1, y2, q01, q11);"], "q111": ["                                 double q010, double q011, double q100, double q101, double q110, double q111,", "        double q11 = lerp(x, x1, x2, q011, q111);", "        double q1 = lerp(y, y1, y2, q01, q11);", "        return lerp(z, z1, z2, q0, q1);"], "x1": ["                                 double x1, double x2, double y1, double y2, double z1, double z2) {", "        double q00 = lerp(x, x1, x2, q000, q100);", "        double q01 = lerp(x, x1, x2, q010, q110);", "        double q10 = lerp(x, x1, x2, q001, q101);", "        double q11 = lerp(x, x1, x2, q011, q111);"], "x2": ["                                 double x1, double x2, double y1, double y2, double z1, double z2) {", "        double q00 = lerp(x, x1, x2, q000, q100);", "        double q01 = lerp(x, x1, x2, q010, q110);", "        double q10 = lerp(x, x1, x2, q001, q101);", "        double q11 = lerp(x, x1, x2, q011, q111);"], "y1": ["                                 double x1, double x2, double y1, double y2, double z1, double z2) {", "        double q0 = lerp(y, y1, y2, q00, q10);", "        double q1 = lerp(y, y1, y2, q01, q11);"], "y2": ["                                 double x1, double x2, double y1, double y2, double z1, double z2) {", "        double q0 = lerp(y, y1, y2, q00, q10);", "        double q1 = lerp(y, y1, y2, q01, q11);"], "z1": ["                                 double x1, double x2, double y1, double y2, double z1, double z2) {", "        return lerp(z, z1, z2, q0, q1);"], "z2": ["                                 double x1, double x2, double y1, double y2, double z1, double z2) {", "        return lerp(z, z1, z2, q0, q1);"]}
{"a": ["public static Color blend(Color a, Color b) {", "        return lerp(a, b, a.getAlpha() / 255f);"], "b": ["public static Color blend(Color a, Color b) {", "        return lerp(a, b, a.getAlpha() / 255f);"]}
{"value": ["public static double clamp(double value, double low, double high) {", "        if (value < low) {", "        if (value > high) {", "        return value;"], "low": ["public static double clamp(double value, double low, double high) {", "        if (value < low) {", "            return low;"], "high": ["public static double clamp(double value, double low, double high) {", "        if (value > high) {", "            return high;"]}
{"a": ["public static double inverseSqrt(double a) {", "        final double halfA = 0.5d * a;", "        a = Double.longBitsToDouble(0x5FE6EB50C7B537AAl - (Double.doubleToRawLongBits(a) >> 1));", "        return a * (1.5d - halfA * a * a);"]}
{"o": ["public static Float castFloat(Object o) {", "        if (o == null) {", "        if (o instanceof Number) {", "            return ((Number) o).floatValue();", "            return Float.valueOf(o.toString());"]}
{"o": ["public static Byte castByte(Object o) {", "        if (o == null) {", "        if (o instanceof Number) {", "            return ((Number) o).byteValue();", "            return Byte.valueOf(o.toString());"]}
{"o": ["public static Short castShort(Object o) {", "        if (o == null) {", "        if (o instanceof Number) {", "            return ((Number) o).shortValue();", "            return Short.valueOf(o.toString());"]}
{"o": ["public static Integer castInt(Object o) {", "        if (o == null) {", "        if (o instanceof Number) {", "            return ((Number) o).intValue();", "            return Integer.valueOf(o.toString());"]}
{"o": ["public static Double castDouble(Object o) {", "        if (o == null) {", "        if (o instanceof Number) {", "            return ((Number) o).doubleValue();", "            return Double.valueOf(o.toString());"]}
{"o": ["public static Long castLong(Object o) {", "        if (o == null) {", "        if (o instanceof Number) {", "            return ((Number) o).longValue();", "            return Long.valueOf(o.toString());"]}
{"o": ["public static Boolean castBoolean(Object o) {", "        if (o == null) {", "        if (o instanceof Boolean) {", "            return (Boolean) o;", "        } else if (o instanceof String) {", "                return Boolean.parseBoolean((String) o);"]}
{"Result": "Method without Parameter"}
{"a": ["public static double mod(double a, double div) {", "        final double remainder = a % div;"], "div": ["public static double mod(double a, double div) {", "        final double remainder = a % div;", "        return remainder < 0 ? remainder + div : remainder;"]}
{"a": ["public static int multiplyToShift(int a) {", "        if (a < 1) {", "        int shift = 31 - Integer.numberOfLeadingZeros(a);", "        if ((1 << shift) != a) {", "        return shift;"]}
{"a": ["    public Quaterniond mul(double a) {", "        return new Quaterniond(x * a, y * a, z * a, w * a);"]}
{"a": ["    public Quaterniond div(double a) {", "        return new Quaterniond(x / a, y / a, z / a, w / a);"]}
{"x": ["public Vector3d rotate(double x, double y, double z) {", "        final double nx = this.x / length;", "        final double px = nw * x + ny * z - nz * y;", "        final double py = nw * y + nz * x - nx * z;", "        final double pz = nw * z + nx * y - ny * x;", "        final double pw = -nx * x - ny * y - nz * z;", "                pw * -nx + px * nw - py * nz + pz * ny,", "                pw * -ny + py * nw - pz * nx + px * nz,", "                pw * -nz + pz * nw - px * ny + py * nx);"], "y": ["public Vector3d rotate(double x, double y, double z) {", "        final double ny = this.y / length;", "        final double px = nw * x + ny * z - nz * y;", "        final double py = nw * y + nz * x - nx * z;", "        final double pz = nw * z + nx * y - ny * x;", "        final double pw = -nx * x - ny * y - nz * z;", "                pw * -nx + px * nw - py * nz + pz * ny,", "                pw * -ny + py * nw - pz * nx + px * nz,", "                pw * -nz + pz * nw - px * ny + py * nx);"], "z": ["public Vector3d rotate(double x, double y, double z) {", "        final double nz = this.z / length;", "        final double px = nw * x + ny * z - nz * y;", "        final double py = nw * y + nz * x - nx * z;", "        final double pz = nw * z + nx * y - ny * x;", "        final double pw = -nx * x - ny * y - nz * z;", "                pw * -nx + px * nw - py * nz + pz * ny,", "                pw * -ny + py * nw - pz * nx + px * nz,", "                pw * -nz + pz * nw - px * ny + py * nx);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"x": ["public static Quaterniond fromImaginary(double x, double y, double z) {", "         return x == 0 && y == 0 && z == 0 ? ZERO : new Quaterniond(x, y, z, 0);"], "y": ["public static Quaterniond fromImaginary(double x, double y, double z) {", "         return x == 0 && y == 0 && z == 0 ? ZERO : new Quaterniond(x, y, z, 0);"], "z": ["public static Quaterniond fromImaginary(double x, double y, double z) {", "         return x == 0 && y == 0 && z == 0 ? ZERO : new Quaterniond(x, y, z, 0);"]}
{"x": ["public static Quaterniond from(double x, double y, double z, double w) {", "         return x == 0 && y == 0 && z == 0 && w == 0 ? ZERO : new Quaterniond(x, y, z, w);"], "y": ["public static Quaterniond from(double x, double y, double z, double w) {", "         return x == 0 && y == 0 && z == 0 && w == 0 ? ZERO : new Quaterniond(x, y, z, w);"], "z": ["public static Quaterniond from(double x, double y, double z, double w) {", "         return x == 0 && y == 0 && z == 0 && w == 0 ? ZERO : new Quaterniond(x, y, z, w);"], "w": ["public static Quaterniond from(double x, double y, double z, double w) {", "         return x == 0 && y == 0 && z == 0 && w == 0 ? ZERO : new Quaterniond(x, y, z, w);"]}
{"pitch": ["public static Quaterniond fromAxesAnglesDeg(double pitch, double yaw, double roll) {", "                mul(Quaterniond.fromAngleDegAxis(pitch, Vector3d.UNIT_X))."], "yaw": ["public static Quaterniond fromAxesAnglesDeg(double pitch, double yaw, double roll) {", "        return Quaterniond.fromAngleDegAxis(yaw, Vector3d.UNIT_Y)."], "roll": ["public static Quaterniond fromAxesAnglesDeg(double pitch, double yaw, double roll) {", "                mul(Quaterniond.fromAngleDegAxis(roll, Vector3d.UNIT_Z));"]}
{"pitch": ["public static Quaterniond fromAxesAnglesRad(double pitch, double yaw, double roll) {", "                mul(Quaterniond.fromAngleRadAxis(pitch, Vector3d.UNIT_X))."], "yaw": ["public static Quaterniond fromAxesAnglesRad(double pitch, double yaw, double roll) {", "        return Quaterniond.fromAngleRadAxis(yaw, Vector3d.UNIT_Y)."], "roll": ["public static Quaterniond fromAxesAnglesRad(double pitch, double yaw, double roll) {", "                mul(Quaterniond.fromAngleRadAxis(roll, Vector3d.UNIT_Z));"]}
{"angle": ["public static Quaterniond fromAngleRadAxis(double angle, Vector3d axis) {", "        return fromAngleRadAxis(angle, axis.getX(), axis.getY(), axis.getZ());"], "axis": ["public static Quaterniond fromAngleRadAxis(double angle, Vector3d axis) {", "        return fromAngleRadAxis(angle, axis.getX(), axis.getY(), axis.getZ());"]}
{"angle": ["public static Quaterniond fromAngleDegAxis(float angle, float x, float y, float z) {", "        return fromAngleRadAxis(Math.toRadians(angle), x, y, z);"], "x": ["public static Quaterniond fromAngleDegAxis(float angle, float x, float y, float z) {", "        return fromAngleRadAxis(Math.toRadians(angle), x, y, z);"], "y": ["public static Quaterniond fromAngleDegAxis(float angle, float x, float y, float z) {", "        return fromAngleRadAxis(Math.toRadians(angle), x, y, z);"], "z": ["public static Quaterniond fromAngleDegAxis(float angle, float x, float y, float z) {", "        return fromAngleRadAxis(Math.toRadians(angle), x, y, z);"]}
{"Result": "Method without Parameter"}
{"x": ["public Complexf mul(float x, float y) {", "                this.x * x - this.y * y,", "                this.x * y + this.y * x);"], "y": ["public Complexf mul(float x, float y) {", "                this.x * x - this.y * y,", "                this.x * y + this.y * x);"]}
{"x": ["public Complexf div(float x, float y) {", "        final float d = x * x + y * y;", "                (this.x * x + this.y * y) / d,", "                (this.y * x - this.x * y) / d);"], "y": ["public Complexf div(float x, float y) {", "        final float d = x * x + y * y;", "                (this.x * x + this.y * y) / d,", "                (this.y * x - this.x * y) / d);"]}
{"x": ["public Vector2f rotate(float x, float y) {", "        final float nx = this.x / length;", "        return new Vector2f(x * nx - y * ny, y * nx + x * ny);"], "y": ["public Vector2f rotate(float x, float y) {", "        final float ny = this.y / length;", "        return new Vector2f(x * nx - y * ny, y * nx + x * ny);"]}
{"Result": "Method without Parameter"}
{"x": ["public Quaternionf toQuaternion(float x, float y, float z) {", "        return Quaternionf.fromAngleRadAxis(getAngleRad(), x, y, z);"], "y": ["public Quaternionf toQuaternion(float x, float y, float z) {", "        return Quaternionf.fromAngleRadAxis(getAngleRad(), x, y, z);"], "z": ["public Quaternionf toQuaternion(float x, float y, float z) {", "        return Quaternionf.fromAngleRadAxis(getAngleRad(), x, y, z);"]}
{"x": ["public static Complexf from(float x, float y) {", "         return x == 0 && y == 0 ? ZERO : new Complexf(x, y);"], "y": ["public static Complexf from(float x, float y) {", "         return x == 0 && y == 0 ? ZERO : new Complexf(x, y);"]}
{"angle": ["public static Complexf fromAngleRad(float angle) {", "        return new Complexf(TrigMath.cos(angle), TrigMath.sin(angle));"]}
{"Result": "Method without Parameter"}
{"value": ["public static int hash(double value) {", "        assert !Double.isNaN(value) : \"Values of NaN are not supported.\";", "        long bits = Double.doubleToLongBits(value);", "        return (int) (bits ^ (bits >>> 32));"]}
{"x": ["public Quaternionf add(float x, float y, float z, float w) {", "        return new Quaternionf(this.x + x, this.y + y, this.z + z, this.w + w);"], "y": ["public Quaternionf add(float x, float y, float z, float w) {", "        return new Quaternionf(this.x + x, this.y + y, this.z + z, this.w + w);"], "z": ["public Quaternionf add(float x, float y, float z, float w) {", "        return new Quaternionf(this.x + x, this.y + y, this.z + z, this.w + w);"], "w": ["public Quaternionf add(float x, float y, float z, float w) {", "        return new Quaternionf(this.x + x, this.y + y, this.z + z, this.w + w);"]}
{"a": ["    public Quaternionf mul(float a) {", "        return new Quaternionf(x * a, y * a, z * a, w * a);"]}
{"a": ["    public Quaternionf div(float a) {", "        return new Quaternionf(x / a, y / a, z / a, w / a);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"x": ["public static Quaternionf fromImaginary(float x, float y, float z) {", "         return x == 0 && y == 0 && z == 0 ? ZERO : new Quaternionf(x, y, z, 0);"], "y": ["public static Quaternionf fromImaginary(float x, float y, float z) {", "         return x == 0 && y == 0 && z == 0 ? ZERO : new Quaternionf(x, y, z, 0);"], "z": ["public static Quaternionf fromImaginary(float x, float y, float z) {", "         return x == 0 && y == 0 && z == 0 ? ZERO : new Quaternionf(x, y, z, 0);"]}
{"x": ["public static Quaternionf from(float x, float y, float z, float w) {", "         return x == 0 && y == 0 && z == 0 && w == 0 ? ZERO : new Quaternionf(x, y, z, w);"], "y": ["public static Quaternionf from(float x, float y, float z, float w) {", "         return x == 0 && y == 0 && z == 0 && w == 0 ? ZERO : new Quaternionf(x, y, z, w);"], "z": ["public static Quaternionf from(float x, float y, float z, float w) {", "         return x == 0 && y == 0 && z == 0 && w == 0 ? ZERO : new Quaternionf(x, y, z, w);"], "w": ["public static Quaternionf from(float x, float y, float z, float w) {", "         return x == 0 && y == 0 && z == 0 && w == 0 ? ZERO : new Quaternionf(x, y, z, w);"]}
{"pitch": ["public static Quaternionf fromAxesAnglesDeg(float pitch, float yaw, float roll) {", "                mul(Quaternionf.fromAngleDegAxis(pitch, Vector3f.UNIT_X))."], "yaw": ["public static Quaternionf fromAxesAnglesDeg(float pitch, float yaw, float roll) {", "        return Quaternionf.fromAngleDegAxis(yaw, Vector3f.UNIT_Y)."], "roll": ["public static Quaternionf fromAxesAnglesDeg(float pitch, float yaw, float roll) {", "                mul(Quaternionf.fromAngleDegAxis(roll, Vector3f.UNIT_Z));"]}
{"pitch": ["public static Quaternionf fromAxesAnglesRad(float pitch, float yaw, float roll) {", "                mul(Quaternionf.fromAngleRadAxis(pitch, Vector3f.UNIT_X))."], "yaw": ["public static Quaternionf fromAxesAnglesRad(float pitch, float yaw, float roll) {", "        return Quaternionf.fromAngleRadAxis(yaw, Vector3f.UNIT_Y)."], "roll": ["public static Quaternionf fromAxesAnglesRad(float pitch, float yaw, float roll) {", "                mul(Quaternionf.fromAngleRadAxis(roll, Vector3f.UNIT_Z));"]}
{"angle": ["public static Quaternionf fromAngleRadAxis(float angle, Vector3f axis) {", "        return fromAngleRadAxis(angle, axis.getX(), axis.getY(), axis.getZ());"], "axis": ["public static Quaternionf fromAngleRadAxis(float angle, Vector3f axis) {", "        return fromAngleRadAxis(angle, axis.getX(), axis.getY(), axis.getZ());"]}
{"angle": ["public static Quaternionf fromAngleRadAxis(double angle, double x, double y, double z) {", "        return fromAngleRadAxis((float) angle, (float) x, (float) y, (float) z);"], "x": ["public static Quaternionf fromAngleRadAxis(double angle, double x, double y, double z) {", "        return fromAngleRadAxis((float) angle, (float) x, (float) y, (float) z);"], "y": ["public static Quaternionf fromAngleRadAxis(double angle, double x, double y, double z) {", "        return fromAngleRadAxis((float) angle, (float) x, (float) y, (float) z);"], "z": ["public static Quaternionf fromAngleRadAxis(double angle, double x, double y, double z) {", "        return fromAngleRadAxis((float) angle, (float) x, (float) y, (float) z);"]}
{"x": ["public Complexd mul(double x, double y) {", "                this.x * x - this.y * y,", "                this.x * y + this.y * x);"], "y": ["public Complexd mul(double x, double y) {", "                this.x * x - this.y * y,", "                this.x * y + this.y * x);"]}
{"x": ["public Complexd div(double x, double y) {", "        final double d = x * x + y * y;", "                (this.x * x + this.y * y) / d,", "                (this.y * x - this.x * y) / d);"], "y": ["public Complexd div(double x, double y) {", "        final double d = x * x + y * y;", "                (this.x * x + this.y * y) / d,", "                (this.y * x - this.x * y) / d);"]}
{"x": ["public Vector2d rotate(double x, double y) {", "        final double nx = this.x / length;", "        return new Vector2d(x * nx - y * ny, y * nx + x * ny);"], "y": ["public Vector2d rotate(double x, double y) {", "        final double ny = this.y / length;", "        return new Vector2d(x * nx - y * ny, y * nx + x * ny);"]}
{"x": ["public Quaterniond toQuaternion(double x, double y, double z) {", "        return Quaterniond.fromAngleRadAxis(getAngleRad(), x, y, z);"], "y": ["public Quaterniond toQuaternion(double x, double y, double z) {", "        return Quaterniond.fromAngleRadAxis(getAngleRad(), x, y, z);"], "z": ["public Quaterniond toQuaternion(double x, double y, double z) {", "        return Quaterniond.fromAngleRadAxis(getAngleRad(), x, y, z);"]}
{"x": ["public static Complexd from(double x, double y) {", "         return x == 0 && y == 0 ? ZERO : new Complexd(x, y);"], "y": ["public static Complexd from(double x, double y) {", "         return x == 0 && y == 0 ? ZERO : new Complexd(x, y);"]}
{"angle": ["public static Complexd fromAngleRad(double angle) {", "        return new Complexd(TrigMath.cos(angle), TrigMath.sin(angle));"]}
{"pChildView": ["public void moveChildView(View pChildView, float pScale_Left, float pScale_Top) {", "        ScalableLayout.LayoutParams lSLLP = getChildLayoutParams(pChildView);"], "pScale_Left": ["public void moveChildView(View pChildView, float pScale_Left, float pScale_Top) {", "        lSLLP.mScale_Left = pScale_Left;"], "pScale_Top": ["public void moveChildView(View pChildView, float pScale_Left, float pScale_Top) {", "        lSLLP.mScale_Top = pScale_Top;"]}
{"pChildView": ["public void moveChildView(View pChildView, float pScale_Left, float pScale_Top, float pScale_Width, float pScale_Height) {", "        ScalableLayout.LayoutParams lSLLP = getChildLayoutParams(pChildView);"], "pScale_Left": ["public void moveChildView(View pChildView, float pScale_Left, float pScale_Top, float pScale_Width, float pScale_Height) {", "        lSLLP.mScale_Left = pScale_Left;"], "pScale_Top": ["public void moveChildView(View pChildView, float pScale_Left, float pScale_Top, float pScale_Width, float pScale_Height) {", "        lSLLP.mScale_Top = pScale_Top;"], "pScale_Width": ["public void moveChildView(View pChildView, float pScale_Left, float pScale_Top, float pScale_Width, float pScale_Height) {", "        lSLLP.mScale_Width = pScale_Width;"], "pScale_Height": ["public void moveChildView(View pChildView, float pScale_Left, float pScale_Top, float pScale_Width, float pScale_Height) {", "        lSLLP.mScale_Height = pScale_Height;"]}
{"builder": ["private static void setBlockSpan(SpannableStringBuilder builder, Object what) {", "\t\tint length = Math.max(0, builder.length() - 1);", "\t\tbuilder.setSpan(what, 0, length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);"], "what": ["private static void setBlockSpan(SpannableStringBuilder builder, Object what) {", "\t\tbuilder.setSpan(what, 0, length, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);"]}
{"typeSolver": ["public BoundSet reduce(TypeSolver typeSolver) {", "            boundSet.incorporate(reductionResult.getBoundSet(), typeSolver);"]}
{"transformer": ["    public ResolvedType transformTypeParameters(ResolvedTypeTransformer transformer) {", "            ResolvedType transformedTp = transformer.transform(tp);", "            if (transformedTp != tp) {", "                typeParametersCorrected.set(i, transformedTp);"]}
{"symbolDeclaration": ["public static <S extends ResolvedDeclaration, S2 extends S> SymbolReference<S> solved(S2 symbolDeclaration) {", "        return new SymbolReference<S>(Optional.of(symbolDeclaration));"]}
{"clazz": []}
{"type": ["public static boolean isProperType(ResolvedType type) {", "        if (type instanceof InferenceVariable) {", "        if (type instanceof ResolvedReferenceType) {", "            ResolvedReferenceType referenceType = (ResolvedReferenceType) type;", "            return referenceType.typeParametersValues().stream().allMatch(it -> isProperType(it));", "        if (type instanceof ResolvedWildcard) {", "            ResolvedWildcard wildcard = (ResolvedWildcard)type;", "            if (wildcard.isBounded()) {", "                return isProperType(wildcard.getBoundedType());", "        if (type.isPrimitive()) {", "        if (type.isTypeVariable()) {", "        if (type.isArray()) {", "            return isProperType(type.asArrayType().getComponentType());", "        throw new UnsupportedOperationException(type.toString());"]}
{"types": ["public static ResolvedType leastUpperBound(Set<ResolvedType> types) {", "        if (types.size() == 0) {", "        if (types.size() == 1) {", "            return types.stream().findFirst().get();"]}
{"lambdaExpr": ["public static Pair<ResolvedType, Boolean> groundTargetTypeOfLambda(LambdaExpr lambdaExpr, ResolvedType T, TypeSolver typeSolver) {", "            if (ExpressionHelper.isExplicitlyTyped(lambdaExpr)) {"], "T": ["public static Pair<ResolvedType, Boolean> groundTargetTypeOfLambda(LambdaExpr lambdaExpr, ResolvedType T, TypeSolver typeSolver) {", "        boolean wildcardParameterized = T.asReferenceType().typeParametersValues().stream()", "                return new Pair<>(nonWildcardParameterizationOf(T.asReferenceType(), typeSolver), used18_5_3);", "        return new Pair<>(T, used18_5_3);"], "typeSolver": ["public static Pair<ResolvedType, Boolean> groundTargetTypeOfLambda(LambdaExpr lambdaExpr, ResolvedType T, TypeSolver typeSolver) {", "                return new Pair<>(nonWildcardParameterizationOf(T.asReferenceType(), typeSolver), used18_5_3);"]}
{"originalType": ["private static ResolvedReferenceType nonWildcardParameterizationOf(ResolvedReferenceType originalType, TypeSolver typeSolver) {", "        List<ResolvedType> AIs = originalType.typeParametersValues();", "        List<ResolvedTypeParameterDeclaration> TPs = originalType.getTypeDeclaration().getTypeParameters();", "            if (Ti == null && Ai.isWildcard() && Ai.asWildcard().mention(originalType.getTypeDeclaration().getTypeParameters())) {", "        return new ReferenceTypeImpl(originalType.getTypeDeclaration(), TIs, typeSolver);"], "typeSolver": ["private static ResolvedReferenceType nonWildcardParameterizationOf(ResolvedReferenceType originalType, TypeSolver typeSolver) {", "        ResolvedReferenceType object = new ReferenceTypeImpl(typeSolver.solveType(Object.class.getCanonicalName()), typeSolver);", "                ResolvedType Bi = TPs.get(i).hasLowerBound() ? TPs.get(i).getLowerBound() : object;", "                    Ti = Bi;", "                    Ti = glb(new HashSet<>(Arrays.asList(Ui, Bi)));", "            TIs.add(Ti);", "        return new ReferenceTypeImpl(originalType.getTypeDeclaration(), TIs, typeSolver);"]}
{"types": ["public static ResolvedType glb(Set<ResolvedType> types) {", "        if (types.size() == 0) {", "        if (types.size() == 1) {", "            return types.iterator().next();", "        return new ResolvedIntersectionType(types);"]}
{"parentType": ["private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {", "        if (parentType.hasField(node.getName().getId())) {", "            return parentType.getField(node.getName().getId()).getType();", "        } else if (parentType.hasInternalType(node.getName().getId())) {", "            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()), typeSolver);"], "node": ["private ResolvedType solveDotExpressionType(ResolvedReferenceTypeDeclaration parentType, FieldAccessExpr node) {", "        if (parentType.hasField(node.getName().getId())) {", "            return parentType.getField(node.getName().getId()).getType();", "        } else if (parentType.hasInternalType(node.getName().getId())) {", "            return new ReferenceTypeImpl(parentType.getInternalType(node.getName().getId()), typeSolver);", "            throw new UnsolvedSymbolException(node.getName().getId());"]}
{"objectCreationExpr": ["public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {", "        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);", "        ResolvedType classDecl = JavaParserFacade.get(typeSolver).convert(objectCreationExpr.getType(), objectCreationExpr);", "        if (!classDecl.isReferenceType()) {", "        SymbolReference<ResolvedConstructorDeclaration> res = ConstructorResolutionLogic.findMostApplicable(((ResolvedClassDeclaration) classDecl.asReferenceType().getTypeDeclaration()).getConstructors(), argumentTypes, typeSolver);"], "solveLambdas": ["public SymbolReference<ResolvedConstructorDeclaration> solve(ObjectCreationExpr objectCreationExpr, boolean solveLambdas) {", "        solveArguments(objectCreationExpr, objectCreationExpr.getArguments(), solveLambdas, argumentTypes, placeholders);"]}
{"methodCallExpr": ["public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {", "        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);", "        SymbolReference<ResolvedMethodDeclaration> res = JavaParserFactory.getContext(methodCallExpr, typeSolver).solveMethod(methodCallExpr.getName().getId(), argumentTypes, false, typeSolver);"], "solveLambdas": ["public SymbolReference<ResolvedMethodDeclaration> solve(MethodCallExpr methodCallExpr, boolean solveLambdas) {", "        solveArguments(methodCallExpr, methodCallExpr.getArguments(), solveLambdas, argumentTypes, placeholders);"]}
{"map": ["private Optional<ResolvedType> find(Map<Node, ResolvedType> map, LambdaExpr lambdaExpr) {", "        for (Node key : map.keySet()) {", "            if (key instanceof LambdaExpr) {", "                LambdaExpr keyLambdaExpr = (LambdaExpr) key;", "                if (keyLambdaExpr.toString().equals(lambdaExpr.toString()) && getParentNode(keyLambdaExpr) == getParentNode(lambdaExpr)) {", "                    return Optional.of(map.get(keyLambdaExpr));"], "lambdaExpr": ["private Optional<ResolvedType> find(Map<Node, ResolvedType> map, LambdaExpr lambdaExpr) {", "                if (keyLambdaExpr.toString().equals(lambdaExpr.toString()) && getParentNode(keyLambdaExpr) == getParentNode(lambdaExpr)) {"]}
{"classOrInterfaceType": ["private String qName(ClassOrInterfaceType classOrInterfaceType) {", "        String name = classOrInterfaceType.getName().getId();", "        if (classOrInterfaceType.getScope().isPresent()) {", "            return qName(classOrInterfaceType.getScope().get()) + \".\" + name;"]}
{"node": ["public ResolvedType getTypeOfThisIn(Node node) {", "        if (node instanceof ClassOrInterfaceDeclaration) {", "            return new ReferenceTypeImpl(getTypeDeclaration((ClassOrInterfaceDeclaration) node), typeSolver);", "        } else if (node instanceof EnumDeclaration) {", "            JavaParserEnumDeclaration enumDeclaration = new JavaParserEnumDeclaration((EnumDeclaration) node, typeSolver);", "        } else if (node instanceof ObjectCreationExpr && ((ObjectCreationExpr) node).getAnonymousClassBody().isPresent()) {", "            JavaParserAnonymousClassDeclaration anonymousDeclaration = new JavaParserAnonymousClassDeclaration((ObjectCreationExpr) node, typeSolver);", "            return getTypeOfThisIn(getParentNode(node));"]}
{"breakStmt": ["public boolean exitTheStatement(BreakStmt breakStmt) {", "        if (!isReachable(breakStmt)) {", "        Statement breakTarget = breakTarget(breakStmt);", "        for (TryStmt tryStmt : containedTryStmts(breakTarget)) {", "            if (contains(tryStmt.getTryBlock(), breakStmt)) {", "                if (!tryStmt.getFinallyBlock().isPresent() && !canCompleteNormally(tryStmt.getFinallyBlock().get())) {"]}
{"statement": ["public boolean canCompleteNormally(Statement statement) {", "        if (!isReachable(statement)) {", "                if (n.isEmpty() && !parentIs(statement, SwitchStmt.class)) {", "                    return isReachable(statement);", "                if (!n.isEmpty() && !parentIs(statement, SwitchStmt.class)) {", "        return statement.accept(visitor, null);"]}
{"typeDeclaration": ["    public SymbolReference<ResolvedTypeDeclaration> solveTypeInType(ResolvedTypeDeclaration typeDeclaration, String name) {", "        if (typeDeclaration instanceof JavaParserClassDeclaration) {", "            return ((JavaParserClassDeclaration) typeDeclaration).solveType(name, typeSolver);", "        if (typeDeclaration instanceof JavaParserInterfaceDeclaration) {", "            return ((JavaParserInterfaceDeclaration) typeDeclaration).solveType(name, typeSolver);"], "name": ["    public SymbolReference<ResolvedTypeDeclaration> solveTypeInType(ResolvedTypeDeclaration typeDeclaration, String name) {", "            return ((JavaParserClassDeclaration) typeDeclaration).solveType(name, typeSolver);", "            return ((JavaParserInterfaceDeclaration) typeDeclaration).solveType(name, typeSolver);"]}
{"typeDeclaration": ["public static SymbolReference<ResolvedMethodDeclaration> solveMethodInType(ResolvedTypeDeclaration typeDeclaration,", "        if (typeDeclaration instanceof JavaParserClassDeclaration) {", "            Context ctx = ((JavaParserClassDeclaration) typeDeclaration).getContext();", "        if (typeDeclaration instanceof JavaParserInterfaceDeclaration) {", "            Context ctx = ((JavaParserInterfaceDeclaration) typeDeclaration).getContext();", "        if (typeDeclaration instanceof JavaParserEnumDeclaration) {", "                return SymbolReference.solved(new JavaParserEnumDeclaration.ValuesMethod((JavaParserEnumDeclaration) typeDeclaration, typeSolver));", "            Context ctx = ((JavaParserEnumDeclaration) typeDeclaration).getContext();", "        if (typeDeclaration instanceof JavaParserAnonymousClassDeclaration) {", "        \tContext ctx = ((JavaParserAnonymousClassDeclaration) typeDeclaration).getContext();", "        if (typeDeclaration instanceof ReflectionClassDeclaration) {", "            return ((ReflectionClassDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "        if (typeDeclaration instanceof ReflectionInterfaceDeclaration) {", "          return ((ReflectionInterfaceDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "          if (typeDeclaration instanceof ReflectionEnumDeclaration) {", "            return ((ReflectionEnumDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "        if (typeDeclaration instanceof JavassistInterfaceDeclaration) {", "            return ((JavassistInterfaceDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "        if (typeDeclaration instanceof JavassistClassDeclaration) {", "          return ((JavassistClassDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "          if (typeDeclaration instanceof JavassistEnumDeclaration) {", "            return ((JavassistEnumDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "        throw new UnsupportedOperationException(typeDeclaration.getClass().getCanonicalName());"], "name": ["                                                                               String name, List<ResolvedType> argumentsTypes, boolean staticOnly,", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            if (name.equals(\"values\") && argumentsTypes.isEmpty()) {", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            return ((ReflectionClassDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "          return ((ReflectionInterfaceDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "            return ((ReflectionEnumDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "            return ((JavassistInterfaceDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "          return ((JavassistClassDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "            return ((JavassistEnumDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);"], "argumentsTypes": ["                                                                               String name, List<ResolvedType> argumentsTypes, boolean staticOnly,", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            if (name.equals(\"values\") && argumentsTypes.isEmpty()) {", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            return ((ReflectionClassDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "          return ((ReflectionInterfaceDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "            return ((ReflectionEnumDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "            return ((JavassistInterfaceDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "          return ((JavassistClassDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "            return ((JavassistEnumDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);"], "staticOnly": ["                                                                               String name, List<ResolvedType> argumentsTypes, boolean staticOnly,", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            return ((ReflectionClassDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "          return ((ReflectionInterfaceDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "            return ((ReflectionEnumDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "            return ((JavassistInterfaceDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "          return ((JavassistClassDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);", "            return ((JavassistEnumDeclaration) typeDeclaration).solveMethod(name, argumentsTypes, staticOnly);"], "typeSolver": ["                                                                               TypeSolver typeSolver) {", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "                return SymbolReference.solved(new JavaParserEnumDeclaration.ValuesMethod((JavaParserEnumDeclaration) typeDeclaration, typeSolver));", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);", "            return ctx.solveMethod(name, argumentsTypes, staticOnly, typeSolver);"]}
{"decl": ["public static Value from(ResolvedValueDeclaration decl) {", "        ResolvedType type = decl.getType();", "        return new Value(type, decl.getName());"]}
{"methodCallExpr": ["public boolean invocationApplicabilityInference(MethodCallExpr methodCallExpr, ResolvedMethodDeclaration methodDeclaration) {", "        if (!methodCallExpr.getNameAsString().equals(methodDeclaration.getName())) {", "        Optional<InstantiationSet> partial = instantiationInference(methodCallExpr, methodDeclaration);", "        int nActualParams = methodCallExpr.getArguments().size();"], "methodDeclaration": ["public boolean invocationApplicabilityInference(MethodCallExpr methodCallExpr, ResolvedMethodDeclaration methodDeclaration) {", "        if (!methodCallExpr.getNameAsString().equals(methodDeclaration.getName())) {", "        Optional<InstantiationSet> partial = instantiationInference(methodCallExpr, methodDeclaration);", "        if (!partial.isPresent()) {", "        int nFormalParams = methodDeclaration.getNumberOfParams();", "            if (methodDeclaration.hasVariadicParameter()) {"]}
{"methodCall": [], "m1": [], "m2": ["public boolean moreSpecificMethodInference(MethodCallExpr methodCall, ResolvedMethodDeclaration m1, ResolvedMethodDeclaration m2) {", "        if (!m2.isGeneric()) {", "            throw new IllegalArgumentException(\"M2 is not generic (m2: \" + m2 + \")\");"]}
{"expression": ["private static boolean appearsInAssignmentContext(Expression expression) {", "        if (expression.getParentNode().isPresent()) {", "            Node parent = expression.getParentNode().get();"]}
{"feat": ["public float[] predict(FVec feat, boolean output_margin, int ntree_limit) {", "        float[] preds = predictRaw(feat, ntree_limit);"], "output_margin": ["public float[] predict(FVec feat, boolean output_margin, int ntree_limit) {", "        if (! output_margin) {"], "ntree_limit": ["public float[] predict(FVec feat, boolean output_margin, int ntree_limit) {", "        float[] preds = predictRaw(feat, ntree_limit);", "            preds = obj.predTransform(preds);", "        return preds;"]}
{"reader": ["public void loadModel(ModelReader reader) throws IOException {", "        param = new Param(reader);", "        nodes = new Node[param.num_nodes];", "        for (int i = 0; i < param.num_nodes; i++) {", "            nodes[i] = new Node(reader);", "        stats = new RTreeNodeStat[param.num_nodes];", "        for (int i = 0; i < param.num_nodes; i++) {", "            stats[i] = new RTreeNodeStat(reader);"]}
{"feat": ["    public int getLeafIndex(FVec feat, int root_id) {", "        while (!(n = nodes[pid])._isLeaf) {", "            pid = n.next(feat);", "        return pid;"], "root_id": ["    public int getLeafIndex(FVec feat, int root_id) {", "        int pid = root_id;", "        while (!(n = nodes[pid])._isLeaf) {", "            pid = n.next(feat);", "        return pid;"]}
{"feat": ["    public float getLeafValue(FVec feat, int root_id) {", "        while (!n._isLeaf) {", "            n = nodes[n.next(feat)];", "        return n.leaf_value;"], "root_id": ["    public float getLeafValue(FVec feat, int root_id) {", "        Node n = nodes[root_id];", "        while (!n._isLeaf) {", "            n = nodes[n.next(feat)];", "        return n.leaf_value;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"lists": ["public static <E> List<E> concatView(List<List<? extends E>> lists) {", "        if(lists.isEmpty()) {", "            return ConcatView.create(lists);"]}
{"observable": ["public static EventStream<Void> invalidationsOf(Observable observable) {", "                observable.addListener(listener);", "                return () -> observable.removeListener(listener);"]}
{"observable": ["    EventStream<O> repeatOnInvalidation(O observable) {", "                InvalidationListener listener = obs -> emit(observable);", "                observable.addListener(listener);", "                return () -> observable.removeListener(listener);", "                subscriber.accept(observable);"]}
{"Result": "Method without Parameter"}
{"set": ["            ObservableSet<? extends EventStream<T>> set) {", "                return Subscription.dynamic(set, s -> s.subscribe(this::emit));"]}
{"delegate": ["    public static <E> ObservableList<E> wrap(javafx.collections.ObservableList<E> delegate) {", "        return LiveList.suspendable(delegate);"]}
{"f": ["public <T> T onWhile(Supplier<T> f) {", "            return f.get();"]}
{"observer": ["    public final Subscription observe(O observer) {", "        P adapted = adaptObserver(observer);", "        underlying.addObserver(adapted);", "        return () -> underlying.removeObserver(adapted);"]}
{"Result": "Method without Parameter"}
{"str": ["protected String stripKnownPrefix(String str, String prefix)", "      int startIndex = str.lastIndexOf(prefix);", "         return str.substring(startIndex + prefix.length());"], "prefix": ["protected String stripKnownPrefix(String str, String prefix)", "      int startIndex = str.lastIndexOf(prefix);", "      if (startIndex != -1)", "         return str.substring(startIndex + prefix.length());"]}
{"digester": ["private Digester configureDigester(final Digester digester)", "      digester.setUseContextClassLoader(true);", "      digester.addObjectCreate(\"pretty-config/rewrite\", RewriteRule.class);", "      digester.addSetProperties(\"pretty-config/rewrite\");", "      digester.addSetNext(\"pretty-config/rewrite\", \"addRewriteRule\");", "      digester.addObjectCreate(\"pretty-config/url-mapping\", UrlMapping.class);", "      digester.addSetProperties(\"pretty-config/url-mapping\");", "      digester.addCallMethod(\"pretty-config/url-mapping/pattern\", \"setPattern\", 1);", "      digester.addCallParam(\"pretty-config/url-mapping/pattern\", 0, \"value\");", "      digester.addCallMethod(\"pretty-config/url-mapping/pattern\", \"setPattern\", 0);", "      digester.addCallMethod(\"pretty-config/url-mapping/view-id\", \"setViewId\", 1);", "      digester.addCallParam(\"pretty-config/url-mapping/view-id\", 0, \"value\");", "      digester.addCallMethod(\"pretty-config/url-mapping/view-id\", \"setViewId\", 0);", "      digester.addObjectCreate(\"pretty-config/url-mapping/pattern/validate\", PathValidator.class);", "      digester.addSetProperties(\"pretty-config/url-mapping/pattern/validate\");", "      digester.addSetNext(\"pretty-config/url-mapping/pattern/validate\", \"addPathValidator\");", "      digester.addObjectCreate(\"pretty-config/url-mapping/query-param\", QueryParameter.class);", "      digester.addSetProperties(\"pretty-config/url-mapping/query-param\");", "      digester.addCallMethod(\"pretty-config/url-mapping/query-param\", \"setExpression\", 0);", "      digester.addSetNext(\"pretty-config/url-mapping/query-param\", \"addQueryParam\");", "      digester.addObjectCreate(\"pretty-config/url-mapping/action\", UrlAction.class);", "      digester.addSetProperties(\"pretty-config/url-mapping/action\");", "      digester.addCallMethod(\"pretty-config/url-mapping/action\", \"setAction\", 0);", "      digester.addSetNext(\"pretty-config/url-mapping/action\", \"addAction\");", "      digester.addSetNext(\"pretty-config/url-mapping\", \"addMapping\");", "      return digester;"]}
{"clazz": ["public String[] processClassMappingAnnotations(Class<?> clazz)", "      URLMapping mappingAnnotation = (URLMapping) clazz.getAnnotation(URLMapping.class);", "         String mappingId = processPrettyMappingAnnotation(clazz, mappingAnnotation);", "      URLMappings mappingsAnnotation = (URLMappings) clazz.getAnnotation(URLMappings.class);", "            String mappingId = processPrettyMappingAnnotation(clazz, child);", "            classMappingIds.add(mappingId);"]}
{"values": ["private static String join(String[] values, String separator)", "      if (values != null)", "         for (int i = 0; i < values.length; i++)", "            result.append(values[i]);"], "separator": ["private static String join(String[] values, String separator)", "               result.append(separator);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"value": ["public static boolean isEL(final String value)", "      if (value == null)", "      return elPattern.matcher(value).matches();"]}
{"value": ["public static boolean containsEL(final String value)", "      if (value == null)", "      return elPattern.matcher(value).find();"]}
{"url": ["private String buildScriptInternal(final String url)", "      builder.append(url);"]}
{"retrieve": ["public static El method(final String retrieve, final String submit)", "      return new ElMethod(new ConstantExpression(retrieve), new ConstantExpression(submit));"], "submit": ["public static El method(final String retrieve, final String submit)", "      return new ElMethod(new ConstantExpression(retrieve), new ConstantExpression(submit));"]}
{"str": ["private boolean containsFieldDescriptor(String str)", "         if (str.contains(descriptor)) {"]}
{"proxyResponse": ["protected void copyResponseHeaders(HttpResponse proxyResponse, HttpServletResponse servletResponse)", "      for (Header header : proxyResponse.getAllHeaders())", "         if (hopByHopHeaders.containsHeader(header.getName()))", "         servletResponse.addHeader(header.getName(), header.getValue());"], "servletResponse": ["protected void copyResponseHeaders(HttpResponse proxyResponse, HttpServletResponse servletResponse)", "         servletResponse.addHeader(header.getName(), header.getValue());"]}
{"in": ["protected static CharSequence encodeUriQuery(CharSequence in)", "      for (int i = 0; i < in.length(); i++)", "         char c = in.charAt(i);", "         if (c < 128)", "            if (asciiQueryChars.get(c))", "         else if (!Character.isISOControl(c) && !Character.isSpaceChar(c))", "            if (outBuf != null)", "               outBuf.append(c);", "            if (outBuf == null)", "               outBuf = new StringBuilder(in.length() + 5 * 3);", "               outBuf.append(in, 0, i);", "               formatter = new Formatter(outBuf);", "            formatter.format(\"%%%02X\", (int) c);// TODO", "      return outBuf != null ? outBuf : in;"]}
{"Result": "Method without Parameter"}
{"url": ["public static QueryString build(final String url)", "      queryString.addParameters(url);"]}
{"name": ["public String getParameter(final String name)", "      List<String> values = parameters.get(name);", "      if (values == null)", "      if (values.size() == 0)", "      return values.get(0);"]}
{"name": ["public String[] getParameterValues(final String name)", "      List<String> values = parameters.get(name);", "      if (values == null)", "      return values.toArray(new String[values.size()]);"]}
{"url": ["public void addParameters(String url)", "      if ((url != null) && !\"\".equals(url))", "         url = url.trim();"]}
{"context": ["   public String deriveViewId(final FacesContext context, final String rawViewId)", "      return parent.deriveViewId(context, canonicalViewId);"], "rawViewId": ["   public String deriveViewId(final FacesContext context, final String rawViewId)", "      String canonicalViewId = new URLDuplicatePathCanonicalizer().canonicalize(rawViewId);", "      return parent.deriveViewId(context, canonicalViewId);"]}
{"Result": "Method without Parameter"}
{"param": ["public List<PathValidator> getValidatorsForPathParam(final PathParameter param)", "         if (pv.getIndex() == param.getPosition())"]}
{"parameters": ["public static QueryStringBuilder createFromEncoded(final String parameters)", "      queryString.addParameters(parameters);"]}
{"url": ["public static String extractQuery(String url)", "      if (url != null)", "         int index = url.indexOf('?');", "            url = url.substring(index + 1);", "      return url;"]}
{"name": ["public void addParameter(final String name, final String... values)", "      parameter.put(name, values);"]}
{"event": ["   private List<DispatcherTypeProvider> getDispatcherTypeProviders(HttpServletRewrite event)", "               event.getRequest().getAttribute(PROVIDER_KEY);", "         event.getRequest().setAttribute(PROVIDER_KEY, providers);"]}
{"context": ["public static int getNegationCount(final EvaluationContext context)", "      if (context == null)", "      Integer count = (Integer)context.get(NEGATION_COUNT_KEY);"]}
{"name": ["public Navigate with(CharSequence name, Object value)", "      Assert.notNull(name, \"name must not be null\");", "         parameters.put(name.toString(), value.toString());"], "value": ["public Navigate with(CharSequence name, Object value)", "      if (value != null) {", "         parameters.put(name.toString(), value.toString());"]}
{"Result": "Method without Parameter"}
{"entryName": ["private void handleClassEntry(String entryName, ClassVisitor visitor)", "      String className = getClassName(entryName.substring(CLASSES_FOLDER.length()));", "            classFileStream = servletContext.getResourceAsStream(entryName);", "            if (classFileStream == null)", "                  log.debug(\"Could not obtain InputStream for class file: \" + entryName);", "            processClass(className, classFileStream, visitor);", "               if (classFileStream != null)", "                  classFileStream.close();"], "visitor": ["private void handleClassEntry(String entryName, ClassVisitor visitor)", "            processClass(className, classFileStream, visitor);"]}
{"query": ["AddressBuilderQuery queryLiteral(String query)", "      if (query != null)", "         if (query.startsWith(\"?\"))", "            query = query.substring(1);", "         query = decodeHTMLAmpersands(query);", "         while ((index = query.indexOf('&')) >= 0 || !query.isEmpty())", "            String pair = query;", "            if (index >= 0)", "               pair = query.substring(0, index);", "               query = query.substring(index);", "               if (!query.isEmpty())", "                  query = query.substring(1);", "            int pos = pair.indexOf('=');", "            if (pos == -1)", "               name = pair;", "               name = pair.substring(0, pos);", "               value = pair.substring(pos + 1, pair.length());", "            List<CharSequence> list = params.get(name);", "            if (list == null)", "               params.put(name, list);", "            list.add(value);", "            query(entry.getKey(), entry.getValue().toArray());"]}
{"Result": "Method without Parameter"}
{"mapping": ["public URL buildURL(final UrlMapping mapping)", "         URLPatternParser parser = mapping.getPatternParser();", "                        + mapping.getId() + \" >, Required value \" + \" < \" + expression + \" > was null\");", "                  + mapping.getId() + \" >, Error occurred while extracting values from backing bean\" + \" < \""]}
{"code": ["public void sendError(int code, String message, HttpServletResponse response)", "            response.sendError(code, message);", "            response.sendError(code);", "         throw new IllegalStateException(\"Failed to send error code: \" + code, e);"], "message": ["public void sendError(int code, String message, HttpServletResponse response)", "         if (message != null)", "            response.sendError(code, message);"], "response": ["public void sendError(int code, String message, HttpServletResponse response)", "      Assert.notNull(response, \"HttpServletResponse argument was null\");", "            response.sendError(code, message);", "            response.sendError(code);"]}
{"clazz": ["   public void visit(Class<?> clazz)", "      ClassContextImpl context = new ClassContextImpl(builder, clazz);", "      context.put(clazz, payload);", "         log.trace(\"Scanning class: {}\", clazz.getName());", "      visit(clazz, context);", "      if (context.hasRuleBuildingStarted()) {", "         Class<?> currentType = clazz;", "         while (currentType != null) {", "            for (Field field : currentType.getDeclaredFields())", "               visit(field, new FieldContextImpl(context, field));", "            for (Method method : currentType.getDeclaredMethods())", "               MethodContextImpl methodContext = new MethodContextImpl(context, method);", "               visit(method, methodContext);", "               for (int i = 0; i < method.getParameterTypes().length; i++)", "                  ParameterImpl parameter = new ParameterImpl(method, method.getParameterTypes()[i],", "                           method.getParameterAnnotations()[i], i);", "                  visit(parameter, new ParameterContextImpl(methodContext, parameter));", "            currentType = currentType.getSuperclass();"]}
{"externalContext": ["private String prependContextPath(ExternalContext externalContext, String url)", "      String contextPath = externalContext.getRequestContextPath();"], "url": ["private String prependContextPath(ExternalContext externalContext, String url)", "      if (\"/\".equals(contextPath) || (url.startsWith(contextPath))) {", "         return url;", "      return contextPath + url;"]}
{"contextPath": ["private String stripContextPath(final String contextPath, String uri)", "      if (!contextPath.equals(\"/\") && uri.startsWith(contextPath))", "         uri = uri.substring(contextPath.length());"], "uri": ["private String stripContextPath(final String contextPath, String uri)", "      if (!contextPath.equals(\"/\") && uri.startsWith(contextPath))", "         uri = uri.substring(contextPath.length());", "      return uri;"]}
{"lang": ["private String translate(String lang, String value)", "         if (!bundleMap.containsKey(lang))", "            Locale locale = new Locale(lang);", "               ResourceBundle loadedBundle = ResourceBundle.getBundle(bundleName, locale,", "               bundleMap.put(lang, loadedBundle);", "            translatation = bundleMap.get(lang).getString(value);"], "value": ["private String translate(String lang, String value)", "      if (value != null)", "            translatation = bundleMap.get(lang).getString(value);", "      return translatation;"]}
{"facesServletMapping": ["public String buildDynaViewId(final String facesServletMapping)", "         Matcher m = p.matcher(facesServletMapping);", "         if (m.matches())", "            m.appendReplacement(result, replacement);", "         result.append(facesServletMapping);"]}
{"prettyContext": ["public void processDynaView(final PrettyContext prettyContext, final FacesContext facesContext)", "      log.trace(\"Requesting DynaView processing for: \" + prettyContext.getRequestURL());", "         viewId = prettyContext.getCurrentViewId();", "            prettyContext.setDynaviewProcessed(true);"], "facesContext": ["public void processDynaView(final PrettyContext prettyContext, final FacesContext facesContext)", "         Object result = computeDynaViewId(facesContext);", "         if (result instanceof String)", "            viewId = (String) result;", "            log.trace(\"Forwarding to DynaView: \" + viewId);", "            facesContext.getExternalContext().dispatch(viewId);", "            facesContext.responseComplete();", "         prettyRedirector.send404(facesContext);", "         throw new PrettyException(\"Could not forward to view: \" + viewId + \"\", e);"]}
{"clazz": ["private Type getRequiredType(Class<?> clazz)", "      TypeVariable<?>[] typeParameters = clazz.getTypeParameters();", "         return new ParameterizedTypeImpl(clazz, actualTypeParameters, null);", "      return clazz;"]}
{"customAnnotation": ["    public static <T extends Annotation> T getAnnotationProxy(Annotation customAnnotation, Class<T> referenceAnnotation) {", "        InvocationHandler handler = new AnnotationInvocationHandler(customAnnotation);", "        return (T)Proxy.newProxyInstance(referenceAnnotation.getClassLoader(), new Class[] { referenceAnnotation }, handler);"], "referenceAnnotation": ["    public static <T extends Annotation> T getAnnotationProxy(Annotation customAnnotation, Class<T> referenceAnnotation) {", "        return (T)Proxy.newProxyInstance(referenceAnnotation.getClassLoader(), new Class[] { referenceAnnotation }, handler);"]}
{"refClass": ["private Collection<Field> getFilteredFields(Class<?> refClass) {", "        SoftReference<Collection<Field>> ref = fieldCache.get(refClass);", "        Collection<Field> fieldList = ref != null ? ref.get() : null;", "            result = sizeOfFilter.filterFields(refClass, getAllFields(refClass));", "                for (Field field : result) {", "                    if (Modifier.isTransient(field.getModifiers())) {", "                        LOG.debug(\"SizeOf engine walking transient field '{}' of class {}\", field.getName(), refClass.getName());", "            fieldCache.put(refClass, new SoftReference<>(result));", "            return result;"]}
{"refClass": ["private static Collection<Field> getAllFields(Class<?> refClass) {", "        for (Class<?> klazz = refClass; klazz != null; klazz = klazz.getSuperclass()) {", "            for (Field field : klazz.getDeclaredFields()) {", "                if (!Modifier.isStatic(field.getModifiers()) &&", "                    !field.getType().isPrimitive()) {", "                        field.setAccessible(true);", "                                  \" - cache sizes may be underestimated as a result\", field, e);", "                    fields.add(field);"]}
{"key": ["public V put(K key, V value) {", "        return map.put(new IdentityWeakReference<>(key, queue), value);"], "value": ["public V put(K key, V value) {", "        return map.put(new IdentityWeakReference<>(key, queue), value);"]}
{"key": ["public V remove(K key) {", "        return map.remove(new IdentityWeakReference<>(key, queue));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"in": ["public static void copyFile( PlexusIoResource in, File outFile )", "            input = in.getContents();"], "outFile": ["public static void copyFile( PlexusIoResource in, File outFile )", "            output = new FileOutputStream( outFile );", "            IOUtil.copy( input, output );", "            IOUtil.close( output );"]}
{"resource": ["public static boolean isSame( PlexusIoResource resource, File file )", "        if ( resource instanceof FileSupplier )", "            File resourceFile = ((FileSupplier) resource).getFile();"], "file": ["public static boolean isSame( PlexusIoResource resource, File file )", "            return file.equals( resourceFile );"]}
{"directoryName": ["public void addWebinf( File directoryName, String[] includes, String[] excludes )", "        addDirectory( directoryName, \"WEB-INF/\", includes, excludes );"], "includes": ["public void addWebinf( File directoryName, String[] includes, String[] excludes )", "        addDirectory( directoryName, \"WEB-INF/\", includes, excludes );"], "excludes": ["public void addWebinf( File directoryName, String[] includes, String[] excludes )", "        addDirectory( directoryName, \"WEB-INF/\", includes, excludes );"]}
{"zOut": ["protected void initZipOutputStream( ZipArchiveOutputStream zOut )", "        super.initZipOutputStream( zOut );"]}
{"entry": ["protected void zipFile( ArchiveEntry entry, ZipArchiveOutputStream zOut, String vPath )", "                     || !ResourceUtils.isCanonicalizedSame( entry.getResource(), deploymentDescriptor ) ) ) )", "                super.zipFile( entry, zOut, vPath );", "            super.zipFile( entry, zOut, vPath );"], "zOut": ["protected void zipFile( ArchiveEntry entry, ZipArchiveOutputStream zOut, String vPath )", "                super.zipFile( entry, zOut, vPath );", "            super.zipFile( entry, zOut, vPath );"], "vPath": ["protected void zipFile( ArchiveEntry entry, ZipArchiveOutputStream zOut, String vPath )", "        if ( vPath.equalsIgnoreCase( \"WEB-INF/web.xml\" ) )", "                super.zipFile( entry, zOut, vPath );", "            super.zipFile( entry, zOut, vPath );"]}
{"Result": "Method without Parameter"}
{"section": ["public void addConfiguredSection( Section section )", "        String sectionName = section.getName();", "        for ( String s : section.attributes.keySet() )", "            Attribute attribute = section.getAttribute( s );", "            attributes.putValue( attribute.getName(), attribute.getValue() );"]}
{"writer": ["public void write( PrintWriter writer )", "            writer.write( (char) b );"]}
{"Result": "Method without Parameter"}
{"name": ["public ExistingSection getSection( String name )", "        Attributes attributes = getAttributes( name );", "        if ( attributes != null )", "            return new ExistingSection( attributes, name );"]}
{"entry": ["protected void copyFile( final ArchiveEntry entry, final String vPath )", "        final PlexusIoResource in = entry.getResource();", "            ResourceUtils.copyFile( entry.getInputStream(), outFile );", "                ArchiveEntryUtils.chmod( outFile, entry.getMode(), getLogger(), isUseJvmChmod() );"], "vPath": ["protected void copyFile( final ArchiveEntry entry, final String vPath )", "        if ( vPath.length() <= 0 )", "        final File outFile = new File( vPath );", "        final long outLastModified = outFile.lastModified();", "            if ( !outFile.getParentFile().exists() )", "                if ( !outFile.getParentFile().mkdirs() )", "                    throw new ArchiverException( \"Unable to create directory or parent directory of \" + outFile );", "            ResourceUtils.copyFile( entry.getInputStream(), outFile );", "                ArchiveEntryUtils.chmod( outFile, entry.getMode(), getLogger(), isUseJvmChmod() );", "            if ( outFile.exists() )", "                if ( !outFile.isDirectory() )", "                                    + in.getName() + \" to \" + outFile );", "            else if ( !outFile.mkdirs() )", "                throw new ArchiverException( \"Unable to create directory or parent directory of \" + outFile );", "        outFile.setLastModified( inLastModified == PlexusIoResource.UNKNOWN_MODIFICATION_DATE ? System.currentTimeMillis()"]}
{"newManifest": ["public void addConfiguredManifest( Manifest newManifest )", "            configuredManifest = newManifest;", "            JdkManifestFactory.merge( configuredManifest, newManifest, false );", "        savedConfiguredManifest = configuredManifest;"]}
{"is": ["protected void zipFile( InputStream is, ZipArchiveOutputStream zOut, String vPath, long lastModified, File fromArchive,", "                filesetManifest( fromArchive, is );", "            super.zipFile( is, zOut, vPath, lastModified, fromArchive, mode, symlinkDestination );"], "zOut": ["protected void zipFile( InputStream is, ZipArchiveOutputStream zOut, String vPath, long lastModified, File fromArchive,", "            super.zipFile( is, zOut, vPath, lastModified, fromArchive, mode, symlinkDestination );"], "vPath": ["protected void zipFile( InputStream is, ZipArchiveOutputStream zOut, String vPath, long lastModified, File fromArchive,", "        if ( MANIFEST_NAME.equalsIgnoreCase( vPath ) )", "        else if ( INDEX_NAME.equalsIgnoreCase( vPath ) && index )", "            if ( index && ( !vPath.contains( \"/\" ) ) )", "                rootEntries.addElement( vPath );", "            super.zipFile( is, zOut, vPath, lastModified, fromArchive, mode, symlinkDestination );"], "lastModified": ["protected void zipFile( InputStream is, ZipArchiveOutputStream zOut, String vPath, long lastModified, File fromArchive,", "            super.zipFile( is, zOut, vPath, lastModified, fromArchive, mode, symlinkDestination );"], "fromArchive": ["protected void zipFile( InputStream is, ZipArchiveOutputStream zOut, String vPath, long lastModified, File fromArchive,", "                filesetManifest( fromArchive, is );", "            super.zipFile( is, zOut, vPath, lastModified, fromArchive, mode, symlinkDestination );"], "mode": ["                            int mode, String symlinkDestination )", "            super.zipFile( is, zOut, vPath, lastModified, fromArchive, mode, symlinkDestination );"], "symlinkDestination": ["                            int mode, String symlinkDestination )", "            super.zipFile( is, zOut, vPath, lastModified, fromArchive, mode, symlinkDestination );"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"dirs": ["protected final void writeIndexLikeList( List<String> dirs, List<String> files, PrintWriter writer )", "        Collections.sort( dirs );", "        Iterator iter = dirs.iterator();"], "files": ["protected final void writeIndexLikeList( List<String> dirs, List<String> files, PrintWriter writer )", "        Collections.sort( files );", "        iter = files.iterator();"], "writer": ["protected final void writeIndexLikeList( List<String> dirs, List<String> files, PrintWriter writer )", "            writer.println( dir );", "            writer.println( iter.next() );"]}
{"file": ["protected static void grabFilesAndDirs( String file, List<String> dirs, List<String> files )", "        File zipFile = new File( file );", "        if ( !zipFile.exists() )", "            logger.error( \"JarArchive skipping non-existing file: \" + zipFile.getAbsolutePath() );", "        else if ( zipFile.isDirectory() )", "            logger.info( \"JarArchiver skipping indexJar \" + zipFile + \" because it is not a jar\" );", "                zf = new org.apache.commons.compress.archivers.zip.ZipFile( file, \"utf-8\" );"], "dirs": ["protected static void grabFilesAndDirs( String file, List<String> dirs, List<String> files )", "                dirs.addAll( dirSet );"], "files": ["protected static void grabFilesAndDirs( String file, List<String> dirs, List<String> files )", "                            files.add( name );"]}
{"compression": ["private InputStream decompress( UntarCompressionMethod compression, final File file, final InputStream istream )", "\t\tif ( compression == UntarCompressionMethod.GZIP )", "\t\telse if ( compression == UntarCompressionMethod.BZIP2 )", "        else if ( compression == UntarCompressionMethod.SNAPPY )"], "file": [], "istream": ["private InputStream decompress( UntarCompressionMethod compression, final File file, final InputStream istream )", "\t\t\treturn new GZIPInputStream( istream );", "\t\t\treturn new BZip2CompressorInputStream( istream );", "            return new SnappyInputStream( istream );", "\t\treturn istream;"]}
{"Result": "Method without Parameter"}
{"target": ["public static void mergeAttributes( java.util.jar.Attributes target, java.util.jar.Attributes section )", "            target.put( key, value );"], "section": ["public static void mergeAttributes( java.util.jar.Attributes target, java.util.jar.Attributes section )", "        for ( Object o : section.keySet() )", "            java.util.jar.Attributes.Name key = (Attributes.Name) o;", "            final Object value = section.get( o );", "            target.put( key, value );"]}
{"descr": ["public void setAppxml( File descr )", "        deploymentDescriptor = descr;", "        if ( !deploymentDescriptor.exists() )", "            throw new ArchiverException( \"Deployment descriptor: \" + deploymentDescriptor + \" does not exist.\" );", "        addFile( descr, \"META-INF/application.xml\" );"]}
{"fileName": ["public void addArchive( File fileName )", "        addDirectory( fileName.getParentFile(), \"/\", new String[]{fileName.getName()}, null );"]}
{"directoryName": ["public void addArchives( File directoryName, String[] includes, String[] excludes )", "        addDirectory( directoryName, \"/\", includes, excludes );"], "includes": ["public void addArchives( File directoryName, String[] includes, String[] excludes )", "        addDirectory( directoryName, \"/\", includes, excludes );"], "excludes": ["public void addArchives( File directoryName, String[] includes, String[] excludes )", "        addDirectory( directoryName, \"/\", includes, excludes );"]}
{"Result": "Method without Parameter"}
{"resources": ["    protected final void addResources( ResourceIterator resources, ZipArchiveOutputStream zOut )", "        while ( resources.hasNext() )", "            ArchiveEntry entry = resources.next();", "            String name = entry.getName();", "            name = name.replace( File.separatorChar, '/' );", "            if ( \"\".equals( name ) )", "            if ( entry.getResource().isDirectory() && !name.endsWith( \"/\" ) )", "                name = name + \"/\";", "            addParentDirs( entry, base, name, zOut, \"\" );", "            if ( entry.getResource().isFile() )", "                zipFile( entry, zOut, name );", "                zipDir( entry.getResource(), zOut, name, entry.getMode() );"], "zOut": ["    protected final void addResources( ResourceIterator resources, ZipArchiveOutputStream zOut )", "            addParentDirs( entry, base, name, zOut, \"\" );", "                zipFile( entry, zOut, name );", "                zipDir( entry.getResource(), zOut, name, entry.getMode() );"]}
{"archiveEntry": ["    private void addParentDirs( ArchiveEntry archiveEntry, File baseDir, String entry, ZipArchiveOutputStream zOut,", "                zipDir( res, zOut, prefix + dir, archiveEntry.getDefaultDirMode() );"], "baseDir": ["    private void addParentDirs( ArchiveEntry archiveEntry, File baseDir, String entry, ZipArchiveOutputStream zOut,", "                if ( baseDir != null )", "                    f = new File( baseDir, dir );", "\t\t\t\tfinal PlexusIoResource res = new AnonymousResource( f);", "                zipDir( res, zOut, prefix + dir, archiveEntry.getDefaultDirMode() );"], "entry": ["    private void addParentDirs( ArchiveEntry archiveEntry, File baseDir, String entry, ZipArchiveOutputStream zOut,", "            int slashPos = entry.length() - ( entry.endsWith( \"/\" ) ? 1 : 0 );", "            while ( ( slashPos = entry.lastIndexOf( '/', slashPos - 1 ) ) != -1 )", "                String dir = entry.substring( 0, slashPos + 1 );", "                if ( addedDirs.contains( prefix + dir ) )", "                directories.push( dir );"], "zOut": ["    private void addParentDirs( ArchiveEntry archiveEntry, File baseDir, String entry, ZipArchiveOutputStream zOut,", "                zipDir( res, zOut, prefix + dir, archiveEntry.getDefaultDirMode() );"], "prefix": ["                                String prefix )", "                if ( addedDirs.contains( prefix + dir ) )", "                zipDir( res, zOut, prefix + dir, archiveEntry.getDefaultDirMode() );"]}
{"in": ["    protected void zipFile( InputStream in, ZipArchiveOutputStream zOut, String vPath, long lastModified, File fromArchive,", "            int read = in.read(header);", "                IOUtil.copy( in, zOut, 8 * 1024);", "                if (in.markSupported())", "                    in.mark( Integer.MAX_VALUE );", "                    readWithZipStats(in, header, read, ze, null);", "                    in.reset();", "                    IOUtil.copy(in, zOut, 8 * 1024);", "                    readWithZipStats(in, header,read, ze, bos);"], "zOut": ["    protected void zipFile( InputStream in, ZipArchiveOutputStream zOut, String vPath, long lastModified, File fromArchive,", "                zOut.putArchiveEntry( ze );", "                zOut.write( bytes, 0, bytes.length);", "            } else if (zOut.isSeekable() || compressThis) {", "                zOut.putArchiveEntry( ze );", "                if (read > 0) zOut.write(header, 0, read);", "                IOUtil.copy( in, zOut, 8 * 1024);", "                    zOut.putArchiveEntry( ze);", "                    if (read > 0) zOut.write(header, 0, read);", "                    IOUtil.copy(in, zOut, 8 * 1024);", "                    zOut.putArchiveEntry(ze);", "                    if (read > 0) zOut.write(header, 0, read);", "                    bos.writeTo( zOut);", "            zOut.closeArchiveEntry();"], "vPath": ["    protected void zipFile( InputStream in, ZipArchiveOutputStream zOut, String vPath, long lastModified, File fromArchive,", "        getLogger().debug( \"adding entry \" + vPath );", "        entries.put( vPath, vPath );", "            ZipArchiveEntry ze = new ZipArchiveEntry( vPath );", "            setTime(ze, lastModified);", "            ze.setMethod( compressThis ? ZipArchiveEntry.DEFLATED : ZipArchiveEntry.STORED );", "            ze.setUnixMode( UnixStat.FILE_FLAG | mode );", "            if (ze.isUnixSymlink()){", "                zOut.putArchiveEntry( ze );", "                zOut.putArchiveEntry( ze );", "                    readWithZipStats(in, header, read, ze, null);", "                    zOut.putArchiveEntry( ze);", "                    readWithZipStats(in, header,read, ze, bos);", "                    zOut.putArchiveEntry(ze);"], "lastModified": ["    protected void zipFile( InputStream in, ZipArchiveOutputStream zOut, String vPath, long lastModified, File fromArchive,", "            setTime(ze, lastModified);"], "fromArchive": [], "mode": ["                            int mode, String symlinkDestination )", "            ze.setUnixMode( UnixStat.FILE_FLAG | mode );"], "symlinkDestination": ["                            int mode, String symlinkDestination )", "                final byte[] bytes =  enc.encode( symlinkDestination).array();"]}
{"zipFile": ["    protected boolean createEmptyZip( File zipFile )", "        getLogger().info( \"Note: creating empty \" + archiveType + \" archive \" + zipFile );", "            os = new FileOutputStream( zipFile );", "            os.write( empty );", "            IOUtil.close( os );"]}
{"Result": "Method without Parameter"}
{"in": ["private void compressFile( InputStream in, OutputStream zOut )", "            count = in.read( buffer, 0, buffer.length );"], "zOut": ["private void compressFile( InputStream in, OutputStream zOut )", "            zOut.write( buffer, 0, count );"]}
{"resource": ["protected void compress( PlexusIoResource resource, OutputStream zOut )", "        InputStream in = Streams.bufferedInputStream( resource.getContents() );"], "zOut": ["protected void compress( PlexusIoResource resource, OutputStream zOut )", "            compressFile( in, zOut );"]}
{"maxHeaderTableSize": ["public void setMaxHeaderTableSize(int maxHeaderTableSize) {", "    maxDynamicTableSize = maxHeaderTableSize;", "    if (maxDynamicTableSize < encoderMaxDynamicTableSize) {", "      dynamicTable.setCapacity(maxDynamicTableSize);"]}
{"in": ["private static int decodeULE128(InputStream in) throws IOException {", "    in.mark(5);", "      if (in.available() == 0) {", "        in.reset();", "      byte b = (byte) in.read();", "      if (shift == 28 && (b & 0xF8) != 0) {", "      result |= (b & 0x7F) << shift;", "      if ((b & 0x80) == 0) {", "        return result;", "    in.reset();"]}
{"name": ["static int getIndex(byte[] name) {", "    String nameString = new String(name, 0, name.length, ISO_8859_1);"]}
{"name": ["static int getIndex(byte[] name, byte[] value) {", "    int index = getIndex(name);", "    if (index == -1) {", "    while (index <= length) {", "      HeaderField entry = getEntry(index);", "      if (!HpackUtil.equals(name, entry.name)) {", "      if (HpackUtil.equals(value, entry.value)) {", "        return index;"], "value": ["static int getIndex(byte[] name, byte[] value) {", "      if (HpackUtil.equals(value, entry.value)) {"]}
{"Result": "Method without Parameter"}
{"data": ["public int getEncodedLength(byte[] data) {", "    if (data == null) {", "    for (byte b : data) {", "      len += lengths[b & 0xFF];", "    return (int)((len + 7) >> 3);"]}
{"Result": "Method without Parameter"}
{"header": ["public void add(HeaderField header) {", "    int headerSize = header.size();", "    headerFields[head++] = header;", "    size += header.size();", "    if (head == headerFields.length) {"]}
{"capacity": ["public void setCapacity(int capacity) {", "    if (capacity < 0) {", "      throw new IllegalArgumentException(\"Illegal Capacity: \"+ capacity);", "    if (this.capacity == capacity) {", "    this.capacity = capacity;", "    if (capacity == 0) {", "      while (size > capacity) {", "    int maxEntries = capacity / HEADER_ENTRY_OVERHEAD;", "    if (capacity % HEADER_ENTRY_OVERHEAD != 0) {"]}
{"out": ["public void encodeHeader(OutputStream out, byte[] name, byte[] value, boolean sensitive) throws IOException {", "      encodeLiteral(out, name, value, IndexType.NEVER, nameIndex);", "        encodeLiteral(out, name, value, IndexType.NONE, nameIndex);", "        encodeInteger(out, 0x80, 7, staticTableIndex);", "      encodeLiteral(out, name, value, IndexType.NONE, nameIndex);", "      encodeInteger(out, 0x80, 7, index);", "        encodeInteger(out, 0x80, 7, staticTableIndex);", "        encodeLiteral(out, name, value, indexType, nameIndex);"], "name": ["public void encodeHeader(OutputStream out, byte[] name, byte[] value, boolean sensitive) throws IOException {", "      int nameIndex = getNameIndex(name);", "      encodeLiteral(out, name, value, IndexType.NEVER, nameIndex);", "      int staticTableIndex = StaticTable.getIndex(name, value);", "        int nameIndex = StaticTable.getIndex(name);", "        encodeLiteral(out, name, value, IndexType.NONE, nameIndex);", "    int headerSize = HeaderField.sizeOf(name, value);", "      int nameIndex = getNameIndex(name);", "      encodeLiteral(out, name, value, IndexType.NONE, nameIndex);", "    HeaderEntry headerField = getEntry(name, value);", "      int staticTableIndex = StaticTable.getIndex(name, value);", "        int nameIndex = getNameIndex(name);", "        encodeLiteral(out, name, value, indexType, nameIndex);", "          add(name, value);"], "value": ["public void encodeHeader(OutputStream out, byte[] name, byte[] value, boolean sensitive) throws IOException {", "      encodeLiteral(out, name, value, IndexType.NEVER, nameIndex);", "      int staticTableIndex = StaticTable.getIndex(name, value);", "      if (staticTableIndex == -1) {", "        encodeLiteral(out, name, value, IndexType.NONE, nameIndex);", "        encodeInteger(out, 0x80, 7, staticTableIndex);", "    int headerSize = HeaderField.sizeOf(name, value);", "    if (headerSize > capacity) {", "      encodeLiteral(out, name, value, IndexType.NONE, nameIndex);", "    HeaderEntry headerField = getEntry(name, value);", "    if (headerField != null) {", "      int index = getIndex(headerField.index) + StaticTable.length;", "      int staticTableIndex = StaticTable.getIndex(name, value);", "      if (staticTableIndex != -1) {", "        encodeInteger(out, 0x80, 7, staticTableIndex);", "          ensureCapacity(headerSize);", "        encodeLiteral(out, name, value, indexType, nameIndex);", "          add(name, value);"], "sensitive": ["public void encodeHeader(OutputStream out, byte[] name, byte[] value, boolean sensitive) throws IOException {", "    if (sensitive) {"]}
{"out": ["public void setMaxHeaderTableSize(OutputStream out, int maxHeaderTableSize) throws IOException {", "    encodeInteger(out, 0x20, 5, maxHeaderTableSize);"], "maxHeaderTableSize": ["public void setMaxHeaderTableSize(OutputStream out, int maxHeaderTableSize) throws IOException {", "    if (maxHeaderTableSize < 0) {", "      throw new IllegalArgumentException(\"Illegal Capacity: \" + maxHeaderTableSize);", "    if (capacity == maxHeaderTableSize) {", "    capacity = maxHeaderTableSize;", "    encodeInteger(out, 0x20, 5, maxHeaderTableSize);"]}
{"out": ["private static void encodeInteger(OutputStream out, int mask, int n, int i) throws IOException {", "      out.write(mask | i);", "      out.write(mask | nbits);", "          out.write(length);", "          out.write((length & 0x7F) | 0x80);"], "mask": ["private static void encodeInteger(OutputStream out, int mask, int n, int i) throws IOException {", "      out.write(mask | i);", "      out.write(mask | nbits);"], "n": ["private static void encodeInteger(OutputStream out, int mask, int n, int i) throws IOException {", "    if (n < 0 || n > 8) {", "      throw new IllegalArgumentException(\"N: \" + n);", "    int nbits = 0xFF >>> (8 - n);", "    if (i < nbits) {", "      out.write(mask | nbits);", "      int length = i - nbits;", "        if ((length & ~0x7F) == 0) {", "          out.write(length);", "          out.write((length & 0x7F) | 0x80);"], "i": ["private static void encodeInteger(OutputStream out, int mask, int n, int i) throws IOException {", "    if (i < nbits) {", "      out.write(mask | i);", "      int length = i - nbits;"]}
{"out": ["private void encodeStringLiteral(OutputStream out, byte[] string) throws IOException {", "      encodeInteger(out, 0x80, 7, huffmanLength);", "      Huffman.ENCODER.encode(out, string);", "      encodeInteger(out, 0x00, 7, string.length);", "      out.write(string, 0, string.length);"], "string": ["private void encodeStringLiteral(OutputStream out, byte[] string) throws IOException {", "    int huffmanLength = Huffman.ENCODER.getEncodedLength(string);", "    if ((huffmanLength < string.length && !forceHuffmanOff) || forceHuffmanOn) {", "      encodeInteger(out, 0x80, 7, huffmanLength);", "      Huffman.ENCODER.encode(out, string);", "      encodeInteger(out, 0x00, 7, string.length);", "      out.write(string, 0, string.length);"]}
{"out": ["private void encodeLiteral(OutputStream out, byte[] name, byte[] value, IndexType indexType, int nameIndex)", "    encodeInteger(out, mask, prefixBits, nameIndex == -1 ? 0 : nameIndex);", "      encodeStringLiteral(out, name);", "    encodeStringLiteral(out, value);"], "name": ["private void encodeLiteral(OutputStream out, byte[] name, byte[] value, IndexType indexType, int nameIndex)", "      encodeStringLiteral(out, name);"], "value": ["private void encodeLiteral(OutputStream out, byte[] name, byte[] value, IndexType indexType, int nameIndex)", "    encodeStringLiteral(out, value);"], "indexType": ["private void encodeLiteral(OutputStream out, byte[] name, byte[] value, IndexType indexType, int nameIndex)", "    switch(indexType) {"], "nameIndex": ["private void encodeLiteral(OutputStream out, byte[] name, byte[] value, IndexType indexType, int nameIndex)", "    encodeInteger(out, mask, prefixBits, nameIndex == -1 ? 0 : nameIndex);", "    if (nameIndex == -1) {"]}
{"headerSize": ["private void ensureCapacity(int headerSize) throws IOException {", "    while (size + headerSize > capacity) {"]}
{"index": []}
{"name": ["private HeaderEntry getEntry(byte[] name, byte[] value) {", "    if (length() == 0 || name == null || value == null) {", "    int h = hash(name);", "    int i = index(h);", "    for (HeaderEntry e = headerFields[i]; e != null; e = e.next) {", "      if (e.hash == h &&", "          HpackUtil.equals(name, e.name) &&", "          HpackUtil.equals(value, e.value)) {", "        return e;"], "value": ["private HeaderEntry getEntry(byte[] name, byte[] value) {", "    if (length() == 0 || name == null || value == null) {", "          HpackUtil.equals(value, e.value)) {"]}
{"name": ["private int getIndex(byte[] name) {", "    if (length() == 0 || name == null) {", "    int h = hash(name);", "    int i = index(h);", "    for (HeaderEntry e = headerFields[i]; e != null; e = e.next) {", "      if (e.hash == h && HpackUtil.equals(name, e.name)) {", "        index = e.index;", "    return getIndex(index);"]}
{"name": ["private void add(byte[] name, byte[] value) {", "    int headerSize = HeaderField.sizeOf(name, value);", "    name = Arrays.copyOf(name, name.length);"], "value": ["private void add(byte[] name, byte[] value) {", "    int headerSize = HeaderField.sizeOf(name, value);", "    if (headerSize > capacity) {", "    while (size + headerSize > capacity) {", "    value = Arrays.copyOf(value, value.length);", "    size += headerSize;"]}
{"name": ["private static int hash(byte[] name) {", "    for (int i = 0; i < name.length; i++) {", "      h = 31 * h + name[i];", "    if (h > 0) {", "      return h;", "    } else if (h == Integer.MIN_VALUE) {", "      return -h;"]}
{"buf": ["public byte[] decode(byte[] buf) throws IOException {", "    for (int i = 0; i < buf.length; i++) {", "      int b = buf[i] & 0xFF;", "      current = (current << 8) | b;", "      while (bits >= 8) {", "        int c = (current >>> (bits - 8)) & 0xFF;", "        node = node.children[c];", "        bits -= node.bits;", "        if (node.isTerminal()) {", "          if (node.symbol == HpackUtil.HUFFMAN_EOS) {", "          baos.write(node.symbol);", "    while (bits > 0) {", "      int c = (current << (8 - bits)) & 0xFF;", "      node = node.children[c];", "      if (node.isTerminal() && node.bits <= bits) {", "        bits -= node.bits;", "        baos.write(node.symbol);", "    int mask = (1 << bits) - 1;", "    if ((current & mask) != mask) {"]}
{"scriptNames": ["public void setDefaultScriptNames(String scriptNames) {", "\t\tif (!scriptNames.trim().isEmpty())", "\t\t\tservice.setDefaultScripts(asList(scriptNames.split(\",\")));"]}
{"description": ["public void assertEqualTo(Description description, Short actual, short expected) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldBeEqual(actual, expected));\r"], "actual": ["public void assertEqualTo(Description description, Short actual, short expected) {\r", "    assertNotNull(description, actual);\r", "    if (!isEqualTo(actual, expected)) {\r", "      throw failures.failure(description, shouldBeEqual(actual, expected));\r"], "expected": ["public void assertEqualTo(Description description, Short actual, short expected) {\r", "    if (!isEqualTo(actual, expected)) {\r", "      throw failures.failure(description, shouldBeEqual(actual, expected));\r"]}
{"description": ["public void assertNotEqualTo(Description description, Short actual, short expected) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldNotBeEqual(actual, expected));\r"], "actual": ["public void assertNotEqualTo(Description description, Short actual, short expected) {\r", "    assertNotNull(description, actual);\r", "    if (isEqualTo(actual, expected)) {\r", "      throw failures.failure(description, shouldNotBeEqual(actual, expected));\r"], "expected": ["public void assertNotEqualTo(Description description, Short actual, short expected) {\r", "    if (isEqualTo(actual, expected)) {\r", "      throw failures.failure(description, shouldNotBeEqual(actual, expected));\r"]}
{"description": ["public void assertGreaterThan(Description description, Short actual, short expected) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, ShouldBeGreaterThan.shouldBeGreaterThan(actual, expected));\r"], "actual": ["public void assertGreaterThan(Description description, Short actual, short expected) {\r", "    assertNotNull(description, actual);\r", "    if (!isGreaterThan(actual, expected)) {\r", "      throw failures.failure(description, ShouldBeGreaterThan.shouldBeGreaterThan(actual, expected));\r"], "expected": ["public void assertGreaterThan(Description description, Short actual, short expected) {\r", "    if (!isGreaterThan(actual, expected)) {\r", "      throw failures.failure(description, ShouldBeGreaterThan.shouldBeGreaterThan(actual, expected));\r"]}
{"description": ["public void assertGreaterThan(Description description, Float actual, float expected) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldBeGreaterThan(actual, expected));\r"], "actual": ["public void assertGreaterThan(Description description, Float actual, float expected) {\r", "    assertNotNull(description, actual);\r", "    if (!isGreaterThan(actual, expected)) {\r", "      throw failures.failure(description, shouldBeGreaterThan(actual, expected));\r"], "expected": ["public void assertGreaterThan(Description description, Float actual, float expected) {\r", "    if (!isGreaterThan(actual, expected)) {\r", "      throw failures.failure(description, shouldBeGreaterThan(actual, expected));\r"]}
{"description": ["public void assertEqual(Description description, Character actual, char expected) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldBeEqual(actual, expected));\r"], "actual": ["public void assertEqual(Description description, Character actual, char expected) {\r", "    assertNotNull(description, actual);\r", "    if (actual.charValue() != expected) {\r", "      throw failures.failure(description, shouldBeEqual(actual, expected));\r"], "expected": ["public void assertEqual(Description description, Character actual, char expected) {\r", "    if (actual.charValue() != expected) {\r", "      throw failures.failure(description, shouldBeEqual(actual, expected));\r"]}
{"description": ["public void assertNotEqual(Description description, Character actual, char other) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldNotBeEqual(actual, other));\r"], "actual": ["public void assertNotEqual(Description description, Character actual, char other) {\r", "    assertNotNull(description, actual);\r", "    if (actual.charValue() == other) {\r", "      throw failures.failure(description, shouldNotBeEqual(actual, other));\r"], "other": ["public void assertNotEqual(Description description, Character actual, char other) {\r", "    if (actual.charValue() == other) {\r", "      throw failures.failure(description, shouldNotBeEqual(actual, other));\r"]}
{"description": ["public void assertLessThan(Description description, Character actual, char other) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldBeLessThan(actual, other));\r"], "actual": ["public void assertLessThan(Description description, Character actual, char other) {\r", "    assertNotNull(description, actual);\r", "    if (!isLessThan(actual, other)) {\r", "      throw failures.failure(description, shouldBeLessThan(actual, other));\r"], "other": ["public void assertLessThan(Description description, Character actual, char other) {\r", "    if (!isLessThan(actual, other)) {\r", "      throw failures.failure(description, shouldBeLessThan(actual, other));\r"]}
{"description": ["public void assertNotGreaterThan(Description description, Character actual, char other) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldNotBeGreaterThan(actual, other));\r"], "actual": ["public void assertNotGreaterThan(Description description, Character actual, char other) {\r", "    assertNotNull(description, actual);\r", "    if (isGreaterThan(actual, other)) {\r", "      throw failures.failure(description, shouldNotBeGreaterThan(actual, other));\r"], "other": ["public void assertNotGreaterThan(Description description, Character actual, char other) {\r", "    if (isGreaterThan(actual, other)) {\r", "      throw failures.failure(description, shouldNotBeGreaterThan(actual, other));\r"]}
{"description": ["public void assertGreaterThan(Description description, Character actual, char other) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldBeGreaterThan(actual, other));\r"], "actual": ["public void assertGreaterThan(Description description, Character actual, char other) {\r", "    assertNotNull(description, actual);\r", "    if (!isGreaterThan(actual, other)) {\r", "      throw failures.failure(description, shouldBeGreaterThan(actual, other));\r"], "other": ["public void assertGreaterThan(Description description, Character actual, char other) {\r", "    if (!isGreaterThan(actual, other)) {\r", "      throw failures.failure(description, shouldBeGreaterThan(actual, other));\r"]}
{"description": ["public void assertNotLessThan(Description description, Character actual, char other) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, ShouldNotBeLessThan.shouldNotBeLessThan(actual, other));\r"], "actual": ["public void assertNotLessThan(Description description, Character actual, char other) {\r", "    assertNotNull(description, actual);\r", "    if (isLessThan(actual, other)) {\r", "      throw failures.failure(description, ShouldNotBeLessThan.shouldNotBeLessThan(actual, other));\r"], "other": ["public void assertNotLessThan(Description description, Character actual, char other) {\r", "    if (isLessThan(actual, other)) {\r", "      throw failures.failure(description, ShouldNotBeLessThan.shouldNotBeLessThan(actual, other));\r"]}
{"description": ["public void assertLowerCase(Description description, Character actual) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldBeLowerCase(actual));\r"], "actual": ["public void assertLowerCase(Description description, Character actual) {\r", "    assertNotNull(description, actual);\r", "    if (!isLowerCase(actual)) {\r", "      throw failures.failure(description, shouldBeLowerCase(actual));\r"]}
{"description": ["public void assertUpperCase(Description description, Character actual) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldBeUpperCase(actual));\r"], "actual": ["public void assertUpperCase(Description description, Character actual) {\r", "    assertNotNull(description, actual);\r", "    if (!isUpperCase(actual)) {\r", "      throw failures.failure(description, shouldBeUpperCase(actual));\r"]}
{"description": ["public void assertHasSize(Description description, int[] actual, int expectedSize) {\r", "    arrays.assertHasSize(description, actual, expectedSize);\r"], "actual": ["public void assertHasSize(Description description, int[] actual, int expectedSize) {\r", "    arrays.assertHasSize(description, actual, expectedSize);\r"], "expectedSize": ["public void assertHasSize(Description description, int[] actual, int expectedSize) {\r", "    arrays.assertHasSize(description, actual, expectedSize);\r"]}
{"description": ["public void assertContains(Description description, int[] actual, int[] values) {\r", "    arrays.assertContains(description, actual, values);\r"], "actual": ["public void assertContains(Description description, int[] actual, int[] values) {\r", "    arrays.assertContains(description, actual, values);\r"], "values": ["public void assertContains(Description description, int[] actual, int[] values) {\r", "    arrays.assertContains(description, actual, values);\r"]}
{"description": ["public <K> void assertContainsKey(Description description, Map<?, ?> actual, K key) {", "    assertNotNull(description, actual);", "      throw failures.failure(description, shouldContainKey(actual, key));"], "actual": ["public <K> void assertContainsKey(Description description, Map<?, ?> actual, K key) {", "    assertNotNull(description, actual);", "    if (!actual.containsKey(key)) {", "      throw failures.failure(description, shouldContainKey(actual, key));"], "key": ["public <K> void assertContainsKey(Description description, Map<?, ?> actual, K key) {", "    if (!actual.containsKey(key)) {", "      throw failures.failure(description, shouldContainKey(actual, key));"]}
{"description": ["public <K> void assertDoesNotContainKey(Description description, Map<?, ?> actual, K key) {", "    assertNotNull(description, actual);", "      throw failures.failure(description, shouldNotContainKey(actual, key));"], "actual": ["public <K> void assertDoesNotContainKey(Description description, Map<?, ?> actual, K key) {", "    assertNotNull(description, actual);", "    if (actual.containsKey(key)) {", "      throw failures.failure(description, shouldNotContainKey(actual, key));"], "key": ["public <K> void assertDoesNotContainKey(Description description, Map<?, ?> actual, K key) {", "    if (actual.containsKey(key)) {", "      throw failures.failure(description, shouldNotContainKey(actual, key));"]}
{"description": ["public <V> void assertContainsValue(Description description, Map<?, ?> actual, V value) {", "    assertNotNull(description, actual);", "      throw failures.failure(description, shouldContainValue(actual, value));"], "actual": ["public <V> void assertContainsValue(Description description, Map<?, ?> actual, V value) {", "    assertNotNull(description, actual);", "    if (!actual.containsValue(value)) {", "      throw failures.failure(description, shouldContainValue(actual, value));"], "value": ["public <V> void assertContainsValue(Description description, Map<?, ?> actual, V value) {", "    if (!actual.containsValue(value)) {", "      throw failures.failure(description, shouldContainValue(actual, value));"]}
{"description": ["public <V> void assertDoesNotContainValue(Description description, Map<?, ?> actual, V value) {", "    assertNotNull(description, actual);", "      throw failures.failure(description, shouldNotContainValue(actual, value));"], "actual": ["public <V> void assertDoesNotContainValue(Description description, Map<?, ?> actual, V value) {", "    assertNotNull(description, actual);", "    if (actual.containsValue(value)) {", "      throw failures.failure(description, shouldNotContainValue(actual, value));"], "value": ["public <V> void assertDoesNotContainValue(Description description, Map<?, ?> actual, V value) {", "    if (actual.containsValue(value)) {", "      throw failures.failure(description, shouldNotContainValue(actual, value));"]}
{"description": ["public <K, V> void assertDoesNotContainDuplicateValues(Description description, Map<K, V> actual) {", "    assertNotNull(description, actual);", "      throw failures.failure(description, shouldNotHaveDuplicates(actual, duplicates));"], "actual": ["public <K, V> void assertDoesNotContainDuplicateValues(Description description, Map<K, V> actual) {", "    assertNotNull(description, actual);", "    Collection<?> duplicates = duplicatesFrom(actual.values());", "      throw failures.failure(description, shouldNotHaveDuplicates(actual, duplicates));"]}
{"description": ["public void assertEqual(Description description, BigDecimal actual, BigDecimal expected) {\r", "    assertNotNull(description, actual);\r", "    comparables.assertEqual(description, actual, expected);\r"], "actual": ["public void assertEqual(Description description, BigDecimal actual, BigDecimal expected) {\r", "    assertNotNull(description, actual);\r", "    comparables.assertEqual(description, actual, expected);\r"], "expected": ["public void assertEqual(Description description, BigDecimal actual, BigDecimal expected) {\r", "    checkNumberIsNotNull(expected);\r", "    comparables.assertEqual(description, actual, expected);\r"]}
{"description": ["public void assertIsZero(Description description, BigDecimal actual) {\r", "    comparables.assertEqual(description, actual, ZERO);\r"], "actual": ["public void assertIsZero(Description description, BigDecimal actual) {\r", "    comparables.assertEqual(description, actual, ZERO);\r"]}
{"description": ["public void assertIsNotZero(Description description, BigDecimal actual) {\r", "    comparables.assertNotEqual(description, actual, ZERO);\r"], "actual": ["public void assertIsNotZero(Description description, BigDecimal actual) {\r", "    comparables.assertNotEqual(description, actual, ZERO);\r"]}
{"description": ["public void assertIsPositive(Description description, BigDecimal actual) {\r", "    comparables.assertGreaterThan(description, actual, ZERO);\r"], "actual": ["public void assertIsPositive(Description description, BigDecimal actual) {\r", "    comparables.assertGreaterThan(description, actual, ZERO);\r"]}
{"description": ["public void assertIsNegative(Description description, BigDecimal actual) {\r", "    comparables.assertLessThan(description, actual, ZERO);\r"], "actual": ["public void assertIsNegative(Description description, BigDecimal actual) {\r", "    comparables.assertLessThan(description, actual, ZERO);\r"]}
{"expected": ["public FloatAssert isEqualTo(float expected, Offset<Float> offset) {\r", "    floats.assertEqual(description, actual, expected, offset);\r"], "offset": ["public FloatAssert isEqualTo(float expected, Offset<Float> offset) {\r", "    floats.assertEqual(description, actual, expected, offset);\r"]}
{"value": ["public ByteArrayAssert contains(byte value, Index index) {\r", "    arrays.assertContains(description, actual, value, index);\r"], "index": ["public ByteArrayAssert contains(byte value, Index index) {\r", "    arrays.assertContains(description, actual, value, index);\r"]}
{"description": ["public void assertNotEqual(Description description, Double actual, Double expected, Offset<Double> offset) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldNotBeEqual(actual, expected));\r"], "actual": ["public void assertNotEqual(Description description, Double actual, Double expected, Offset<Double> offset) {\r", "    assertNotNull(description, actual);\r", "    if (isEqualTo(actual, expected, offset)) {\r", "      throw failures.failure(description, shouldNotBeEqual(actual, expected));\r"], "expected": ["public void assertNotEqual(Description description, Double actual, Double expected, Offset<Double> offset) {\r", "    checkNumberIsNotNull(expected);\r", "    if (isEqualTo(actual, expected, offset)) {\r", "      throw failures.failure(description, shouldNotBeEqual(actual, expected));\r"], "offset": ["public void assertNotEqual(Description description, Double actual, Double expected, Offset<Double> offset) {\r", "    checkOffsetIsNotNull(offset);\r", "    if (isEqualTo(actual, expected, offset)) {\r"]}
{"description": ["public void assertNotGreaterThan(Description description, Double actual, double expected) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldNotBeGreaterThan(actual, expected));\r"], "actual": ["public void assertNotGreaterThan(Description description, Double actual, double expected) {\r", "    assertNotNull(description, actual);\r", "    if (isGreaterThan(actual, expected)) {\r", "      throw failures.failure(description, shouldNotBeGreaterThan(actual, expected));\r"], "expected": ["public void assertNotGreaterThan(Description description, Double actual, double expected) {\r", "    if (isGreaterThan(actual, expected)) {\r", "      throw failures.failure(description, shouldNotBeGreaterThan(actual, expected));\r"]}
{"description": ["public void assertLessThan(Description description, Double actual, double expected) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldBeLessThan(actual, expected));\r"], "actual": ["public void assertLessThan(Description description, Double actual, double expected) {\r", "    assertNotNull(description, actual);\r", "    if (!isLessThan(actual, expected)) {\r", "      throw failures.failure(description, shouldBeLessThan(actual, expected));\r"], "expected": ["public void assertLessThan(Description description, Double actual, double expected) {\r", "    if (!isLessThan(actual, expected)) {\r", "      throw failures.failure(description, shouldBeLessThan(actual, expected));\r"]}
{"description": ["public void assertNotLessThan(Description description, Double actual, double expected) {\r", "    assertNotNull(description, actual);\r", "      throw failures.failure(description, shouldNotBeLessThan(actual, expected));\r"], "actual": ["public void assertNotLessThan(Description description, Double actual, double expected) {\r", "    assertNotNull(description, actual);\r", "    if (isLessThan(actual, expected)) {\r", "      throw failures.failure(description, shouldNotBeLessThan(actual, expected));\r"], "expected": ["public void assertNotLessThan(Description description, Double actual, double expected) {\r", "    if (isLessThan(actual, expected)) {\r", "      throw failures.failure(description, shouldNotBeLessThan(actual, expected));\r"]}
{"description": ["public void assertContainsOnly(Description description, byte[] actual, byte[] values) {\r", "    arrays.assertContainsOnly(description, actual, values);\r"], "actual": ["public void assertContainsOnly(Description description, byte[] actual, byte[] values) {\r", "    arrays.assertContainsOnly(description, actual, values);\r"], "values": ["public void assertContainsOnly(Description description, byte[] actual, byte[] values) {\r", "    arrays.assertContainsOnly(description, actual, values);\r"]}
{"description": ["public void assertContainsSequence(Description description, byte[] actual, byte[] sequence) {\r", "    arrays.assertContainsSequence(description, actual, sequence);\r"], "actual": ["public void assertContainsSequence(Description description, byte[] actual, byte[] sequence) {\r", "    arrays.assertContainsSequence(description, actual, sequence);\r"], "sequence": ["public void assertContainsSequence(Description description, byte[] actual, byte[] sequence) {\r", "    arrays.assertContainsSequence(description, actual, sequence);\r"]}
{"description": ["public void assertEqual(Description description, Object actual, Object expected) {\r", "      throw shouldBeEqual(actual, expected).newAssertionError(description);\r"], "actual": ["public void assertEqual(Description description, Object actual, Object expected) {\r", "    if (!areEqual(actual, expected)) {\r", "      throw shouldBeEqual(actual, expected).newAssertionError(description);\r"], "expected": ["public void assertEqual(Description description, Object actual, Object expected) {\r", "    if (!areEqual(actual, expected)) {\r", "      throw shouldBeEqual(actual, expected).newAssertionError(description);\r"]}
{"description": ["public void assertNotEqual(Description description, Object actual, Object other) {\r", "      throw failures.failure(description, shouldNotBeEqual(actual, other));\r"], "actual": ["public void assertNotEqual(Description description, Object actual, Object other) {\r", "    if (areEqual(actual, other)) {\r", "      throw failures.failure(description, shouldNotBeEqual(actual, other));\r"], "other": ["public void assertNotEqual(Description description, Object actual, Object other) {\r", "    if (areEqual(actual, other)) {\r", "      throw failures.failure(description, shouldNotBeEqual(actual, other));\r"]}
{"description": ["public void assertSame(Description description, Object actual, Object expected) {\r", "      throw failures.failure(description, new BasicErrorMessageFactory(format, expected, actual));\r"], "actual": ["public void assertSame(Description description, Object actual, Object expected) {\r", "    if (actual != expected) {\r", "      throw failures.failure(description, new BasicErrorMessageFactory(format, expected, actual));\r"], "expected": ["public void assertSame(Description description, Object actual, Object expected) {\r", "    if (actual != expected) {\r", "      throw failures.failure(description, new BasicErrorMessageFactory(format, expected, actual));\r"]}
{"description": ["public void assertNotSame(Description description, Object actual, Object other) {\r", "      throw failures.failure(description, new BasicErrorMessageFactory(format, actual));\r"], "actual": ["public void assertNotSame(Description description, Object actual, Object other) {\r", "    if (actual == other) {\r", "      throw failures.failure(description, new BasicErrorMessageFactory(format, actual));\r"], "other": ["public void assertNotSame(Description description, Object actual, Object other) {\r", "    if (actual == other) {\r"]}
{"description": ["public void assertDoesNotContain(Description description, char[] actual, char[] values) {\r", "    arrays.assertDoesNotContain(description, actual, values);\r"], "actual": ["public void assertDoesNotContain(Description description, char[] actual, char[] values) {\r", "    arrays.assertDoesNotContain(description, actual, values);\r"], "values": ["public void assertDoesNotContain(Description description, char[] actual, char[] values) {\r", "    arrays.assertDoesNotContain(description, actual, values);\r"]}
{"description": ["public void assertIsSorted(Description description, char[] actual) {\r", "        throw failures.failure(description, shouldBeSorted(i, actual));\r"], "actual": ["public void assertIsSorted(Description description, char[] actual) {\r", "    if(actual == null) {\r", "    if (actual.length == 0) {\r", "    for (int i = 0; i < actual.length - 1; i++) {\r", "      if (actual[i] > actual[i + 1]) {\r", "        throw failures.failure(description, shouldBeSorted(i, actual));\r"]}
{"name": ["  public static <T> Matcher<T> named(String name, Matcher<T> matcher) {", "    return describedAs(\"%0 = %1\", matcher, name, matcher);"], "matcher": ["  public static <T> Matcher<T> named(String name, Matcher<T> matcher) {", "    return describedAs(\"%0 = %1\", matcher, name, matcher);"]}
{"Result": "Method without Parameter"}
{"fieldName": ["static String getMiddleNameForPrefixingAsAccessorMutatorJavaBeansSpecCompliance(String fieldName) {", "        if (fieldName.length() > 1 && Character.isUpperCase(fieldName.charAt(1))) {", "            return fieldName;", "        return fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);"]}
{"type": ["private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {", "        JMethod m = type.findMethod(fieldName, args);", "            JClassType superType = type.getSuperclass();"], "field": ["private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {", "        if (field instanceof DummyJField) {", "            args = new JType[] { field.getType() };", "            JClassType fieldType = field.getType().isClassOrInterface();", "                return m.getReturnType().equals(field.getType());", "                return exists(superType, field, fieldName, isSetter);"], "fieldName": ["private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {", "        JMethod m = type.findMethod(fieldName, args);", "                return exists(superType, field, fieldName, isSetter);"], "isSetter": ["private boolean exists(JClassType type, JField field, String fieldName, boolean isSetter) {", "        if (isSetter) {", "            if (isSetter) {", "                return exists(superType, field, fieldName, isSetter);"]}
{"context": ["public static List<AnnotationResolver> getAnnotationResolvers(GeneratorContext context,", "                for (String className : context.getPropertyOracle()", "                    logger.log(TreeLogger.INFO, \"classname to resolve: \" + className);", "                        clazz = Class.forName(className);", "                        throw new RuntimeException(\"could not resolve class \" + className + \" \" + e.getMessage());", "                    if (null != clazz) {", "                            logger.log(TreeLogger.INFO, \"add annotationresolver: \" + clazz.getName());", "                            addAnnotationResolver((AnnotationResolver) clazz.newInstance());", "                            throw new RuntimeException(\"could not instanciate class \" + className + \" \" + e.getMessage());", "                            throw new RuntimeException(\"could not access class \" + className + \" \" + e.getMessage());", "                        throw new RuntimeException(\"could not create instance for classname \" + className);"], "logger": ["                                                                  TreeLogger logger) {", "                    logger.log(TreeLogger.INFO, \"classname to resolve: \" + className);", "                            logger.log(TreeLogger.INFO, \"add annotationresolver: \" + clazz.getName());", "                logger.log(TreeLogger.DEBUG, \"no additional annotationresolvers found\");"]}
{"Result": "Method without Parameter"}
{"newClassName": ["private String reduceName(String newClassName, String suffix) {", "        if (newClassName.length() < MAX_FILE_NAME_LENGTH) {", "            return newClassName;", "        String noSufix = newClassName.substring(0, newClassName.length() - suffix.length());", "        if (newClassName.indexOf(\"__\") > 0) {", "        return newClassName;"], "suffix": ["private String reduceName(String newClassName, String suffix) {", "        String noSufix = newClassName.substring(0, newClassName.length() - suffix.length());", "            String finalName = primaryName + stringBuilder.toString() + suffix;", "            if (finalName.length() > MAX_FILE_NAME_LENGTH) {", "                finalName =", "                        \"_\" + middle.substring(middle.length() - 9) + baseName.substring(lastPosition) + suffix;", "                return finalName;", "            return finalName;"]}
{"logger": ["protected static boolean getBooleanProperty(TreeLogger logger, PropertyOracle propertyOracle, String propertyName,", "            SelectionProperty prop = propertyOracle.getSelectionProperty(logger, propertyName);"], "propertyOracle": ["protected static boolean getBooleanProperty(TreeLogger logger, PropertyOracle propertyOracle, String propertyName,", "            SelectionProperty prop = propertyOracle.getSelectionProperty(logger, propertyName);"], "propertyName": ["protected static boolean getBooleanProperty(TreeLogger logger, PropertyOracle propertyOracle, String propertyName,", "            SelectionProperty prop = propertyOracle.getSelectionProperty(logger, propertyName);", "            String propVal = prop.getCurrentValue();"], "defaultValue": ["                                                boolean defaultValue) {", "        return defaultValue;"]}
{"method": ["    public RequestCallback filter(Method method, Response response, RequestCallback callback) {", "        final CacheKey ck = cacheKey(method.builder);", "            cacheResult(method, response);"], "response": ["    public RequestCallback filter(Method method, Response response, RequestCallback callback) {", "        int code = response.getStatusCode();", "                public void onResponseReceived(Request request, Response response) {", "                        cb.onResponseReceived(request, response);", "            cacheResult(method, response);"], "callback": ["    public RequestCallback filter(Method method, Response response, RequestCallback callback) {", "            return callback;", "        return callback;"]}
{"classes": ["    private String[] getAnnotationsAsStringArray(Class[] classes) {", "        if (null == classes) {", "        for (Class c : classes) {", "            ret.add(c.getName());"]}
{"callback": ["public Object send(AsyncCallback<JavaScriptObject> callback) {", "        return jsonpBuilder.requestObject(resource.getUri(), callback);"]}
{"parameters": ["            MultivaluedMap<String, String> parameters, String clientId,", "                parameters, clientId, clientSecret, properties,"], "clientId": ["            MultivaluedMap<String, String> parameters, String clientId,", "                parameters, clientId, clientSecret, properties,"], "clientSecret": ["            String clientSecret, String[] clientCertificatePath)", "                parameters, clientId, clientSecret, properties,"], "clientCertificatePath": ["            String clientSecret, String[] clientCertificatePath)", "        if (clientCertificatePath != null && clientCertificatePath.length > 0)", "            clientCertificate = clientCertificatePath[0];", "            if (clientCertificatePath.length > 1)", "                        clientCertificatePath, 1, clientCertificatePath.length);", "        TokenResponse response = getApiCaller().callToken(", "                clientCertificate, clientCertificatePath);", "        Action action = response.getAction();", "        String content = response.getResponseContent();", "                return handlePassword(response);"]}
{"response": ["private Response handlePassword(TokenResponse response)", "        String username = response.getUsername();", "        String password = response.getPassword();", "        String ticket = response.getTicket();"]}
{"ticket": ["public Response handle(String ticket, String[] claimNames, String[] claimLocales) throws WebApplicationException", "            return process(ticket, claimNames, claimLocales);"], "claimNames": ["public Response handle(String ticket, String[] claimNames, String[] claimLocales) throws WebApplicationException", "            return process(ticket, claimNames, claimLocales);"], "claimLocales": ["public Response handle(String ticket, String[] claimNames, String[] claimLocales) throws WebApplicationException", "            return process(ticket, claimNames, claimLocales);"]}
{"ticket": ["private Response process(String ticket, String[] claimNames, String[] claimLocales)", "            return fail(ticket, Reason.DENIED);", "            return fail(ticket, Reason.NOT_AUTHENTICATED);", "        return authorize(ticket, subject, authTime, acr, claims, properties, scopes);"], "claimNames": ["private Response process(String ticket, String[] claimNames, String[] claimLocales)", "        Map<String, Object> claims = collectClaims(subject, claimNames, claimLocales);"], "claimLocales": ["private Response process(String ticket, String[] claimNames, String[] claimLocales)", "        Map<String, Object> claims = collectClaims(subject, claimNames, claimLocales);", "        return authorize(ticket, subject, authTime, acr, claims, properties, scopes);"]}
{"subject": [], "claimNames": ["private Map<String, Object> collectClaims(String subject, String[] claimNames, String[] claimLocales)", "        if (claimNames == null || claimNames.length == 0)", "        for (String claimName : claimNames)", "            if (claimName == null || claimName.length() == 0)", "            String[] elements = claimName.split(\"#\", 2);", "            String name = elements[0];", "            String tag  = (elements.length == 2) ? elements[1] : null;", "            if (name == null || name.length() == 0)", "            Object value = getClaim(name, tag, claimLocales);", "            if (value == null)", "            if (tag == null)", "                claimName = name;", "            claims.put(claimName, value);"], "claimLocales": ["private Map<String, Object> collectClaims(String subject, String[] claimNames, String[] claimLocales)", "        claimLocales = normalizeClaimLocales(claimLocales);", "            Object value = getClaim(name, tag, claimLocales);", "            if (value == null)", "            claims.put(claimName, value);"]}
{"api": ["            AuthleteApi api, AuthorizationDecisionHandlerSpi spi,", "            AuthorizationDecisionHandler handler = new AuthorizationDecisionHandler(api, spi);"], "spi": ["            AuthleteApi api, AuthorizationDecisionHandlerSpi spi,", "            AuthorizationDecisionHandler handler = new AuthorizationDecisionHandler(api, spi);", "            return handler.handle(ticket, claimNames, claimLocales);"], "ticket": ["            String ticket, String[] claimNames, String[] claimLocales)", "            return handler.handle(ticket, claimNames, claimLocales);"], "claimNames": ["            String ticket, String[] claimNames, String[] claimLocales)", "            return handler.handle(ticket, claimNames, claimLocales);"], "claimLocales": ["            String ticket, String[] claimNames, String[] claimLocales)", "            return handler.handle(ticket, claimNames, claimLocales);"]}
{"accessToken": ["public Response userInfoIssue(String accessToken, Map<String, Object> claims)", "        UserInfoIssueResponse response = callUserInfoIssue(accessToken, claims);"], "claims": ["public Response userInfoIssue(String accessToken, Map<String, Object> claims)", "        UserInfoIssueResponse response = callUserInfoIssue(accessToken, claims);", "        UserInfoIssueResponse.Action action = response.getAction();", "        String content = response.getResponseContent();"]}
{"info": ["private static String computeLoginId(AuthorizationResponse info)", "        if (info.getSubject() != null)", "            return info.getSubject();", "        return info.getLoginHint();"]}
{"api": ["public Response handle(AuthleteApi api)", "            JwksRequestHandler handler = new JwksRequestHandler(api);", "            return handler.handle();"]}
{"api": ["public Response handle(AuthleteApi api, MultivaluedMap<String, String> parameters)", "            IntrospectionRequestHandler handler = new IntrospectionRequestHandler(api);", "            return handler.handle(parameters);"], "parameters": ["public Response handle(AuthleteApi api, MultivaluedMap<String, String> parameters)", "            return handler.handle(parameters);"]}
{"configuration": ["private String createServiceOwnerCredentials(AuthleteConfiguration configuration)", "        if (configuration.getServiceOwnerAccessToken() != null)", "            return \"Bearer \" + configuration.getServiceOwnerAccessToken();", "            String key    = configuration.getServiceOwnerApiKey();", "            String secret = configuration.getServiceOwnerApiSecret();"]}
{"configuration": ["private String createServiceCredentials(AuthleteConfiguration configuration)", "        if (configuration.getServiceAccessToken() != null)", "            return \"Bearer \" + configuration.getServiceAccessToken();", "            String key    = configuration.getServiceApiKey();", "            String secret = configuration.getServiceApiSecret();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"client": ["private void setConnectionTimeout(javax.ws.rs.client.Client client)", "        client.property(\"jersey.config.client.connectTimeout\", value);", "        client.property(\"http.connection.timeout\", value);", "        client.property(\"com.ibm.ws.jaxrs.client.connection.timeout\", value);"]}
{"client": ["private void setReadTimeout(javax.ws.rs.client.Client client)", "        client.property(\"jersey.config.client.readTimeout\", value);", "        client.property(\"http.receive.timeout\", value);", "        client.property(\"com.ibm.ws.jaxrs.client.receive.timeout\", value);"]}
{"apiCall": ["private <TResponse> TResponse executeApiCall(AuthleteApiCall<TResponse> apiCall) throws AuthleteApiException", "            return apiCall.call();"]}
{"api": ["            AuthleteApi api, AuthorizationRequestHandlerSpi spi,", "            AuthorizationRequestHandler handler = new AuthorizationRequestHandler(api, spi);"], "spi": ["            AuthleteApi api, AuthorizationRequestHandlerSpi spi,", "            AuthorizationRequestHandler handler = new AuthorizationRequestHandler(api, spi);", "            return handler.handle(parameters);"], "parameters": ["            MultivaluedMap<String, String> parameters)", "            return handler.handle(parameters);"]}
{"parameters": ["private Response process(MultivaluedMap<String, String> parameters)", "        StandardIntrospectionResponse response = getApiCaller().callStandardIntrospection(parameters);", "        Action action = response.getAction();", "        String content = response.getResponseContent();"]}
{"accessToken": ["private Response process(String accessToken)", "        UserInfoResponse response = getApiCaller().callUserInfo(accessToken);", "        Action action = response.getAction();", "        String content = response.getResponseContent();", "                return getUserInfo(response);"]}
{"api": ["            AuthleteApi api, UserInfoRequestHandlerSpi spi, String accessToken)", "            UserInfoRequestHandler handler = new UserInfoRequestHandler(api, spi);"], "spi": ["            AuthleteApi api, UserInfoRequestHandlerSpi spi, String accessToken)", "            UserInfoRequestHandler handler = new UserInfoRequestHandler(api, spi);", "            return handler.handle(accessToken);"], "accessToken": ["            AuthleteApi api, UserInfoRequestHandlerSpi spi, String accessToken)", "            return handler.handle(accessToken);"]}
{"parameters": ["private Response process(MultivaluedMap<String, String> parameters)", "        AuthorizationResponse response = getApiCaller().callAuthorization(parameters);", "        AuthorizationResponse.Action action = response.getAction();", "        String content = response.getResponseContent();", "                return handleInteraction(response);", "                return handleNoInteraction(response);"]}
{"response": ["private void noInteractionCheckAuthentication(AuthorizationResponse response)", "        throw getApiCaller().authorizationFail(response.getTicket(), Reason.NOT_LOGGED_IN);"]}
{"parameters": ["private Response process(MultivaluedMap<String, String> parameters, String clientId, String clientSecret)", "        RevocationResponse response = getApiCaller().callRevocation(parameters, clientId, clientSecret);"], "clientId": ["private Response process(MultivaluedMap<String, String> parameters, String clientId, String clientSecret)", "        RevocationResponse response = getApiCaller().callRevocation(parameters, clientId, clientSecret);"], "clientSecret": ["private Response process(MultivaluedMap<String, String> parameters, String clientId, String clientSecret)", "        RevocationResponse response = getApiCaller().callRevocation(parameters, clientId, clientSecret);", "        Action action = response.getAction();", "        String content = response.getResponseContent();"]}
{"request": ["protected String extractClientCertificate(HttpServletRequest request)", "        String[] certs = extractClientCertificateChain(request);", "        if (certs != null && certs.length > 0)", "            return certs[0];"]}
{"event": ["public void updateImpliedStores( @Observes final ArtifactStorePreUpdateEvent event )", "            final Map<StoreKey, ArtifactStore> currentStores = mapStores( event );", "            for ( final ArtifactStore store : event )", "                logger.debug( \"Processing store: {} for implied repo metadata\", store );", "                processStore( store, currentStores );"]}
{"pair": ["public static X509Certificate generateX509Certificate( KeyPair pair, String dn, int days, String algorithm )", "        PrivateKey privateKey = pair.getPrivate();", "        info.set( X509CertInfo.KEY, new CertificateX509Key( pair.getPublic() ) );"], "dn": ["public static X509Certificate generateX509Certificate( KeyPair pair, String dn, int days, String algorithm )", "        X500Name owner = new X500Name( dn );", "        info.set( X509CertInfo.SUBJECT, owner );", "        info.set( X509CertInfo.ISSUER, owner );"], "days": ["public static X509Certificate generateX509Certificate( KeyPair pair, String dn, int days, String algorithm )", "        Date to = new Date( from.getTime() + TimeUnit.DAYS.toMillis( days ) );", "        CertificateValidity interval = new CertificateValidity( from, to );", "        info.set( X509CertInfo.VALIDITY, interval );"], "algorithm": ["public static X509Certificate generateX509Certificate( KeyPair pair, String dn, int days, String algorithm )", "        cert.sign( privateKey, algorithm );", "        cert.sign( privateKey, algorithm );"]}
{"nodePrefix": ["public static String getName( String nodePrefix, String name, String defaultName, String... suffix )", "        return name( name( nodePrefix, name ), suffix );"], "name": ["public static String getName( String nodePrefix, String name, String defaultName, String... suffix )", "        if ( isBlank( name ) || name.equals( DEFAULT ) )", "        return name( name( nodePrefix, name ), suffix );"], "defaultName": ["public static String getName( String nodePrefix, String name, String defaultName, String... suffix )", "            name = defaultName;", "        return name( name( nodePrefix, name ), suffix );"]}
{"transfer": ["public Transfer generateRelationshipFile( Transfer transfer, TransferOperation op )", "        logger.debug( \"Relate generation for {}\", transfer );", "        if ( transfer == null )", "        String txfrPath = transfer.getPath();", "        ConcreteResource pomResource = transfer.getResource();", "        StoreKey storeKey = StoreKey.fromString( transfer.getLocation().getName() );", "            MavenPomView pomView = mavenPomReader.read( ref, transfer, supplementalLocations, ALL_PROFILES );", "            Transfer transferRel = transfer.getSiblingMeta( REL_SUFFIX );"], "op": ["public Transfer generateRelationshipFile( Transfer transfer, TransferOperation op )", "            writeRelationships( rel, transferRel, op );"]}
{"Result": "Method without Parameter"}
{"key": ["private void addSnapshotDataObject( String key, Snapshot snapshot, long clock, List<DataObject> dataObjectList )", "        dataObjectList.add( toDataObject( key, \".min\", snapshot.getMin(), clock ) );", "        dataObjectList.add( toDataObject( key, \".max\", snapshot.getMax(), clock ) );", "        dataObjectList.add( toDataObject( key, \".mean\", snapshot.getMean(), clock ) );", "        dataObjectList.add( toDataObject( key, \".stddev\", snapshot.getStdDev(), clock ) );", "        dataObjectList.add( toDataObject( key, \".median\", snapshot.getMedian(), clock ) );", "        dataObjectList.add( toDataObject( key, \".75th\", snapshot.get75thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".95th\", snapshot.get95thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".98th\", snapshot.get98thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".99th\", snapshot.get99thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".99.9th\", snapshot.get999thPercentile(), clock ) );"], "snapshot": ["private void addSnapshotDataObject( String key, Snapshot snapshot, long clock, List<DataObject> dataObjectList )", "        dataObjectList.add( toDataObject( key, \".min\", snapshot.getMin(), clock ) );", "        dataObjectList.add( toDataObject( key, \".max\", snapshot.getMax(), clock ) );", "        dataObjectList.add( toDataObject( key, \".mean\", snapshot.getMean(), clock ) );", "        dataObjectList.add( toDataObject( key, \".stddev\", snapshot.getStdDev(), clock ) );", "        dataObjectList.add( toDataObject( key, \".median\", snapshot.getMedian(), clock ) );", "        dataObjectList.add( toDataObject( key, \".75th\", snapshot.get75thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".95th\", snapshot.get95thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".98th\", snapshot.get98thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".99th\", snapshot.get99thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".99.9th\", snapshot.get999thPercentile(), clock ) );"], "clock": ["private void addSnapshotDataObject( String key, Snapshot snapshot, long clock, List<DataObject> dataObjectList )", "        dataObjectList.add( toDataObject( key, \".min\", snapshot.getMin(), clock ) );", "        dataObjectList.add( toDataObject( key, \".max\", snapshot.getMax(), clock ) );", "        dataObjectList.add( toDataObject( key, \".mean\", snapshot.getMean(), clock ) );", "        dataObjectList.add( toDataObject( key, \".stddev\", snapshot.getStdDev(), clock ) );", "        dataObjectList.add( toDataObject( key, \".median\", snapshot.getMedian(), clock ) );", "        dataObjectList.add( toDataObject( key, \".75th\", snapshot.get75thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".95th\", snapshot.get95thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".98th\", snapshot.get98thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".99th\", snapshot.get99thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".99.9th\", snapshot.get999thPercentile(), clock ) );"], "dataObjectList": ["private void addSnapshotDataObject( String key, Snapshot snapshot, long clock, List<DataObject> dataObjectList )", "        dataObjectList.add( toDataObject( key, \".min\", snapshot.getMin(), clock ) );", "        dataObjectList.add( toDataObject( key, \".max\", snapshot.getMax(), clock ) );", "        dataObjectList.add( toDataObject( key, \".mean\", snapshot.getMean(), clock ) );", "        dataObjectList.add( toDataObject( key, \".stddev\", snapshot.getStdDev(), clock ) );", "        dataObjectList.add( toDataObject( key, \".median\", snapshot.getMedian(), clock ) );", "        dataObjectList.add( toDataObject( key, \".75th\", snapshot.get75thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".95th\", snapshot.get95thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".98th\", snapshot.get98thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".99th\", snapshot.get99thPercentile(), clock ) );", "        dataObjectList.add( toDataObject( key, \".99.9th\", snapshot.get999thPercentile(), clock ) );"]}
{"url": ["private String getRemoteRepositoryName( URL url ) throws IndyDataException", "        final String name = repoCreator.formatId( url.getHost(), getPort( url ), 0, null, StoreType.remote );"]}
{"names": ["public String getNextName( List<String> names )", "        if ( names.isEmpty() )", "        String name0 = names.get( 0 );", "        if ( names.size() == 1 )", "        Collections.sort( names );", "        String last = names.get( names.size() - 1 );"]}
{"topic": ["public void send( String topic, String message, LogbackFormatter formatter ) throws IOException", "        doKafkaSend( topic, message, formatter );"], "message": ["public void send( String topic, String message, LogbackFormatter formatter ) throws IOException", "        doKafkaSend( topic, message, formatter );"], "formatter": ["public void send( String topic, String message, LogbackFormatter formatter ) throws IOException", "        doKafkaSend( topic, message, formatter );"]}
{"topic": ["public void send( String topic, String message, long timeoutMillis )", "        send( topic, message, null, timeoutMillis );"], "message": ["public void send( String topic, String message, long timeoutMillis )", "        send( topic, message, null, timeoutMillis );"], "timeoutMillis": ["public void send( String topic, String message, long timeoutMillis )", "        send( topic, message, null, timeoutMillis );"]}
{"topic": ["public void send( String topic, String message, LogbackFormatter formatter, long timeoutMillis )", "        Future future = doKafkaSend( topic, message, formatter );"], "message": ["public void send( String topic, String message, LogbackFormatter formatter, long timeoutMillis )", "        Future future = doKafkaSend( topic, message, formatter );"], "formatter": ["public void send( String topic, String message, LogbackFormatter formatter, long timeoutMillis )", "        Future future = doKafkaSend( topic, message, formatter );", "        if ( future != null )", "            future.get( timeoutMillis, TimeUnit.MILLISECONDS );"], "timeoutMillis": ["public void send( String topic, String message, LogbackFormatter formatter, long timeoutMillis )", "            future.get( timeoutMillis, TimeUnit.MILLISECONDS );"]}
{"Result": "Method without Parameter"}
{"out": ["public static void zipTrackedContent( File out, Set<TrackedContent> sealed ) throws IOException", "        logger.info( \"Writing sealed zip to: '{}'\", out.getAbsolutePath() );", "        try (ZipOutputStream zip = new ZipOutputStream( new FileOutputStream( out ) ))"], "sealed": ["public static void zipTrackedContent( File out, Set<TrackedContent> sealed ) throws IOException", "            for ( TrackedContent f : sealed )", "                String name = SEALED.getValue() + \"/\" + f.getKey().getId();", "                logger.trace( \"Adding {} to zip\", name );", "                zip.putNextEntry( new ZipEntry( name ) );", "                copy( toInputStream( f ), zip );"]}
{"inputStream": ["public static int readZipInputStreamAnd( InputStream inputStream, Consumer<TrackedContent> consumer )", "        try ( ZipInputStream stream = new ZipInputStream( inputStream ) )"], "consumer": ["public static int readZipInputStreamAnd( InputStream inputStream, Consumer<TrackedContent> consumer )", "                consumer.accept( record );"]}
{"targetName": ["private StoreKey getTargetKey( final String targetName )", "        return targetGroupKeyMap.computeIfAbsent( targetName,", "                                                                     StoreType.group, targetName ) );"]}
{"store": ["public static boolean checkListingMask( final ArtifactStore store, final String path )", "        Set<String> maskPatterns = store.getPathMaskPatterns();", "        logger.trace( \"Checking mask in: {}\", store.getKey() );", "        logger.trace( \"Mask patterns in {}: {}\", store.getName(), maskPatterns );", "            logger.trace( \"Checking mask in: {}, - NO PATTERNS\", store.getName() );", "                logger.trace( \"Checking mask in: {}, pattern: {} - MATCH\", store.getName(), pattern );", "        logger.debug( \"Listing for path {} not enabled by path mask {} of repo {}\", path, maskPatterns, store.getKey() );"], "path": ["public static boolean checkListingMask( final ArtifactStore store, final String path )", "            if ( path.startsWith( pattern ) || pattern.startsWith( path ) )", "        logger.debug( \"Listing for path {} not enabled by path mask {} of repo {}\", path, maskPatterns, store.getKey() );"]}
{"item": ["private void clearObsoleteFiles( Transfer item )", "        Transfer httpMeta = item.getSiblingMeta( HTTP_METADATA_EXT );"]}
{"repoName": ["public String parse( String repoName )", "        if ( repoName.startsWith( KOJI_BINARY_ ) )", "        else if ( repoName.startsWith( KOJI_ ) )", "            return repoName.substring( prefix.length() );"]}
{"packageType": ["    public Response exists( final @PathParam( \"packageType\" ) String packageType,", "        logger.info( \"Checking for existence of: {}:{}:{}\", packageType, st, name );", "        if ( adminController.exists( new StoreKey( packageType, st, name ) ) )"], "type": ["                            @PathParam( \"type\" ) String type,", "        final StoreType st = StoreType.get( type );", "        logger.info( \"Checking for existence of: {}:{}:{}\", packageType, st, name );", "        if ( adminController.exists( new StoreKey( packageType, st, name ) ) )"], "name": ["                            @ApiParam( required = true ) @PathParam( \"name\" ) final String name )", "        logger.info( \"Checking for existence of: {}:{}:{}\", packageType, st, name );", "        if ( adminController.exists( new StoreKey( packageType, st, name ) ) )"]}
{"manager": ["public static void loadFromDiskAnd( DataFileManager manager, IndyObjectMapper serializer,", "        loadFromDiskAnd( manager, serializer, null, summary, consumer );"], "serializer": ["public static void loadFromDiskAnd( DataFileManager manager, IndyObjectMapper serializer,", "        loadFromDiskAnd( manager, serializer, null, summary, consumer );"], "summary": ["                                        final ChangeSummary summary, Consumer<ArtifactStore> consumer )", "        loadFromDiskAnd( manager, serializer, null, summary, consumer );"], "consumer": ["                                        final ChangeSummary summary, Consumer<ArtifactStore> consumer )", "        loadFromDiskAnd( manager, serializer, null, summary, consumer );"]}
{"manager": ["public static void loadFromDiskAnd( DataFileManager manager, IndyObjectMapper serializer, StoreKey key,", "            DataFile f = manager.getDataFile( INDY_STORE, key.getPackageType(), key.getType().singularEndpointName(),", "        DataFile[] packageDirs = manager.getDataFile( INDY_STORE ).listFiles( ( f ) -> true );"], "serializer": ["public static void loadFromDiskAnd( DataFileManager manager, IndyObjectMapper serializer, StoreKey key,", "                    store = serializer.readValue( json, key.getType().getStoreClass() );", "                            final ArtifactStore store = serializer.readValue( json, type.getStoreClass() );", "                            if ( store == null )", "                                consumer.accept( store );"], "key": ["public static void loadFromDiskAnd( DataFileManager manager, IndyObjectMapper serializer, StoreKey key,", "        if ( key != null ) // Load a single file", "            DataFile f = manager.getDataFile( INDY_STORE, key.getPackageType(), key.getType().singularEndpointName(),", "                                              key.getName() + \".json\" );", "                    store = serializer.readValue( json, key.getType().getStoreClass() );"], "summary": ["                                        final ChangeSummary summary, Consumer<ArtifactStore> consumer )", "                                f.delete( summary );", "                                f.delete( summary );"], "consumer": ["                                        final ChangeSummary summary, Consumer<ArtifactStore> consumer )", "                consumer.accept( store );", "                                consumer.accept( store );"]}
{"fileInput": ["public HostedRepository createStoreByArc( final InputStream fileInput, final String repoName, final String user,", "        storeZipContentInHosted( fileInput, ignoredPrefix, repo );"], "repoName": ["public HostedRepository createStoreByArc( final InputStream fileInput, final String repoName, final String user,", "        final HostedRepository repo = createHostedByName( repoName, user, \"Create hosted by zip.\" );"], "user": ["public HostedRepository createStoreByArc( final InputStream fileInput, final String repoName, final String user,", "        final HostedRepository repo = createHostedByName( repoName, user, \"Create hosted by zip.\" );"], "ignoredPrefix": ["                                              final String ignoredPrefix )", "        storeZipContentInHosted( fileInput, ignoredPrefix, repo );"]}
{"siteId": ["public HttpClientContext createContext( final String siteId ) throws IndyHttpException", "            return httpFactory.createContext( siteConfigLookup.lookup( siteId ) );"]}
{"siteId": ["public CloseableHttpClient createClient( final String siteId ) throws IndyHttpException", "            return httpFactory.createClient( siteConfigLookup.lookup( siteId ) );"]}
{"packageType": ["private KojiRepairResult.RepairResult doRepair( String packageType, RemoteRepository repository,", "            storeKey = new StoreKey( packageType, StoreType.remote, name );"], "repository": ["private KojiRepairResult.RepairResult doRepair( String packageType, RemoteRepository repository,", "        if ( repository != null )", "            storeKey = repository.getKey();", "        String url = repository.getUrl();", "                repository.setUrl( newUrl );", "                repository.setMetadata( METADATA_KOJI_BUILD_ID, Integer.toString( buildInfo.getId() ) );", "                    storeManager.storeArtifactStore( repository, changeSummary, skipIfExists, fireEvents, new EventMetadata() );"], "buildInfo": ["                                                    KojiBuildInfo buildInfo, String user, boolean isDryRun )", "            String name = kojiUtils.getRepositoryName( buildInfo );", "            storeKey = new StoreKey( packageType, StoreType.remote, name );", "                repository = (RemoteRepository) storeManager.getArtifactStore( storeKey );", "                throw new KojiRepairException( \"Cannot get store: %s. Reason: %s\", e, storeKey,", "        KojiRepairResult.RepairResult repairResult = new KojiRepairResult.RepairResult( storeKey );", "        String url = repository.getUrl();", "            newUrl = kojiUtils.formatStorageUrl( config.getStorageRootUrl(), buildInfo ); // volume is involved", "            throw new KojiRepairException( \"Failed to format storage Url: %s. Reason: %s\", e, storeKey,", "        boolean changed = !url.equals( newUrl );", "        if ( changed )", "            repairResult.withPropertyChange( \"url\", url, newUrl );", "                                                                 \"Repair \" + storeKey + \" url with volume: \" + buildInfo", "                repository.setUrl( newUrl );", "                repository.setMetadata( METADATA_KOJI_BUILD_ID, Integer.toString( buildInfo.getId() ) );", "                    storeManager.storeArtifactStore( repository, changeSummary, skipIfExists, fireEvents, new EventMetadata() );", "                    throw new KojiRepairException( \"Failed to repair store: %s. Reason: %s\", e, storeKey, e.getMessage() );", "        return repairResult;"], "user": ["                                                    KojiBuildInfo buildInfo, String user, boolean isDryRun )", "                ChangeSummary changeSummary = new ChangeSummary( user,"], "isDryRun": ["                                                    KojiBuildInfo buildInfo, String user, boolean isDryRun )", "            if ( !isDryRun )"]}
{"store": ["private void handleGroupMembersChanged(final ArtifactStore store,", "        final StoreKey key = store.getKey();", "            final List<StoreKey> newMembers = ( (Group) store ).getConstituents();", "            logger.trace( \"New members of: {} are: {}\", store.getKey(), newMembers );", "            final Group group = (Group) changeMap.get( store );", "            final List<StoreKey> oldMembers = group.getConstituents();", "            logger.trace( \"Old members of: {} are: {}\", group.getName(), oldMembers );", "                logger.trace( \"Membership change confirmed. Clearing caches for group: {} and groups affected by it.\", group.getKey() );", "                clearGroupMetaCache( group, group );", "                    storeManager.query().getGroupsAffectedBy( group.getKey() ).forEach( g -> clearGroupMetaCache( g, group ) );", "                    logger.error( String.format( \"Can not get affected groups of %s\", group.getKey() ), e );"], "changeMap": ["                                           final Map<ArtifactStore, ArtifactStore> changeMap)", "            final Group group = (Group) changeMap.get( store );"]}
{"Result": "Method without Parameter"}
{"streamRef": ["protected static ArrayList<FileRange> getFileRanges(InputStream streamRef) throws ParserConfigurationException,", "        saxParser.parse(streamRef, handler);"]}
{"stream": ["public static ArrayList<CloudQueueMessage> readMessages(final InputStream stream, final boolean shouldEncodeMessage)", "        saxParser.parse(stream, handler);"], "shouldEncodeMessage": ["public static ArrayList<CloudQueueMessage> readMessages(final InputStream stream, final boolean shouldEncodeMessage)", "        QueueMessageHandler handler = new QueueMessageHandler(shouldEncodeMessage);", "        saxParser.parse(stream, handler);", "        return handler.messages;"]}
{"options": ["    public boolean createIfNotExists(TableRequestOptions options, OperationContext opContext) throws StorageException {", "        options = TableRequestOptions.populateAndApplyDefaults(options, this.tableServiceClient);"], "opContext": ["    public boolean createIfNotExists(TableRequestOptions options, OperationContext opContext) throws StorageException {", "        boolean exists = this.exists(true, options, opContext);", "        if (exists) {", "                this.create(options, opContext);"]}
{"options": ["    public void delete(TableRequestOptions options, OperationContext opContext) throws StorageException {", "        options = TableRequestOptions.populateAndApplyDefaults(options, this.tableServiceClient);"], "opContext": ["    public void delete(TableRequestOptions options, OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "        opContext.initialize();", "        deleteOp.execute(this.tableServiceClient, TableConstants.TABLES_SERVICE_TABLES_NAME, options, opContext);"]}
{"options": ["    public boolean deleteIfExists(TableRequestOptions options, OperationContext opContext) throws StorageException {", "        options = TableRequestOptions.populateAndApplyDefaults(options, this.tableServiceClient);"], "opContext": ["    public boolean deleteIfExists(TableRequestOptions options, OperationContext opContext) throws StorageException {", "        if (this.exists(true, options, opContext)) {", "                this.delete(options, opContext);"]}
{"permissions": ["    public void uploadPermissions(final TablePermissions permissions, TableRequestOptions options,", "                this.uploadPermissionsImpl(permissions, options), options.getRetryPolicyFactory(), opContext);"], "options": ["    public void uploadPermissions(final TablePermissions permissions, TableRequestOptions options,", "        options = TableRequestOptions.populateAndApplyDefaults(options, this.tableServiceClient);"], "opContext": ["            OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "        opContext.initialize();", "                this.uploadPermissionsImpl(permissions, options), options.getRetryPolicyFactory(), opContext);"]}
{"options": ["    public TablePermissions downloadPermissions(TableRequestOptions options, OperationContext opContext)", "        options = TableRequestOptions.populateAndApplyDefaults(options, this.tableServiceClient);"], "opContext": ["    public TablePermissions downloadPermissions(TableRequestOptions options, OperationContext opContext)", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"modifiedOptions": ["protected static void applyBaseDefaultsInternal(final RequestOptions modifiedOptions) {", "        Utility.assertNotNull(\"modifiedOptions\", modifiedOptions);", "        if (modifiedOptions.getRetryPolicyFactory() == null) {", "            modifiedOptions.setRetryPolicyFactory(new RetryExponentialRetry());", "        if (modifiedOptions.getLocationMode() == null) {", "            modifiedOptions.setLocationMode(LocationMode.PRIMARY_ONLY);"]}
{"stream": ["public static StorageExtendedErrorInformation getExtendedErrorInformation(final InputStream stream)", "        saxParser.parse(stream, handler);"]}
{"sequenceNumber": ["public static AccessCondition generateIfSequenceNumberLessThanOrEqualCondition(long sequenceNumber) {", "        retCondition.ifSequenceNumberLessThanOrEqual = sequenceNumber;", "        return retCondition;"]}
{"sequenceNumber": ["public static AccessCondition generateIfSequenceNumberLessThanCondition(long sequenceNumber) {", "        retCondition.ifSequenceNumberLessThan = sequenceNumber;", "        return retCondition;"]}
{"sequenceNumber": ["public static AccessCondition generateIfSequenceNumberEqualCondition(long sequenceNumber) {", "        retCondition.ifSequenceNumberEqual = sequenceNumber;", "        return retCondition;"]}
{"request": ["public void applyConditionToRequest(final HttpURLConnection request) {", "        applyLeaseConditionToRequest(request);", "            request.setRequestProperty(Constants.HeaderConstants.IF_MODIFIED_SINCE,", "            request.setRequestProperty(Constants.HeaderConstants.IF_UNMODIFIED_SINCE,", "            request.setRequestProperty(Constants.HeaderConstants.IF_MATCH, this.ifMatchETag);", "            request.setRequestProperty(Constants.HeaderConstants.IF_NONE_MATCH, this.ifNoneMatchETag);"]}
{"request": ["public void applySourceConditionToRequest(final HttpURLConnection request) {    ", "            request.setRequestProperty(", "            request.setRequestProperty(Constants.HeaderConstants.SOURCE_IF_UNMODIFIED_SINCE_HEADER,", "            request.setRequestProperty(", "            request.setRequestProperty("]}
{"request": ["public void applyAppendConditionToRequest(final HttpURLConnection request) {", "            request.setRequestProperty(Constants.HeaderConstants.IF_MAX_SIZE_LESS_THAN_OR_EQUAL,", "            request.setRequestProperty(Constants.HeaderConstants.IF_APPEND_POSITION_EQUAL_HEADER,"]}
{"request": ["public void applyLeaseConditionToRequest(final HttpURLConnection request) {", "            request.setRequestProperty(Constants.HeaderConstants.LEASE_ID_HEADER, this.leaseID);"]}
{"request": ["public void applySequenceConditionToRequest(final HttpURLConnection request) {", "            request.setRequestProperty(", "            request.setRequestProperty(", "            request.setRequestProperty("]}
{"etag": ["public boolean verifyConditional(final String etag, final Date lastModified) {", "            if (!this.ifMatchETag.equals(etag) && !this.ifMatchETag.equals(\"*\")) {", "            if (this.ifNoneMatchETag.equals(etag)) {"], "lastModified": ["public boolean verifyConditional(final String etag, final Date lastModified) {", "            if (!lastModified.after(this.ifModifiedSinceDate)) {", "            if (lastModified.after(this.ifUnmodifiedSinceDate)) {"]}
{"filterA": ["public static String combineFilters(String filterA, String operator, String filterB) {", "        return String.format(\"(%s) %s (%s)\", filterA, operator, filterB);"], "operator": ["public static String combineFilters(String filterA, String operator, String filterB) {", "        return String.format(\"(%s) %s (%s)\", filterA, operator, filterB);"], "filterB": ["public static String combineFilters(String filterA, String operator, String filterB) {", "        return String.format(\"(%s) %s (%s)\", filterA, operator, filterB);"]}
{"storageUri": ["protected final void setStorageUri(final StorageUri storageUri) {", "        this.usePathStyleUris = Utility.determinePathStyleFromUri(storageUri.getPrimaryUri());", "        this.storageUri = storageUri;"]}
{"sharedAccessPolicies": ["            final HashMap<String, T> sharedAccessPolicies, final StringWriter outWriter)", "        Utility.assertNotNull(\"sharedAccessPolicies\", sharedAccessPolicies);", "        if (sharedAccessPolicies.keySet().size() > Constants.MAX_SHARED_ACCESS_POLICY_IDENTIFIERS) {", "                    sharedAccessPolicies.keySet().size(), Constants.MAX_SHARED_ACCESS_POLICY_IDENTIFIERS);", "        for (final Entry<String, T> entry : sharedAccessPolicies.entrySet()) {", "            final SharedAccessPolicy policy = entry.getValue();", "            Utility.serializeElement(xmlw, Constants.ID, entry.getKey());", "                    .getUTCTimeOrEmpty(policy.getSharedAccessStartTime()).toString());", "                    Utility.getUTCTimeOrEmpty(policy.getSharedAccessExpiryTime()).toString());", "            Utility.serializeElement(xmlw, Constants.PERMISSION, policy.permissionsToString());"], "outWriter": ["            final HashMap<String, T> sharedAccessPolicies, final StringWriter outWriter)", "        Utility.assertNotNull(\"outWriter\", outWriter);", "        final XmlSerializer xmlw = Utility.getXmlSerializer(outWriter);", "        xmlw.startDocument(Constants.UTF8_CHARSET, true);", "        xmlw.startTag(Constants.EMPTY_STRING, Constants.SIGNED_IDENTIFIERS_ELEMENT);", "            xmlw.startTag(Constants.EMPTY_STRING, Constants.SIGNED_IDENTIFIER_ELEMENT);", "            Utility.serializeElement(xmlw, Constants.ID, entry.getKey());", "            xmlw.startTag(Constants.EMPTY_STRING, Constants.ACCESS_POLICY);", "            Utility.serializeElement(xmlw, Constants.START, Utility", "            Utility.serializeElement(xmlw, Constants.EXPIRY,", "            Utility.serializeElement(xmlw, Constants.PERMISSION, policy.permissionsToString());", "            xmlw.endTag(Constants.EMPTY_STRING, Constants.ACCESS_POLICY);", "            xmlw.endTag(Constants.EMPTY_STRING, Constants.SIGNED_IDENTIFIER_ELEMENT);", "        xmlw.endTag(Constants.EMPTY_STRING, Constants.SIGNED_IDENTIFIERS_ELEMENT);", "        xmlw.endDocument();"]}
{"message": ["public static byte[] generateMessageRequestBody(final String message) throws IllegalArgumentException,", "        Utility.serializeElement(xmlw, QueueConstants.MESSAGE_TEXT_ELEMENT, message);"]}
{"conn": ["private static void addCanonicalizedHeaders(final HttpURLConnection conn, final StringBuilder canonicalizedString) {", "        final Map<String, List<String>> headers = conn.getRequestProperties();"], "canonicalizedString": ["private static void addCanonicalizedHeaders(final HttpURLConnection conn, final StringBuilder canonicalizedString) {", "                appendCanonicalizedElement(canonicalizedString, canonicalizedElement.toString());"]}
{"builder": ["protected static void appendCanonicalizedElement(final StringBuilder builder, final String element) {", "        builder.append(\"\\n\");", "        builder.append(element);"], "element": ["protected static void appendCanonicalizedElement(final StringBuilder builder, final String element) {", "        builder.append(element);"]}
{"address": ["protected static String canonicalizeHttpRequest(final java.net.URL address, final String accountName,", "        appendCanonicalizedElement(canonicalizedString, getCanonicalizedResource(address, accountName));"], "accountName": ["protected static String canonicalizeHttpRequest(final java.net.URL address, final String accountName,", "        appendCanonicalizedElement(canonicalizedString, getCanonicalizedResource(address, accountName));"], "method": [], "contentType": ["            final String method, final String contentType, final long contentLength, final String date,", "        appendCanonicalizedElement(canonicalizedString, contentType != null ? contentType : Constants.EMPTY_STRING);"], "contentLength": ["            final String method, final String contentType, final long contentLength, final String date,", "                contentLength <= 0 ? Constants.EMPTY_STRING : String.valueOf(contentLength));"], "date": ["            final String method, final String contentType, final long contentLength, final String date,", "        appendCanonicalizedElement(canonicalizedString, dateString.equals(Constants.EMPTY_STRING) ? date"], "conn": ["            final HttpURLConnection conn) throws StorageException {", "        canonicalizedString.append(conn.getRequestMethod());", "                Utility.getStandardHeaderValue(conn, Constants.HeaderConstants.CONTENT_ENCODING));", "                Utility.getStandardHeaderValue(conn, Constants.HeaderConstants.CONTENT_LANGUAGE));", "                Utility.getStandardHeaderValue(conn, Constants.HeaderConstants.CONTENT_MD5));", "        final String dateString = Utility.getStandardHeaderValue(conn, Constants.HeaderConstants.DATE);", "                Utility.getStandardHeaderValue(conn, Constants.HeaderConstants.IF_MODIFIED_SINCE));", "                Utility.getStandardHeaderValue(conn, Constants.HeaderConstants.IF_MATCH));", "                Utility.getStandardHeaderValue(conn, Constants.HeaderConstants.IF_NONE_MATCH));", "                Utility.getStandardHeaderValue(conn, Constants.HeaderConstants.IF_UNMODIFIED_SINCE));", "                Utility.getStandardHeaderValue(conn, Constants.HeaderConstants.RANGE));", "        addCanonicalizedHeaders(conn, canonicalizedString);"]}
{"address": ["protected static String canonicalizeTableHttpRequest(final java.net.URL address, final String accountName,", "        appendCanonicalizedElement(canonicalizedString, getCanonicalizedResourceLite(address, accountName));"], "accountName": ["protected static String canonicalizeTableHttpRequest(final java.net.URL address, final String accountName,", "        appendCanonicalizedElement(canonicalizedString, getCanonicalizedResourceLite(address, accountName));"], "method": [], "contentType": ["            final String method, final String contentType, final long contentLength, final String date,", "        appendCanonicalizedElement(canonicalizedString, contentType);"], "contentLength": [], "date": ["            final String method, final String contentType, final long contentLength, final String date,", "        appendCanonicalizedElement(canonicalizedString, dateString.equals(Constants.EMPTY_STRING) ? date : dateString);"], "conn": ["            final HttpURLConnection conn) throws StorageException {", "        canonicalizedString.append(conn.getRequestMethod());", "        final String httpContentMD5Value = Utility.getStandardHeaderValue(conn, Constants.HeaderConstants.CONTENT_MD5);", "        final String dateString = Utility.getStandardHeaderValue(conn, Constants.HeaderConstants.DATE);"]}
{"creds": ["public static synchronized String computeHmac256(final StorageCredentials creds, final String value) throws InvalidKeyException {", "        if (creds.getClass().equals(StorageCredentialsAccountAndKey.class)) {", "            return Base64.encode(((StorageCredentialsAccountAndKey) creds).getHmac256().doFinal(utf8Bytes));"], "value": ["public static synchronized String computeHmac256(final StorageCredentials creds, final String value) throws InvalidKeyException {", "                utf8Bytes = value.getBytes(Constants.UTF8_CHARSET);"]}
{"creds": ["public static void signTableRequest(final StorageCredentials creds, final java.net.HttpURLConnection request,", "        if (creds.getClass().equals(StorageCredentialsAccountAndKey.class)) {", "            final String stringToSign = canonicalizer.canonicalize(request, creds.getAccountName(), contentLength);", "            final String computedBase64Signature = StorageCredentialsHelper.computeHmac256(creds, stringToSign);", "                    String.format(\"%s %s:%s\", \"SharedKey\", creds.getAccountName(), computedBase64Signature));"], "request": ["public static void signTableRequest(final StorageCredentials creds, final java.net.HttpURLConnection request,", "            request.setRequestProperty(Constants.HeaderConstants.DATE, Utility.getGMTTime());", "            final Canonicalizer canonicalizer = CanonicalizerFactory.getTableCanonicalizer(request);", "            final String stringToSign = canonicalizer.canonicalize(request, creds.getAccountName(), contentLength);", "            request.setRequestProperty(Constants.HeaderConstants.AUTHORIZATION,"], "contentLength": ["            final long contentLength, OperationContext opContext) throws InvalidKeyException, StorageException {", "            final String stringToSign = canonicalizer.canonicalize(request, creds.getAccountName(), contentLength);", "            final String computedBase64Signature = StorageCredentialsHelper.computeHmac256(creds, stringToSign);", "            Logger.debug(opContext, LogConstants.SIGNING, stringToSign);", "                    String.format(\"%s %s:%s\", \"SharedKey\", creds.getAccountName(), computedBase64Signature));"], "opContext": ["            final long contentLength, OperationContext opContext) throws InvalidKeyException, StorageException {", "            opContext = opContext == null ? new OperationContext() : opContext;", "            Logger.debug(opContext, LogConstants.SIGNING, stringToSign);"]}
{"messages": ["private static CloudQueueMessage getFirstOrNull(final Iterable<CloudQueueMessage> messages) {", "        for (final CloudQueueMessage m : messages) {", "            return m;"]}
{"message": ["    public void addMessage(final CloudQueueMessage message, final int timeToLiveInSeconds,", "        Utility.assertNotNull(\"message\", message);", "        Utility.assertNotNull(\"messageContent\", message.getMessageContentAsByte());", "            this.addMessageImpl(message, realTimeToLiveInSeconds, initialVisibilityDelayInSeconds, options),"], "timeToLiveInSeconds": ["    public void addMessage(final CloudQueueMessage message, final int timeToLiveInSeconds,", "        Utility.assertInBounds(\"timeToLiveInSeconds\", timeToLiveInSeconds, 0,", "        final int realTimeToLiveInSeconds = timeToLiveInSeconds == 0 ? QueueConstants.MAX_TIME_TO_LIVE_IN_SECONDS", "                : timeToLiveInSeconds;", "                realTimeToLiveInSeconds - 1);", "            this.addMessageImpl(message, realTimeToLiveInSeconds, initialVisibilityDelayInSeconds, options),"], "initialVisibilityDelayInSeconds": ["            final int initialVisibilityDelayInSeconds, QueueRequestOptions options, OperationContext opContext)", "        Utility.assertInBounds(\"initialVisibilityDelayInSeconds\", initialVisibilityDelayInSeconds, 0,", "            this.addMessageImpl(message, realTimeToLiveInSeconds, initialVisibilityDelayInSeconds, options),"], "options": ["            final int initialVisibilityDelayInSeconds, QueueRequestOptions options, OperationContext opContext)", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this.queueServiceClient);"], "opContext": ["            final int initialVisibilityDelayInSeconds, QueueRequestOptions options, OperationContext opContext)", "        if (opContext == null) {", "        opContext.initialize();", "            options.getRetryPolicyFactory(), opContext);"]}
{"options": ["    public void clear(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this.queueServiceClient);"], "opContext": ["    public void clear(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"options": ["    public void create(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this.queueServiceClient);"], "opContext": ["    public void create(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"options": ["    public boolean createIfNotExists(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this.queueServiceClient);"], "opContext": ["    public boolean createIfNotExists(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        boolean exists = this.exists(true, options, opContext);", "        if (exists) {", "                this.create(options, opContext);"]}
{"options": ["    public void delete(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this.queueServiceClient);"], "opContext": ["    public void delete(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"options": ["    public boolean deleteIfExists(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this.queueServiceClient);"], "opContext": ["    public boolean deleteIfExists(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        boolean exists = this.exists(true, options, opContext);", "        if (exists) {", "                this.delete(options, opContext);"]}
{"message": ["    public void deleteMessage(final CloudQueueMessage message, QueueRequestOptions options, OperationContext opContext)", "        Utility.assertNotNull(\"message\", message);", "        Utility.assertNotNullOrEmpty(\"messageId\", message.getId());", "        Utility.assertNotNullOrEmpty(\"popReceipt\", message.getPopReceipt());", "        ExecutionEngine.executeWithRetry(this.queueServiceClient, this, this.deleteMessageImpl(message, options),"], "options": ["    public void deleteMessage(final CloudQueueMessage message, QueueRequestOptions options, OperationContext opContext)", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this.queueServiceClient);"], "opContext": ["    public void deleteMessage(final CloudQueueMessage message, QueueRequestOptions options, OperationContext opContext)", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"options": ["    public void downloadAttributes(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this.queueServiceClient);"], "opContext": ["    public void downloadAttributes(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"options": ["    public boolean exists(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        return this.exists(false, options, opContext);"], "opContext": ["    public boolean exists(QueueRequestOptions options, OperationContext opContext) throws StorageException {", "        return this.exists(false, options, opContext);"]}
{"options": [], "opContext": []}
{"numberOfMessages": ["    public Iterable<CloudQueueMessage> peekMessages(final int numberOfMessages) throws StorageException {", "        return this.peekMessages(numberOfMessages, null /* options */, null /* opContext */);"]}
{"numberOfMessages": ["    public Iterable<CloudQueueMessage> peekMessages(final int numberOfMessages, QueueRequestOptions options,", "        Utility.assertInBounds(\"numberOfMessages\", numberOfMessages, 1, QueueConstants.MAX_NUMBER_OF_MESSAGES_TO_PEEK);", "                this.peekMessagesImpl(numberOfMessages, options), options.getRetryPolicyFactory(), opContext);"], "options": ["    public Iterable<CloudQueueMessage> peekMessages(final int numberOfMessages, QueueRequestOptions options,", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this.queueServiceClient);"], "opContext": ["            OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "        opContext.initialize();", "                this.peekMessagesImpl(numberOfMessages, options), options.getRetryPolicyFactory(), opContext);"]}
{"visibilityTimeoutInSeconds": ["    public CloudQueueMessage retrieveMessage(final int visibilityTimeoutInSeconds, final QueueRequestOptions options,", "        return getFirstOrNull(this.retrieveMessages(1, visibilityTimeoutInSeconds, options, opContext));"], "options": ["    public CloudQueueMessage retrieveMessage(final int visibilityTimeoutInSeconds, final QueueRequestOptions options,", "        return getFirstOrNull(this.retrieveMessages(1, visibilityTimeoutInSeconds, options, opContext));"], "opContext": ["            final OperationContext opContext) throws StorageException {", "        return getFirstOrNull(this.retrieveMessages(1, visibilityTimeoutInSeconds, options, opContext));"]}
{"numberOfMessages": ["    public Iterable<CloudQueueMessage> retrieveMessages(final int numberOfMessages) throws StorageException {", "        return this.retrieveMessages(numberOfMessages, QueueConstants.DEFAULT_VISIBILITY_MESSAGE_TIMEOUT_IN_SECONDS,"]}
{"numberOfMessages": ["    public Iterable<CloudQueueMessage> retrieveMessages(final int numberOfMessages,", "        Utility.assertInBounds(\"numberOfMessages\", numberOfMessages, 1, QueueConstants.MAX_NUMBER_OF_MESSAGES_TO_PEEK);", "                this.retrieveMessagesImpl(numberOfMessages, visibilityTimeoutInSeconds, options),"], "visibilityTimeoutInSeconds": ["            final int visibilityTimeoutInSeconds, QueueRequestOptions options, OperationContext opContext)", "        Utility.assertInBounds(\"visibilityTimeoutInSeconds\", visibilityTimeoutInSeconds, 0,", "                this.retrieveMessagesImpl(numberOfMessages, visibilityTimeoutInSeconds, options),"], "options": ["            final int visibilityTimeoutInSeconds, QueueRequestOptions options, OperationContext opContext)", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this.queueServiceClient);"], "opContext": ["            final int visibilityTimeoutInSeconds, QueueRequestOptions options, OperationContext opContext)", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"message": ["public void updateMessage(final CloudQueueMessage message, final int visibilityTimeoutInSeconds)", "        this.updateMessage(message, visibilityTimeoutInSeconds, EnumSet.of(MessageUpdateFields.VISIBILITY),"], "visibilityTimeoutInSeconds": ["public void updateMessage(final CloudQueueMessage message, final int visibilityTimeoutInSeconds)", "        this.updateMessage(message, visibilityTimeoutInSeconds, EnumSet.of(MessageUpdateFields.VISIBILITY),"]}
{"message": ["    public void updateMessage(final CloudQueueMessage message, final int visibilityTimeoutInSeconds,", "        Utility.assertNotNull(\"message\", message);", "        Utility.assertNotNullOrEmpty(\"messageId\", message.getId());", "        Utility.assertNotNullOrEmpty(\"popReceipt\", message.getPopReceipt());", "                this.updateMessageImpl(message, visibilityTimeoutInSeconds, messageUpdateFields, options),"], "visibilityTimeoutInSeconds": ["    public void updateMessage(final CloudQueueMessage message, final int visibilityTimeoutInSeconds,", "        Utility.assertInBounds(\"visibilityTimeoutInSeconds\", visibilityTimeoutInSeconds, 0,", "                this.updateMessageImpl(message, visibilityTimeoutInSeconds, messageUpdateFields, options),"], "messageUpdateFields": ["            final EnumSet<MessageUpdateFields> messageUpdateFields, QueueRequestOptions options,", "                this.updateMessageImpl(message, visibilityTimeoutInSeconds, messageUpdateFields, options),"], "options": ["            final EnumSet<MessageUpdateFields> messageUpdateFields, QueueRequestOptions options,", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this.queueServiceClient);"], "opContext": ["            OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"permissions": ["    public void uploadPermissions(final QueuePermissions permissions, QueueRequestOptions options,", "                this.uploadPermissionsImpl(permissions, options), options.getRetryPolicyFactory(), opContext);"], "options": ["    public void uploadPermissions(final QueuePermissions permissions, QueueRequestOptions options,", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this.queueServiceClient);"], "opContext": ["            OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "        opContext.initialize();", "                this.uploadPermissionsImpl(permissions, options), options.getRetryPolicyFactory(), opContext);"]}
{"options": ["    public QueuePermissions downloadPermissions(QueueRequestOptions options, OperationContext opContext)", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this.queueServiceClient);"], "opContext": ["    public QueuePermissions downloadPermissions(QueueRequestOptions options, OperationContext opContext)", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"opContext": ["private final StorageUri getTransformedAddress(final OperationContext opContext) throws URISyntaxException,", "        return this.queueServiceClient.getCredentials().transformUri(this.getStorageUri(), opContext);"]}
{"service": ["public CloudTable getHourMetricsTable(StorageService service, StorageLocation location) throws URISyntaxException,", "        Utility.assertNotNull(\"service\", service);", "        switch (service) {"], "location": ["public CloudTable getHourMetricsTable(StorageService service, StorageLocation location) throws URISyntaxException,", "        if (location == null) {", "                if (location == StorageLocation.PRIMARY) {", "                if (location == StorageLocation.PRIMARY) {", "                if (location == StorageLocation.PRIMARY) {", "                if (location == StorageLocation.PRIMARY) {"]}
{"service": ["public CloudTable getMinuteMetricsTable(StorageService service, StorageLocation location)", "        Utility.assertNotNull(\"service\", service);", "        switch (service) {"], "location": ["public CloudTable getMinuteMetricsTable(StorageService service, StorageLocation location)", "        if (location == null) {", "                if (location == StorageLocation.PRIMARY) {", "                if (location == StorageLocation.PRIMARY) {", "                if (location == StorageLocation.PRIMARY) {", "                if (location == StorageLocation.PRIMARY) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"stream": ["public static ListResponse<ListFileItem> getFileAndDirectoryList(final InputStream stream,", "        saxParser.parse(stream, handler);"], "directory": ["            final CloudFileDirectory directory) throws ParserConfigurationException, SAXException, IOException {", "        FileListHandler handler = new FileListHandler(directory);", "        saxParser.parse(stream, handler);", "        return handler.response;"]}
{"builder": ["private static void applyContinuationToQueryBuilder(final UriQueryBuilder builder,", "                builder.add(TableConstants.TABLE_SERVICE_NEXT_PARTITION_KEY, continuationToken.getNextPartitionKey());", "                builder.add(TableConstants.TABLE_SERVICE_NEXT_ROW_KEY, continuationToken.getNextRowKey());", "                builder.add(TableConstants.TABLE_SERVICE_NEXT_TABLE_NAME, continuationToken.getNextTableName());"], "continuationToken": ["            final ResultContinuation continuationToken) throws StorageException {", "        if (continuationToken != null) {", "            if (continuationToken.getNextPartitionKey() != null) {", "                builder.add(TableConstants.TABLE_SERVICE_NEXT_PARTITION_KEY, continuationToken.getNextPartitionKey());", "            if (continuationToken.getNextRowKey() != null) {", "                builder.add(TableConstants.TABLE_SERVICE_NEXT_ROW_KEY, continuationToken.getNextRowKey());", "            if (continuationToken.getNextTableName() != null) {", "                builder.add(TableConstants.TABLE_SERVICE_NEXT_TABLE_NAME, continuationToken.getNextTableName());"]}
{"rootUri": ["public static HttpURLConnection merge(final URI rootUri, final TableRequestOptions tableOptions,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "tableOptions": ["public static HttpURLConnection merge(final URI rootUri, final TableRequestOptions tableOptions,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "queryBuilder": ["            final UriQueryBuilder queryBuilder, final OperationContext opContext, final String tableName,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "opContext": ["            final UriQueryBuilder queryBuilder, final OperationContext opContext, final String tableName,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "tableName": ["            final UriQueryBuilder queryBuilder, final OperationContext opContext, final String tableName,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "identity": ["            final String identity, final String eTag) throws IOException, URISyntaxException, StorageException {", "                eTag, identity, \"POST\");"], "eTag": ["            final String identity, final String eTag) throws IOException, URISyntaxException, StorageException {", "                eTag, identity, \"POST\");"]}
{"rootUri": ["public static HttpURLConnection query(final URI rootUri, final TableRequestOptions tableOptions,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "tableOptions": ["public static HttpURLConnection query(final URI rootUri, final TableRequestOptions tableOptions,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "queryBuilder": ["            UriQueryBuilder queryBuilder, final OperationContext opContext, final String tableName,", "        if (queryBuilder == null) {", "        applyContinuationToQueryBuilder(queryBuilder, continuationToken);", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "opContext": ["            UriQueryBuilder queryBuilder, final OperationContext opContext, final String tableName,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "tableName": ["            UriQueryBuilder queryBuilder, final OperationContext opContext, final String tableName,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "identity": ["            final String identity, final ResultContinuation continuationToken) throws IOException, URISyntaxException,", "                null, identity, \"GET\");"], "continuationToken": ["            final String identity, final ResultContinuation continuationToken) throws IOException, URISyntaxException,", "        applyContinuationToQueryBuilder(queryBuilder, continuationToken);"]}
{"rootUri": ["public static HttpURLConnection update(final URI rootUri, final TableRequestOptions tableOptions,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "tableOptions": ["public static HttpURLConnection update(final URI rootUri, final TableRequestOptions tableOptions,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "queryBuilder": ["            final UriQueryBuilder queryBuilder, final OperationContext opContext, final String tableName,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "opContext": ["            final UriQueryBuilder queryBuilder, final OperationContext opContext, final String tableName,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "tableName": ["            final UriQueryBuilder queryBuilder, final OperationContext opContext, final String tableName,", "        final HttpURLConnection retConnection = coreCreate(rootUri, tableOptions, queryBuilder, opContext, tableName,"], "identity": ["            final String identity, final String eTag) throws IOException, URISyntaxException, StorageException {", "                eTag, identity, \"PUT\");"], "eTag": ["            final String identity, final String eTag) throws IOException, URISyntaxException, StorageException {", "                eTag, identity, \"PUT\");"]}
{"rootUri": ["public static HttpURLConnection setAcl(final URI rootUri, final TableRequestOptions options,", "        final HttpURLConnection retConnection = BaseRequest.createURLConnection(rootUri, options, queryBuilder,"], "options": ["public static HttpURLConnection setAcl(final URI rootUri, final TableRequestOptions options,", "        final HttpURLConnection retConnection = BaseRequest.createURLConnection(rootUri, options, queryBuilder,"], "opContext": ["            final OperationContext opContext) throws IOException, URISyntaxException, StorageException {", "        final HttpURLConnection retConnection = BaseRequest.createURLConnection(rootUri, options, queryBuilder,", "                opContext);", "        retConnection.setRequestMethod(\"PUT\");", "        retConnection.setDoOutput(true);", "        return retConnection;"]}
{"properties": ["public static byte[] serializeToByteArray(final ServiceProperties properties) throws IllegalArgumentException,", "        if (properties.getLogging() != null) {", "            writeLoggingProperties(xmlw, properties.getLogging());", "        if (properties.getHourMetrics() != null) {", "            writeMetricsProperties(xmlw, properties.getHourMetrics(), Constants.AnalyticsConstants.HOUR_METRICS_ELEMENT);", "        if (properties.getMinuteMetrics() != null) {", "            writeMetricsProperties(xmlw, properties.getMinuteMetrics(),", "        if (properties.getCors() != null) {", "            writeCorsProperties(xmlw, properties.getCors());", "        if (properties.getDefaultServiceVersion() != null) {", "                    properties.getDefaultServiceVersion());"]}
{"xmlw": ["private static void writeRetentionPolicy(final XmlSerializer xmlw, final Integer val)", "        xmlw.startTag(Constants.EMPTY_STRING, Constants.AnalyticsConstants.RETENTION_POLICY_ELEMENT);", "        Utility.serializeElement(xmlw, Constants.AnalyticsConstants.ENABLED_ELEMENT, val != null ? Constants.TRUE", "            Utility.serializeElement(xmlw, Constants.AnalyticsConstants.DAYS_ELEMENT, val.toString());", "        xmlw.endTag(Constants.EMPTY_STRING, Constants.AnalyticsConstants.RETENTION_POLICY_ELEMENT);"], "val": ["private static void writeRetentionPolicy(final XmlSerializer xmlw, final Integer val)", "        Utility.serializeElement(xmlw, Constants.AnalyticsConstants.ENABLED_ELEMENT, val != null ? Constants.TRUE", "        if (val != null) {", "            Utility.serializeElement(xmlw, Constants.AnalyticsConstants.DAYS_ELEMENT, val.toString());"]}
{"xmlw": ["private static void writeCorsProperties(final XmlSerializer xmlw, final CorsProperties cors)", "        xmlw.startTag(Constants.EMPTY_STRING, Constants.AnalyticsConstants.CORS_ELEMENT);", "            xmlw.startTag(Constants.EMPTY_STRING, Constants.AnalyticsConstants.CORS_RULE_ELEMENT);", "            Utility.serializeElement(xmlw, Constants.AnalyticsConstants.ALLOWED_ORIGINS_ELEMENT,", "            Utility.serializeElement(xmlw, Constants.AnalyticsConstants.ALLOWED_METHODS_ELEMENT,", "            Utility.serializeElement(xmlw, Constants.AnalyticsConstants.EXPOSED_HEADERS_ELEMENT,", "            Utility.serializeElement(xmlw, Constants.AnalyticsConstants.ALLOWED_HEADERS_ELEMENT,", "            Utility.serializeElement(xmlw, Constants.AnalyticsConstants.MAX_AGE_IN_SECONDS_ELEMENT,", "            xmlw.endTag(Constants.EMPTY_STRING, Constants.AnalyticsConstants.CORS_RULE_ELEMENT);", "        xmlw.endTag(Constants.EMPTY_STRING, Constants.AnalyticsConstants.CORS_ELEMENT);"], "cors": ["private static void writeCorsProperties(final XmlSerializer xmlw, final CorsProperties cors)", "        Utility.assertNotNull(\"CorsRules\", cors.getCorsRules());", "        for (CorsRule rule : cors.getCorsRules()) {", "            if (rule.getAllowedOrigins().isEmpty() || rule.getAllowedMethods().isEmpty()", "                    || rule.getMaxAgeInSeconds() < 0) {", "                    joinToString(rule.getAllowedOrigins(), \",\"));", "                    joinToString(rule.getAllowedMethods(), \",\"));", "                    joinToString(rule.getExposedHeaders(), \",\"));", "                    joinToString(rule.getAllowedHeaders(), \",\"));", "                    Integer.toString(rule.getMaxAgeInSeconds()));"]}
{"xmlw": ["private static void writeMetricsProperties(final XmlSerializer xmlw, final MetricsProperties metrics,", "        xmlw.startTag(Constants.EMPTY_STRING, metricsName);", "        Utility.serializeElement(xmlw, Constants.AnalyticsConstants.VERSION_ELEMENT, metrics.getVersion());", "        Utility.serializeElement(xmlw, Constants.AnalyticsConstants.ENABLED_ELEMENT,", "            Utility.serializeElement(xmlw, Constants.AnalyticsConstants.INCLUDE_APIS_ELEMENT,", "        writeRetentionPolicy(xmlw, metrics.getRetentionIntervalInDays());", "        xmlw.endTag(Constants.EMPTY_STRING, metricsName);"], "metrics": ["private static void writeMetricsProperties(final XmlSerializer xmlw, final MetricsProperties metrics,", "        Utility.assertNotNull(\"metrics.Configuration\", metrics.getMetricsLevel());", "        Utility.serializeElement(xmlw, Constants.AnalyticsConstants.VERSION_ELEMENT, metrics.getVersion());", "                metrics.getMetricsLevel() != MetricsLevel.DISABLED ? Constants.TRUE : Constants.FALSE);", "        if (metrics.getMetricsLevel() != MetricsLevel.DISABLED) {", "                    metrics.getMetricsLevel() == MetricsLevel.SERVICE_AND_API ? Constants.TRUE : Constants.FALSE);", "        writeRetentionPolicy(xmlw, metrics.getRetentionIntervalInDays());"], "metricsName": ["            final String metricsName) throws IllegalArgumentException, IllegalStateException, IOException {", "        xmlw.startTag(Constants.EMPTY_STRING, metricsName);", "        xmlw.endTag(Constants.EMPTY_STRING, metricsName);"]}
{"xmlw": ["private static void writeLoggingProperties(final XmlSerializer xmlw, final LoggingProperties logging)", "        xmlw.startTag(Constants.EMPTY_STRING, Constants.AnalyticsConstants.LOGGING_ELEMENT);", "        Utility.serializeElement(xmlw, Constants.AnalyticsConstants.VERSION_ELEMENT, logging.getVersion());", "        Utility.serializeElement(xmlw, Constants.AnalyticsConstants.DELETE_ELEMENT, logging.getLogOperationTypes()", "        Utility.serializeElement(xmlw, Constants.AnalyticsConstants.READ_ELEMENT, logging.getLogOperationTypes()", "        Utility.serializeElement(xmlw, Constants.AnalyticsConstants.WRITE_ELEMENT, logging.getLogOperationTypes()", "        writeRetentionPolicy(xmlw, logging.getRetentionIntervalInDays());", "        xmlw.endTag(Constants.EMPTY_STRING, Constants.AnalyticsConstants.LOGGING_ELEMENT);"], "logging": ["private static void writeLoggingProperties(final XmlSerializer xmlw, final LoggingProperties logging)", "        Utility.assertNotNull(\"logging.LogOperationTypes\", logging.getLogOperationTypes());", "        Utility.serializeElement(xmlw, Constants.AnalyticsConstants.VERSION_ELEMENT, logging.getVersion());", "        Utility.serializeElement(xmlw, Constants.AnalyticsConstants.DELETE_ELEMENT, logging.getLogOperationTypes()", "        Utility.serializeElement(xmlw, Constants.AnalyticsConstants.READ_ELEMENT, logging.getLogOperationTypes()", "        Utility.serializeElement(xmlw, Constants.AnalyticsConstants.WRITE_ELEMENT, logging.getLogOperationTypes()", "        writeRetentionPolicy(xmlw, logging.getRetentionIntervalInDays());"]}
{"uri": ["public static HttpURLConnection abortCopy(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "fileOptions": ["public static HttpURLConnection abortCopy(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition, final String copyId)", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);", "        request.setFixedLengthStreamingMode(0);", "        request.setDoOutput(true);", "        request.setRequestMethod(Constants.HTTP_PUT);", "        request.setRequestProperty(Constants.HeaderConstants.COPY_ACTION_HEADER,", "            accessCondition.applyConditionToRequest(request);", "        return request;"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition, final String copyId)", "        if (accessCondition != null) {", "            accessCondition.applyConditionToRequest(request);"], "copyId": ["            final OperationContext opContext, final AccessCondition accessCondition, final String copyId)", "        builder.add(Constants.QueryConstants.COPY_ID, copyId);"]}
{"builder": ["public static void addShareSnapshot(final UriQueryBuilder builder, final String snapshotVersion)", "            builder.add(Constants.QueryConstants.SHARE_SNAPSHOT, snapshotVersion);"], "snapshotVersion": ["public static void addShareSnapshot(final UriQueryBuilder builder, final String snapshotVersion)", "        if (snapshotVersion != null) {", "            builder.add(Constants.QueryConstants.SHARE_SNAPSHOT, snapshotVersion);"]}
{"uri": ["public static HttpURLConnection copyFrom(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, null, opContext);"], "fileOptions": ["public static HttpURLConnection copyFrom(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, null, opContext);"], "opContext": ["            final OperationContext opContext, final AccessCondition sourceAccessCondition,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, null, opContext);", "        request.setFixedLengthStreamingMode(0);", "        request.setDoOutput(true);", "        request.setRequestMethod(Constants.HTTP_PUT);", "        request.setRequestProperty(Constants.HeaderConstants.COPY_SOURCE_HEADER, source);", "            sourceAccessCondition.applyConditionToRequest(request);", "            destinationAccessCondition.applyConditionToRequest(request);", "        return request;"], "sourceAccessCondition": ["            final OperationContext opContext, final AccessCondition sourceAccessCondition,", "        if (sourceAccessCondition != null) {", "            sourceAccessCondition.applyConditionToRequest(request);"], "destinationAccessCondition": ["            final AccessCondition destinationAccessCondition, String source)", "        if (destinationAccessCondition != null) {", "            destinationAccessCondition.applyConditionToRequest(request);"], "source": ["            final AccessCondition destinationAccessCondition, String source)", "        request.setRequestProperty(Constants.HeaderConstants.COPY_SOURCE_HEADER, source);"]}
{"uri": ["public static HttpURLConnection createShare(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.create(uri, fileOptions, shareBuilder, opContext);"], "fileOptions": ["public static HttpURLConnection createShare(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.create(uri, fileOptions, shareBuilder, opContext);"], "opContext": ["            final OperationContext opContext, final FileShareProperties properties)", "        final HttpURLConnection request = BaseRequest.create(uri, fileOptions, shareBuilder, opContext);", "        addProperties(request, properties);", "        return request;"], "properties": ["            final OperationContext opContext, final FileShareProperties properties)", "        addProperties(request, properties);"]}
{"uri": ["public static HttpURLConnection deleteShare(final URI uri, final FileRequestOptions fileOptions,", "        HttpURLConnection request = BaseRequest.delete(uri, fileOptions, shareBuilder, opContext);"], "fileOptions": ["public static HttpURLConnection deleteShare(final URI uri, final FileRequestOptions fileOptions,", "        HttpURLConnection request = BaseRequest.delete(uri, fileOptions, shareBuilder, opContext);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition, String snapshotVersion, DeleteShareSnapshotsOption deleteSnapshotsOption) ", "        HttpURLConnection request = BaseRequest.delete(uri, fileOptions, shareBuilder, opContext);", "            accessCondition.applyConditionToRequest(request);", "            request.setRequestProperty(Constants.HeaderConstants.DELETE_SNAPSHOT_HEADER,", "        return request;"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition, String snapshotVersion, DeleteShareSnapshotsOption deleteSnapshotsOption) ", "        if (accessCondition != null) {", "            accessCondition.applyConditionToRequest(request);"], "snapshotVersion": ["            final OperationContext opContext, final AccessCondition accessCondition, String snapshotVersion, DeleteShareSnapshotsOption deleteSnapshotsOption) ", "        FileRequest.addShareSnapshot(shareBuilder, snapshotVersion);"], "deleteSnapshotsOption": ["            final OperationContext opContext, final AccessCondition accessCondition, String snapshotVersion, DeleteShareSnapshotsOption deleteSnapshotsOption) ", "        switch (deleteSnapshotsOption) {"]}
{"uri": ["public static HttpURLConnection getAcl(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "fileOptions": ["public static HttpURLConnection getAcl(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "accessCondition": ["            final AccessCondition accessCondition, final OperationContext opContext) throws IOException,", "        if (accessCondition != null && !Utility.isNullOrEmpty(accessCondition.getLeaseID())) {", "            accessCondition.applyLeaseConditionToRequest(request);"], "opContext": ["            final AccessCondition accessCondition, final OperationContext opContext) throws IOException,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);", "        request.setRequestMethod(Constants.HTTP_GET);", "            accessCondition.applyLeaseConditionToRequest(request);", "        return request;"]}
{"uri": ["public static HttpURLConnection getFile(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "fileOptions": ["public static HttpURLConnection getFile(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition, final String snapshotVersion, final Long offset,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);", "        request.setRequestMethod(Constants.HTTP_GET);", "            accessCondition.applyConditionToRequest(request);", "                request.setRequestProperty(Constants.HeaderConstants.STORAGE_RANGE_HEADER, String.format(", "                request.setRequestProperty(Constants.HeaderConstants.STORAGE_RANGE_HEADER, String.format(", "            request.setRequestProperty(Constants.HeaderConstants.RANGE_GET_CONTENT_MD5, Constants.TRUE);", "        return request;"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition, final String snapshotVersion, final Long offset,", "        if (accessCondition != null) {", "            accessCondition.applyConditionToRequest(request);"], "snapshotVersion": ["            final OperationContext opContext, final AccessCondition accessCondition, final String snapshotVersion, final Long offset,", "        FileRequest.addShareSnapshot(builder, snapshotVersion);"], "offset": ["            final OperationContext opContext, final AccessCondition accessCondition, final String snapshotVersion, final Long offset,", "        if (offset != null && requestRangeContentMD5) {", "        if (offset != null) {", "            long rangeStart = offset;", "                rangeEnd = offset + count - 1;", "                        Utility.LOCALE_US, Constants.HeaderConstants.RANGE_HEADER_FORMAT, rangeStart, rangeEnd));", "                        Utility.LOCALE_US, Constants.HeaderConstants.BEGIN_RANGE_HEADER_FORMAT, rangeStart));", "        if (offset != null && requestRangeContentMD5) {"], "count": ["            final Long count, boolean requestRangeContentMD5) throws IOException, URISyntaxException, StorageException {", "            Utility.assertNotNull(\"count\", count);", "            Utility.assertInBounds(\"count\", count, 1, Constants.MAX_BLOCK_SIZE);", "            if (count != null) {", "                rangeEnd = offset + count - 1;"], "requestRangeContentMD5": ["            final Long count, boolean requestRangeContentMD5) throws IOException, URISyntaxException, StorageException {", "        if (offset != null && requestRangeContentMD5) {", "        if (offset != null && requestRangeContentMD5) {"]}
{"uri": ["public static HttpURLConnection getFileProperties(final URI uri, final FileRequestOptions fileOptions,", "        return getProperties(uri, fileOptions, opContext, accessCondition, builder, snapshotVersion);"], "fileOptions": ["public static HttpURLConnection getFileProperties(final URI uri, final FileRequestOptions fileOptions,", "        return getProperties(uri, fileOptions, opContext, accessCondition, builder, snapshotVersion);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition, final String snapshotVersion) throws StorageException,", "        return getProperties(uri, fileOptions, opContext, accessCondition, builder, snapshotVersion);"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition, final String snapshotVersion) throws StorageException,", "        return getProperties(uri, fileOptions, opContext, accessCondition, builder, snapshotVersion);"], "snapshotVersion": ["            final OperationContext opContext, final AccessCondition accessCondition, final String snapshotVersion) throws StorageException,", "        return getProperties(uri, fileOptions, opContext, accessCondition, builder, snapshotVersion);"]}
{"uri": ["public static HttpURLConnection getFileRanges(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "fileOptions": ["public static HttpURLConnection getFileRanges(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition, final String snapshotVersion) throws StorageException,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);", "        request.setRequestMethod(Constants.HTTP_GET);", "            accessCondition.applyConditionToRequest(request);", "        return request;"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition, final String snapshotVersion) throws StorageException,", "        if (accessCondition != null) {", "            accessCondition.applyConditionToRequest(request);"], "snapshotVersion": ["            final OperationContext opContext, final AccessCondition accessCondition, final String snapshotVersion) throws StorageException,", "        addShareSnapshot(builder, snapshotVersion);"]}
{"uri": ["public static HttpURLConnection getShareProperties(final URI uri, final FileRequestOptions fileOptions,", "        return getProperties(uri, fileOptions, opContext, accessCondition, shareBuilder, snapshotVersion);"], "fileOptions": ["public static HttpURLConnection getShareProperties(final URI uri, final FileRequestOptions fileOptions,", "        return getProperties(uri, fileOptions, opContext, accessCondition, shareBuilder, snapshotVersion);"], "opContext": ["            final OperationContext opContext, AccessCondition accessCondition, final String snapshotVersion) throws IOException, URISyntaxException,", "        return getProperties(uri, fileOptions, opContext, accessCondition, shareBuilder, snapshotVersion);"], "accessCondition": ["            final OperationContext opContext, AccessCondition accessCondition, final String snapshotVersion) throws IOException, URISyntaxException,", "        return getProperties(uri, fileOptions, opContext, accessCondition, shareBuilder, snapshotVersion);"], "snapshotVersion": ["            final OperationContext opContext, AccessCondition accessCondition, final String snapshotVersion) throws IOException, URISyntaxException,", "        return getProperties(uri, fileOptions, opContext, accessCondition, shareBuilder, snapshotVersion);"]}
{"uri": ["public static HttpURLConnection getShareStats(final URI uri, final FileRequestOptions options,", "        final HttpURLConnection retConnection = BaseRequest.createURLConnection(uri, options, shareBuilder, opContext);"], "options": ["public static HttpURLConnection getShareStats(final URI uri, final FileRequestOptions options,", "        final HttpURLConnection retConnection = BaseRequest.createURLConnection(uri, options, shareBuilder, opContext);"], "opContext": ["            final OperationContext opContext)", "        final HttpURLConnection retConnection = BaseRequest.createURLConnection(uri, options, shareBuilder, opContext);", "        retConnection.setRequestMethod(Constants.HTTP_GET);", "        return retConnection;"]}
{"Result": "Method without Parameter"}
{"uri": ["private static HttpURLConnection getProperties(final URI uri, final FileRequestOptions fileOptions,", "        HttpURLConnection request = BaseRequest.getProperties(uri, fileOptions, builder, opContext);"], "fileOptions": ["private static HttpURLConnection getProperties(final URI uri, final FileRequestOptions fileOptions,", "        HttpURLConnection request = BaseRequest.getProperties(uri, fileOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, AccessCondition accessCondition, final UriQueryBuilder builder,", "        HttpURLConnection request = BaseRequest.getProperties(uri, fileOptions, builder, opContext);", "            accessCondition.applyLeaseConditionToRequest(request);", "        return request;"], "accessCondition": ["            final OperationContext opContext, AccessCondition accessCondition, final UriQueryBuilder builder,", "        if (accessCondition != null) {", "            accessCondition.applyLeaseConditionToRequest(request);"], "builder": ["            final OperationContext opContext, AccessCondition accessCondition, final UriQueryBuilder builder,", "        addShareSnapshot(builder, snapshotVersion);", "        HttpURLConnection request = BaseRequest.getProperties(uri, fileOptions, builder, opContext);"], "snapshotVersion": ["            String snapshotVersion)", "        addShareSnapshot(builder, snapshotVersion);"]}
{"uri": ["public static HttpURLConnection listShares(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "fileOptions": ["public static HttpURLConnection listShares(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, final ListingContext listingContext,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);", "        request.setRequestMethod(Constants.HTTP_GET);", "        return request;"], "listingContext": ["            final OperationContext opContext, final ListingContext listingContext,", "        final UriQueryBuilder builder = BaseRequest.getListUriQueryBuilder(listingContext);", "            builder.add(Constants.QueryConstants.INCLUDE, sb.toString());", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "detailsIncluded": ["            final EnumSet<ShareListingDetails> detailsIncluded) throws URISyntaxException, IOException, StorageException {", "        if (detailsIncluded != null && detailsIncluded.size() > 0) {", "            if (detailsIncluded.contains(ShareListingDetails.SNAPSHOTS)) {", "            if (detailsIncluded.contains(ShareListingDetails.METADATA)) {"]}
{"uri": ["public static HttpURLConnection setShareMetadata(final URI uri, final FileRequestOptions fileOptions,", "        return setMetadata(uri, fileOptions, opContext, accessCondition, shareBuilder);"], "fileOptions": ["public static HttpURLConnection setShareMetadata(final URI uri, final FileRequestOptions fileOptions,", "        return setMetadata(uri, fileOptions, opContext, accessCondition, shareBuilder);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition) throws IOException,", "        return setMetadata(uri, fileOptions, opContext, accessCondition, shareBuilder);"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition) throws IOException,", "        return setMetadata(uri, fileOptions, opContext, accessCondition, shareBuilder);"]}
{"uri": ["public static HttpURLConnection setDirectoryMetadata(final URI uri, final FileRequestOptions fileOptions,", "        return setMetadata(uri, fileOptions, opContext, accessCondition, directoryBuilder);"], "fileOptions": ["public static HttpURLConnection setDirectoryMetadata(final URI uri, final FileRequestOptions fileOptions,", "        return setMetadata(uri, fileOptions, opContext, accessCondition, directoryBuilder);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition) throws IOException,", "        return setMetadata(uri, fileOptions, opContext, accessCondition, directoryBuilder);"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition) throws IOException,", "        return setMetadata(uri, fileOptions, opContext, accessCondition, directoryBuilder);"]}
{"uri": ["public static HttpURLConnection createDirectory(final URI uri, final FileRequestOptions fileOptions,", "        return BaseRequest.create(uri, fileOptions, directoryBuilder, opContext);"], "fileOptions": ["public static HttpURLConnection createDirectory(final URI uri, final FileRequestOptions fileOptions,", "        return BaseRequest.create(uri, fileOptions, directoryBuilder, opContext);"], "opContext": ["            final OperationContext opContext) throws IOException, URISyntaxException, StorageException {", "        return BaseRequest.create(uri, fileOptions, directoryBuilder, opContext);"]}
{"uri": ["public static HttpURLConnection deleteDirectory(final URI uri, final FileRequestOptions fileOptions,", "        HttpURLConnection request = BaseRequest.delete(uri, fileOptions, directoryBuilder, opContext);"], "fileOptions": ["public static HttpURLConnection deleteDirectory(final URI uri, final FileRequestOptions fileOptions,", "        HttpURLConnection request = BaseRequest.delete(uri, fileOptions, directoryBuilder, opContext);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition) throws IOException,", "        HttpURLConnection request = BaseRequest.delete(uri, fileOptions, directoryBuilder, opContext);", "            accessCondition.applyConditionToRequest(request);", "        return request;"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition) throws IOException,", "        if (accessCondition != null) {", "            accessCondition.applyConditionToRequest(request);"]}
{"uri": ["public static HttpURLConnection getDirectoryProperties(final URI uri, final FileRequestOptions fileOptions,", "        return getProperties(uri, fileOptions, opContext, accessCondition, directoryBuilder, snapshotVersion);"], "fileOptions": ["public static HttpURLConnection getDirectoryProperties(final URI uri, final FileRequestOptions fileOptions,", "        return getProperties(uri, fileOptions, opContext, accessCondition, directoryBuilder, snapshotVersion);"], "opContext": ["            final OperationContext opContext, AccessCondition accessCondition, String snapshotVersion) throws IOException, URISyntaxException,", "        return getProperties(uri, fileOptions, opContext, accessCondition, directoryBuilder, snapshotVersion);"], "accessCondition": ["            final OperationContext opContext, AccessCondition accessCondition, String snapshotVersion) throws IOException, URISyntaxException,", "        return getProperties(uri, fileOptions, opContext, accessCondition, directoryBuilder, snapshotVersion);"], "snapshotVersion": ["            final OperationContext opContext, AccessCondition accessCondition, String snapshotVersion) throws IOException, URISyntaxException,", "        return getProperties(uri, fileOptions, opContext, accessCondition, directoryBuilder, snapshotVersion);"]}
{"uri": ["public static HttpURLConnection listFilesAndDirectories(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "fileOptions": ["public static HttpURLConnection listFilesAndDirectories(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, final ListingContext listingContext, String snapshotVersion) throws URISyntaxException,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);", "        request.setRequestMethod(Constants.HTTP_GET);", "        return request;"], "listingContext": ["            final OperationContext opContext, final ListingContext listingContext, String snapshotVersion) throws URISyntaxException,", "        if (listingContext != null) {", "            if (!Utility.isNullOrEmpty(listingContext.getMarker())) {", "                builder.add(Constants.QueryConstants.MARKER, listingContext.getMarker());", "            if (listingContext.getMaxResults() != null && listingContext.getMaxResults() > 0) {", "                builder.add(Constants.QueryConstants.MAX_RESULTS, listingContext.getMaxResults().toString());", "            if (!Utility.isNullOrEmpty(listingContext.getPrefix())) {", "                builder.add(Constants.QueryConstants.PREFIX, listingContext.getPrefix().toString());"], "snapshotVersion": ["            final OperationContext opContext, final ListingContext listingContext, String snapshotVersion) throws URISyntaxException,", "        addShareSnapshot(builder, snapshotVersion);"]}
{"uri": ["public static HttpURLConnection putFile(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, null, opContext);"], "fileOptions": ["public static HttpURLConnection putFile(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, null, opContext);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition, final FileProperties properties,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, null, opContext);", "        request.setDoOutput(true);", "        request.setRequestMethod(Constants.HTTP_PUT);", "        addProperties(request, properties);", "        request.setFixedLengthStreamingMode(0);", "        request.setRequestProperty(Constants.HeaderConstants.CONTENT_LENGTH, \"0\");", "        request.setRequestProperty(FileConstants.FILE_TYPE_HEADER, FileConstants.FILE);", "        request.setRequestProperty(FileConstants.CONTENT_LENGTH_HEADER, String.valueOf(fileSize));", "            accessCondition.applyConditionToRequest(request);", "        return request;"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition, final FileProperties properties,", "        if (accessCondition != null) {", "            accessCondition.applyConditionToRequest(request);"], "properties": ["            final OperationContext opContext, final AccessCondition accessCondition, final FileProperties properties,", "        addProperties(request, properties);", "        properties.setLength(fileSize);"], "fileSize": ["            final long fileSize) throws IOException, URISyntaxException, StorageException {", "        request.setRequestProperty(FileConstants.CONTENT_LENGTH_HEADER, String.valueOf(fileSize));", "        properties.setLength(fileSize);"]}
{"uri": ["public static HttpURLConnection putRange(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "fileOptions": ["public static HttpURLConnection putRange(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition, final FileRange range,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);", "        request.setDoOutput(true);", "        request.setRequestMethod(Constants.HTTP_PUT);", "            request.setFixedLengthStreamingMode(0);", "        request.setRequestProperty(FileConstants.FILE_RANGE_WRITE, operationType.toString());", "        request.setRequestProperty(Constants.HeaderConstants.STORAGE_RANGE_HEADER, range.toString());", "            accessCondition.applyConditionToRequest(request);", "        return request;"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition, final FileRange range,", "        if (accessCondition != null) {", "            accessCondition.applyConditionToRequest(request);"], "range": ["            final OperationContext opContext, final AccessCondition accessCondition, final FileRange range,", "        request.setRequestProperty(Constants.HeaderConstants.STORAGE_RANGE_HEADER, range.toString());"], "operationType": ["            FileRangeOperationType operationType) throws IOException, URISyntaxException, StorageException {", "        if (operationType == FileRangeOperationType.CLEAR) {", "        request.setRequestProperty(FileConstants.FILE_RANGE_WRITE, operationType.toString());"]}
{"uri": ["public static HttpURLConnection resize(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = setFileProperties(uri, fileOptions, opContext, accessCondition, null);"], "fileOptions": ["public static HttpURLConnection resize(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = setFileProperties(uri, fileOptions, opContext, accessCondition, null);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition, final Long newFileSize)", "        final HttpURLConnection request = setFileProperties(uri, fileOptions, opContext, accessCondition, null);"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition, final Long newFileSize)", "        final HttpURLConnection request = setFileProperties(uri, fileOptions, opContext, accessCondition, null);"], "newFileSize": ["            final OperationContext opContext, final AccessCondition accessCondition, final Long newFileSize)", "        if (newFileSize != null) {", "            request.setRequestProperty(FileConstants.CONTENT_LENGTH_HEADER, newFileSize.toString());"]}
{"uri": ["private static HttpURLConnection setMetadata(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.setMetadata(uri, fileOptions, builder, opContext);"], "fileOptions": ["private static HttpURLConnection setMetadata(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.setMetadata(uri, fileOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition, final UriQueryBuilder builder)", "        final HttpURLConnection request = BaseRequest.setMetadata(uri, fileOptions, builder, opContext);", "            accessCondition.applyConditionToRequest(request);", "        return request;"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition, final UriQueryBuilder builder)", "        if (accessCondition != null) {", "            accessCondition.applyConditionToRequest(request);"], "builder": ["            final OperationContext opContext, final AccessCondition accessCondition, final UriQueryBuilder builder)", "        final HttpURLConnection request = BaseRequest.setMetadata(uri, fileOptions, builder, opContext);"]}
{"uri": ["public static HttpURLConnection setFileMetadata(final URI uri, final FileRequestOptions fileOptions,", "        return setMetadata(uri, fileOptions, opContext, accessCondition, null);"], "fileOptions": ["public static HttpURLConnection setFileMetadata(final URI uri, final FileRequestOptions fileOptions,", "        return setMetadata(uri, fileOptions, opContext, accessCondition, null);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition) throws IOException,", "        return setMetadata(uri, fileOptions, opContext, accessCondition, null);"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition) throws IOException,", "        return setMetadata(uri, fileOptions, opContext, accessCondition, null);"]}
{"uri": ["public static HttpURLConnection snapshotShare(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "fileOptions": ["public static HttpURLConnection snapshotShare(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "opContext": ["                                                  final OperationContext opContext, final AccessCondition accessCondition) throws IOException,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);", "        request.setFixedLengthStreamingMode(0);", "        request.setDoOutput(true);", "        request.setRequestMethod(Constants.HTTP_PUT);", "            accessCondition.applyConditionToRequest(request);", "        return request;"], "accessCondition": ["                                                  final OperationContext opContext, final AccessCondition accessCondition) throws IOException,", "        if (accessCondition != null) {", "            accessCondition.applyConditionToRequest(request);"]}
{"uri": ["public static HttpURLConnection setFileProperties(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "fileOptions": ["public static HttpURLConnection setFileProperties(final URI uri, final FileRequestOptions fileOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, final AccessCondition accessCondition, final FileProperties properties)", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, fileOptions, builder, opContext);", "        request.setFixedLengthStreamingMode(0);", "        request.setDoOutput(true);", "        request.setRequestMethod(Constants.HTTP_PUT);", "            accessCondition.applyConditionToRequest(request);", "            addProperties(request, properties);", "        return request;"], "accessCondition": ["            final OperationContext opContext, final AccessCondition accessCondition, final FileProperties properties)", "        if (accessCondition != null) {", "            accessCondition.applyConditionToRequest(request);"], "properties": ["            final OperationContext opContext, final AccessCondition accessCondition, final FileProperties properties)", "        if (properties != null) {", "            addProperties(request, properties);"]}
{"Result": "Method without Parameter"}
{"readLength": ["    private synchronized void dispatchRead(final int readLength) throws IOException {", "            final byte[] byteBuffer = new byte[readLength];", "            this.parentFileRef.downloadRangeInternal(this.currentAbsoluteReadPosition, (long) readLength, byteBuffer,", "            this.currentBuffer = new ByteArrayInputStream(byteBuffer);", "            this.bufferSize = readLength;"]}
{"Result": "Method without Parameter"}
{"b": ["    private synchronized int readInternal(final byte[] b, final int off, int len) throws IOException {", "        final int numberOfBytesRead = this.currentBuffer.read(b, off, len);", "                this.md5Digest.update(b, off, numberOfBytesRead);"], "off": ["    private synchronized int readInternal(final byte[] b, final int off, int len) throws IOException {", "        final int numberOfBytesRead = this.currentBuffer.read(b, off, len);", "                this.md5Digest.update(b, off, numberOfBytesRead);"], "len": ["    private synchronized int readInternal(final byte[] b, final int off, int len) throws IOException {", "        len = Math.min(len, this.readSize);"]}
{"Result": "Method without Parameter"}
{"n": ["    public synchronized long skip(final long n) throws IOException {", "        if (n == 0) {", "        if (n < 0 || this.currentAbsoluteReadPosition + n > this.streamLength) {", "        this.reposition(this.currentAbsoluteReadPosition + n);", "        return n;"]}
{"view": []}
{"view": []}
{"view": []}
{"view": []}
{"view": ["public void outputText(final TextView view, final String value) {", "                view.append(value + \"\\n\");", "                System.out.println(view);"], "value": ["public void outputText(final TextView view, final String value) {", "                view.append(value + \"\\n\");"]}
{"t": ["public void printException(Throwable t) {", "        t.printStackTrace(printWriter);"]}
{"sampleName": ["public void printSampleStartInfo(String sampleName) {", "                sampleName));"]}
{"sampleName": ["public void printSampleCompleteInfo(String sampleName) {", "                sampleName));"]}
{"conn": ["    protected String canonicalize(final HttpURLConnection conn, final String accountName, final Long contentLength)", "        return canonicalizeTableHttpRequest(conn.getURL(), accountName, conn.getRequestMethod(),", "                Utility.getStandardHeaderValue(conn, Constants.HeaderConstants.CONTENT_TYPE), contentLength, null,", "                conn);"], "accountName": ["    protected String canonicalize(final HttpURLConnection conn, final String accountName, final Long contentLength)", "        return canonicalizeTableHttpRequest(conn.getURL(), accountName, conn.getRequestMethod(),"], "contentLength": ["    protected String canonicalize(final HttpURLConnection conn, final String accountName, final Long contentLength)", "        if (contentLength < -1) {", "                Utility.getStandardHeaderValue(conn, Constants.HeaderConstants.CONTENT_TYPE), contentLength, null,"]}
{"Result": "Method without Parameter"}
{"current": ["private boolean isCorrectLogType(ListBlobItem current) {", "        HashMap<String, String> metadata = ((CloudBlob) current).getMetadata();"]}
{"Result": "Method without Parameter"}
{"sourceBlob": ["    public final String startCopy(final CloudBlob sourceBlob) throws StorageException, URISyntaxException {", "        return this.startCopy(sourceBlob, null /* sourceAccessCondition */,"]}
{"sourceBlob": ["    public final String startCopy(final CloudBlob sourceBlob, final AccessCondition sourceAccessCondition,", "        Utility.assertNotNull(\"sourceBlob\", sourceBlob);", "        URI source = sourceBlob.getSnapshotQualifiedUri();", "        if (sourceBlob.getServiceClient() != null && sourceBlob.getServiceClient().getCredentials() != null)", "            source = sourceBlob.getServiceClient().getCredentials().transformUri(sourceBlob.getSnapshotQualifiedUri());"], "sourceAccessCondition": ["    public final String startCopy(final CloudBlob sourceBlob, final AccessCondition sourceAccessCondition,", "        return this.startCopy(source, sourceAccessCondition, destinationAccessCondition, options, opContext);"], "destinationAccessCondition": ["            final AccessCondition destinationAccessCondition, FileRequestOptions options, OperationContext opContext)", "        return this.startCopy(source, sourceAccessCondition, destinationAccessCondition, options, opContext);"], "options": ["            final AccessCondition destinationAccessCondition, FileRequestOptions options, OperationContext opContext)", "        return this.startCopy(source, sourceAccessCondition, destinationAccessCondition, options, opContext);"], "opContext": ["            final AccessCondition destinationAccessCondition, FileRequestOptions options, OperationContext opContext)", "        return this.startCopy(source, sourceAccessCondition, destinationAccessCondition, options, opContext);"]}
{"sourceFile": ["    public final String startCopy(final CloudFile sourceFile) throws StorageException, URISyntaxException {", "        return this.startCopy(sourceFile, null /* sourceAccessCondition */,"]}
{"sourceFile": ["    public final String startCopy(final CloudFile sourceFile, final AccessCondition sourceAccessCondition,", "        Utility.assertNotNull(\"sourceFile\", sourceFile);", "        return this.startCopy(sourceFile.getTransformedAddress(opContext).getPrimaryUri(),"], "sourceAccessCondition": ["    public final String startCopy(final CloudFile sourceFile, final AccessCondition sourceAccessCondition,", "                sourceAccessCondition, destinationAccessCondition, options, opContext);"], "destinationAccessCondition": ["            final AccessCondition destinationAccessCondition, FileRequestOptions options, OperationContext opContext)", "                sourceAccessCondition, destinationAccessCondition, options, opContext);"], "options": ["            final AccessCondition destinationAccessCondition, FileRequestOptions options, OperationContext opContext)", "                sourceAccessCondition, destinationAccessCondition, options, opContext);"], "opContext": ["            final AccessCondition destinationAccessCondition, FileRequestOptions options, OperationContext opContext)", "        return this.startCopy(sourceFile.getTransformedAddress(opContext).getPrimaryUri(),", "                sourceAccessCondition, destinationAccessCondition, options, opContext);"]}
{"source": ["    public final String startCopy(final URI source) throws StorageException, URISyntaxException {", "        return this.startCopy(source, null /* sourceAccessCondition */,"]}
{"source": ["    public final String startCopy(final URI source, final AccessCondition sourceAccessCondition,", "                this.startCopyImpl(source, sourceAccessCondition, destinationAccessCondition, options),"], "sourceAccessCondition": ["    public final String startCopy(final URI source, final AccessCondition sourceAccessCondition,", "                this.startCopyImpl(source, sourceAccessCondition, destinationAccessCondition, options),"], "destinationAccessCondition": ["            final AccessCondition destinationAccessCondition, FileRequestOptions options, OperationContext opContext)", "                this.startCopyImpl(source, sourceAccessCondition, destinationAccessCondition, options),"], "options": ["            final AccessCondition destinationAccessCondition, FileRequestOptions options, OperationContext opContext)", "        options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient);"], "opContext": ["            final AccessCondition destinationAccessCondition, FileRequestOptions options, OperationContext opContext)", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"size": ["    public void create(final long size) throws StorageException, URISyntaxException {", "        this.create(size, null /* accessCondition */, null /* options */, null /* opContext */);"]}
{"size": ["    public void create(final long size, final AccessCondition accessCondition, FileRequestOptions options,", "        ExecutionEngine.executeWithRetry(this.fileServiceClient, this, this.createImpl(size, accessCondition, options),"], "accessCondition": ["    public void create(final long size, final AccessCondition accessCondition, FileRequestOptions options,", "        ExecutionEngine.executeWithRetry(this.fileServiceClient, this, this.createImpl(size, accessCondition, options),"], "options": ["    public void create(final long size, final AccessCondition accessCondition, FileRequestOptions options,", "        options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient);"], "opContext": ["            OperationContext opContext) throws StorageException, URISyntaxException {", "        if (opContext == null) {", "                options.getRetryPolicyFactory(), opContext);"]}
{"outputStream": ["private void deleteEmptyFileOnException(OutputStream outputStream, String path) {", "            outputStream.close();"], "path": ["private void deleteEmptyFileOnException(OutputStream outputStream, String path) {", "            File fileToDelete = new File(path);", "            fileToDelete.delete();"]}
{"charsetName": ["public String downloadText(final String charsetName, final AccessCondition accessCondition,", "        return charsetName == null ? baos.toString() : baos.toString(charsetName);"], "accessCondition": ["public String downloadText(final String charsetName, final AccessCondition accessCondition,", "        this.download(baos, accessCondition, options, opContext);"], "options": ["            FileRequestOptions options, OperationContext opContext) throws StorageException, IOException {", "        this.download(baos, accessCondition, options, opContext);"], "opContext": ["            FileRequestOptions options, OperationContext opContext) throws StorageException, IOException {", "        this.download(baos, accessCondition, options, opContext);"]}
{"accessCondition": ["    public ArrayList<FileRange> downloadFileRanges(final AccessCondition accessCondition, FileRequestOptions options,", "                this.downloadFileRangesImpl(accessCondition, options), options.getRetryPolicyFactory(), opContext);"], "options": ["    public ArrayList<FileRange> downloadFileRanges(final AccessCondition accessCondition, FileRequestOptions options,", "        options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient);"], "opContext": ["            OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "                this.downloadFileRangesImpl(accessCondition, options), options.getRetryPolicyFactory(), opContext);"]}
{"Result": "Method without Parameter"}
{"accessCondition": ["    public FileOutputStream openWriteExisting(AccessCondition accessCondition, FileRequestOptions options,", "        return this.openOutputStreamInternal(null /* length */, accessCondition, options, opContext);"], "options": ["    public FileOutputStream openWriteExisting(AccessCondition accessCondition, FileRequestOptions options,", "        return this.openOutputStreamInternal(null /* length */, accessCondition, options, opContext);"], "opContext": ["            OperationContext opContext) throws StorageException, URISyntaxException {", "        return this.openOutputStreamInternal(null /* length */, accessCondition, options, opContext);"]}
{"length": ["private FileOutputStream openOutputStreamInternal(Long length, AccessCondition accessCondition,", "        if (length != null) {", "            this.create(length, accessCondition, options, opContext);", "        return new FileOutputStream(this, length, accessCondition, options, opContext);"], "accessCondition": ["private FileOutputStream openOutputStreamInternal(Long length, AccessCondition accessCondition,", "            this.create(length, accessCondition, options, opContext);", "            this.downloadAttributes(accessCondition, options, opContext);", "        if (accessCondition != null) {", "            accessCondition = AccessCondition.generateLeaseCondition(accessCondition.getLeaseID());", "        return new FileOutputStream(this, length, accessCondition, options, opContext);"], "options": ["            FileRequestOptions options, OperationContext opContext) throws StorageException, URISyntaxException {", "        options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient, false /* setStartTime */);"], "opContext": ["            FileRequestOptions options, OperationContext opContext) throws StorageException, URISyntaxException {", "        if (opContext == null) {", "            this.create(length, accessCondition, options, opContext);", "            this.downloadAttributes(accessCondition, options, opContext);", "        return new FileOutputStream(this, length, accessCondition, options, opContext);"]}
{"path": ["public void uploadFromFile(final String path) throws StorageException, IOException, URISyntaxException {", "        uploadFromFile(path, null /* accessCondition */, null /* options */, null /* opContext */);"]}
{"path": ["public void uploadFromFile(final String path, final AccessCondition accessCondition, FileRequestOptions options,", "        File file = new File(path);", "        long fileLength = file.length();", "        InputStream inputStream = new BufferedInputStream(new java.io.FileInputStream(file));", "        this.upload(inputStream, fileLength, accessCondition, options, opContext);", "        inputStream.close();"], "accessCondition": ["public void uploadFromFile(final String path, final AccessCondition accessCondition, FileRequestOptions options,", "        this.upload(inputStream, fileLength, accessCondition, options, opContext);"], "options": ["public void uploadFromFile(final String path, final AccessCondition accessCondition, FileRequestOptions options,", "        this.upload(inputStream, fileLength, accessCondition, options, opContext);"], "opContext": ["            OperationContext opContext) throws StorageException, IOException, URISyntaxException {", "        this.upload(inputStream, fileLength, accessCondition, options, opContext);"]}
{"content": ["public void uploadText(final String content) throws StorageException, IOException, URISyntaxException {", "        this.uploadText(content, null /* charsetName */, null /* accessCondition */, null /* options */, null /* opContext */);"]}
{"content": ["public void uploadText(final String content, final String charsetName, final AccessCondition accessCondition,", "        byte[] bytes = (charsetName == null) ? content.getBytes() : content.getBytes(charsetName);"], "charsetName": ["public void uploadText(final String content, final String charsetName, final AccessCondition accessCondition,", "        byte[] bytes = (charsetName == null) ? content.getBytes() : content.getBytes(charsetName);", "        this.uploadFromByteArray(bytes, 0, bytes.length, accessCondition, options, opContext);"], "accessCondition": ["public void uploadText(final String content, final String charsetName, final AccessCondition accessCondition,", "        this.uploadFromByteArray(bytes, 0, bytes.length, accessCondition, options, opContext);"], "options": ["            FileRequestOptions options, OperationContext opContext) throws StorageException, IOException, URISyntaxException {", "        this.uploadFromByteArray(bytes, 0, bytes.length, accessCondition, options, opContext);"], "opContext": ["            FileRequestOptions options, OperationContext opContext) throws StorageException, IOException, URISyntaxException {", "        this.uploadFromByteArray(bytes, 0, bytes.length, accessCondition, options, opContext);"]}
{"sourceStream": ["    public void uploadRange(final InputStream sourceStream, final long offset, final long length)", "        this.uploadRange(sourceStream, offset, length, null /* accessCondition */, null /* options */, null /* opContext */);"], "offset": ["    public void uploadRange(final InputStream sourceStream, final long offset, final long length)", "        this.uploadRange(sourceStream, offset, length, null /* accessCondition */, null /* options */, null /* opContext */);"], "length": ["    public void uploadRange(final InputStream sourceStream, final long offset, final long length)", "        this.uploadRange(sourceStream, offset, length, null /* accessCondition */, null /* options */, null /* opContext */);"]}
{"sourceStream": ["    public void uploadRange(final InputStream sourceStream, final long offset, final long length,", "        while (total < length) {", "            count = sourceStream.read(data, total, (int) Math.min(length - total, Integer.MAX_VALUE));", "            total += count;"], "offset": ["    public void uploadRange(final InputStream sourceStream, final long offset, final long length,", "        final FileRange range = new FileRange(offset, offset + length - 1);"], "length": ["    public void uploadRange(final InputStream sourceStream, final long offset, final long length,", "        final FileRange range = new FileRange(offset, offset + length - 1);", "        final byte[] data = new byte[(int) length];", "        while (total < length) {", "            count = sourceStream.read(data, total, (int) Math.min(length - total, Integer.MAX_VALUE));", "            total += count;", "                digest.update(data, 0, data.length);", "        this.putRangeInternal(range, FileRangeOperationType.UPDATE, data, length, md5, accessCondition, options,"], "accessCondition": ["            final AccessCondition accessCondition, FileRequestOptions options, OperationContext opContext)", "        this.putRangeInternal(range, FileRangeOperationType.UPDATE, data, length, md5, accessCondition, options,"], "options": ["            final AccessCondition accessCondition, FileRequestOptions options, OperationContext opContext)", "        options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient);"], "opContext": ["            final AccessCondition accessCondition, FileRequestOptions options, OperationContext opContext)", "        if (opContext == null) {", "                opContext);"]}
{"range": ["    private void putRangeInternal(final FileRange range, final FileRangeOperationType operationType, final byte[] data,", "                putRangeImpl(range, operationType, data, length, md5, accessCondition, options, opContext),"], "operationType": ["    private void putRangeInternal(final FileRange range, final FileRangeOperationType operationType, final byte[] data,", "                putRangeImpl(range, operationType, data, length, md5, accessCondition, options, opContext),"], "data": ["    private void putRangeInternal(final FileRange range, final FileRangeOperationType operationType, final byte[] data,", "                putRangeImpl(range, operationType, data, length, md5, accessCondition, options, opContext),"], "length": ["            final long length, final String md5, final AccessCondition accessCondition,", "                putRangeImpl(range, operationType, data, length, md5, accessCondition, options, opContext),"], "md5": ["            final long length, final String md5, final AccessCondition accessCondition,", "                putRangeImpl(range, operationType, data, length, md5, accessCondition, options, opContext),"], "accessCondition": ["            final long length, final String md5, final AccessCondition accessCondition,", "                putRangeImpl(range, operationType, data, length, md5, accessCondition, options, opContext),"], "options": ["            final FileRequestOptions options, final OperationContext opContext) throws StorageException {", "                putRangeImpl(range, operationType, data, length, md5, accessCondition, options, opContext),", "                options.getRetryPolicyFactory(), opContext);"], "opContext": ["            final FileRequestOptions options, final OperationContext opContext) throws StorageException {", "                putRangeImpl(range, operationType, data, length, md5, accessCondition, options, opContext),", "                options.getRetryPolicyFactory(), opContext);"]}
{"size": ["public void resize(long size, AccessCondition accessCondition, FileRequestOptions options,", "        ExecutionEngine.executeWithRetry(this.fileServiceClient, this, this.resizeImpl(size, accessCondition, options),"], "accessCondition": ["public void resize(long size, AccessCondition accessCondition, FileRequestOptions options,", "        ExecutionEngine.executeWithRetry(this.fileServiceClient, this, this.resizeImpl(size, accessCondition, options),"], "options": ["public void resize(long size, AccessCondition accessCondition, FileRequestOptions options,", "        options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient);"], "opContext": ["            OperationContext opContext) throws StorageException, URISyntaxException {", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"sourceStream": ["    public void upload(final InputStream sourceStream, final long length) throws StorageException, IOException, URISyntaxException {", "        this.upload(sourceStream, length, null /* accessCondition */, null /* options */, null /* opContext */);"], "length": ["    public void upload(final InputStream sourceStream, final long length) throws StorageException, IOException, URISyntaxException {", "        this.upload(sourceStream, length, null /* accessCondition */, null /* options */, null /* opContext */);"]}
{"sourceStream": ["    public void upload(final InputStream sourceStream, final long length, final AccessCondition accessCondition,", "        if (sourceStream.markSupported()) {", "            sourceStream.mark(Constants.MAX_MARK_LENGTH);", "            streamRef.write(sourceStream, length);"], "length": ["    public void upload(final InputStream sourceStream, final long length, final AccessCondition accessCondition,", "        if (length < 0) {", "        final FileOutputStream streamRef = this.openWriteNew(length, accessCondition, options, opContext);", "            streamRef.write(sourceStream, length);"], "accessCondition": ["    public void upload(final InputStream sourceStream, final long length, final AccessCondition accessCondition,", "        final FileOutputStream streamRef = this.openWriteNew(length, accessCondition, options, opContext);"], "options": ["            FileRequestOptions options, OperationContext opContext) throws StorageException, IOException, URISyntaxException {", "        options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient);"], "opContext": ["            FileRequestOptions options, OperationContext opContext) throws StorageException, IOException, URISyntaxException {", "        if (opContext == null) {", "        final FileOutputStream streamRef = this.openWriteNew(length, accessCondition, options, opContext);", "            streamRef.write(sourceStream, length);", "            streamRef.close();"]}
{"resourceAddress": ["protected static String getParentNameFromURI(final StorageUri resourceAddress, final CloudFileShare share)", "        Utility.assertNotNull(\"resourceAddress\", resourceAddress);", "                resourceAddress.getPrimaryUri());"], "share": ["protected static String getParentNameFromURI(final StorageUri resourceAddress, final CloudFileShare share)", "        Utility.assertNotNull(\"share\", share);", "        String shareName = share.getName() + delimiter;", "        String relativeURIString = Utility.safeRelativize(share.getStorageUri().getPrimaryUri(),"]}
{"Result": "Method without Parameter"}
{"uri": ["public static URI appendPathToSingleUri(final URI uri, final String relativeUri, final String separator)", "        if (uri == null) {", "            return uri;", "        if (uri.getPath().length() == 0 && relativeUri.startsWith(separator)) {", "            return new URI(uri.getScheme(), uri.getAuthority(), relativeUri, uri.getRawQuery(), uri.getRawFragment());", "        final StringBuilder pathString = new StringBuilder(uri.getPath());", "        if (uri.getPath().endsWith(separator)) {", "        return new URI(uri.getScheme(), uri.getAuthority(), pathString.toString(), uri.getQuery(), uri.getFragment());"], "relativeUri": ["public static URI appendPathToSingleUri(final URI uri, final String relativeUri, final String separator)", "        if (relativeUri == null || relativeUri.isEmpty()) {", "        if (uri.getPath().length() == 0 && relativeUri.startsWith(separator)) {", "            return new URI(uri.getScheme(), uri.getAuthority(), relativeUri, uri.getRawQuery(), uri.getRawFragment());", "            pathString.append(relativeUri);", "            pathString.append(relativeUri);"], "separator": ["public static URI appendPathToSingleUri(final URI uri, final String relativeUri, final String separator)", "        if (uri.getPath().length() == 0 && relativeUri.startsWith(separator)) {", "        if (uri.getPath().endsWith(separator)) {", "            pathString.append(separator);"]}
{"inURI": ["public static String getBlobNameFromURI(final URI inURI, final boolean usePathStyleUris) throws URISyntaxException {", "        return Utility.safeRelativize(new URI(getContainerURI(new StorageUri(inURI), usePathStyleUris).getPrimaryUri()", "                .toString().concat(\"/\")), inURI);"], "usePathStyleUris": ["public static String getBlobNameFromURI(final URI inURI, final boolean usePathStyleUris) throws URISyntaxException {", "        return Utility.safeRelativize(new URI(getContainerURI(new StorageUri(inURI), usePathStyleUris).getPrimaryUri()"]}
{"credentials": ["public static String getCanonicalPathFromCredentials(final StorageCredentials credentials, final String absolutePath) {", "        final String account = credentials.getAccountName();"], "absolutePath": ["public static String getCanonicalPathFromCredentials(final StorageCredentials credentials, final String absolutePath) {", "        builder.append(absolutePath);"]}
{"resourceAddress": ["public static String getContainerNameFromUri(final URI resourceAddress, final boolean usePathStyleUris) {", "        return getResourceNameFromUri(resourceAddress, usePathStyleUris,", "                String.format(\"Invalid blob address '%s', missing container information\", resourceAddress));"], "usePathStyleUris": ["public static String getContainerNameFromUri(final URI resourceAddress, final boolean usePathStyleUris) {", "        return getResourceNameFromUri(resourceAddress, usePathStyleUris,"]}
{"resourceAddress": ["public static String getFileNameFromURI(final URI resourceAddress, final boolean usePathStyleUris) {", "        final String[] pathSegments = resourceAddress.getRawPath().split(\"/\");", "            throw new IllegalArgumentException(String.format(\"Invalid file address '%s'.\", resourceAddress));"], "usePathStyleUris": ["public static String getFileNameFromURI(final URI resourceAddress, final boolean usePathStyleUris) {", "        final int shareIndex = usePathStyleUris ? 2 : 1;"]}
{"resourceAddress": ["public static String getShareNameFromUri(final URI resourceAddress, final boolean usePathStyleUris) {", "        return getResourceNameFromUri(resourceAddress, usePathStyleUris,", "                String.format(\"Invalid file address '%s', missing share information\", resourceAddress));"], "usePathStyleUris": ["public static String getShareNameFromUri(final URI resourceAddress, final boolean usePathStyleUris) {", "        return getResourceNameFromUri(resourceAddress, usePathStyleUris,"]}
{"resourceAddress": ["public static String getTableNameFromUri(final URI resourceAddress, final boolean usePathStyleUris) {", "        return getResourceNameFromUri(resourceAddress, usePathStyleUris,", "                String.format(\"Invalid table address '%s', missing table information\", resourceAddress));"], "usePathStyleUris": ["public static String getTableNameFromUri(final URI resourceAddress, final boolean usePathStyleUris) {", "        return getResourceNameFromUri(resourceAddress, usePathStyleUris,"]}
{"resourceAddress": ["private static String getResourceNameFromUri(final URI resourceAddress, final boolean usePathStyleUris,", "        Utility.assertNotNull(\"resourceAddress\", resourceAddress);", "        final String[] pathSegments = resourceAddress.getRawPath().split(\"/\");"], "usePathStyleUris": ["private static String getResourceNameFromUri(final URI resourceAddress, final boolean usePathStyleUris,", "        final int expectedPartsLength = usePathStyleUris ? 3 : 2;", "        final String resourceName = usePathStyleUris ? pathSegments[2] : pathSegments[1];"], "error": ["            final String error) {", "            throw new IllegalArgumentException(error);"]}
{"blobAddress": ["public static StorageUri getContainerURI(final StorageUri blobAddress, final boolean usePathStyleUris)", "        final String containerName = getContainerNameFromUri(blobAddress.getPrimaryUri(), usePathStyleUris);", "        final StorageUri containerUri = appendPathToUri(getServiceClientBaseAddress(blobAddress, usePathStyleUris),"], "usePathStyleUris": ["public static StorageUri getContainerURI(final StorageUri blobAddress, final boolean usePathStyleUris)", "        final String containerName = getContainerNameFromUri(blobAddress.getPrimaryUri(), usePathStyleUris);", "        final StorageUri containerUri = appendPathToUri(getServiceClientBaseAddress(blobAddress, usePathStyleUris),", "                containerName);", "        return containerUri;"]}
{"fileAddress": ["public static StorageUri getShareURI(final StorageUri fileAddress, final boolean usePathStyleUris)", "        final String shareName = getShareNameFromUri(fileAddress.getPrimaryUri(), usePathStyleUris);", "        final StorageUri shareUri = appendPathToUri(getServiceClientBaseAddress(fileAddress, usePathStyleUris),"], "usePathStyleUris": ["public static StorageUri getShareURI(final StorageUri fileAddress, final boolean usePathStyleUris)", "        final String shareName = getShareNameFromUri(fileAddress.getPrimaryUri(), usePathStyleUris);", "        final StorageUri shareUri = appendPathToUri(getServiceClientBaseAddress(fileAddress, usePathStyleUris),", "                shareName);", "        return shareUri;"]}
{"parseString": ["public static HashMap<String, String[]> parseQueryString(String parseString) throws StorageException {", "        if (Utility.isNullOrEmpty(parseString)) {", "        final int queryDex = parseString.indexOf(\"?\");", "        if (queryDex >= 0 && parseString.length() > 0) {", "            parseString = parseString.substring(queryDex + 1);", "        final String[] valuePairs = parseString.contains(\"&\") ? parseString.split(\"&\") : parseString.split(\";\");"]}
{"policy": ["public static String generateSharedAccessSignatureHashForBlobAndFile(final SharedAccessPolicy policy,", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);"], "headers": ["            SharedAccessHeaders headers, final String accessPolicyIdentifier, final String resourceName,", "        if (headers != null) {", "            cacheControl = headers.getCacheControl();", "            contentDisposition = headers.getContentDisposition();", "            contentEncoding = headers.getContentEncoding();", "            contentLanguage = headers.getContentLanguage();", "            contentType = headers.getContentType();"], "accessPolicyIdentifier": ["            SharedAccessHeaders headers, final String accessPolicyIdentifier, final String resourceName,", "        String stringToSign = generateSharedAccessSignatureStringToSign(", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);", "        stringToSign = String.format(\"%s\\n%s\\n%s\\n%s\\n%s\\n%s\", stringToSign,"], "resourceName": ["            SharedAccessHeaders headers, final String accessPolicyIdentifier, final String resourceName,", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);"], "ipRange": ["            final IPRange ipRange, final SharedAccessProtocols protocols, final ServiceClient client)", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);"], "protocols": ["            final IPRange ipRange, final SharedAccessProtocols protocols, final ServiceClient client)", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);"], "client": ["            final IPRange ipRange, final SharedAccessProtocols protocols, final ServiceClient client)", "        return generateSharedAccessSignatureHashHelper(stringToSign, client.getCredentials());"]}
{"policy": ["            final SharedAccessQueuePolicy policy, final String accessPolicyIdentifier, final String resourceName,", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);"], "accessPolicyIdentifier": ["            final SharedAccessQueuePolicy policy, final String accessPolicyIdentifier, final String resourceName,", "        final String stringToSign = generateSharedAccessSignatureStringToSign(", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);", "        return generateSharedAccessSignatureHashHelper(stringToSign, client.getCredentials());"], "resourceName": ["            final SharedAccessQueuePolicy policy, final String accessPolicyIdentifier, final String resourceName,", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);"], "ipRange": ["            final IPRange ipRange, final SharedAccessProtocols protocols, final ServiceClient client)", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);"], "protocols": ["            final IPRange ipRange, final SharedAccessProtocols protocols, final ServiceClient client)", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);"], "client": ["            final IPRange ipRange, final SharedAccessProtocols protocols, final ServiceClient client)", "        return generateSharedAccessSignatureHashHelper(stringToSign, client.getCredentials());"]}
{"policy": ["            final SharedAccessTablePolicy policy, final String accessPolicyIdentifier, final String resourceName,", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);"], "accessPolicyIdentifier": ["            final SharedAccessTablePolicy policy, final String accessPolicyIdentifier, final String resourceName,", "        String stringToSign = generateSharedAccessSignatureStringToSign(", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);", "        stringToSign = String.format(\"%s\\n%s\\n%s\\n%s\\n%s\", stringToSign,"], "resourceName": ["            final SharedAccessTablePolicy policy, final String accessPolicyIdentifier, final String resourceName,", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);"], "ipRange": ["            final IPRange ipRange, final SharedAccessProtocols protocols, final String startPartitionKey,", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);"], "protocols": ["            final IPRange ipRange, final SharedAccessProtocols protocols, final String startPartitionKey,", "                policy, resourceName, ipRange, protocols, accessPolicyIdentifier);"], "startPartitionKey": ["            final IPRange ipRange, final SharedAccessProtocols protocols, final String startPartitionKey,", "                startPartitionKey == null ? Constants.EMPTY_STRING : startPartitionKey,"], "startRowKey": ["            final String startRowKey, final String endPartitionKey, final String endRowKey, final ServiceClient client)", "                startRowKey == null ? Constants.EMPTY_STRING : startRowKey,"], "endPartitionKey": ["            final String startRowKey, final String endPartitionKey, final String endRowKey, final ServiceClient client)", "                endPartitionKey == null ? Constants.EMPTY_STRING : endPartitionKey,"], "endRowKey": ["            final String startRowKey, final String endPartitionKey, final String endRowKey, final ServiceClient client)", "        stringToSign = String.format(\"%s\\n%s\\n%s\\n%s\\n%s\", stringToSign,", "                endRowKey == null ? Constants.EMPTY_STRING : endRowKey);", "        return generateSharedAccessSignatureHashHelper(stringToSign, client.getCredentials());"], "client": ["            final String startRowKey, final String endPartitionKey, final String endRowKey, final ServiceClient client)", "        return generateSharedAccessSignatureHashHelper(stringToSign, client.getCredentials());"]}
{"options": ["    public void create(FileRequestOptions options, OperationContext opContext) throws StorageException, URISyntaxException {", "        options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient);"], "opContext": ["    public void create(FileRequestOptions options, OperationContext opContext) throws StorageException, URISyntaxException {", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"options": ["    public boolean createIfNotExists(FileRequestOptions options, OperationContext opContext) throws StorageException, URISyntaxException {", "        options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient);"], "opContext": ["    public boolean createIfNotExists(FileRequestOptions options, OperationContext opContext) throws StorageException, URISyntaxException {", "        boolean exists = this.exists(true /* primaryOnly */, null /* accessCondition */, options, opContext);", "        if (exists) {", "                this.create(options, opContext);"]}
{"accessCondition": ["    public boolean deleteIfExists(AccessCondition accessCondition, FileRequestOptions options,", "        boolean exists = this.exists(true /* primaryOnly */, accessCondition, options, opContext);", "                this.delete(accessCondition, options, opContext);"], "options": ["    public boolean deleteIfExists(AccessCondition accessCondition, FileRequestOptions options,", "        options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient);"], "opContext": ["            OperationContext opContext) throws StorageException, URISyntaxException {", "        boolean exists = this.exists(true /* primaryOnly */, accessCondition, options, opContext);", "        if (exists) {", "                this.delete(accessCondition, options, opContext);"]}
{"accessCondition": ["    public boolean exists(final AccessCondition accessCondition, FileRequestOptions options, OperationContext opContext)", "        return this.exists(false, accessCondition, options, opContext);"], "options": ["    public boolean exists(final AccessCondition accessCondition, FileRequestOptions options, OperationContext opContext)", "        return this.exists(false, accessCondition, options, opContext);"], "opContext": ["    public boolean exists(final AccessCondition accessCondition, FileRequestOptions options, OperationContext opContext)", "        return this.exists(false, accessCondition, options, opContext);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"uri": ["public static HttpURLConnection clearMessages(final URI uri, final QueueRequestOptions queueOptions,", "        return BaseRequest.delete(uri, queueOptions, null, opContext);"], "queueOptions": ["public static HttpURLConnection clearMessages(final URI uri, final QueueRequestOptions queueOptions,", "        return BaseRequest.delete(uri, queueOptions, null, opContext);"], "opContext": ["            final OperationContext opContext) throws URISyntaxException, IOException, StorageException {", "        return BaseRequest.delete(uri, queueOptions, null, opContext);"]}
{"uri": ["public static HttpURLConnection deleteMessage(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.delete(uri, queueOptions, builder, opContext);"], "queueOptions": ["public static HttpURLConnection deleteMessage(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.delete(uri, queueOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, final String popReceipt) throws URISyntaxException, IOException,", "        final HttpURLConnection request = BaseRequest.delete(uri, queueOptions, builder, opContext);", "        return request;"], "popReceipt": ["            final OperationContext opContext, final String popReceipt) throws URISyntaxException, IOException,", "        builder.add(POP_RECEIPT, popReceipt);"]}
{"uri": ["public static HttpURLConnection downloadAttributes(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection retConnection = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "queueOptions": ["public static HttpURLConnection downloadAttributes(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection retConnection = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext) throws IOException, URISyntaxException, StorageException {", "        final HttpURLConnection retConnection = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);", "        retConnection.setRequestMethod(Constants.HTTP_HEAD);", "        return retConnection;"]}
{"uri": ["public static HttpURLConnection list(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "queueOptions": ["public static HttpURLConnection list(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, final ListingContext listingContext,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);", "        request.setRequestMethod(Constants.HTTP_GET);", "        return request;"], "listingContext": ["            final OperationContext opContext, final ListingContext listingContext,", "        final UriQueryBuilder builder = BaseRequest.getListUriQueryBuilder(listingContext);", "            builder.add(Constants.QueryConstants.INCLUDE, Constants.QueryConstants.METADATA);", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "detailsIncluded": ["            final QueueListingDetails detailsIncluded) throws URISyntaxException, IOException, StorageException {", "        if (detailsIncluded == QueueListingDetails.ALL || detailsIncluded == QueueListingDetails.METADATA) {"]}
{"uri": ["public static HttpURLConnection peekMessages(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "queueOptions": ["public static HttpURLConnection peekMessages(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, final int numberOfMessages) throws URISyntaxException, IOException,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);", "        request.setRequestMethod(Constants.HTTP_GET);", "        return request;"], "numberOfMessages": ["            final OperationContext opContext, final int numberOfMessages) throws URISyntaxException, IOException,", "        if (numberOfMessages != 0) {", "            builder.add(NUMBER_OF_MESSAGES, Integer.toString(numberOfMessages));"]}
{"uri": ["public static HttpURLConnection retrieveMessages(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "queueOptions": ["public static HttpURLConnection retrieveMessages(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, final int numberOfMessages, final int visibilityTimeoutInSeconds)", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);", "        request.setRequestMethod(\"GET\");", "        return request;"], "numberOfMessages": ["            final OperationContext opContext, final int numberOfMessages, final int visibilityTimeoutInSeconds)", "        if (numberOfMessages != 0) {", "            builder.add(NUMBER_OF_MESSAGES, Integer.toString(numberOfMessages));"], "visibilityTimeoutInSeconds": ["            final OperationContext opContext, final int numberOfMessages, final int visibilityTimeoutInSeconds)", "        builder.add(VISIBILITY_TIMEOUT, Integer.toString(visibilityTimeoutInSeconds));"]}
{"uri": ["public static HttpURLConnection updateMessage(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "queueOptions": ["public static HttpURLConnection updateMessage(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext, final String popReceipt, final int visibilityTimeoutInSeconds)", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);", "        request.setDoOutput(true);", "        request.setRequestMethod(Constants.HTTP_PUT);", "        return request;"], "popReceipt": ["            final OperationContext opContext, final String popReceipt, final int visibilityTimeoutInSeconds)", "        builder.add(POP_RECEIPT, popReceipt);"], "visibilityTimeoutInSeconds": ["            final OperationContext opContext, final String popReceipt, final int visibilityTimeoutInSeconds)", "        builder.add(VISIBILITY_TIMEOUT, Integer.toString(visibilityTimeoutInSeconds));"]}
{"uri": ["public static HttpURLConnection setAcl(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "queueOptions": ["public static HttpURLConnection setAcl(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext) throws IOException, URISyntaxException, StorageException {", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);", "        request.setDoOutput(true);", "        request.setRequestMethod(Constants.HTTP_PUT);", "        return request;"]}
{"uri": ["public static HttpURLConnection getAcl(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "queueOptions": ["public static HttpURLConnection getAcl(final URI uri, final QueueRequestOptions queueOptions,", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);"], "opContext": ["            final OperationContext opContext) throws IOException, URISyntaxException, StorageException {", "        final HttpURLConnection request = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);", "        request.setRequestMethod(Constants.HTTP_GET);", "        return request;"]}
{"str": ["private static List<String> splitToList(String str, String delimiter) {", "        StringTokenizer st = new StringTokenizer(str, delimiter);"], "delimiter": ["private static List<String> splitToList(String str, String delimiter) {", "        StringTokenizer st = new StringTokenizer(str, delimiter);", "        while (st.hasMoreElements()) {", "            list.add(st.nextToken());"]}
{"str": ["private static EnumSet<CorsHttpMethods> splitToEnumSet(String str, String delimiter) {", "        StringTokenizer st = new StringTokenizer(str, delimiter);"], "delimiter": ["private static EnumSet<CorsHttpMethods> splitToEnumSet(String str, String delimiter) {", "        StringTokenizer st = new StringTokenizer(str, delimiter);", "        while (st.hasMoreElements()) {", "            set.add(CorsHttpMethods.valueOf(st.nextToken()));"]}
{"key": ["public synchronized void updateKey(final byte[] key) {", "        if (key == null || key.length == 0) {", "        this.key = key;"]}
{"Result": "Method without Parameter"}
{"ipAddress": ["private static void validateIPAddress(String ipAddress) {", "            Inet4Address address = (Inet4Address) Inet4Address.getByName(ipAddress);", "            throw new IllegalArgumentException(String.format(SR.INVALID_IP_ADDRESS, ipAddress), ex);"]}
{"data": ["public static byte[] decode(final String data) {", "        if (data == null) {", "        int byteArrayLength = 3 * data.length() / 4;", "        if (data.endsWith(\"==\")) {", "        else if (data.endsWith(\"=\")) {", "        for (; charDex < data.length(); charDex += 4) {", "            final int char1 = DECODE_64[(byte) data.charAt(charDex)];", "            final int char2 = DECODE_64[(byte) data.charAt(charDex + 1)];", "            final int char3 = DECODE_64[(byte) data.charAt(charDex + 2)];", "            final int char4 = DECODE_64[(byte) data.charAt(charDex + 3)];", "            if (char1 < 0 || char2 < 0 || char3 == -1 || char4 == -1) {", "            int tVal = char1 << 18;", "            tVal += char2 << 12;", "            tVal += (char3 & 0xff) << 6;", "            tVal += char4 & 0xff;", "            if (char3 == -2) {", "            else if (char4 == -2) {", "                retArray[byteDex++] = (byte) (tVal >> 16 & 0xFF);", "                retArray[byteDex++] = (byte) (tVal >> 8 & 0xFF);", "                retArray[byteDex++] = (byte) (tVal & 0xFF);", "        return retArray;"]}
{"data": ["public static String encode(final Byte[] data) {", "        final int dataRemainder = data.length % 3;", "        for (; j < data.length; j += 3) {", "            if (j < data.length - dataRemainder) {", "                n = ((data[j] & 0xFF) << 16) + ((data[j + 1] & 0xFF) << 8) + (data[j + 2] & 0xFF);", "                    n = (data[j] & 0xFF) << 16;", "                    n = ((data[j] & 0xFF) << 16) + ((data[j + 1] & 0xFF) << 8);", "            builder.append(BASE_64_CHARS.charAt((byte) ((n >>> 18) & 0x3F)));", "            builder.append(BASE_64_CHARS.charAt((byte) ((n >>> 12) & 0x3F)));", "            builder.append(BASE_64_CHARS.charAt((byte) ((n >>> 6) & 0x3F)));", "            builder.append(BASE_64_CHARS.charAt((byte) (n & 0x3F)));", "        if (data.length % 3 == 1) {", "        else if (data.length % 3 == 2) {"]}
{"data": ["public static boolean validateIsBase64String(final String data) {", "        if (data == null || data.length() % 4 != 0) {", "        for (int m = 0; m < data.length(); m++) {", "            final byte charByte = (byte) data.charAt(m);", "            if (DECODE_64[charByte] == -2) {", "                if (m < data.length() - 2) {", "                else if (m == data.length() - 2 && DECODE_64[(byte) data.charAt(m + 1)] != -2) {", "            if (charByte < 0 || DECODE_64[charByte] == -1) {"]}
{"containerName": ["public static void validateContainerName(String containerName) {", "\t\tif (!(\"$root\".equals(containerName) || \"$logs\".equals(containerName))) {", "\t\t\tNameValidator.validateShareContainerQueueHelper(containerName, SR.CONTAINER);"]}
{"blobName": ["public static void validateBlobName(String blobName) {", "\t\tif (Utility.isNullOrEmptyOrWhitespace(blobName)) {", "\t\tif (blobName.length() < NameValidator.BLOB_FILE_DIRECTORY_MIN_LENGTH || blobName.length() > NameValidator.BLOB_MAX_LENGTH) {", "\t\tfor (int i = 0; i < blobName.length(); i++)", "\t\t\tif (blobName.charAt(i) == '/')"]}
{"fileName": ["public static void validateFileName(String fileName) {", "\t\tNameValidator.ValidateFileDirectoryHelper(fileName, SR.FILE);", "\t\tif (fileName.endsWith(\"/\")) {", "\t\t\tif (s.equalsIgnoreCase(fileName)) {"]}
{"tableName": ["public static void validateTableName(String tableName) {", "\t\tif (Utility.isNullOrEmptyOrWhitespace(tableName)) {", "\t\tif (tableName.length() < NameValidator.CONTAINER_SHARE_QUEUE_TABLE_MIN_LENGTH || tableName.length() > NameValidator.CONTAINER_SHARE_QUEUE_TABLE_MAX_LENGTH) {", "\t\tif (!(NameValidator.TABLE_REGEX.matcher(tableName).matches()", "\t\t\t\t|| NameValidator.METRICS_TABLE_REGEX.matcher(tableName).matches() ", "\t\t\t\t|| tableName.equalsIgnoreCase(\"$MetricsCapacityBlob\"))) {"]}
{"prefix": ["    public Iterable<CloudFileShare> listShares(final String prefix) {", "        return this.listSharesWithPrefix(prefix, EnumSet.noneOf(ShareListingDetails.class), null /* options */, null /* opContext */);"]}
{"prefix": ["    public Iterable<CloudFileShare> listShares(final String prefix, final EnumSet<ShareListingDetails> detailsIncluded,", "        return this.listSharesWithPrefix(prefix, detailsIncluded, options, opContext);"], "detailsIncluded": ["    public Iterable<CloudFileShare> listShares(final String prefix, final EnumSet<ShareListingDetails> detailsIncluded,", "        return this.listSharesWithPrefix(prefix, detailsIncluded, options, opContext);"], "options": ["            final FileRequestOptions options, final OperationContext opContext) {", "        return this.listSharesWithPrefix(prefix, detailsIncluded, options, opContext);"], "opContext": ["            final FileRequestOptions options, final OperationContext opContext) {", "        return this.listSharesWithPrefix(prefix, detailsIncluded, options, opContext);"]}
{"Result": "Method without Parameter"}
{"prefix": ["    public ResultSegment<CloudFileShare> listSharesSegmented(final String prefix) throws StorageException {", "        return this.listSharesWithPrefixSegmented(prefix, EnumSet.noneOf(ShareListingDetails.class), null, null /* continuationToken */,"]}
{"prefix": ["private Iterable<CloudFileShare> listSharesWithPrefix(final String prefix,", "                prefix, detailsIncluded, null, options, segmentedRequest), this, null, options.getRetryPolicyFactory(),"], "detailsIncluded": ["            final EnumSet<ShareListingDetails> detailsIncluded, FileRequestOptions options, OperationContext opContext) {", "                prefix, detailsIncluded, null, options, segmentedRequest), this, null, options.getRetryPolicyFactory(),"], "options": ["            final EnumSet<ShareListingDetails> detailsIncluded, FileRequestOptions options, OperationContext opContext) {", "        options = FileRequestOptions.populateAndApplyDefaults(options, this);", "                prefix, detailsIncluded, null, options, segmentedRequest), this, null, options.getRetryPolicyFactory(),"], "opContext": ["            final EnumSet<ShareListingDetails> detailsIncluded, FileRequestOptions options, OperationContext opContext) {", "        if (opContext == null) {", "        opContext.initialize();", "                opContext);"]}
{"disableReflectedEntityCache": ["public static void setReflectedEntityCacheDisabled(boolean disableReflectedEntityCache) {", "        if (TableServiceEntity.reflectedEntityCache != null && disableReflectedEntityCache) {", "        TableServiceEntity.disableReflectedEntityCache = disableReflectedEntityCache;"]}
{"request": ["public static String getDate(final HttpURLConnection request) {", "        final String retString = request.getHeaderField(\"Date\");", "        return retString == null ? request.getHeaderField(Constants.HeaderConstants.DATE) : retString;"]}
{"request": ["public static HashMap<String, String> getMetadata(final HttpURLConnection request) {", "        return getValuesByHeaderPrefix(request, Constants.HeaderConstants.PREFIX_FOR_STORAGE_METADATA);"]}
{"request": ["public static boolean isServerRequestEncrypted(HttpURLConnection request) {", "        return Constants.TRUE.equals(request.getHeaderField(Constants.HeaderConstants.SERVER_REQUEST_ENCRYPTED));"]}
{"reader": ["public static StorageExtendedErrorInformation getExtendedErrorInformation(final Reader reader,", "        JsonParser parser = jsonFactory.createParser(reader);", "            if (!parser.hasCurrentToken()) {", "                parser.nextToken();", "            JsonUtilities.assertIsStartObjectJsonToken(parser);", "            parser.nextToken();", "            JsonUtilities.assertIsFieldNameJsonToken(parser);", "            JsonUtilities.assertIsExpectedFieldName(parser, \"odata.error\");", "            parser.nextToken();", "            JsonUtilities.assertIsStartObjectJsonToken(parser);", "            parser.nextValue();", "            JsonUtilities.assertIsExpectedFieldName(parser, TableConstants.ErrorConstants.ERROR_CODE);", "            errorInfo.setErrorCode(parser.getValueAsString());", "            parser.nextToken();", "            JsonUtilities.assertIsFieldNameJsonToken(parser);", "            JsonUtilities.assertIsExpectedFieldName(parser, TableConstants.ErrorConstants.ERROR_MESSAGE);", "            parser.nextToken();", "            JsonUtilities.assertIsStartObjectJsonToken(parser);", "            parser.nextValue();", "            JsonUtilities.assertIsExpectedFieldName(parser, \"lang\");", "            parser.nextValue();", "            JsonUtilities.assertIsExpectedFieldName(parser, \"value\");", "            errorInfo.setErrorMessage(parser.getValueAsString());", "            parser.nextToken();", "            JsonUtilities.assertIsEndObjectJsonToken(parser);", "            parser.nextToken();", "            if (parser.getCurrentToken() == JsonToken.FIELD_NAME) {", "                JsonUtilities.assertIsExpectedFieldName(parser, TableConstants.ErrorConstants.INNER_ERROR);", "                errorInfo.getAdditionalDetails().putAll(parseJsonErrorException(parser));", "                parser.nextToken();", "            JsonUtilities.assertIsEndObjectJsonToken(parser);", "            parser.nextToken();", "            JsonUtilities.assertIsEndObjectJsonToken(parser);", "            parser.close();"], "format": []}
{"request": ["public static StorageExtendedErrorInformation parseErrorDetails(StorageRequest<CloudTableClient, ?, ?> request) {", "            if (request == null || request.getConnection().getErrorStream() == null) {", "            \t\trequest.getConnection().getErrorStream()), "]}
{"parser": ["private static HashMap<String, String[]> parseJsonErrorException(JsonParser parser) throws JsonParseException,", "        parser.nextToken();", "        JsonUtilities.assertIsStartObjectJsonToken(parser);", "        parser.nextToken();", "        JsonUtilities.assertIsFieldNameJsonToken(parser);", "        while (parser.getCurrentToken() != JsonToken.END_OBJECT) {", "            if (parser.getCurrentName().equals(TableConstants.ErrorConstants.ERROR_MESSAGE)) {", "                parser.nextToken();", "                        new String[] { parser.getValueAsString() });", "            else if (parser.getCurrentName().equals(TableConstants.ErrorConstants.ERROR_EXCEPTION_TYPE)) {", "                parser.nextToken();", "                        new String[] { parser.getValueAsString() });", "            else if (parser.getCurrentName().equals(TableConstants.ErrorConstants.ERROR_EXCEPTION_STACK_TRACE)) {", "                parser.nextToken();", "                        .put(Constants.ERROR_EXCEPTION_STACK_TRACE, new String[] { parser.getValueAsString() });", "            parser.nextToken();"]}
{"stream": ["public static <T extends SharedAccessPolicy> HashMap<String, T> getAccessIdentifiers(final InputStream stream,", "        saxParser.parse(stream, handler);"], "cls": ["            final Class<T> cls) throws ParserConfigurationException, SAXException, IOException {", "        SharedAccessPolicyHandler<T> handler = new SharedAccessPolicyHandler<T>(cls);", "        saxParser.parse(stream, handler);", "        return handler.policies;"]}
{"request": ["public static CopyState getCopyState(final HttpURLConnection request) throws URISyntaxException, ParseException {", "        String copyStatusString = request.getHeaderField(Constants.HeaderConstants.COPY_STATUS);", "            copyState.setCopyId(request.getHeaderField(Constants.HeaderConstants.COPY_ID));", "            copyState.setStatusDescription(request.getHeaderField(Constants.HeaderConstants.COPY_STATUS_DESCRIPTION));", "            final String copyProgressString = request.getHeaderField(Constants.HeaderConstants.COPY_PROGRESS);", "            final String copySourceString = request.getHeaderField(Constants.HeaderConstants.COPY_SOURCE);", "                    request.getHeaderField(Constants.HeaderConstants.COPY_COMPLETION_TIME);"]}
{"request": ["public static FileShareAttributes getFileShareAttributes(final HttpURLConnection request,", "        shareProperties.setEtag(BaseResponse.getEtag(request));", "        shareProperties.setShareQuota(parseShareQuota(request));", "        shareProperties.setLastModified(new Date(request.getLastModified()));", "        shareAttributes.setMetadata(getMetadata(request));"], "usePathStyleUris": []}
{"request": ["public static FileDirectoryAttributes getFileDirectoryAttributes(final HttpURLConnection request,", "            tempURI = PathUtility.stripSingleURIQueryAndFragment(request.getURL().toURI());", "        directoryProperties.setEtag(BaseResponse.getEtag(request));", "        directoryProperties.setLastModified(new Date(request.getLastModified()));", "        directoryAttributes.setMetadata(getMetadata(request));", "                Constants.TRUE.equals(request.getHeaderField(Constants.HeaderConstants.SERVER_ENCRYPTED)));"], "usePathStyleUris": ["            final boolean usePathStyleUris) throws StorageException {", "        directoryAttributes.setName(PathUtility.getDirectoryNameFromURI(tempURI, usePathStyleUris));"]}
{"request": ["public static FileAttributes getFileAttributes(final HttpURLConnection request, final StorageUri resourceURI)", "        properties.setCacheControl(request.getHeaderField(Constants.HeaderConstants.CACHE_CONTROL));", "        properties.setContentDisposition(request.getHeaderField(Constants.HeaderConstants.CONTENT_DISPOSITION));", "        properties.setContentEncoding(request.getHeaderField(Constants.HeaderConstants.CONTENT_ENCODING));", "        properties.setContentLanguage(request.getHeaderField(Constants.HeaderConstants.CONTENT_LANGUAGE));", "        if (!Utility.isNullOrEmpty(request.getHeaderField(Constants.HeaderConstants.CONTENT_RANGE))) {", "            properties.setContentMD5(request.getHeaderField(FileConstants.FILE_CONTENT_MD5_HEADER));", "            properties.setContentMD5(request.getHeaderField(Constants.HeaderConstants.CONTENT_MD5));", "        properties.setContentType(request.getHeaderField(Constants.HeaderConstants.CONTENT_TYPE));", "        properties.setEtag(BaseResponse.getEtag(request));", "        properties.setCopyState(FileResponse.getCopyState(request));", "                Constants.TRUE.equals(request.getHeaderField(Constants.HeaderConstants.SERVER_ENCRYPTED)));", "        lastModifiedCalendar.setTime(new Date(request.getLastModified()));", "        final String rangeHeader = request.getHeaderField(Constants.HeaderConstants.CONTENT_RANGE);", "        final String xContentLengthHeader = request.getHeaderField(FileConstants.CONTENT_LENGTH_HEADER);", "            final String contentLength = request.getHeaderField(Constants.HeaderConstants.CONTENT_LENGTH);", "        fileAttributes.setMetadata(BaseResponse.getMetadata(request));"], "resourceURI": ["public static FileAttributes getFileAttributes(final HttpURLConnection request, final StorageUri resourceURI)", "        fileAttributes.setStorageUri(resourceURI);"]}
{"operationType": ["static String getHttpVerbForOperation(final TableOperationType operationType) {", "        if (operationType == TableOperationType.INSERT) {", "        else if (operationType == TableOperationType.DELETE) {", "        else if (operationType == TableOperationType.MERGE || operationType == TableOperationType.INSERT_OR_MERGE) {", "        else if (operationType == TableOperationType.REPLACE || operationType == TableOperationType.INSERT_OR_REPLACE) {", "        else if (operationType == TableOperationType.RETRIEVE) {"]}
{"event": ["public void fireEvent(final EVENT_TYPE event) {", "            listener.eventOccurred(event);"]}
{"opContext": ["private static void fireSendingRequestEvent(OperationContext opContext, HttpURLConnection request,", "        if (opContext.getSendingRequestEventHandler().hasListeners()", "            SendingRequestEvent event = new SendingRequestEvent(opContext, request, result);", "            opContext.getSendingRequestEventHandler().fireEvent(event);"], "request": ["private static void fireSendingRequestEvent(OperationContext opContext, HttpURLConnection request,", "            SendingRequestEvent event = new SendingRequestEvent(opContext, request, result);"], "result": ["            RequestResult result) {", "            SendingRequestEvent event = new SendingRequestEvent(opContext, request, result);", "            opContext.getSendingRequestEventHandler().fireEvent(event);", "            OperationContext.getGlobalSendingRequestEventHandler().fireEvent(event);"]}
{"opContext": ["private static void fireResponseReceivedEvent(OperationContext opContext, HttpURLConnection request,", "        if (opContext.getResponseReceivedEventHandler().hasListeners()", "            ResponseReceivedEvent event = new ResponseReceivedEvent(opContext, request, result);", "            opContext.getResponseReceivedEventHandler().fireEvent(event);"], "request": ["private static void fireResponseReceivedEvent(OperationContext opContext, HttpURLConnection request,", "            ResponseReceivedEvent event = new ResponseReceivedEvent(opContext, request, result);"], "result": ["            RequestResult result) {", "            ResponseReceivedEvent event = new ResponseReceivedEvent(opContext, request, result);", "            opContext.getResponseReceivedEventHandler().fireEvent(event);", "            OperationContext.getGlobalResponseReceivedEventHandler().fireEvent(event);"]}
{"opContext": ["private static void fireErrorReceivingResponseEvent(OperationContext opContext, HttpURLConnection request,", "        if (opContext.getErrorReceivingResponseEventHandler().hasListeners()", "            ErrorReceivingResponseEvent event = new ErrorReceivingResponseEvent(opContext, request, result);", "            opContext.getErrorReceivingResponseEventHandler().fireEvent(event);"], "request": ["private static void fireErrorReceivingResponseEvent(OperationContext opContext, HttpURLConnection request,", "            ErrorReceivingResponseEvent event = new ErrorReceivingResponseEvent(opContext, request, result);"], "result": ["            RequestResult result) {", "            ErrorReceivingResponseEvent event = new ErrorReceivingResponseEvent(opContext, request, result);", "            opContext.getErrorReceivingResponseEventHandler().fireEvent(event);", "            OperationContext.getGlobalErrorReceivingResponseEventHandler().fireEvent(event);"]}
{"opContext": ["private static void fireRequestCompletedEvent(OperationContext opContext, HttpURLConnection request,", "        if (opContext.getRequestCompletedEventHandler().hasListeners()", "            RequestCompletedEvent event = new RequestCompletedEvent(opContext, request, result);", "            opContext.getRequestCompletedEventHandler().fireEvent(event);"], "request": ["private static void fireRequestCompletedEvent(OperationContext opContext, HttpURLConnection request,", "            RequestCompletedEvent event = new RequestCompletedEvent(opContext, request, result);"], "result": ["            RequestResult result) {", "            RequestCompletedEvent event = new RequestCompletedEvent(opContext, request, result);", "            opContext.getRequestCompletedEventHandler().fireEvent(event);", "            OperationContext.getGlobalRequestCompletedEventHandler().fireEvent(event);"]}
{"opContext": ["private static void fireRetryingEvent(OperationContext opContext, HttpURLConnection request, RequestResult result,", "        if (opContext.getRetryingEventHandler().hasListeners()", "            RetryingEvent event = new RetryingEvent(opContext, request, result, retryContext);", "            opContext.getRetryingEventHandler().fireEvent(event);"], "request": ["private static void fireRetryingEvent(OperationContext opContext, HttpURLConnection request, RequestResult result,", "            RetryingEvent event = new RetryingEvent(opContext, request, result, retryContext);"], "result": ["private static void fireRetryingEvent(OperationContext opContext, HttpURLConnection request, RequestResult result,", "            RetryingEvent event = new RetryingEvent(opContext, request, result, retryContext);"], "retryContext": ["            RetryContext retryContext) {", "            RetryingEvent event = new RetryingEvent(opContext, request, result, retryContext);", "            opContext.getRetryingEventHandler().fireEvent(event);", "            OperationContext.getGlobalRetryingEventHandler().fireEvent(event);"]}
{"continuationToken": ["public static void assertContinuationType(final ResultContinuation continuationToken,", "        if (continuationToken != null) {", "            if (!(continuationToken.getContinuationType() == ResultContinuationType.NONE || continuationToken", "                        continuationToken.getContinuationType(), continuationType);"], "continuationType": ["            final ResultContinuationType continuationType) {", "                    .getContinuationType() == continuationType)) {", "                final String errorMessage = String.format(Utility.LOCALE_US, SR.UNEXPECTED_CONTINUATION_TYPE,", "                        continuationToken.getContinuationType(), continuationType);", "                throw new IllegalArgumentException(errorMessage);"]}
{"param": ["public static void assertInBounds(final String param, final long value, final long min, final long max) {", "            throw new IllegalArgumentException(String.format(SR.PARAMETER_NOT_IN_RANGE, param, min, max));"], "value": ["public static void assertInBounds(final String param, final long value, final long min, final long max) {", "        if (value < min || value > max) {"], "min": ["public static void assertInBounds(final String param, final long value, final long min, final long max) {", "        if (value < min || value > max) {", "            throw new IllegalArgumentException(String.format(SR.PARAMETER_NOT_IN_RANGE, param, min, max));"], "max": ["public static void assertInBounds(final String param, final long value, final long min, final long max) {", "        if (value < min || value > max) {", "            throw new IllegalArgumentException(String.format(SR.PARAMETER_NOT_IN_RANGE, param, min, max));"]}
{"param": ["public static void assertGreaterThanOrEqual(final String param, final long value, final long min) {", "            throw new IllegalArgumentException(String.format(SR.PARAMETER_SHOULD_BE_GREATER_OR_EQUAL, param, min));"], "value": ["public static void assertGreaterThanOrEqual(final String param, final long value, final long min) {", "        if (value < min) {"], "min": ["public static void assertGreaterThanOrEqual(final String param, final long value, final long min) {", "        if (value < min) {", "            throw new IllegalArgumentException(String.format(SR.PARAMETER_SHOULD_BE_GREATER_OR_EQUAL, param, min));"]}
{"operationExpiryTimeInMs": ["public static boolean validateMaxExecutionTimeout(Long operationExpiryTimeInMs, long additionalInterval) {", "        if (operationExpiryTimeInMs != null) {", "            return operationExpiryTimeInMs < currentTime + additionalInterval;"], "additionalInterval": ["public static boolean validateMaxExecutionTimeout(Long operationExpiryTimeInMs, long additionalInterval) {", "            return operationExpiryTimeInMs < currentTime + additionalInterval;"]}
{"operationExpiryTimeInMs": ["public static int getRemainingTimeout(Long operationExpiryTimeInMs, Integer timeoutIntervalInMs) throws StorageException {", "        if (operationExpiryTimeInMs != null) {", "            long remainingTime = operationExpiryTimeInMs - new Date().getTime();"], "timeoutIntervalInMs": ["public static int getRemainingTimeout(Long operationExpiryTimeInMs, Integer timeoutIntervalInMs) throws StorageException {", "        else if (timeoutIntervalInMs != null) {", "            return timeoutIntervalInMs + Constants.DEFAULT_READ_TIMEOUT;"]}
{"baseURI": ["public static boolean determinePathStyleFromUri(final URI baseURI) {", "        String path = baseURI.getPath();", "        return pathStylePorts.contains(baseURI.getPort()) || !isHostDnsName(baseURI);"]}
{"uri": ["private static boolean isHostDnsName(URI uri) {", "        String host = uri.getHost();"]}
{"etag": ["public static String formatETag(final String etag) {", "        if (etag.startsWith(\"\\\"\") && etag.endsWith(\"\\\"\")) {", "            return etag;", "            return String.format(\"\\\"%s\\\"\", etag);"]}
{"cause": ["public static StorageException generateNewUnexpectedStorageException(final Exception cause) {", "        exceptionRef.initCause(cause);"]}
{"conn": ["public static String getStandardHeaderValue(final HttpURLConnection conn, final String headerName) {", "        final String headerValue = conn.getRequestProperty(headerName);"], "headerName": ["public static String getStandardHeaderValue(final HttpURLConnection conn, final String headerName) {", "        final String headerValue = conn.getRequestProperty(headerName);", "        return headerValue == null ? Constants.EMPTY_STRING : headerValue;"]}
{"value": ["public static Date parseDateFromString(final String value, final String pattern, final TimeZone timeZone)", "        return rfc1123Format.parse(value);"], "pattern": ["public static Date parseDateFromString(final String value, final String pattern, final TimeZone timeZone)", "        final DateFormat rfc1123Format = new SimpleDateFormat(pattern, Utility.LOCALE_US);"], "timeZone": ["public static Date parseDateFromString(final String value, final String pattern, final TimeZone timeZone)", "        rfc1123Format.setTimeZone(timeZone);"]}
{"value": ["public static Date parseRFC1123DateFromStringInGMT(final String value) throws ParseException {", "        return format.parse(value);"]}
{"baseURI": ["public static String safeRelativize(final URI baseURI, final URI toUri) throws URISyntaxException {", "        if (!baseURI.getHost().equals(toUri.getHost()) || !baseURI.getScheme().equals(toUri.getScheme())) {", "        final String basePath = baseURI.getPath();"], "toUri": ["public static String safeRelativize(final URI baseURI, final URI toUri) throws URISyntaxException {", "        if (!baseURI.getHost().equals(toUri.getHost()) || !baseURI.getScheme().equals(toUri.getScheme())) {", "            return toUri.toString();", "        String toPath = toUri.getPath();", "            return new URI(null, null, null, toUri.getQuery(), toUri.getFragment()).toString();", "            if (!Utility.isNullOrEmpty(toUri.getQuery())) {", "                sb.append(toUri.getQuery());", "            if (!Utility.isNullOrEmpty(toUri.getFragment())) {", "                sb.append(toUri.getRawFragment());"]}
{"ex": ["public static void logHttpError(StorageException ex, OperationContext opContext) {", "                bld.append(ex.getHttpStatusCode());", "                bld.append(ex.getMessage());", "                bld.append(ex.getErrorCode());", "                StorageExtendedErrorInformation extendedError = ex.getExtendedErrorInformation();"], "opContext": ["public static void logHttpError(StorageException ex, OperationContext opContext) {", "        if (Logger.shouldLog(opContext, Log.DEBUG)) {", "                Logger.debug(opContext, bld.toString());"]}
{"conn": ["public static void logHttpResponse(HttpURLConnection conn, OperationContext opContext) throws IOException {", "                for (Map.Entry<String, List<String>> header : conn.getHeaderFields().entrySet()) {", "                    if (header.getKey() != null) {", "                        bld.append(header.getKey());", "                    for (int i = 0; i < header.getValue().size(); i++) {", "                        bld.append(header.getValue().get(i));", "                        if (i < header.getValue().size() - 1) {"], "opContext": ["public static void logHttpResponse(HttpURLConnection conn, OperationContext opContext) throws IOException {", "        if (Logger.shouldLog(opContext, Log.VERBOSE)) {", "                Logger.verbose(opContext, bld.toString());"]}
{"value": ["protected static String trimEnd(final String value, final char trimChar) {", "        int stopDex = value.length() - 1;", "        while (stopDex > 0 && value.charAt(stopDex) == trimChar) {", "        return stopDex == value.length() - 1 ? value : value.substring(stopDex);"], "trimChar": ["protected static String trimEnd(final String value, final char trimChar) {", "        while (stopDex > 0 && value.charAt(stopDex) == trimChar) {"]}
{"value": ["public static String trimStart(final String value) {", "        while (spaceDex < value.length() && value.charAt(spaceDex) == ' ') {", "        return value.substring(spaceDex);"]}
{"dateString": ["public static Date parseDate(String dateString) {", "        switch(dateString.length()) {", "                dateString = dateString.substring(0, MAX_PRECISION_DATESTRING_LENGTH);"]}
{"token": ["public static RequestLocationMode getListingLocationMode(ResultContinuation token) {", "        if ((token != null) && token.getTargetLocation() != null) {", "            switch (token.getTargetLocation()) {", "                            token.getTargetLocation()));"]}
{"options": ["protected static final QueueRequestOptions populateAndApplyDefaults(QueueRequestOptions options, final CloudQueueClient client) {", "        QueueRequestOptions modifiedOptions = new QueueRequestOptions(options);", "        RequestOptions.populateRequestOptions(modifiedOptions, client.getDefaultRequestOptions(), true /* setStartTime */);", "        QueueRequestOptions.applyDefaults(modifiedOptions);", "        return modifiedOptions;"], "client": ["protected static final QueueRequestOptions populateAndApplyDefaults(QueueRequestOptions options, final CloudQueueClient client) {", "        RequestOptions.populateRequestOptions(modifiedOptions, client.getDefaultRequestOptions(), true /* setStartTime */);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"format": ["public Date readDate(DateFormat format) throws IOException, ParseException {", "            return format.parse(temp);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"delimiter": ["private void readDelimiter(char delimiter) throws IOException {", "            if (read == -1 || (char) read != delimiter) {"]}
{"delimiter": ["private boolean tryPeekDelimiter(char delimiter) throws IOException {", "            if ((char) this.peek() != delimiter) {"]}
{"isQuotedString": ["private String readField(boolean isQuotedString) throws IOException {", "            if ((!isQuotedString || isExpectingDelimiterForNextCharacterForQuotedString || fieldBuilder.length() == 0)", "                if (!isQuotedString) {", "        if (isQuotedString && fieldBuilder.length() != 0) {"]}
{"opContext": []}
{"Result": "Method without Parameter"}
{"clazzType": ["protected void setClazzType(final Class<? extends TableEntity> clazzType) {", "        Utility.assertNotNull(\"clazzType\", clazzType);", "        Utility.checkNullaryCtor(clazzType);", "        this.clazzType = clazzType;"]}
{"resolver": ["protected void setResolver(final EntityResolver<?> resolver) {", "        Utility.assertNotNull(SR.QUERY_REQUIRES_VALID_CLASSTYPE_OR_RESOLVER, resolver);", "        this.resolver = resolver;"]}
{"outWriter": ["private static void writeMIMEBoundary(final OutputStreamWriter outWriter, final String boundaryID)", "        outWriter.write(String.format(\"--%s\\r\\n\", boundaryID));"], "boundaryID": ["private static void writeMIMEBoundary(final OutputStreamWriter outWriter, final String boundaryID)", "        outWriter.write(String.format(\"--%s\\r\\n\", boundaryID));"]}
{"outWriter": ["private static void writeMIMEBoundaryClosure(final OutputStreamWriter outWriter, final String boundaryID)", "        outWriter.write(String.format(\"--%s--\\r\\n\", boundaryID));"], "boundaryID": ["private static void writeMIMEBoundaryClosure(final OutputStreamWriter outWriter, final String boundaryID)", "        outWriter.write(String.format(\"--%s--\\r\\n\", boundaryID));"]}
{"outWriter": ["private static void writeMIMEContentType(final OutputStreamWriter outWriter, final String boundaryName)", "        outWriter.write(String.format(\"Content-Type: multipart/mixed; boundary=%s\\r\\n\", boundaryName));"], "boundaryName": ["private static void writeMIMEContentType(final OutputStreamWriter outWriter, final String boundaryName)", "        outWriter.write(String.format(\"Content-Type: multipart/mixed; boundary=%s\\r\\n\", boundaryName));"]}
{"name": ["public void add(final String name, final String value) throws StorageException {", "        if (Utility.isNullOrEmpty(name)) {", "        this.insertKeyValue(name, value);"], "value": ["public void add(final String name, final String value) throws StorageException {", "        this.insertKeyValue(name, value);"]}
{"uri": ["public URI addToURI(final URI uri) throws URISyntaxException, StorageException {", "        final String origRawQuery = uri.getRawQuery();", "        final String rawFragment = uri.getRawFragment();", "        final String uriString = uri.resolve(uri).toASCIIString();", "            if (uri.getRawPath().length() <= 0) {"]}
{"request": ["public static void addOptionalHeader(final HttpURLConnection request, final String name, final String value) {", "            request.setRequestProperty(name, value);"], "name": ["public static void addOptionalHeader(final HttpURLConnection request, final String name, final String value) {", "            request.setRequestProperty(name, value);"], "value": ["public static void addOptionalHeader(final HttpURLConnection request, final String name, final String value) {", "        if (value != null && !value.equals(Constants.EMPTY_STRING)) {", "            request.setRequestProperty(name, value);"]}
{"uri": ["public static HttpURLConnection createURLConnection(final URI uri, final RequestOptions options,", "        final URL resourceUrl = builder.addToURI(uri).toURL();"], "options": ["public static HttpURLConnection createURLConnection(final URI uri, final RequestOptions options,", "        if (options.getTimeoutIntervalInMs() != null && options.getTimeoutIntervalInMs() != 0) {", "            builder.add(TIMEOUT, String.valueOf(options.getTimeoutIntervalInMs() / 1000));", "        int timeout = Utility.getRemainingTimeout(options.getOperationExpiryTimeInMs(), options.getTimeoutIntervalInMs());"], "builder": ["            UriQueryBuilder builder, final OperationContext opContext) throws IOException, URISyntaxException,", "        if (builder == null) {", "            builder.add(TIMEOUT, String.valueOf(options.getTimeoutIntervalInMs() / 1000));", "        final URL resourceUrl = builder.addToURI(uri).toURL();"], "opContext": ["            UriQueryBuilder builder, final OperationContext opContext) throws IOException, URISyntaxException,", "        if (opContext != null && opContext.getProxy() != null) {", "            proxy = opContext.getProxy();", "                opContext.getClientRequestID());"]}
{"uri": ["public static HttpURLConnection delete(final URI uri, final RequestOptions options, UriQueryBuilder builder,", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);"], "options": ["public static HttpURLConnection delete(final URI uri, final RequestOptions options, UriQueryBuilder builder,", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);"], "builder": ["public static HttpURLConnection delete(final URI uri, final RequestOptions options, UriQueryBuilder builder,", "        if (builder == null) {", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);"], "opContext": ["            final OperationContext opContext) throws IOException, URISyntaxException, StorageException {", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);", "        retConnection.setRequestMethod(Constants.HTTP_DELETE);", "        return retConnection;"]}
{"uri": ["public static HttpURLConnection getServiceProperties(final URI uri, final RequestOptions options,", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);"], "options": ["public static HttpURLConnection getServiceProperties(final URI uri, final RequestOptions options,", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);"], "builder": ["            UriQueryBuilder builder, final OperationContext opContext) throws IOException, URISyntaxException,", "        if (builder == null) {", "        builder.add(Constants.QueryConstants.COMPONENT, Constants.QueryConstants.PROPERTIES);", "        builder.add(Constants.QueryConstants.RESOURCETYPE, SERVICE);", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);"], "opContext": ["            UriQueryBuilder builder, final OperationContext opContext) throws IOException, URISyntaxException,", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);", "        retConnection.setRequestMethod(Constants.HTTP_GET);", "        return retConnection;"]}
{"Result": "Method without Parameter"}
{"uri": ["public static HttpURLConnection setMetadata(final URI uri, final RequestOptions options, UriQueryBuilder builder,", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);"], "options": ["public static HttpURLConnection setMetadata(final URI uri, final RequestOptions options, UriQueryBuilder builder,", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);"], "builder": ["public static HttpURLConnection setMetadata(final URI uri, final RequestOptions options, UriQueryBuilder builder,", "        if (builder == null) {", "        builder.add(Constants.QueryConstants.COMPONENT, METADATA);", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);"], "opContext": ["            final OperationContext opContext) throws IOException, URISyntaxException, StorageException {", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);", "        retConnection.setFixedLengthStreamingMode(0);", "        retConnection.setDoOutput(true);", "        retConnection.setRequestMethod(Constants.HTTP_PUT);", "        return retConnection;"]}
{"uri": ["public static HttpURLConnection setServiceProperties(final URI uri, final RequestOptions options,", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);"], "options": ["public static HttpURLConnection setServiceProperties(final URI uri, final RequestOptions options,", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);"], "builder": ["            UriQueryBuilder builder, final OperationContext opContext) throws IOException, URISyntaxException,", "        if (builder == null) {", "        builder.add(Constants.QueryConstants.COMPONENT, Constants.QueryConstants.PROPERTIES);", "        builder.add(Constants.QueryConstants.RESOURCETYPE, SERVICE);", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);"], "opContext": ["            UriQueryBuilder builder, final OperationContext opContext) throws IOException, URISyntaxException,", "        final HttpURLConnection retConnection = createURLConnection(uri, options, builder, opContext);", "        retConnection.setDoOutput(true);", "        retConnection.setRequestMethod(Constants.HTTP_PUT);", "        return retConnection;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"writeLength": ["    private synchronized void dispatchWrite(final int writeLength) throws IOException {", "        if (writeLength == 0) {", "        long tempLength = writeLength;", "        final long opWriteLength = tempLength;", "        this.currentOffset += writeLength;", "                    fileRef.uploadRange(bufferRef, opOffset, opWriteLength, FileOutputStream.this.accessCondition,"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"data": ["    public void write(final byte[] data, final int offset, final int length) throws IOException {", "        if (offset < 0 || length < 0 || length > data.length - offset) {", "        this.writeInternal(data, offset, length);"], "offset": ["    public void write(final byte[] data, final int offset, final int length) throws IOException {", "        if (offset < 0 || length < 0 || length > data.length - offset) {", "        this.writeInternal(data, offset, length);"], "length": ["    public void write(final byte[] data, final int offset, final int length) throws IOException {", "        if (offset < 0 || length < 0 || length > data.length - offset) {", "        this.writeInternal(data, offset, length);"]}
{"sourceStream": ["    public void write(final InputStream sourceStream, final long writeLength) throws IOException, StorageException {", "        Utility.writeToOutputStream(sourceStream, this, writeLength, false, false, this.opContext, this.options, false);"], "writeLength": ["    public void write(final InputStream sourceStream, final long writeLength) throws IOException, StorageException {", "        Utility.writeToOutputStream(sourceStream, this, writeLength, false, false, this.opContext, this.options, false);"]}
{"data": ["    private synchronized void writeInternal(final byte[] data, int offset, int length) throws IOException {", "                this.md5Digest.update(data, offset, nextWrite);", "            this.outBuffer.write(data, offset, nextWrite);"], "offset": ["    private synchronized void writeInternal(final byte[] data, int offset, int length) throws IOException {", "                this.md5Digest.update(data, offset, nextWrite);", "            this.outBuffer.write(data, offset, nextWrite);"], "length": ["    private synchronized void writeInternal(final byte[] data, int offset, int length) throws IOException {", "        while (length > 0) {", "            final int availableBufferBytes = this.internalWriteThreshold - this.currentBufferedBytes;", "            final int nextWrite = Math.min(availableBufferBytes, length);", "                this.md5Digest.update(data, offset, nextWrite);", "            this.outBuffer.write(data, offset, nextWrite);", "            this.currentBufferedBytes += nextWrite;", "            offset += nextWrite;", "            length -= nextWrite;", "            if (this.currentBufferedBytes == this.internalWriteThreshold) {"]}
{"service": ["private static String getDNS(String service, String base) {", "        return String.format(DNS_NAME_FORMAT, service, base);"], "base": ["private static String getDNS(String service, String base) {", "        if (base == null) {", "        return String.format(DNS_NAME_FORMAT, service, base);"]}
{"settings": ["private static CloudStorageAccount tryConfigureDevStore(final Map<String, String> settings)", "                settings,", "            if (!Boolean.parseBoolean(settings.get(USE_DEVELOPMENT_STORAGE_NAME))) {", "            if (settings.containsKey(DEVELOPMENT_STORAGE_PROXY_URI_NAME)) {", "                devStoreProxyUri = new URI(settings.get(DEVELOPMENT_STORAGE_PROXY_URI_NAME));"]}
{"settings": ["private static CloudStorageAccount tryConfigureServiceAccount(final Map<String, String> settings)", "        Boolean matchesAutomaticEndpointsSpec = matchesSpecification(settings, automaticEndpointsMatchSpec);", "        Boolean matchesExplicitEndpointsSpec = matchesSpecification(settings, explicitEndpointsMatchSpec);", "            if (matchesAutomaticEndpointsSpec && !settings.containsKey(DEFAULT_ENDPOINTS_PROTOCOL_NAME)) {", "                settings.put(DEFAULT_ENDPOINTS_PROTOCOL_NAME, \"https\");", "            String blobEndpoint = settingOrDefault(settings, BLOB_ENDPOINT_NAME);", "            String queueEndpoint = settingOrDefault(settings, QUEUE_ENDPOINT_NAME);", "            String tableEndpoint = settingOrDefault(settings, TABLE_ENDPOINT_NAME);", "            String fileEndpoint = settingOrDefault(settings, FILE_ENDPOINT_NAME);", "            String blobSecondaryEndpoint = settingOrDefault(settings, BLOB_SECONDARY_ENDPOINT_NAME);", "            String queueSecondaryEndpoint = settingOrDefault(settings, QUEUE_SECONDARY_ENDPOINT_NAME);", "            String tableSecondaryEndpoint = settingOrDefault(settings, TABLE_SECONDARY_ENDPOINT_NAME);", "            String fileSecondaryEndpoint = settingOrDefault(settings, FILE_SECONDARY_ENDPOINT_NAME);", "                                StorageCredentials.tryParseCredentials(settings),", "                                getStorageUri(settings, SR.BLOB, BLOB_ENDPOINT_NAME, BLOB_SECONDARY_ENDPOINT_NAME, matchesAutomaticEndpointsSpec),", "                                getStorageUri(settings, SR.QUEUE, QUEUE_ENDPOINT_NAME, QUEUE_SECONDARY_ENDPOINT_NAME, matchesAutomaticEndpointsSpec),", "                                getStorageUri(settings, SR.TABLE, TABLE_ENDPOINT_NAME, TABLE_SECONDARY_ENDPOINT_NAME, matchesAutomaticEndpointsSpec),", "                                getStorageUri(settings, SR.FILE, FILE_ENDPOINT_NAME, FILE_SECONDARY_ENDPOINT_NAME, matchesAutomaticEndpointsSpec)", "                accountInformation.endpointSuffix = settingOrDefault(settings, ENDPOINT_SUFFIX_NAME);", "                accountInformation.accountName = settingOrDefault(settings, ACCOUNT_NAME_NAME);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"policy": ["public String generateSharedAccessSignature(SharedAccessAccountPolicy policy)", "                this.credentials.getAccountName(), policy, this.getCredentials());", "                SharedAccessSignatureHelper.generateSharedAccessSignatureForAccount(policy, sig);"]}
{"isSingleIndexEntry": ["protected String generateRequestIdentity(boolean isSingleIndexEntry, final String entryName)", "        if (isSingleIndexEntry) {"], "entryName": ["protected String generateRequestIdentity(boolean isSingleIndexEntry, final String entryName)", "            return String.format(\"'%s'\", entryName.replace(\"'\", \"''\"));"]}
{"tableName": ["protected String generateRequestIdentityWithTable(final String tableName) throws StorageException {", "        return String.format(\"%s(%s)\", tableName, generateRequestIdentity(false, null));"]}
{"opContext": ["protected final void initialize(OperationContext opContext) {", "        opContext.appendRequestResult(currResult);"]}
{"opContext": ["protected final StorageException materializeException(final OperationContext opContext) {", "        return StorageException.translateException(this, null, opContext);"]}
{"connection": [], "parentObject": [], "client": [], "context": [], "storageObject": ["            R storageObject) throws Exception {", "        return storageObject;"]}
{"Result": "Method without Parameter"}
{"entity": ["public void delete(final TableEntity entity) {", "        this.lockToPartitionKey(entity.getPartitionKey());", "        this.add(TableOperation.delete(entity));"]}
{"entity": ["public void insert(final TableEntity entity, boolean echoContent) {", "        this.lockToPartitionKey(entity.getPartitionKey());", "        this.add(TableOperation.insert(entity, echoContent));"], "echoContent": ["public void insert(final TableEntity entity, boolean echoContent) {", "        this.add(TableOperation.insert(entity, echoContent));"]}
{"entity": ["public void insertOrMerge(final TableEntity entity) {", "        this.lockToPartitionKey(entity.getPartitionKey());", "        this.add(TableOperation.insertOrMerge(entity));"]}
{"entity": ["public void insertOrReplace(final TableEntity entity) {", "        this.lockToPartitionKey(entity.getPartitionKey());", "        this.add(TableOperation.insertOrReplace(entity));"]}
{"entity": ["public void merge(final TableEntity entity) {", "        this.lockToPartitionKey(entity.getPartitionKey());", "        this.add(TableOperation.merge(entity));"]}
{"index": ["    public TableOperation remove(int index) {", "        TableOperation op = super.remove(index);", "        return op;"]}
{"c": ["    public boolean removeAll(java.util.Collection<?> c) {", "        boolean ret = super.removeAll(c);", "        return ret;"]}
{"entity": ["public void replace(final TableEntity entity) {", "        this.lockToPartitionKey(entity.getPartitionKey());", "        this.add(TableOperation.replace(entity));"]}
{"op": ["private void checkSingleQueryPerBatch(final TableOperation op, final int size) {", "        if (op.getOperationType() == TableOperationType.RETRIEVE) {", "        this.containsWrites = op.getOperationType() != TableOperationType.RETRIEVE;"], "size": ["private void checkSingleQueryPerBatch(final TableOperation op, final int size) {", "            if (size > 0) {"]}
{"partitionKey": ["private void lockToPartitionKey(final String partitionKey) {", "        if (this.partitionKey == null) {", "            this.partitionKey = partitionKey;", "            if (partitionKey.length() != partitionKey.length() || !this.partitionKey.equals(partitionKey)) {"]}
{"options": ["    public void create(FileRequestOptions options, OperationContext opContext) throws StorageException {", "        options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient);"], "opContext": ["    public void create(FileRequestOptions options, OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"accessCondition": ["    public boolean deleteIfExists(AccessCondition accessCondition, FileRequestOptions options,", "        return this.deleteIfExists(DeleteShareSnapshotsOption.NONE, accessCondition, options, opContext);"], "options": ["    public boolean deleteIfExists(AccessCondition accessCondition, FileRequestOptions options,", "        return this.deleteIfExists(DeleteShareSnapshotsOption.NONE, accessCondition, options, opContext);"], "opContext": ["            OperationContext opContext) throws StorageException {", "        return this.deleteIfExists(DeleteShareSnapshotsOption.NONE, accessCondition, options, opContext);"]}
{"accessCondition": ["    public FileSharePermissions downloadPermissions(AccessCondition accessCondition, FileRequestOptions options,", "                downloadPermissionsImpl(accessCondition, options), options.getRetryPolicyFactory(), opContext);"], "options": ["    public FileSharePermissions downloadPermissions(AccessCondition accessCondition, FileRequestOptions options,", "        options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient);"], "opContext": ["            OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "        opContext.initialize();", "                downloadPermissionsImpl(accessCondition, options), options.getRetryPolicyFactory(), opContext);"]}
{"policy": ["            final SharedAccessFilePolicy policy, final String groupPolicyIdentifier, final IPRange ipRange,", "                policy, null /* SharedAccessHeaders */, groupPolicyIdentifier, resourceName,", "                policy, null /* SharedAccessHeaders */, groupPolicyIdentifier, \"s\", ipRange, protocols, signature);"], "groupPolicyIdentifier": ["            final SharedAccessFilePolicy policy, final String groupPolicyIdentifier, final IPRange ipRange,", "                policy, null /* SharedAccessHeaders */, groupPolicyIdentifier, resourceName,", "                policy, null /* SharedAccessHeaders */, groupPolicyIdentifier, \"s\", ipRange, protocols, signature);"], "ipRange": ["            final SharedAccessFilePolicy policy, final String groupPolicyIdentifier, final IPRange ipRange,", "                ipRange, protocols, this.fileServiceClient);", "                policy, null /* SharedAccessHeaders */, groupPolicyIdentifier, \"s\", ipRange, protocols, signature);"], "protocols": ["            final SharedAccessProtocols protocols)", "                ipRange, protocols, this.fileServiceClient);", "                policy, null /* SharedAccessHeaders */, groupPolicyIdentifier, \"s\", ipRange, protocols, signature);"]}
{"permissions": ["    public void uploadPermissions(final FileSharePermissions permissions) throws StorageException {", "        this.uploadPermissions(permissions, null /* accessCondition */, null /* options */, null /* opContext */);"]}
{"permissions": ["    public void uploadPermissions(final FileSharePermissions permissions, final AccessCondition accessCondition,", "                uploadPermissionsImpl(permissions, accessCondition, options), options.getRetryPolicyFactory(),"], "accessCondition": ["    public void uploadPermissions(final FileSharePermissions permissions, final AccessCondition accessCondition,", "                uploadPermissionsImpl(permissions, accessCondition, options), options.getRetryPolicyFactory(),"], "options": ["            FileRequestOptions options, OperationContext opContext) throws StorageException {", "        options = FileRequestOptions.populateAndApplyDefaults(options, this.fileServiceClient);"], "opContext": ["            FileRequestOptions options, OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "        opContext.initialize();", "                opContext);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"prefix": ["private TableQuery<TableServiceEntity> generateListTablesQuery(final String prefix) {", "        if (!Utility.isNullOrEmpty(prefix)) {", "            final String prefixFilter = String.format(\"(%s ge '%s') and (%s lt '%s{')\", TableConstants.TABLE_NAME,", "                    prefix, TableConstants.TABLE_NAME, prefix);", "            listQuery = listQuery.where(prefixFilter);", "        return listQuery;"]}
{"queryToExecute": ["protected <T extends TableEntity, R> ResultSegment<?> executeQuerySegmentedImpl(final TableQuery<T> queryToExecute,", "        return ExecutionEngine.executeWithRetry(this, queryToExecute,", "                this.executeQuerySegmentedWithResolverCoreImpl(queryToExecute, resolver, options, segmentedRequest),"], "resolver": ["            final EntityResolver<R> resolver, final ResultContinuation continuationToken, TableRequestOptions options,", "                this.executeQuerySegmentedWithResolverCoreImpl(queryToExecute, resolver, options, segmentedRequest),"], "continuationToken": ["            final EntityResolver<R> resolver, final ResultContinuation continuationToken, TableRequestOptions options,", "        Utility.assertContinuationType(continuationToken, ResultContinuationType.TABLE);", "        segmentedRequest.setToken(continuationToken);"], "options": ["            final EntityResolver<R> resolver, final ResultContinuation continuationToken, TableRequestOptions options,", "        options = TableRequestOptions.populateAndApplyDefaults(options, this);", "                this.executeQuerySegmentedWithResolverCoreImpl(queryToExecute, resolver, options, segmentedRequest),", "                options.getRetryPolicyFactory(), opContext);"], "opContext": ["            OperationContext opContext) throws StorageException {", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"queryRef": ["protected <T extends TableEntity, R> Iterable<?> generateIteratorForQuery(final TableQuery<T> queryRef,", "                    queryRef, resolver, options, segmentedRequest), this, queryRef, options.getRetryPolicyFactory(),", "                    this.executeQuerySegmentedWithResolverCoreImpl(queryRef, resolver, options, segmentedRequest),", "                    this, queryRef, options.getRetryPolicyFactory(), opContext);"], "resolver": ["            final EntityResolver<R> resolver, TableRequestOptions options, OperationContext opContext) {", "        if (resolver == null) {", "                    queryRef, resolver, options, segmentedRequest), this, queryRef, options.getRetryPolicyFactory(),", "                    this.executeQuerySegmentedWithResolverCoreImpl(queryRef, resolver, options, segmentedRequest),"], "options": ["            final EntityResolver<R> resolver, TableRequestOptions options, OperationContext opContext) {", "        options = TableRequestOptions.populateAndApplyDefaults(options, this);", "                    queryRef, resolver, options, segmentedRequest), this, queryRef, options.getRetryPolicyFactory(),", "                    this.executeQuerySegmentedWithResolverCoreImpl(queryRef, resolver, options, segmentedRequest),", "                    this, queryRef, options.getRetryPolicyFactory(), opContext);"], "opContext": ["            final EntityResolver<R> resolver, TableRequestOptions options, OperationContext opContext) {", "        if (opContext == null) {", "        opContext.initialize();", "                    opContext);", "                    this, queryRef, options.getRetryPolicyFactory(), opContext);"]}
{"reader": ["private void populateVersion1Log(LogRecordStreamReader reader) throws IOException, ParseException,", "        this.requestStartTime = reader.readDate(LogRecord.REQUEST_START_TIME_FORMAT);", "        this.operationType = reader.readString();", "        this.requestStatus = reader.readString();", "        this.httpStatusCode = reader.readString();", "        this.endToEndLatencyInMS = reader.readInteger();", "        this.serverLatencyInMS = reader.readInteger();", "        this.authenticationType = reader.readString();", "        this.requesterAccountName = reader.readString();", "        this.ownerAccountName = reader.readString();", "        this.serviceType = reader.readString();", "        this.requestUrl = reader.readUri();", "        this.requestedObjectKey = reader.readQuotedString();", "        this.requestIdHeader = reader.readUuid();", "        this.operationCount = reader.readInteger();", "        this.requesterIPAddress = reader.readString();", "        this.requestVersionHeader = reader.readString();", "        this.requestHeaderSize = reader.readLong();", "        this.requestPacketSize = reader.readLong();", "        this.responseHeaderSize = reader.readLong();", "        this.responsePacketSize = reader.readLong();", "        this.requestContentLength = reader.readLong();", "        this.requestMD5 = reader.readQuotedString();", "        this.serverMD5 = reader.readQuotedString();", "        this.eTagIdentifier = reader.readQuotedString();", "        this.lastModifiedTime = reader.readDate(LogRecord.LAST_MODIFIED_TIME_FORMAT);", "        this.conditionsUsed = reader.readQuotedString();", "        this.userAgentHeader = reader.readQuotedString();", "        this.referrerHeader = reader.readQuotedString();", "        this.clientRequestId = reader.readQuotedString();", "        reader.endCurrentRecord();"]}
{"stream": ["public static ListResponse<CloudQueue> getQueues(final InputStream stream, final CloudQueueClient serviceClient)", "        saxParser.parse(stream, handler);"], "serviceClient": ["public static ListResponse<CloudQueue> getQueues(final InputStream stream, final CloudQueueClient serviceClient)", "        QueueListHandler handler = new QueueListHandler(serviceClient);", "        saxParser.parse(stream, handler);", "        return handler.response;"]}
{"statusCode": ["protected static StorageException translateFromHttpStatus(final int statusCode, final String statusDescription,", "        switch (statusCode) {", "            return new StorageException(errorCode, statusDescription, statusCode, null, inner);"], "statusDescription": ["protected static StorageException translateFromHttpStatus(final int statusCode, final String statusDescription,", "            return new StorageException(errorCode, statusDescription, statusCode, null, inner);"], "inner": ["            final Exception inner) {", "            return new StorageException(errorCode, statusDescription, statusCode, null, inner);"]}
{"Result": "Method without Parameter"}
{"prefix": ["    public Iterable<CloudQueue> listQueues(final String prefix) {", "        return this.listQueues(prefix, QueueListingDetails.NONE, null, null);"]}
{"prefix": ["    public Iterable<CloudQueue> listQueues(final String prefix, final QueueListingDetails detailsIncluded,", "        return new LazySegmentedIterable<CloudQueueClient, Void, CloudQueue>(this.listQueuesSegmentedImpl(prefix,"], "detailsIncluded": ["    public Iterable<CloudQueue> listQueues(final String prefix, final QueueListingDetails detailsIncluded,", "                detailsIncluded, null, options, segmentedRequest), this, null, options.getRetryPolicyFactory(), opContext);"], "options": ["            QueueRequestOptions options, OperationContext opContext) {", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this);", "                detailsIncluded, null, options, segmentedRequest), this, null, options.getRetryPolicyFactory(), opContext);"], "opContext": ["            QueueRequestOptions options, OperationContext opContext) {", "        if (opContext == null) {", "        opContext.initialize();", "                detailsIncluded, null, options, segmentedRequest), this, null, options.getRetryPolicyFactory(), opContext);"]}
{"Result": "Method without Parameter"}
{"prefix": ["    public ResultSegment<CloudQueue> listQueuesSegmented(final String prefix,", "                this.listQueuesSegmentedImpl(prefix, detailsIncluded, maxResults, options, segmentedRequest),"], "detailsIncluded": ["            final QueueListingDetails detailsIncluded, final Integer maxResults,", "                this.listQueuesSegmentedImpl(prefix, detailsIncluded, maxResults, options, segmentedRequest),"], "maxResults": ["            final QueueListingDetails detailsIncluded, final Integer maxResults,", "                this.listQueuesSegmentedImpl(prefix, detailsIncluded, maxResults, options, segmentedRequest),"], "continuationToken": ["            final ResultContinuation continuationToken, QueueRequestOptions options, OperationContext opContext)", "        segmentedRequest.setToken(continuationToken);"], "options": ["            final ResultContinuation continuationToken, QueueRequestOptions options, OperationContext opContext)", "        options = QueueRequestOptions.populateAndApplyDefaults(options, this);", "                this.listQueuesSegmentedImpl(prefix, detailsIncluded, maxResults, options, segmentedRequest),", "                options.getRetryPolicyFactory(), opContext);"], "opContext": ["            final ResultContinuation continuationToken, QueueRequestOptions options, OperationContext opContext)", "        if (opContext == null) {", "        opContext.initialize();", "                options.getRetryPolicyFactory(), opContext);"]}
{"aXmlCatalog": ["public void addConfiguredXMLCatalog (@Nonnull final XMLCatalog aXmlCatalog)", "    m_aXmlCatalog.addConfiguredXMLCatalog (aXmlCatalog);", "    log (\"Added XMLCatalog \" + aXmlCatalog, Project.MSG_DEBUG);"]}
{"sID": ["  public String getUniqueID (@Nullable final String sID)", "    if (sID == null)", "    if (m_aUsedIDs.add (sID))", "      return sID;", "    String sNewID = sID + nIndex;", "      sNewID = sID + nIndex;"]}
{"sPhase": ["  public SchematronResourcePure setPhase (@Nullable final String sPhase)", "    m_sPhase = sPhase;"]}
{"aErrorHandler": ["  public SchematronResourcePure setErrorHandler (@Nullable final IPSErrorHandler aErrorHandler)", "    m_aErrorHandler = aErrorHandler;"]}
{"aVariableResolver": ["  public SchematronResourcePure setVariableResolver (@Nullable final XPathVariableResolver aVariableResolver)", "    m_aVariableResolver = aVariableResolver;"]}
{"aFunctionResolver": ["  public SchematronResourcePure setFunctionResolver (@Nullable final XPathFunctionResolver aFunctionResolver)", "    m_aFunctionResolver = aFunctionResolver;"]}
{"aEntityResolver": ["  public SchematronResourcePure setEntityResolver (@Nullable final EntityResolver aEntityResolver)", "    internalSetEntityResolver (aEntityResolver);"]}
{"Result": "Method without Parameter"}
{"aErrorHandler": ["public void validateCompletely (@Nonnull final IPSErrorHandler aErrorHandler)", "    ValueEnforcer.notNull (aErrorHandler, \"ErrorHandler\");", "      getOrCreateBoundSchema ().getOriginalSchema ().validateCompletely (aErrorHandler);"]}
{"aXMLNode": ["  public SchematronOutputType applySchematronValidationToSVRL (@Nonnull final Node aXMLNode,", "    ValueEnforcer.notNull (aXMLNode, \"XMLNode\");", "    final SchematronOutputType aSOT = getOrCreateBoundSchema ().validateComplete (aXMLNode, sBaseURI);"], "sBaseURI": ["                                                               @Nullable final String sBaseURI) throws SchematronException", "    final SchematronOutputType aSOT = getOrCreateBoundSchema ().validateComplete (aXMLNode, sBaseURI);", "      LOGGER.info (\"Created SVRL:\\n\" + new SVRLMarshaller (false).getAsString (aSOT));", "    return aSOT;"]}
{"aRuleContent": ["private void _resolveRuleContent (@Nonnull final ICommonsList <IPSElement> aRuleContent,", "    for (final IPSElement aElement : aRuleContent)", "      if (aElement instanceof PSAssertReport)", "        final PSAssertReport aAssertReport = (PSAssertReport) aElement;", "        aTargetRule.addAssertReport (_getPreprocessedAssert (aAssertReport, aIDPool, aParamValueMap));", "        final PSExtends aExtends = (PSExtends) aElement;", "        final String sRuleID = aExtends.getRule ();", "        final PSRule aBaseRule = aLookup.getAbstractRuleOfID (sRuleID);", "        if (aBaseRule == null)", "                                                   sRuleID +", "        _resolveRuleContent (aBaseRule.getAllContentElements (), aLookup, aIDPool, aParamValueMap, aTargetRule);", "        for (final PSLet aBaseLet : aBaseRule.getAllLets ())", "          aTargetRule.addLet (aBaseLet.getClone ());"], "aLookup": ["                                    @Nonnull final PreprocessorLookup aLookup,", "        final PSRule aBaseRule = aLookup.getAbstractRuleOfID (sRuleID);", "        if (aBaseRule == null)", "                                                   aLookup.getAllAbstractRuleIDs ());", "        _resolveRuleContent (aBaseRule.getAllContentElements (), aLookup, aIDPool, aParamValueMap, aTargetRule);", "        for (final PSLet aBaseLet : aBaseRule.getAllLets ())", "          aTargetRule.addLet (aBaseLet.getClone ());"], "aIDPool": ["                                    @Nonnull final PreprocessorIDPool aIDPool,", "        aTargetRule.addAssertReport (_getPreprocessedAssert (aAssertReport, aIDPool, aParamValueMap));", "        _resolveRuleContent (aBaseRule.getAllContentElements (), aLookup, aIDPool, aParamValueMap, aTargetRule);"], "aParamValueMap": ["                                    @Nullable final ICommonsMap <String, String> aParamValueMap,", "        aTargetRule.addAssertReport (_getPreprocessedAssert (aAssertReport, aIDPool, aParamValueMap));", "        _resolveRuleContent (aBaseRule.getAllContentElements (), aLookup, aIDPool, aParamValueMap, aTargetRule);"], "aTargetRule": ["                                    @Nonnull final PSRule aTargetRule) throws SchematronPreprocessException", "        aTargetRule.addAssertReport (_getPreprocessedAssert (aAssertReport, aIDPool, aParamValueMap));", "        _resolveRuleContent (aBaseRule.getAllContentElements (), aLookup, aIDPool, aParamValueMap, aTargetRule);", "          aTargetRule.addLet (aBaseLet.getClone ());"]}
{"aSchema": ["  public PSSchema getAsMinimalSchema (@Nonnull final PSSchema aSchema) throws SchematronPreprocessException", "    ValueEnforcer.notNull (aSchema, \"Schema\");", "    if (aSchema.isMinimal ())", "      return aSchema;", "    return getForcedPreprocessedSchema (aSchema);"]}
{"aSchema": ["  public PSSchema getAsPreprocessedSchema (@Nonnull final PSSchema aSchema) throws SchematronPreprocessException", "    ValueEnforcer.notNull (aSchema, \"Schema\");", "    if (aSchema.isPreprocessed ())", "      return aSchema;", "    return getForcedPreprocessedSchema (aSchema);"]}
{"aSchema": ["  public PSSchema getForcedPreprocessedSchema (@Nonnull final PSSchema aSchema) throws SchematronPreprocessException", "    ValueEnforcer.notNull (aSchema, \"Schema\");", "    final PreprocessorLookup aLookup = new PreprocessorLookup (aSchema);", "    final PSSchema ret = new PSSchema (aSchema.getResource ());", "    ret.setID (aIDPool.getUniqueID (aSchema.getID ()));", "    ret.setRich (aSchema.getRichClone ());", "    ret.setSchemaVersion (aSchema.getSchemaVersion ());", "    ret.setDefaultPhase (aSchema.getDefaultPhase ());", "    ret.setQueryBinding (aSchema.getQueryBinding ());", "    if (m_bKeepTitles && aSchema.hasTitle ())", "      ret.setTitle (aSchema.getTitle ().getClone ());", "    if (aSchema.hasAnyInclude ())", "    for (final PSNS aNS : aSchema.getAllNSs ())", "      ret.addNS (aNS.getClone ());", "    for (final PSLet aLet : aSchema.getAllLets ())", "      ret.addLet (aLet.getClone ());", "    for (final PSPhase aPhase : aSchema.getAllPhases ())", "      ret.addPhase (_getPreprocessedPhase (aPhase, aIDPool));", "    for (final PSPattern aPattern : aSchema.getAllPatterns ())", "      final PSPattern aMinifiedPattern = _getPreprocessedPattern (aPattern, aLookup, aIDPool);", "      if (aMinifiedPattern != null)", "        if (aMinifiedPattern.getRuleCount () > 0 || m_bKeepEmptyPatterns)", "          ret.addPattern (aMinifiedPattern);", "    if (aSchema.getPatternCount () == 0 && !m_bKeepEmptySchema)", "    if (m_bKeepDiagnostics && aSchema.hasDiagnostics ())", "      ret.setDiagnostics (_getPreprocessedDiagnostics (aSchema.getDiagnostics ()));", "    ret.addForeignElements (aSchema.getAllForeignElements ());", "    ret.addForeignAttributes (aSchema.getAllForeignAttributes ());"]}
{"aResource": ["  public PSSchema readSchema (@Nonnull final IReadableResource aResource,", "    return new PSReader (aResource, aErrorHandler, aEntityResolver).readSchema ();"], "aErrorHandler": ["                              @Nullable final IPSErrorHandler aErrorHandler,", "    return new PSReader (aResource, aErrorHandler, aEntityResolver).readSchema ();"], "aEntityResolver": ["                              @Nullable final EntityResolver aEntityResolver) throws SchematronException", "    return new PSReader (aResource, aErrorHandler, aEntityResolver).readSchema ();"]}
{"aSchema": ["  public IPSQueryBinding getQueryBinding (@Nonnull final PSSchema aSchema) throws SchematronException", "    return PSQueryBindingRegistry.getQueryBindingOfNameOrThrow (aSchema.getQueryBinding ());"]}
{"aSchema": ["  public PSSchema createPreprocessedSchema (@Nonnull final PSSchema aSchema,", "    final PSSchema aPreprocessedSchema = aPreprocessor.getAsPreprocessedSchema (aSchema);", "    if (aPreprocessedSchema == null)", "                                               aSchema +", "                      MicroWriter.getNodeAsString (aPreprocessedSchema.getAsMicroElement ()));", "    return aPreprocessedSchema;"], "aQueryBinding": ["                                            @Nonnull final IPSQueryBinding aQueryBinding) throws SchematronException", "    final PSPreprocessor aPreprocessor = createPreprocessor (aQueryBinding);", "    final PSSchema aPreprocessedSchema = aPreprocessor.getAsPreprocessedSchema (aSchema);", "                                               aQueryBinding);"]}
{"aPSElement": ["  public ESuccess writeToFile (@Nonnull final IPSElement aPSElement, @Nonnull final File aFile)", "    ValueEnforcer.notNull (aPSElement, \"PSElement\");", "    final IMicroElement eXML = aPSElement.getAsMicroElement ();"], "aFile": ["  public ESuccess writeToFile (@Nonnull final IPSElement aPSElement, @Nonnull final File aFile)", "    return MicroWriter.writeToFile (getAsDocument (eXML), aFile, m_aWriterSettings.getXMLWriterSettings ());"]}
{"aPSElement": ["  public ESuccess writeToStream (@Nonnull final IPSElement aPSElement, @Nonnull @WillClose final OutputStream aOS)", "    ValueEnforcer.notNull (aPSElement, \"PSElement\");", "    final IMicroElement eXML = aPSElement.getAsMicroElement ();"], "aOS": ["  public ESuccess writeToStream (@Nonnull final IPSElement aPSElement, @Nonnull @WillClose final OutputStream aOS)", "    return MicroWriter.writeToStream (getAsDocument (eXML), aOS, m_aWriterSettings.getXMLWriterSettings ());"]}
{"aPSElement": ["  public ESuccess writeToWriter (@Nonnull final IPSElement aPSElement, @Nonnull @WillClose final Writer aWriter)", "    ValueEnforcer.notNull (aPSElement, \"PSElement\");", "    final IMicroElement eXML = aPSElement.getAsMicroElement ();"], "aWriter": ["  public ESuccess writeToWriter (@Nonnull final IPSElement aPSElement, @Nonnull @WillClose final Writer aWriter)", "    return MicroWriter.writeToWriter (getAsDocument (eXML), aWriter, m_aWriterSettings.getXMLWriterSettings ());"]}
{"aSchematron": ["  public static SchematronOutputType applySchematron (@Nonnull final ISchematronResource aSchematron,", "    ValueEnforcer.notNull (aSchematron, \"SchematronResource\");", "      return aSchematron.applySchematronValidationToSVRL (aXML);", "                                          aSchematron.getID () +"], "aXML": ["                                                      @Nonnull final IReadableResource aXML)", "    ValueEnforcer.notNull (aXML, \"XMLSource\");", "      return aSchematron.applySchematronValidationToSVRL (aXML);", "                                          aXML.getResourceID (),"]}
{"aSchematron": ["  public static SchematronOutputType applySchematron (@Nonnull final ISchematronResource aSchematron,", "    ValueEnforcer.notNull (aSchematron, \"SchematronResource\");", "    return applySchematron (aSchematron, new DOMSource (aNode));"], "aNode": ["                                                      @Nonnull final Node aNode)", "    ValueEnforcer.notNull (aNode, \"Node\");", "    return applySchematron (aSchematron, new DOMSource (aNode));"]}
{"sVarName": ["  public EChange remove (@Nullable final String sVarName)", "    if (StringHelper.hasText (sVarName))", "      if (m_aMap.remove (PSXPathQueryBinding.PARAM_VARIABLE_PREFIX + sVarName) == null)"]}
{"aVars": ["  public EChange removeAll (@Nullable final Iterable <String> aVars)", "    if (aVars != null)", "      for (final String sName : aVars)", "        eChange = eChange.or (remove (sName));", "    return eChange;", "  public boolean contains (@Nullable final String sName)", "    if (StringHelper.hasNoText (sName))", "    return m_aMap.containsKey (sName);"]}
{"aSchematronOutput": ["  public static ICommonsList <SVRLFailedAssert> getAllFailedAssertions (@Nullable final SchematronOutputType aSchematronOutput)", "    if (aSchematronOutput != null)", "      for (final Object aObj : aSchematronOutput.getActivePatternAndFiredRuleAndFailedAssert ())", "        if (aObj instanceof FailedAssert)", "          ret.add (new SVRLFailedAssert ((FailedAssert) aObj));"]}
{"aSchematronOutput": ["  public static ICommonsList <SVRLFailedAssert> getAllFailedAssertionsMoreOrEqualSevereThan (@Nullable final SchematronOutputType aSchematronOutput,", "    if (aSchematronOutput != null)", "      for (final Object aObj : aSchematronOutput.getActivePatternAndFiredRuleAndFailedAssert ())", "        if (aObj instanceof FailedAssert)", "          final SVRLFailedAssert aFA = new SVRLFailedAssert ((FailedAssert) aObj);", "          if (aFA.getFlag ().isGE (aErrorLevel))", "            ret.add (aFA);"], "aErrorLevel": ["                                                                                             @Nonnull final IErrorLevel aErrorLevel)", "          if (aFA.getFlag ().isGE (aErrorLevel))"]}
{"aSchematronOutput": ["  public static ICommonsList <SVRLSuccessfulReport> getAllSuccessfulReports (@Nullable final SchematronOutputType aSchematronOutput)", "    if (aSchematronOutput != null)", "      for (final Object aObj : aSchematronOutput.getActivePatternAndFiredRuleAndFailedAssert ())", "        if (aObj instanceof SuccessfulReport)", "          ret.add (new SVRLSuccessfulReport ((SuccessfulReport) aObj));"]}
{"aSchematronOutput": ["  public static ICommonsList <SVRLSuccessfulReport> getAllSuccessfulReportsMoreOrEqualSevereThan (@Nullable final SchematronOutputType aSchematronOutput,", "    if (aSchematronOutput != null)", "      for (final Object aObj : aSchematronOutput.getActivePatternAndFiredRuleAndFailedAssert ())", "        if (aObj instanceof SuccessfulReport)", "          final SVRLSuccessfulReport aSR = new SVRLSuccessfulReport ((SuccessfulReport) aObj);", "          if (aSR.getFlag ().isGE (aErrorLevel))", "            ret.add (aSR);"], "aErrorLevel": ["                                                                                                  @Nonnull final IErrorLevel aErrorLevel)", "          if (aSR.getFlag ().isGE (aErrorLevel))"]}
{"aSchematronOutput": ["  public static ICommonsList <AbstractSVRLMessage> getAllFailedAssertionsAndSuccessfulReports (@Nullable final SchematronOutputType aSchematronOutput)", "    if (aSchematronOutput != null)", "      for (final Object aObj : aSchematronOutput.getActivePatternAndFiredRuleAndFailedAssert ())", "        if (aObj instanceof FailedAssert)", "          ret.add (new SVRLFailedAssert ((FailedAssert) aObj));", "          if (aObj instanceof SuccessfulReport)", "            ret.add (new SVRLSuccessfulReport ((SuccessfulReport) aObj));"]}
{"aELD": ["public static void setErrorLevelDeterminator (@Nonnull final ISVRLErrorLevelDeterminator aELD)", "    ValueEnforcer.notNull (aELD, \"ErrorLevelDeterminator\");", "    s_aRWLock.readLocked ( () -> s_aELD = aELD);"]}
{"sName": ["  public static IPSQueryBinding getQueryBindingOfName (@Nullable final String sName)", "    if (sName == null)", "    return s_aRWLock.readLocked ( () -> s_aMap.get (sName));"]}
{"sName": ["  public static IPSQueryBinding getQueryBindingOfNameOrThrow (@Nullable final String sName) throws SchematronBindException", "    final IPSQueryBinding aQB = getQueryBindingOfName (sName);", "    if (aQB == null)", "      throw new SchematronBindException (\"No query binding implementation present for query binding '\" + sName + \"'\");", "    return aQB;"]}
{"aXQueryIS": ["  public MapBasedXPathFunctionResolver loadXQuery (@Nonnull @WillClose final InputStream aXQueryIS) throws XPathException,", "    ValueEnforcer.notNull (aXQueryIS, \"XQueryIS\");", "      final XQueryExpression exp = aStaticQueryCtx.compileQuery (aXQueryIS, sEncoding);", "      StreamHelper.close (aXQueryIS);"]}
{"format": ["private String _format (final String format, final Object arg)", "    final FormattingTuple tuple = MessageFormatter.format (format, arg);"], "arg": ["private String _format (final String format, final Object arg)", "    final FormattingTuple tuple = MessageFormatter.format (format, arg);", "    return tuple.getMessage ();"]}
{"format": ["private String _format (final String format, final Object first, final Object second)", "    final FormattingTuple tuple = MessageFormatter.format (format, first, second);"], "first": ["private String _format (final String format, final Object first, final Object second)", "    final FormattingTuple tuple = MessageFormatter.format (format, first, second);"], "second": ["private String _format (final String format, final Object first, final Object second)", "    final FormattingTuple tuple = MessageFormatter.format (format, first, second);", "    return tuple.getMessage ();"]}
{"aNode": ["public static boolean isValidSchematron (@Nullable final IMicroNode aNode)", "    if (aNode == null)", "    return isValidSchematron (TransformSourceFactory.create (MicroWriter.getNodeAsString (aNode)));"]}
{"aNode": ["public static boolean isValidSchematron (@Nullable final Node aNode)", "    if (aNode == null)", "    return isValidSchematron (TransformSourceFactory.create (aNode));"]}
{"aRes": ["public static boolean isValidSchematron (@Nullable final IReadableResource aRes)", "    if (aRes == null)", "    return isValidSchematron (TransformSourceFactory.create (aRes));"]}
{"aSource": ["public static boolean isValidSchematron (@Nullable final Source aSource)", "    if (aSource == null)", "      aValidator.validate (aSource, null);", "      LOGGER.warn (\"Failed to read source \" + aSource, ex);"]}
{"aSchematronResource": ["  public static SchematronProviderXSLTFromSCH createSchematronXSLTProvider (@Nonnull final IReadableResource aSchematronResource,", "      LOGGER.debug (\"Compiling Schematron instance \" + aSchematronResource.toString ());", "    final SchematronProviderXSLTFromSCH aXSLTPreprocessor = new SchematronProviderXSLTFromSCH (aSchematronResource,", "      LOGGER.warn (\"The Schematron resource '\" + aSchematronResource.getResourceID () + \"' is invalid!\");", "                                       aSchematronResource.getResourceID () +", "      LOGGER.debug (\"Finished compiling Schematron instance \" + aSchematronResource.toString ());"], "aTransformerCustomizer": ["                                                                            @Nonnull final SCHTransformerCustomizer aTransformerCustomizer)", "    final SchematronProviderXSLTFromSCH aXSLTPreprocessor = new SchematronProviderXSLTFromSCH (aSchematronResource,", "                                                                                               aTransformerCustomizer);", "    if (!aXSLTPreprocessor.isValidSchematron ())", "      if (LOGGER.isDebugEnabled () && aXSLTPreprocessor.getXSLTDocument () != null)", "                         XMLWriter.getNodeAsString (aXSLTPreprocessor.getXSLTDocument ()));", "    if (aXSLTPreprocessor.getXSLTDocument () == null)", "    return aXSLTPreprocessor;"]}
{"aSchematronResource": ["  public static SchematronProviderXSLTFromSCH getSchematronXSLTProvider (@Nonnull final IReadableResource aSchematronResource,", "    ValueEnforcer.notNull (aSchematronResource, \"SchematronResource\");", "    if (!aSchematronResource.exists ())", "      LOGGER.warn (\"Schematron resource \" + aSchematronResource + \" does not exist!\");", "      return createSchematronXSLTProvider (aSchematronResource, aTransformerCustomizer);", "                                                                aSchematronResource.getResourceID (),", "        aProvider = createSchematronXSLTProvider (aSchematronResource, aTransformerCustomizer);"], "aTransformerCustomizer": ["                                                                         @Nonnull final SCHTransformerCustomizer aTransformerCustomizer)", "    ValueEnforcer.notNull (aTransformerCustomizer, \"TransformerCustomizer\");", "    if (!aTransformerCustomizer.canCacheResult ())", "      return createSchematronXSLTProvider (aSchematronResource, aTransformerCustomizer);", "                                                                StringHelper.getNotNull (aTransformerCustomizer.getPhase ()),", "                                                                StringHelper.getNotNull (aTransformerCustomizer.getLanguageCode ()));", "        aProvider = createSchematronXSLTProvider (aSchematronResource, aTransformerCustomizer);", "        if (aProvider != null)", "          s_aCache.put (sCacheKey, aProvider);", "      return aProvider;"]}
{"aBoundContentElements": ["  private String _getErrorText (@Nonnull final List <PSXPathBoundElement> aBoundContentElements,", "    for (final PSXPathBoundElement aBoundElement : aBoundContentElements)", "      final Object aContent = aBoundElement.getElement ();", "      if (aContent instanceof String)", "        aSB.append ((String) aContent);", "        if (aContent instanceof PSName)", "          final PSName aName = (PSName) aContent;", "          if (aName.hasPath ())", "              aSB.append ((String) XPathEvaluationHelper.evaluate (aBoundElement.getBoundExpression (),", "              _error (aName,", "                      \"Failed to evaluate XPath expression to a string: '\" + aBoundElement.getExpression () + \"'\",", "              aSB.append (aName.getPath ());", "          if (aContent instanceof PSValueOf)", "            final PSValueOf aValueOf = (PSValueOf) aContent;", "              aSB.append ((String) XPathEvaluationHelper.evaluate (aBoundElement.getBoundExpression (),", "              _error (aValueOf,", "                      \"Failed to evaluate XPath expression to a string: '\" + aBoundElement.getExpression () + \"'\",", "              aSB.append (aValueOf.getSelect ());", "            if (aContent instanceof PSEmph)", "              aSB.append (((PSEmph) aContent).getAsText ());", "              if (aContent instanceof PSDir)", "                aSB.append (((PSDir) aContent).getAsText ());", "                if (aContent instanceof PSSpan)", "                  aSB.append (((PSSpan) aContent).getAsText ());", "                  throw new SchematronValidationException (\"Unsupported assert/report content element: \" + aContent);"], "aSourceNode": ["                                @Nonnull final Node aSourceNode) throws SchematronValidationException", "                                                                   aSourceNode,", "            aSB.append (aSourceNode.getNodeName ());", "                                                                   aSourceNode,"]}
{"sNamespaceURI": ["  public static String getBeautifiedLocation (@Nonnull final String sNamespaceURI, @Nonnull final String sLocalName)", "      final String sBeautified = aBeautifier.getReplacementText (sNamespaceURI, sLocalName);", "      if (sBeautified != null)", "        return sBeautified;", "      LOGGER.debug (\"Unsupported elements for beautification: \" + sNamespaceURI + \" -- \" + sLocalName);"], "sLocalName": ["  public static String getBeautifiedLocation (@Nonnull final String sNamespaceURI, @Nonnull final String sLocalName)", "      final String sBeautified = aBeautifier.getReplacementText (sNamespaceURI, sLocalName);", "      if (sBeautified != null)", "        return sBeautified;", "      LOGGER.debug (\"Unsupported elements for beautification: \" + sNamespaceURI + \" -- \" + sLocalName);"]}
{"aSourceElement": ["private void _warn (@Nonnull final IPSElement aSourceElement, @Nonnull final String sMessage)", "    ValueEnforcer.notNull (aSourceElement, \"SourceElement\");", "    m_aErrorHandler.warn (m_aResource, aSourceElement, sMessage);"], "sMessage": ["private void _warn (@Nonnull final IPSElement aSourceElement, @Nonnull final String sMessage)", "    ValueEnforcer.notNull (sMessage, \"Message\");", "    m_aErrorHandler.warn (m_aResource, aSourceElement, sMessage);"]}
{"eActive": ["  public PSActive readActiveFromXML (@Nonnull final IMicroElement eActive)", "    eActive.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eActive.forAllChildren (aActiveChild -> {"]}
{"eAssertReport": ["  public PSAssertReport readAssertReportFromXML (@Nonnull final IMicroElement eAssertReport)", "    final PSAssertReport ret = new PSAssertReport (eAssertReport.getLocalName ()", "    eAssertReport.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eAssertReport.forAllChildren (aAssertReportChild -> {"]}
{"eDiagnostic": ["  public PSDiagnostic readDiagnosticFromXML (@Nonnull final IMicroElement eDiagnostic)", "    eDiagnostic.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eDiagnostic.forAllChildren (aDiagnosticChild -> {"]}
{"eDiagnostics": ["  public PSDiagnostics readDiagnosticsFromXML (@Nonnull final IMicroElement eDiagnostics)", "    eDiagnostics.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eDiagnostics.forAllChildElements (eDiagnosticsChild -> {"]}
{"eDir": ["  public PSDir readDirFromXML (@Nonnull final IMicroElement eDir)", "    eDir.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eDir.forAllChildren (aDirChild -> {"]}
{"eEmph": ["  public PSEmph readEmphFromXML (@Nonnull final IMicroElement eEmph)", "    eEmph.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eEmph.forAllChildren (aEmphChild -> {"]}
{"eExtends": ["  public PSExtends readExtendsFromXML (@Nonnull final IMicroElement eExtends)", "    eExtends.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eExtends.forAllChildElements (eChild -> {"]}
{"eInclude": ["  public PSInclude readIncludeFromXML (@Nonnull final IMicroElement eInclude)", "    eInclude.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eInclude.forAllChildElements (eValueOfChild -> {"]}
{"eLet": ["  public PSLet readLetFromXML (@Nonnull final IMicroElement eLet)", "    eLet.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eLet.forAllChildElements (eLetChild -> {"]}
{"eName": ["  public PSName readNameFromXML (@Nonnull final IMicroElement eName)", "    eName.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eName.forAllChildElements (eNameChild -> {"]}
{"eNS": ["  public PSNS readNSFromXML (@Nonnull final IMicroElement eNS)", "    eNS.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eNS.forAllChildElements (eLetChild -> {"]}
{"eP": ["  public PSP readPFromXML (@Nonnull final IMicroElement eP)", "    eP.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eP.forAllChildren (aChild -> {"]}
{"eParam": ["  public PSParam readParamFromXML (@Nonnull final IMicroElement eParam)", "    eParam.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eParam.forAllChildElements (eParamChild -> {"]}
{"ePattern": ["  public PSPattern readPatternFromXML (@Nonnull final IMicroElement ePattern)", "    ePattern.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    ePattern.forAllChildElements (ePatternChild -> {"]}
{"ePhase": ["  public PSPhase readPhaseFromXML (@Nonnull final IMicroElement ePhase)", "    ePhase.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    ePhase.forAllChildElements (ePhaseChild -> {"]}
{"eRule": ["  public PSRule readRuleFromXML (@Nonnull final IMicroElement eRule)", "    eRule.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eRule.forAllChildElements (eRuleChild -> {"]}
{"eSchema": ["  public PSSchema readSchemaFromXML (@Nonnull final IMicroElement eSchema) throws SchematronReadException", "    ValueEnforcer.notNull (eSchema, \"Schema\");", "    if (!CSchematron.NAMESPACE_SCHEMATRON.equals (eSchema.getNamespaceURI ()))", "    eSchema.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eSchema.forAllChildElements (eSchemaChild -> {"]}
{"eSpan": ["  public PSSpan readSpanFromXML (@Nonnull final IMicroElement eSpan)", "    eSpan.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eSpan.forAllChildren (aSpanChild -> {"]}
{"eTitle": ["  public PSTitle readTitleFromXML (@Nonnull final IMicroElement eTitle)", "    eTitle.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eTitle.forAllChildren (aTitleChild -> {"]}
{"eValueOf": ["  public PSValueOf readValueOfFromXML (@Nonnull final IMicroElement eValueOf)", "    eValueOf.forAllAttributes ( (sNS, sAttrName, sVal) -> {", "    eValueOf.forAllChildElements (eValueOfChild -> {"]}
{"aSchema": ["  public static MapBasedNamespaceContext createNamespaceMapping (@Nonnull final PSSchema aSchema)", "    for (final PSNS aItem : aSchema.getAllNSs ())", "      ret.addMapping (aItem.getPrefix (), aItem.getUri ());"]}
{"requestHeader": ["private <T> CompletionStage<T> regex(final Http.RequestHeader requestHeader,", "                                .thenCombine(getSubject(requestHeader,"], "deadboltHandler": ["                                         final DeadboltHandler deadboltHandler,", "                                                             deadboltHandler),", "                                                                                                                                                  deadboltHandler,", "                                                                                                                                                 deadboltHandler,", "                                                                                                                                               deadboltHandler,", "                                                                                                                                                    deadboltHandler,"], "content": ["                                         final Optional<String> content,", "                                                                                                                                                  content,", "                                                                                                                                               content,", "                                                                                                                                                    content)));"], "values": ["                                         final String[] values,", "        return CompletableFuture.completedFuture(patternCache.apply(values[valueIndex]))", "                                .thenCompose(hasPassed -> (invert ? !hasPassed._1 : hasPassed._1) ? (successCallAgain(mode, values, valueIndex) ? regex(hasPassed._2,", "                                                                                                                                                  values,", "                                                                                            : (failCallAgain(mode, values, valueIndex) ? regex(hasPassed._2,", "                                                                                                                                               values,"], "valueIndex": ["                                         final int valueIndex,", "        return CompletableFuture.completedFuture(patternCache.apply(values[valueIndex]))", "                                .thenCompose(hasPassed -> (invert ? !hasPassed._1 : hasPassed._1) ? (successCallAgain(mode, values, valueIndex) ? regex(hasPassed._2,", "                                                                                                                                                  valueIndex + 1,", "                                                                                            : (failCallAgain(mode, values, valueIndex) ? regex(hasPassed._2,", "                                                                                                                                               valueIndex + 1,"], "mode": ["                                         final ConstraintMode mode,", "                                .thenCompose(hasPassed -> (invert ? !hasPassed._1 : hasPassed._1) ? (successCallAgain(mode, values, valueIndex) ? regex(hasPassed._2,", "                                                                                                                                                  mode,", "                                                                                            : (failCallAgain(mode, values, valueIndex) ? regex(hasPassed._2,", "                                                                                                                                               mode,"], "invert": ["                                         final boolean invert,", "                                                                         : invert, subject._2)) // this is a little clumsy - it means no subject + invert is still denied", "                                .thenCompose(hasPassed -> (invert ? !hasPassed._1 : hasPassed._1) ? (successCallAgain(mode, values, valueIndex) ? regex(hasPassed._2,", "                                                                                                                                                  invert,", "                                                                                                                                               invert,"], "pass": ["                                         final Function<Http.RequestHeader, CompletionStage<T>> pass,", "                                                                                                                                                  pass,", "                                                                                                                                          : pass(hasPassed._2,", "                                                                                                                                                 pass,", "                                                                                                                                               pass,"], "fail": ["                                         final TriFunction<Http.RequestHeader, DeadboltHandler, Optional<String>, CompletionStage<T>> fail,", "                                                                                                                                                  fail,", "                                                                                                                                               fail,", "                                                                                                                                       : fail.apply(hasPassed._2,"], "constraintPoint": ["                                         final ConstraintPoint constraintPoint)", "                                                                                                                                                  constraintPoint)", "                                                                                                                                                 constraintPoint,", "                                                                                                                                               constraintPoint)"]}
{"request": ["private Http.RequestHeader markAsAuthorised(final Http.RequestHeader request)", "        return request.addAttr(ACTION_AUTHORISED,"]}
{"request": ["protected static boolean isAuthorised(final Http.RequestHeader request)", "        return request.attrs().getOptional(ACTION_AUTHORISED).orElse(false);"]}
{"request": ["protected Http.RequestHeader defer(final Http.RequestHeader request,", "            return request.addAttr(ACTION_DEFERRED,", "        return request;"], "action": ["                         final AbstractDeadboltAction<T> action)", "        if (action != null)", "                         action);"]}
{"request": ["    public F.Tuple<AbstractDeadboltAction<?>, Http.RequestHeader> getDeferredAction(final Http.RequestHeader request)", "        return request.attrs().getOptional(ACTION_DEFERRED).map(action -> {", "            return F.<AbstractDeadboltAction<?>, Http.RequestHeader>Tuple(action, request.removeAttr(ACTION_DEFERRED).addAttr(IGNORE_DEFERRED_FLAG, true));", "        }).orElseGet(() -> F.Tuple(null, request));"]}
{"request": ["protected CompletionStage<Result> authorizeAndExecute(final Http.RequestHeader request)", "            return delegate.call((Http.Request)markAsAuthorised(request));", "        return delegate.call((Http.Request)request);"]}
{"action": ["private static boolean deadboltActionLeftInActionChain(final Action<?> action) {", "        if(action != null) {", "            if(action.delegate instanceof AbstractDeadboltAction) {", "            return deadboltActionLeftInActionChain(action.delegate);"]}
{"subjectOption": ["public List<String> getRoleNames(final Optional<? extends Subject> subjectOption)", "        subjectOption.ifPresent(subject ->"]}
{"subjectOption": ["public boolean hasRole(final Optional<? extends Subject> subjectOption,", "        return getRoleNames(subjectOption).contains(roleName);"], "roleName": ["                           final String roleName)", "        return getRoleNames(subjectOption).contains(roleName);"]}
{"content": ["public FilterFunction subjectPresent(final Optional<String> content)", "                beforeAuthCheckCache.apply(handler, requestHeader, content)", "                                                                                                                content,"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"roles": ["public boolean viewRestrict(final List<String[]> roles,", "                                               () -> roles,"], "handler": ["                                final DeadboltHandler handler,", "                                               handler(handler),"], "content": ["                                final Optional<String> content,", "                                               content,"], "timeoutInMillis": ["                                final long timeoutInMillis,", "                                     .get(timeoutInMillis,", "            allowed = timeoutHandler.apply(timeoutInMillis,"], "requestHeader": ["                                final Http.RequestHeader requestHeader) throws Throwable", "            allowed = constraintLogic.restrict(requestHeader,"]}
{"input": ["static CoderResult overflow(CharBuffer input, int i, CharBuffer output, int j) {", "        input.position(i - input.arrayOffset());"], "i": ["static CoderResult overflow(CharBuffer input, int i, CharBuffer output, int j) {", "        input.position(i - input.arrayOffset());"], "output": ["static CoderResult overflow(CharBuffer input, int i, CharBuffer output, int j) {", "        output.position(j - output.arrayOffset());"], "j": ["static CoderResult overflow(CharBuffer input, int i, CharBuffer output, int j) {", "        output.position(j - output.arrayOffset());"]}
{"input": ["static CoderResult underflow(CharBuffer input, int i, CharBuffer output, int j) {", "        input.position(i - input.arrayOffset());"], "i": ["static CoderResult underflow(CharBuffer input, int i, CharBuffer output, int j) {", "        input.position(i - input.arrayOffset());"], "output": ["static CoderResult underflow(CharBuffer input, int i, CharBuffer output, int j) {", "        output.position(j - output.arrayOffset());"], "j": ["static CoderResult underflow(CharBuffer input, int i, CharBuffer output, int j) {", "        output.position(j - output.arrayOffset());"]}
{"min": ["ASCIIBits set(int min, int max) {", "        int i=min;", "        for (int n = Math.min(max,63) ; i<=n ; ++i) {"], "max": ["ASCIIBits set(int min, int max) {", "        for (int n = Math.min(max,63) ; i<=n ; ++i) {", "        for ( ; i<=max ; ++i) {"]}
{"encoder": ["static String encode(Encoder encoder, String str) {", "        int j = encoder.firstEncodedOffset(str, 0, n);", "        return new Buffer().encode(encoder, str, j);"], "str": ["static String encode(Encoder encoder, String str) {", "        if (str == null) {", "        final int n = str.length();", "        int j = encoder.firstEncodedOffset(str, 0, n);", "            return str;", "        return new Buffer().encode(encoder, str, j);"]}
{"encoder": ["static void encode(Encoder encoder, Writer out, String str)", "        int j = encoder.firstEncodedOffset(str, 0, n);", "        new Buffer().encode(encoder, out, str, j);"], "out": ["static void encode(Encoder encoder, Writer out, String str)", "            out.write(str);", "        new Buffer().encode(encoder, out, str, j);"], "str": ["static void encode(Encoder encoder, Writer out, String str)", "        if (str == null) {", "        final int n = str.length();", "        int j = encoder.firstEncodedOffset(str, 0, n);", "            out.write(str);", "        new Buffer().encode(encoder, out, str, j);"]}
{"name": ["private static <T extends Encoder> T map(String name, T encoder) {", "        Encoder old = ENCODERS_MAP.put(name, encoder);"], "encoder": ["private static <T extends Encoder> T map(String name, T encoder) {", "        Encoder old = ENCODERS_MAP.put(name, encoder);", "        assert old == null;", "        return encoder;"]}
{"contextName": ["public static Encoder forName(String contextName) throws NullPointerException, UnsupportedContextException {", "        if (contextName == null) {", "        Encoder encoder = ENCODERS_MAP.get(contextName);", "        if (encoder == null) {", "            throw new UnsupportedContextException(contextName);", "        return encoder;"]}
{"src": ["static int append(char[] src, char[] out, int j) {", "        System.arraycopy(src, 0, out, j, src.length);", "        return j + src.length;"], "out": ["static int append(char[] src, char[] out, int j) {", "        System.arraycopy(src, 0, out, j, src.length);"], "j": ["static int append(char[] src, char[] out, int j) {", "        System.arraycopy(src, 0, out, j, src.length);", "        return j + src.length;"]}
{"str": ["public String encode(String str) {", "        if (str == null) {", "        int n = str.length();", "        int j = _first.firstEncodedOffset(str, 0, n);", "            return Encode.encode(_last, str);", "        str.getChars(0, j, input.array(), 0);", "        str.getChars(j, n, input.array(), m - remaining);"]}
{"Result": "Method without Parameter"}
{"input": ["private void flushLeftOver(CharBuffer input) throws IOException {", "            if (input != null && input.hasRemaining()) {", "                _leftOverBuffer.put(input.get());", "            CoderResult cr = _encoder.encode(_leftOverBuffer, _buffer, input == null);", "            if (cr.isUnderflow()) {", "            if (cr.isOverflow()) {"]}
{"sensorType": ["public Flowable<ReactiveSensorEvent> observeSensor(int sensorType, final int samplingPeriodInUs,", "    if (!hasSensor(sensorType)) {", "      String message = String.format(Locale.getDefault(), format, sensorType);", "      return Flowable.error(new SensorNotFoundException(message));", "    final Sensor sensor = sensorManager.getDefaultSensor(sensorType);", "          sensorManager.registerListener(listener, sensor, samplingPeriodInUs);", "          sensorManager.registerListener(listener, sensor, samplingPeriodInUs, handler);"], "samplingPeriodInUs": ["public Flowable<ReactiveSensorEvent> observeSensor(int sensorType, final int samplingPeriodInUs,", "          sensorManager.registerListener(listener, sensor, samplingPeriodInUs);", "          sensorManager.registerListener(listener, sensor, samplingPeriodInUs, handler);"], "handler": ["      final Handler handler, final BackpressureStrategy strategy) {", "        if (handler == null) {", "          sensorManager.registerListener(listener, sensor, samplingPeriodInUs, handler);"], "strategy": ["      final Handler handler, final BackpressureStrategy strategy) {", "    }, strategy).doOnCancel(new Action() {"]}
{"node": ["private String getText(JsonNode node, String propertyName) {", "        JsonNode childNode = node.get(propertyName);"], "propertyName": ["private String getText(JsonNode node, String propertyName) {", "        JsonNode childNode = node.get(propertyName);", "        if (childNode == null) {", "        return childNode.asText();"]}
{"query": ["public Result execute(Query query) throws SonarBreakException, IOException {", "        URL queryURL = buildURL(sonarURL, query);", "        log.debug(\"Built a sonar query url of: \" + queryURL.toString());", "        return fetchSonarStatusWithRetries(queryURL, query.getVersion());"]}
{"sonarURL": ["protected static URL buildURL(URL sonarURL, Query query) throws MalformedURLException, IllegalArgumentException {", "        return new URL(sonarURL, sonarPathWithResource);"], "query": ["protected static URL buildURL(URL sonarURL, Query query) throws MalformedURLException, IllegalArgumentException {", "        if (query.getSonarKey() == null || query.getSonarKey().length() == 0) {", "        String sonarPathWithResource = String.format(SONAR_FORMAT_PATH, query.getSonarKey());"]}
{"queryURL": ["private Result fetchSonarStatusWithRetries(URL queryURL, String version) throws IOException, SonarBreakException {", "            if (isURLAvailable(queryURL, 1)) {", "                Result result = fetchSonarStatus(queryURL);", "                if (result.getVersion().equals(version) && result.getDatetime().isAfter(oneMinuteAgo)) {", "                    return result;", "                        result.getVersion(), oneMinuteAgo.toString(), result.getDatetime().toString());", "                log.debug(String.format(\"Query url not available yet: %s\", queryURL));"], "version": ["private Result fetchSonarStatusWithRetries(URL queryURL, String version) throws IOException, SonarBreakException {", "                if (result.getVersion().equals(version) && result.getDatetime().isAfter(oneMinuteAgo)) {", "                                \"Sonar reporting Version: %s.  Looking back until: %s  Last result time: %s\", version,"]}
{"queryURL": ["private Result fetchSonarStatus(URL queryURL) throws IOException, SonarBreakException {", "            URLConnection connection = queryURL.openConnection();"]}
{"response": ["protected static Result parseResponse(String response) throws SonarBreakException {", "            results = mapper.readValue(response, new TypeReference<List<Result>>() {", "            throw new SonarBreakException(\"Unable to parse the json into a List of QualityGateResults.  Json is: \" + response, e);", "            throw new SonarBreakException(\"Unable to deserialize JSON response: \" + response);"]}
{"Result": "Method without Parameter"}
{"report": ["private List<Artifact> processUploads(TrackedContentDTO report)", "        Set<TrackedContentEntryDTO> uploads = report.getUploads();"]}
{"transfer": ["private String computeIdentifier(final TrackedContentEntryDTO transfer) {", "        switch (transfer.getStoreKey().getPackageType()) {", "                ArtifactPathInfo pathInfo = ArtifactPathInfo.parse(transfer.getPath());", "                NpmPackagePathInfo npmPathInfo = NpmPackagePathInfo.parse(transfer.getPath());", "                logger.warn(\"Package type {} is not handled by Indy repository session.\", transfer.getStoreKey().getPackageType());", "            identifier = computeGenericIdentifier(transfer.getOriginUrl(), transfer.getLocalUrl(), transfer.getSha256());"]}
{"originUrl": ["private String computeGenericIdentifier(String originUrl, String localUrl, String sha256) {", "        String identifier = originUrl;"], "localUrl": ["private String computeGenericIdentifier(String originUrl, String localUrl, String sha256) {", "            identifier = localUrl;"], "sha256": ["private String computeGenericIdentifier(String originUrl, String localUrl, String sha256) {", "        identifier += '|' + sha256;"]}
{"artifact": ["private Artifact validateArtifact(Artifact artifact) throws RepositoryManagerException {", "        Set<ConstraintViolation<Artifact>> violations = validator.validate(artifact);", "        if (!violations.isEmpty()) {", "            throw new RepositoryManagerException(\"Repository manager returned invalid artifact: \" + artifact.toString() + \" Constraint Violations: %s\", violations);", "        return artifact;"]}
{"buildTask": ["public boolean hasConfigDependencyOn(BuildTask buildTask) {", "        if (buildTask == null || this.equals(buildTask)) {", "        return buildConfiguration.dependsOn(buildTask.getBuildConfigurationAudited().getBuildConfiguration());"]}
{"buildTask": ["public boolean hasDirectConfigDependencyOn(BuildTask buildTask) {", "        if (buildTask == null || this.equals(buildTask)) {", "        return buildConfiguration.getDependencies().contains(buildTask.getBuildConfigurationAudited().getBuildConfiguration());"]}
{"configContent": ["            String configContent, ConfigProvider<T> provider) throws ConfigurationParseException {", "            PNCModuleGroup pncGroup = getModuleGroup(mapper, configContent,"], "provider": ["            String configContent, ConfigProvider<T> provider) throws ConfigurationParseException {", "            provider.registerProvider(mapper);", "                if (config.getClass().isAssignableFrom(provider.getType())) {", "            throw new ConfigurationParseException(\"Did not find config for provider \" + provider.getType().getSimpleName() + \".\");"]}
{"onComplete": ["    public void monitor(Consumer<CompletedRepositoryDeletion> onComplete, Consumer<Exception> onError) {", "            onComplete.accept(new IndyCompletedDeletion(true));"], "onError": ["    public void monitor(Consumer<CompletedRepositoryDeletion> onComplete, Consumer<Exception> onError) {", "            onError.accept(e);"]}
{"Result": "Method without Parameter"}
{"buildConfigurationAudited": ["public BuildTask getBuildTask(BuildConfigurationAudited buildConfigurationAudited) {", "        return buildTasks.stream().filter((bt) -> bt.getBuildConfigurationAudited().equals(buildConfigurationAudited)).findFirst().orElse(null);"]}
{"onComplete": ["    public void monitor(Consumer<CompletedRepositoryPromotion> onComplete, Consumer<Exception> onError) {", "            onComplete.accept(new IndyCompletedPromotion(result));"], "onError": ["    public void monitor(Consumer<CompletedRepositoryPromotion> onComplete, Consumer<Exception> onError) {", "            onError.accept(e);"]}
{"target": ["public static <T> void merge(Graph<T> target, Graph<T> toMerge) {", "            target.addVertex(vertex);", "        List<Edge<T>> edges = target.getEdges();"], "toMerge": ["public static <T> void merge(Graph<T> target, Graph<T> toMerge) {", "        for (Vertex<T> vertex : toMerge.getVerticies()) {", "            target.addVertex(vertex);", "        for (Edge newEdge : toMerge.getEdges()) {", "            Optional<Edge<T>> any = edges.stream()", "                            existing.getFrom().getName().equals(newEdge.getFrom().getName())", "                             && existing.getTo().getName().equals(newEdge.getTo().getName())", "            if (!any.isPresent()) {", "                edges.add(newEdge);"]}
{"fileName": ["public static String readFileAsString(File fileName) throws IOException {", "        try (Scanner sc = new Scanner(fileName, Charset.defaultCharset().name())) {"]}
{"stream": ["public static String readStreamAsString(InputStream stream) throws IOException {", "        try (Scanner sc = new Scanner(stream, Charset.defaultCharset().name())) {"]}
{"milestone": ["public void startRelease(ProductMilestone milestone, String accessToken) {", "        ProductMilestoneRelease release = triggerRelease(milestone, accessToken);"], "accessToken": ["public void startRelease(ProductMilestone milestone, String accessToken) {", "        ProductMilestoneRelease release = triggerRelease(milestone, accessToken);", "        productMilestoneReleaseRepository.save(release);"]}
{"Result": "Method without Parameter"}
{"buildId": ["    public Integer getTaskIdByBuildId(int buildId) {", "                .filter(t -> ((BpmBuildTask) t).getBuildTask().getId() == buildId)"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"execution": ["private void setupBuildRepos(BuildExecution execution, String packageType, Indy indy, Map<String, String> genericParameters) throws IndyClientException {", "        String buildContentId = execution.getBuildContentId();", "        int id = execution.getId();", "            boolean tempBuild = execution.isTempBuild();", "            if (execution.getArtifactRepositories() != null) {", "                extraDependencyRepositories.addAll(execution.getArtifactRepositories());"], "packageType": ["private void setupBuildRepos(BuildExecution execution, String packageType, Indy indy, Map<String, String> genericParameters) throws IndyClientException {", "        StoreKey groupKey = new StoreKey(packageType, StoreType.group, buildContentId);", "            StoreKey hostedKey = new StoreKey(packageType, StoreType.hosted, buildContentId);", "                HostedRepository buildArtifacts = new HostedRepository(packageType, buildContentId);", "                buildArtifacts.setDescription(String.format(\"Build output for PNC %s build #%s\", packageType, id));", "                indy.stores().create(buildArtifacts, \"Creating hosted repository for \" + packageType + \" build: \" + id", "            Group buildGroup = new Group(packageType, buildContentId);", "            addGlobalConstituents(packageType, buildGroup, tempBuild);", "            addExtraConstituents(packageType, extraDependencyRepositories, id, buildContentId, indy, buildGroup);"], "indy": ["private void setupBuildRepos(BuildExecution execution, String packageType, Indy indy, Map<String, String> genericParameters) throws IndyClientException {", "        if (!indy.stores().exists(groupKey)) {", "            if (!indy.stores().exists(hostedKey)) {", "                indy.stores().create(buildArtifacts, \"Creating hosted repository for \" + packageType + \" build: \" + id", "            addExtraConstituents(packageType, extraDependencyRepositories, id, buildContentId, indy, buildGroup);", "            indy.stores().create(buildGroup, \"Creating repository group for resolving artifacts in build: \" + id"], "genericParameters": ["private void setupBuildRepos(BuildExecution execution, String packageType, Indy indy, Map<String, String> genericParameters) throws IndyClientException {", "            List<ArtifactRepository> extraDependencyRepositories = extractExtraRepositoriesFromGenericParameters(genericParameters);", "                extraDependencyRepositories.addAll(execution.getArtifactRepositories());", "            addExtraConstituents(packageType, extraDependencyRepositories, id, buildContentId, indy, buildGroup);"]}
{"notification": ["private void onRCCreationSuccess(BpmNotificationRest notification, BuildConfigurationRest buildConfigurationRest) {", "        LOG.debug(\"Received BPM event RC_CREATION_SUCCESS: \" + notification);", "        BpmStringMapNotificationRest repositoryCreationTaskResult = (BpmStringMapNotificationRest) notification;", "            repositoryConfigurationId = Integer.valueOf(repositoryCreationTaskResult.getData().get(\"repositoryConfigurationId\"));", "            String errorMessage = \"Receive notification about successful BC creation '\" + repositoryCreationTaskResult", "                    + \"' but the ID of the newly created RC '\" + repositoryCreationTaskResult.getData()"], "buildConfigurationRest": ["private void onRCCreationSuccess(BpmNotificationRest notification, BuildConfigurationRest buildConfigurationRest) {", "        if (buildConfigurationRest != null) { //TODO test me", "            BuildConfiguration buildConfiguration = buildConfigurationRest.toDBEntityBuilder()", "            Set<Integer> bcSetIds = buildConfigurationRest.getBuildConfigurationSetIds();"]}
{"task": ["private void addWebsocketForwardingListeners(RepositoryCreationTask task) {", "        task.addListener(BpmEventType.RC_REPO_CREATION_SUCCESS, doNotify);", "        task.addListener(BpmEventType.RC_REPO_CREATION_ERROR, doNotify);", "        task.addListener(BpmEventType.RC_REPO_CLONE_SUCCESS, doNotify);", "        task.addListener(BpmEventType.RC_REPO_CLONE_ERROR, doNotify);", "        task.addListener(BpmEventType.RC_CREATION_ERROR, doNotify);"]}
{"id": ["public static Artifact mockImportedArtifact(int id) {", "        return getArtifactBuilder(id)", "                .originUrl(\"http://central.maven.org/org/jboss/mock/artifactFile\" + id + \".jar\")"]}
{"sslRequired": ["public static void setSslRequired(boolean sslRequired) {", "        if (HttpUtil.sslRequired != sslRequired) {", "            HttpUtil.sslRequired = sslRequired;"]}
{"buildRecordId": ["public Result deleteTemporaryBuild(Integer buildRecordId, String authToken) throws ValidationException {", "        BuildRecord buildRecord = buildRecordRepository.findByIdFetchAllProperties(buildRecordId);", "        if (!buildRecord.isTemporaryBuild()) {", "        log.info(\"Starting deletion of a temporary build \" + buildRecord + \"; Built artifacts: \" + buildRecord.getBuiltArtifacts()", "                + \"; Dependencies: \" + buildRecord.getDependencies());", "        Result result = remoteBuildsCleaner.deleteRemoteBuilds(buildRecord, authToken);", "            log.error(\"Failed to delete remote temporary builds for BR.id:{}.\", buildRecord.getId());", "            return new Result(buildRecordId.toString(), Result.Status.FAILED, \"Failed to delete remote temporary builds.\");", "        removeRelationBuildRecordArtifact(buildRecord, artifactsToBeDeleted);", "        deleteDependencies(buildRecord);", "        buildRecordRepository.delete(buildRecord.getId());", "        log.info(\"Deletion of the temporary build {} finished successfully.\", buildRecord);", "        return new Result(buildRecordId.toString(), Result.Status.SUCCESS);"], "authToken": ["public Result deleteTemporaryBuild(Integer buildRecordId, String authToken) throws ValidationException {", "        Result result = remoteBuildsCleaner.deleteRemoteBuilds(buildRecord, authToken);", "        if (!result.isSuccess()) {"]}
{"buildConfigSetRecordId": ["public Result deleteTemporaryBuildConfigSetRecord(Integer buildConfigSetRecordId, String authToken)", "        BuildConfigSetRecord buildConfigSetRecord = buildConfigSetRecordRepository.queryById(buildConfigSetRecordId);", "        if (!buildConfigSetRecord.isTemporaryBuild()) {", "        log.info(\"Starting deletion of a temporary build record set \" + buildConfigSetRecord);", "        for (BuildRecord br : buildConfigSetRecord.getBuildRecords()) {", "            Result result = deleteTemporaryBuild(br.getId(), authToken);", "            if (!result.isSuccess()) {", "                return result;", "        buildConfigSetRecordRepository.delete(buildConfigSetRecord.getId());", "        log.info(\"Deletion of a temporary build record set {} finished successfully.\", buildConfigSetRecord);", "        return new Result(buildConfigSetRecordId.toString(), Result.Status.SUCCESS);"], "authToken": ["public Result deleteTemporaryBuildConfigSetRecord(Integer buildConfigSetRecordId, String authToken)", "            Result result = deleteTemporaryBuild(br.getId(), authToken);", "            if (!result.isSuccess()) {", "                return result;"]}
{"buildConfigurationAudited": ["    public BuildSetTask build(BuildConfigurationAudited buildConfigurationAudited,", "        return build0(user, buildOptions, buildConfigurationAudited);"], "user": ["                              User user,", "        return build0(user, buildOptions, buildConfigurationAudited);"], "buildOptions": ["                              BuildOptions buildOptions) throws BuildConflictException {", "        return build0(user, buildOptions, buildConfigurationAudited);"]}
{"buildSetTask": ["private void checkForEmptyBuildSetTask(BuildSetTask buildSetTask) {", "        if (buildSetTask.getBuildTasks() == null || buildSetTask.getBuildTasks().isEmpty()) {", "            updateBuildSetTaskStatus(buildSetTask, BuildSetStatus.REJECTED, \"Build config set is empty\");"]}
{"systemImageType": ["public EnvironmentDriver getDriver(SystemImageType systemImageType) throws ExecutorException {", "            if (driver.canRunImageType(systemImageType))", "        throw new ExecutorException(\"No environment driver available for \" + systemImageType + \" system image type.\");"]}
{"Result": "Method without Parameter"}
{"buildConfigAudited": ["private void loadBuildConfigurations(BuildConfigurationAudited buildConfigAudited) {", "        Project project = buildConfigAudited.getProject();"]}
{"buildTask": ["public BuildRecord storeResult(BuildTask buildTask, Optional<BuildResult> buildResult, Throwable e) throws DatastoreException {", "        BuildRecord.Builder buildRecordBuilder = initBuildRecordBuilder(buildTask);", "        buildRecordBuilder.status(SYSTEM_ERROR);", "                buildRecordBuilder.executionRootName(repourResult.getExecutionRootName());", "                buildRecordBuilder.executionRootVersion(repourResult.getExecutionRootVersion());", "                buildRecordBuilder.repourLog(repourResult.getLog());", "        buildRecordBuilder.buildLog(errorLog.toString());", "        return datastore.storeCompletedBuild(buildRecordBuilder);"], "buildResult": ["public BuildRecord storeResult(BuildTask buildTask, Optional<BuildResult> buildResult, Throwable e) throws DatastoreException {", "        buildResult.ifPresent(result -> {", "        errorLog.append(\"Build status: \").append(getBuildStatus(buildResult)).append(\"\\n\");", "        userLog.error(\"Build status: {}.\", getBuildStatus(buildResult));"], "e": ["public BuildRecord storeResult(BuildTask buildTask, Optional<BuildResult> buildResult, Throwable e) throws DatastoreException {", "        errorLog.append(\"Caught exception: \").append(e.toString()).append(\"\\n\");", "        e.printStackTrace(new PrintWriter(stackTraceWriter));", "        log.debug(\"Storing ERROR result of buildTask.getBuildConfigurationAudited().getName() to datastore.\",  e);"]}
{"buildTask": ["private BuildRecord.Builder initBuildRecordBuilder(BuildTask buildTask) {", "        BuildOptions buildOptions = buildTask.getBuildOptions();", "                .id(buildTask.getId())", "                .buildConfigurationAudited(buildTask.getBuildConfigurationAudited())", "                .user(buildTask.getUser())", "                .submitTime(buildTask.getSubmitTime())", "                .startTime(buildTask.getStartTime())", "                .productMilestone(buildTask.getProductMilestone())", "        if (buildTask.getEndTime() == null) {", "            buildTask.setEndTime(Date.from(Instant.now()));", "        builder.endTime(buildTask.getEndTime());", "        if (buildTask.getBuildConfigSetRecordId() != null) {", "            BuildConfigSetRecord buildConfigSetRecord = datastore.getBuildConfigSetRecordById(buildTask.getBuildConfigSetRecordId());", "        List<Integer> dependencies = buildTask.getDependencies().stream().map(t -> t.getId()).collect(Collectors.toList());", "        List<Integer> dependants = buildTask.getDependants().stream().map(t -> t.getId()).collect(Collectors.toList());"]}
{"buildConfigurationId": ["public static Predicate<ProductVersion> withBuildConfigurationId(Integer buildConfigurationId) {", "            return cb.equal(buildConfigurationJoin.get(BuildConfiguration_.id), buildConfigurationId);"]}
{"url": ["boolean isJenkinsServerSecuredWithCSRF(String url) throws BuildDriverException {", "            if (url == null || username == null || password == null) {", "                JenkinsHttpClient jenkinsHttpClient = new JenkinsHttpClient(new URI(url), username, password);", "                throw new BuildDriverException(\"Cannot instantiate \" + JenkinsBuildDriver.DRIVER_ID + \". Make sure you are using valid url: \" + url, e);"]}
{"artifacts": ["private Set<Artifact> saveArtifacts(Collection<Artifact> artifacts,", "        logger.debug(\"Saving {} artifacts.\", artifacts.size());", "        for (Artifact artifact : artifacts) {", "            artifactConstraints.add(new Artifact.IdentifierSha256(artifact.getIdentifier(), artifact.getSha256()));", "        for (Artifact artifact : artifacts) {", "            TargetRepository targetRepository = artifact.getTargetRepository();", "            linkTargetRepository(repositoriesCache, artifact, targetRepository);", "            if (RepositoryType.GENERIC_PROXY.equals(targetRepository.getRepositoryType())) {", "                artifactFromDb = saveHttpArtifact(artifact);", "                artifactFromDb = getOrSaveRepositoryArtifact(artifact, artifactCache);", "            savedArtifacts.add(artifactFromDb);", "        logger.debug(\"Artifacts saved: {}.\", artifacts);"], "repositoriesCache": ["            Map<String, TargetRepository> repositoriesCache,", "            linkTargetRepository(repositoriesCache, artifact, targetRepository);"], "artifactCache": ["            Map<Artifact.IdentifierSha256, Artifact> artifactCache) {", "                artifactCache.put(artifact.getIdentifierSha256(), artifact);", "                artifactFromDb = getOrSaveRepositoryArtifact(artifact, artifactCache);", "            savedArtifacts.add(artifactFromDb);"]}
{"buildConfigSetRecord": ["    public BuildConfigSetRecord saveBuildConfigSetRecord(BuildConfigSetRecord buildConfigSetRecord) {", "        return buildConfigSetRecordRepository.save(buildConfigSetRecord);"]}
{"buildConfigurationSet": ["    public Set<BuildConfiguration> getBuildConfigurations(BuildConfigurationSet buildConfigurationSet) {", "        return new HashSet<>(buildConfigurationRepository.queryWithPredicates(withBuildConfigurationSetId(buildConfigurationSet.getId())));"]}
{"latestSuccessfulBuildRecord": ["private boolean hasARebuiltImplicitDependency(BuildRecord latestSuccessfulBuildRecord, boolean temporaryBuild) {", "        Collection<BuildRecord> lastBuiltFrom = getRecordsUsedFor(latestSuccessfulBuildRecord);", "        return lastBuiltFrom.stream()"], "temporaryBuild": ["private boolean hasARebuiltImplicitDependency(BuildRecord latestSuccessfulBuildRecord, boolean temporaryBuild) {", "                .anyMatch(br -> hasNewerVersion(br, temporaryBuild));"]}
{"latestSuccessfulBuildRecord": ["private boolean hasARebuiltExplicitDependency(BuildRecord latestSuccessfulBuildRecord, Set<BuildConfiguration> dependencies, boolean temporaryBuild) {", "            boolean newer = dependencyLatestSuccessfulBuildRecord.getEndTime().after(latestSuccessfulBuildRecord.getEndTime());", "            if (newer) {"], "dependencies": ["private boolean hasARebuiltExplicitDependency(BuildRecord latestSuccessfulBuildRecord, Set<BuildConfiguration> dependencies, boolean temporaryBuild) {", "        for (BuildConfiguration dependencyBuildConfiguration : dependencies) {", "            BuildRecord dependencyLatestSuccessfulBuildRecord = buildRecordRepository.getLatestSuccessfulBuildRecord(dependencyBuildConfiguration.getId(), temporaryBuild);", "            if (dependencyLatestSuccessfulBuildRecord == null) {", "            boolean newer = dependencyLatestSuccessfulBuildRecord.getEndTime().after(latestSuccessfulBuildRecord.getEndTime());", "            if (newer) {"], "temporaryBuild": ["private boolean hasARebuiltExplicitDependency(BuildRecord latestSuccessfulBuildRecord, Set<BuildConfiguration> dependencies, boolean temporaryBuild) {", "            BuildRecord dependencyLatestSuccessfulBuildRecord = buildRecordRepository.getLatestSuccessfulBuildRecord(dependencyBuildConfiguration.getId(), temporaryBuild);", "            if (dependencyLatestSuccessfulBuildRecord == null) {", "            boolean newer = dependencyLatestSuccessfulBuildRecord.getEndTime().after(latestSuccessfulBuildRecord.getEndTime());", "            if (newer) {"]}
{"eventType": ["public <T extends BpmNotificationRest> void addListener(BpmEventType eventType, Consumer<T> listener) {", "        List<Consumer<?>> consumers = listeners.computeIfAbsent(eventType, (k) -> new ArrayList<>());"], "listener": ["public <T extends BpmNotificationRest> void addListener(BpmEventType eventType, Consumer<T> listener) {", "        consumers.add(listener);"]}
{"Result": "Method without Parameter"}
{"buildConfiguration": ["private boolean collectDependentConfigurations(BuildConfiguration buildConfiguration,", "        if (visited.contains(buildConfiguration)) {", "        visited.add(buildConfiguration);", "        for (BuildConfiguration dependency : buildConfiguration.getDependencies()) {", "            boolean dependencyRequiresRebuild = collectDependentConfigurations(dependency,", "                    datastoreAdapter.getLatestBuildConfigurationAuditedInitializeBCDependencies(dependency.getId()),", "            requiresRebuild = requiresRebuild || dependencyRequiresRebuild;", "        log.debug(\"Configuration {} requires rebuild: \", buildConfiguration.getId(), requiresRebuild);", "        if (requiresRebuild) {", "        return requiresRebuild;"], "buildConfigurationAudited": ["            BuildConfigurationAudited buildConfigurationAudited,", "            return toBuild.contains(buildConfigurationAudited);", "        boolean requiresRebuild = forceRebuild || datastoreAdapter.requiresRebuild(buildConfigurationAudited, checkImplicitDependencies, temporaryBuild);", "            toBuild.add(buildConfigurationAudited);"], "toBuild": ["            Set<BuildConfigurationAudited> toBuild,", "            return toBuild.contains(buildConfigurationAudited);", "            boolean dependencyRequiresRebuild = collectDependentConfigurations(dependency,", "                    toBuild,", "            requiresRebuild = requiresRebuild || dependencyRequiresRebuild;", "        log.debug(\"Configuration {} requires rebuild: \", buildConfiguration.getId(), requiresRebuild);", "        if (requiresRebuild) {", "            toBuild.add(buildConfigurationAudited);", "        return requiresRebuild;"], "visited": ["            Set<BuildConfiguration> visited,", "        if (visited.contains(buildConfiguration)) {", "        visited.add(buildConfiguration);", "            boolean dependencyRequiresRebuild = collectDependentConfigurations(dependency,", "                    visited,", "            requiresRebuild = requiresRebuild || dependencyRequiresRebuild;", "        log.debug(\"Configuration {} requires rebuild: \", buildConfiguration.getId(), requiresRebuild);", "        if (requiresRebuild) {", "        return requiresRebuild;"], "checkImplicitDependencies": ["            boolean checkImplicitDependencies,", "        boolean requiresRebuild = forceRebuild || datastoreAdapter.requiresRebuild(buildConfigurationAudited, checkImplicitDependencies, temporaryBuild);", "            boolean dependencyRequiresRebuild = collectDependentConfigurations(dependency,", "                    checkImplicitDependencies,", "            requiresRebuild = requiresRebuild || dependencyRequiresRebuild;", "        log.debug(\"Configuration {} requires rebuild: \", buildConfiguration.getId(), requiresRebuild);", "        if (requiresRebuild) {", "        return requiresRebuild;"], "forceRebuild": ["            boolean forceRebuild,", "        boolean requiresRebuild = forceRebuild || datastoreAdapter.requiresRebuild(buildConfigurationAudited, checkImplicitDependencies, temporaryBuild);", "            boolean dependencyRequiresRebuild = collectDependentConfigurations(dependency,", "                    forceRebuild,", "            requiresRebuild = requiresRebuild || dependencyRequiresRebuild;", "        log.debug(\"Configuration {} requires rebuild: \", buildConfiguration.getId(), requiresRebuild);", "        if (requiresRebuild) {", "        return requiresRebuild;"], "temporaryBuild": ["            boolean temporaryBuild) {", "        boolean requiresRebuild = forceRebuild || datastoreAdapter.requiresRebuild(buildConfigurationAudited, checkImplicitDependencies, temporaryBuild);", "            boolean dependencyRequiresRebuild = collectDependentConfigurations(dependency,", "                    temporaryBuild);", "            requiresRebuild = requiresRebuild || dependencyRequiresRebuild;", "        log.debug(\"Configuration {} requires rebuild: \", buildConfiguration.getId(), requiresRebuild);", "        if (requiresRebuild) {", "        return requiresRebuild;"]}
{"buildConfigurationSet": ["            BuildConfigurationSet buildConfigurationSet,", "        return createBuildSetTask(buildConfigurationSet, Collections.emptyMap(), user, buildOptions,"], "user": ["            User user,", "        return createBuildSetTask(buildConfigurationSet, Collections.emptyMap(), user, buildOptions,"], "buildOptions": ["            BuildOptions buildOptions,", "        return createBuildSetTask(buildConfigurationSet, Collections.emptyMap(), user, buildOptions,"], "buildTaskIdProvider": ["            Supplier<Integer> buildTaskIdProvider,", "                buildTaskIdProvider, submittedBuildTasks);"], "submittedBuildTasks": ["            Set<BuildTask> submittedBuildTasks) throws CoreException {", "                buildTaskIdProvider, submittedBuildTasks);"]}
{"buildConfigurationSet": ["            BuildConfigurationSet buildConfigurationSet,", "        BuildSetTask buildSetTask = initBuildSetTask(buildConfigurationSet, user, buildOptions);", "        for (BuildConfiguration buildConfiguration : datastoreAdapter.getBuildConfigurations(buildConfigurationSet)) {", "            BuildConfigurationAudited buildConfigurationAudited = buildConfigurationAuditedsMap.get(buildConfiguration.getId());", "            if(buildConfigurationAudited == null) {", "                buildConfigurationAudited = datastoreAdapter.getLatestBuildConfigurationAuditedInitializeBCDependencies(buildConfiguration.getId());", "            buildConfigurationAuditeds.add(buildConfigurationAudited);", "                buildConfigurationSet.getCurrentProductMilestone(),"], "buildConfigurationAuditedsMap": ["            Map<Integer, BuildConfigurationAudited> buildConfigurationAuditedsMap,", "            BuildConfigurationAudited buildConfigurationAudited = buildConfigurationAuditedsMap.get(buildConfiguration.getId());", "            if(buildConfigurationAudited == null) {", "            buildConfigurationAuditeds.add(buildConfigurationAudited);"], "user": ["            User user,", "        BuildSetTask buildSetTask = initBuildSetTask(buildConfigurationSet, user, buildOptions);", "                user,"], "buildOptions": ["            BuildOptions buildOptions,", "        BuildSetTask buildSetTask = initBuildSetTask(buildConfigurationSet, user, buildOptions);", "                buildSetTask,", "                buildOptions);", "        return buildSetTask;"], "buildTaskIdProvider": ["            Supplier<Integer> buildTaskIdProvider,", "                buildTaskIdProvider,"], "submittedBuildTasks": ["            Set<BuildTask> submittedBuildTasks) throws CoreException {", "                submittedBuildTasks,"]}
{"buildSetTask": ["            BuildSetTask buildSetTask,", "                buildTask = BuildTask.build(", "                        buildSetTask.getBuildOptions(),", "                        buildSetTask,", "                        buildSetTask.getStartTime(),", "                log.debug(\"Created new buildTask {} for BuildConfigurationAudited {}.\", buildTask, buildConfigAudited);", "            buildSetTask.addBuildTask(buildTask);", "        for (BuildTask buildTask : buildSetTask.getBuildTasks()) {", "            for (BuildTask checkDepBuildTask : buildSetTask.getBuildTasks()) {", "                if (buildTask.hasDirectConfigDependencyOn(checkDepBuildTask)) {", "                    buildTask.addDependency(checkDepBuildTask);"], "user": ["            User user,", "                buildTask = BuildTask.build(", "                        user,", "                log.debug(\"Created new buildTask {} for BuildConfigurationAudited {}.\", buildTask, buildConfigAudited);", "            buildSetTask.addBuildTask(buildTask);"], "buildTaskIdProvider": ["            Supplier<Integer> buildTaskIdProvider,", "                int buildId = buildTaskIdProvider.get();", "                String buildContentId = ContentIdentityManager.getBuildContentId(buildId);", "                MDCUtils.addBuildContext(buildContentId, buildOptions.isTemporaryBuild(), temporaryBuildExpireDate);", "                buildTask = BuildTask.build(", "                        buildId,", "                        buildContentId);", "                log.debug(\"Created new buildTask {} for BuildConfigurationAudited {}.\", buildTask, buildConfigAudited);", "            buildSetTask.addBuildTask(buildTask);"], "productMilestone": ["            ProductMilestone productMilestone,", "                buildTask = BuildTask.build(", "                        productMilestone,", "                log.debug(\"Created new buildTask {} for BuildConfigurationAudited {}.\", buildTask, buildConfigAudited);", "            buildSetTask.addBuildTask(buildTask);"], "toBuild": ["            Set<BuildConfigurationAudited> toBuild,", "        for (BuildConfigurationAudited buildConfigAudited : toBuild) {", "            Optional<BuildTask> taskOptional = alreadySubmittedBuildTasks.stream()", "                    .filter(bt -> bt.getBuildConfigurationAudited().equals(buildConfigAudited))", "            if (taskOptional.isPresent()) {", "                buildTask = taskOptional.get();", "                log.debug(\"Linking BuildConfigurationAudited {} to existing task {}.\", buildConfigAudited, buildTask);", "                buildTask = BuildTask.build(", "                        buildConfigAudited,", "                log.debug(\"Created new buildTask {} for BuildConfigurationAudited {}.\", buildTask, buildConfigAudited);", "            buildSetTask.addBuildTask(buildTask);"], "alreadySubmittedBuildTasks": ["            Set<BuildTask> alreadySubmittedBuildTasks,", "            Optional<BuildTask> taskOptional = alreadySubmittedBuildTasks.stream()", "            if (taskOptional.isPresent()) {", "                buildTask = taskOptional.get();", "                log.debug(\"Linking BuildConfigurationAudited {} to existing task {}.\", buildConfigAudited, buildTask);", "            buildSetTask.addBuildTask(buildTask);"], "buildOptions": ["            BuildOptions buildOptions) {", "                MDCUtils.addBuildContext(buildContentId, buildOptions.isTemporaryBuild(), temporaryBuildExpireDate);"]}
{"pageIndex": ["public CollectionInfo<ArtifactRest> getBuiltArtifactsForBuildRecord(int pageIndex, int pageSize, String sortingRsql, String query,", "        return queryForCollection(pageIndex, pageSize, sortingRsql, query, withBuildRecordId(buildRecordId));"], "pageSize": ["public CollectionInfo<ArtifactRest> getBuiltArtifactsForBuildRecord(int pageIndex, int pageSize, String sortingRsql, String query,", "        return queryForCollection(pageIndex, pageSize, sortingRsql, query, withBuildRecordId(buildRecordId));"], "sortingRsql": ["public CollectionInfo<ArtifactRest> getBuiltArtifactsForBuildRecord(int pageIndex, int pageSize, String sortingRsql, String query,", "        return queryForCollection(pageIndex, pageSize, sortingRsql, query, withBuildRecordId(buildRecordId));"], "query": ["public CollectionInfo<ArtifactRest> getBuiltArtifactsForBuildRecord(int pageIndex, int pageSize, String sortingRsql, String query,", "        return queryForCollection(pageIndex, pageSize, sortingRsql, query, withBuildRecordId(buildRecordId));"], "buildRecordId": ["            int buildRecordId) {", "        return queryForCollection(pageIndex, pageSize, sortingRsql, query, withBuildRecordId(buildRecordId));"]}
{"string": ["public static String addEndingSlash(String string) {", "        if (string == null) {", "        if (!string.endsWith(\"/\")) {", "        return string;"]}
{"string": ["public static Integer[] deserializeInt(String string) {", "        if (string == null) {", "        return Arrays.stream(string.split(\",\"))"]}
{"integers": ["public static String serializeInt(Integer[] integers) {", "        if (integers == null) {", "        return Arrays.stream(integers)"]}
{"task": ["public synchronized boolean addReadyTask(BuildTask task) {", "        if (!task.readyToBuild()) {", "            throw new IllegalArgumentException(\"a not ready task added to the queue: \" + task);", "        unfinishedTasks.add(task);", "        log.debug(\"adding task: {}\", task);", "        readyTasks.add(task);"]}
{"task": ["public synchronized void addWaitingTask(BuildTask task, Runnable taskReadyCallback) {", "        unfinishedTasks.add(task);", "        log.debug(\"adding waiting task: {}\", task);", "        waitingTasksWithCallbacks.put(task, taskReadyCallback);"], "taskReadyCallback": ["public synchronized void addWaitingTask(BuildTask task, Runnable taskReadyCallback) {", "        waitingTasksWithCallbacks.put(task, taskReadyCallback);"]}
{"Result": "Method without Parameter"}
{"buildConfigAudited": ["public synchronized Optional<BuildTask> getTask(BuildConfigurationAudited buildConfigAudited) {", "        Optional<BuildTask> ready = readyTasks.stream().filter(bt -> bt.getBuildConfigurationAudited().equals(buildConfigAudited)).findAny();", "        Optional<BuildTask> waiting = waitingTasksWithCallbacks.keySet().stream().filter(bt -> bt.getBuildConfigurationAudited().equals(buildConfigAudited)).findAny();", "        Optional<BuildTask> inProgress = tasksInProgress.stream().filter(bt -> bt.getBuildConfigurationAudited().equals(buildConfigAudited)).findAny();"]}
{"artifactOriginUrl": ["static boolean isTrusted(String artifactOriginUrl, TargetRepository targetRepository) {", "        if (artifactOriginUrl == null || artifactOriginUrl.isEmpty()) {", "            if (artifactOriginUrl.startsWith(trustedRepoUrl)) {"], "targetRepository": ["static boolean isTrusted(String artifactOriginUrl, TargetRepository targetRepository) {", "        if (targetRepository.temporaryRepo) {"]}
{"buildRecord": ["public BuildRecord addBuildRecord(BuildRecord buildRecord) {", "        getBuildRecords().add(buildRecord);", "        buildRecord.setUser(this);", "        return buildRecord;"]}
{"buildRecord": ["public BuildRecord removeBuildRecord(BuildRecord buildRecord) {", "        getBuildRecords().remove(buildRecord);", "        buildRecord.setUser(null);", "        return buildRecord;"]}
{"buildRecordId": ["public boolean deleteTemporaryBuild(Integer buildRecordId, String authToken, Consumer<Result> onComplete) throws ValidationException {", "        BuildRecord buildRecord = buildRecordRepository.findByIdFetchAllProperties(buildRecordId);", "        if (buildRecord == null) {", "        if (!buildRecord.isTemporaryBuild()) {", "                Result result = temporaryBuildsCleaner.deleteTemporaryBuild(buildRecordId, authToken);", "                logger.error(\"Failed to delete temporary buildRecord.id: \" + buildRecordId + \".\", e);", "                onComplete.accept(new Result(buildRecordId.toString(), Result.Status.FAILED, \"Failed to delete temporary buildRecord.\"));"], "authToken": ["public boolean deleteTemporaryBuild(Integer buildRecordId, String authToken, Consumer<Result> onComplete) throws ValidationException {", "                Result result = temporaryBuildsCleaner.deleteTemporaryBuild(buildRecordId, authToken);", "                onComplete.accept(result);"], "onComplete": ["public boolean deleteTemporaryBuild(Integer buildRecordId, String authToken, Consumer<Result> onComplete) throws ValidationException {", "                onComplete.accept(result);", "                onComplete.accept(new Result(buildRecordId.toString(), Result.Status.FAILED, \"Failed to delete temporary buildRecord.\"));"]}
{"Result": "Method without Parameter"}
{"dependant": ["private boolean addDependant(BuildConfiguration dependant) {", "        boolean result = dependants.add(dependant);", "        if (!dependant.getDependencies().contains(this)) {", "            dependant.addDependency(this);", "        return result;"]}
{"dependant": ["private boolean removeDependant(BuildConfiguration dependant) {", "        boolean result = dependants.remove(dependant);", "        if (dependant.getDependencies().contains(this)) {", "            dependant.removeDependency(this);", "        return result;"]}
{"bcName": ["public static String retrieveCloneName(String bcName, Date now) {", "        int index = bcName.indexOf(\"_\");", "            bcNameToAppend = bcName;", "            String prefix = bcName.substring(0, index);", "                    bcNameToAppend = bcName.substring(index + 1);", "                    bcNameToAppend = bcName;", "                bcNameToAppend = bcName;", "        sb.append(new SimpleDateFormat(CLONE_PREFIX_DATE_FORMAT).format(now)).append(\"_\").append(bcNameToAppend);"], "now": ["public static String retrieveCloneName(String bcName, Date now) {", "        sb.append(new SimpleDateFormat(CLONE_PREFIX_DATE_FORMAT).format(now)).append(\"_\").append(bcNameToAppend);"]}
{"provider": ["    public <T extends AbstractModuleConfig> T getModuleConfig(ConfigProvider<T> provider) throws ConfigurationParseException {", "        Class<T> moduleClass = provider.getType();", "            T config = configurationJsonParser.parseJSONPNCConfig(CONFIG_STRING,  provider);", "            configCache.put(moduleClass, config);", "            return config;"]}
{"klass": ["private static EmbeddedTomcat instantiate(Class<?> klass) {", "\t\tEmbeddedTomcatConfiguration configuration = extractConfiguration(klass);", "\t\treturn configuration == null ? new EmbeddedTomcat() : new EmbeddedTomcat(configuration);"]}
{"context": ["private EmbeddedServerRunner registerEmbeddedServer(ExtensionContext context, boolean staticMode) {", "\t\tClass<?> testClass = context.getRequiredTestClass();", "\t\tputEmbeddedServerAdapterInStore(context, serverAdapter, staticMode);"], "staticMode": ["private EmbeddedServerRunner registerEmbeddedServer(ExtensionContext context, boolean staticMode) {", "\t\tputEmbeddedServerAdapterInStore(context, serverAdapter, staticMode);"]}
{"context": ["private void unregisterEmbeddedServer(ExtensionContext context, boolean staticMode) {", "\t\tboolean registeredAsStatic = findInStore(context, SERVER_RUNNER_STATIC_MODE);", "\t\t\t\tEmbeddedServerRunner serverAdapter = findEmbeddedServerAdapterInStore(context);", "\t\t\t\tserverAdapter.afterAll();", "\t\t\t\tremoveEmbeddedServerAdapterFromStore(context);"], "staticMode": ["private void unregisterEmbeddedServer(ExtensionContext context, boolean staticMode) {", "\t\tif (registeredAsStatic == staticMode) {"]}
{"context": ["\tprivate static <T> void putInStore(ExtensionContext context, String name, T value) {", "\t\tgetStore(context).put(name, value);"], "name": ["\tprivate static <T> void putInStore(ExtensionContext context, String name, T value) {", "\t\tgetStore(context).put(name, value);"], "value": ["\tprivate static <T> void putInStore(ExtensionContext context, String name, T value) {", "\t\tgetStore(context).put(name, value);"]}
{"context": ["\tprivate static <T> T findInStore(ExtensionContext context, String name) {", "\t\treturn (T) getStore(context).get(name);"], "name": ["\tprivate static <T> T findInStore(ExtensionContext context, String name) {", "\t\treturn (T) getStore(context).get(name);"]}
{"path": ["public static String concatenatePath(String path, String endpoint) {", "\t\tString firstSegment = ensureAbsolutePath(path);", "\t\t\treturn firstSegment;", "\t\tStringBuilder sb = new StringBuilder(firstSegment);", "\t\tif (path.charAt(path.length() - 1) != PATH_SEPARATOR) {", "\t\t\tsb.append(PATH_SEPARATOR);", "\t\t\tsb.append(endpoint.substring(1));", "\t\t\tsb.append(endpoint);", "\t\treturn sb.toString();"], "endpoint": ["public static String concatenatePath(String path, String endpoint) {", "\t\tif (endpoint == null || endpoint.isEmpty()) {", "\t\tif (endpoint.charAt(0) == PATH_SEPARATOR) {", "\t\t\tsb.append(endpoint.substring(1));", "\t\t\tsb.append(endpoint);"]}
{"Result": "Method without Parameter"}
{"rawValue": ["public static Cookie read(String rawValue) {", "\t\tnotBlank(rawValue, \"Cookie value\");", "\t\tfinal String[] parts = rawValue.split(FIELD_SEPARATOR);"]}
{"name": ["public static HttpHeader header(String name, String value) {", "\t\treturn new HttpHeader(name, singletonList(value));"], "value": ["public static HttpHeader header(String name, String value) {", "\t\treturn new HttpHeader(name, singletonList(value));"]}
{"name": ["public static HttpHeader header(String name, Collection<String> values) {", "\t\treturn new HttpHeader(name, values);"], "values": ["public static HttpHeader header(String name, Collection<String> values) {", "\t\treturn new HttpHeader(name, values);"]}
{"Result": "Method without Parameter"}
{"pre": ["private void execHooks(boolean pre) {", "\t\t\tif (pre) {", "\t\t\t\thook.pre(this);"]}
{"target": ["private void process(Object target, boolean before) {", "\t\tList<Field> fields = findAllFields(target.getClass());", "\t\t\t\tprocessField(target, handler, field, before);"], "before": ["private void process(Object target, boolean before) {", "\t\t\t\tprocessField(target, handler, field, before);"]}
{"target": ["private void processField(Object target, AnnotationHandler handler, Field field, boolean before) {", "\t\t\t\t\thandler.before(target, field);", "\t\t\t\t\thandler.after(target, field);"], "handler": ["private void processField(Object target, AnnotationHandler handler, Field field, boolean before) {", "\t\t\tif (handler.support(annotation)) {", "\t\t\t\t\thandler.before(target, field);", "\t\t\t\t\thandler.after(target, field);"], "field": ["private void processField(Object target, AnnotationHandler handler, Field field, boolean before) {", "\t\tfor (Annotation annotation : field.getAnnotations()) {", "\t\t\tif (handler.support(annotation)) {", "\t\t\t\t\thandler.before(target, field);", "\t\t\t\t\thandler.after(target, field);"], "before": ["private void processField(Object target, AnnotationHandler handler, Field field, boolean before) {", "\t\t\t\tif (before) {", "\t\t\t\t\thandler.before(target, field);"]}
{"server": ["\tpublic static ApacheHttpClient newApacheHttpClient(EmbeddedServer<?> server, CloseableHttpClient client) {", "\t\treturn new ApacheHttpClient(HttpClientConfiguration.defaultConfiguration(), server, client);"], "client": ["\tpublic static ApacheHttpClient newApacheHttpClient(EmbeddedServer<?> server, CloseableHttpClient client) {", "\t\treturn new ApacheHttpClient(HttpClientConfiguration.defaultConfiguration(), server, client);"]}
{"server": ["public static ApacheHttpClient defaultApacheHttpClient(EmbeddedServer<?> server) {", "\t\treturn newApacheHttpClient(configuration, server);"]}
{"httpRequest": ["private void handleBody(HttpRequestBase httpRequest) {", "\t\t\tHttpEntityEnclosingRequestBase rq = (HttpEntityEnclosingRequestBase) httpRequest;", "\t\t\t\thandleFormParameters(rq);", "\t\t\t\thandleRequestBody(rq);"]}
{"Result": "Method without Parameter"}
{"httpRequest": ["private void handleHeaders(HttpRequestBase httpRequest) {", "\t\t\thttpRequest.addHeader(header.getName(), header.serializeValues());"]}
{"httpRequest": ["private void handleFormParameters(HttpEntityEnclosingRequestBase httpRequest) {", "\t\thttpRequest.setEntity(entity);"]}
{"httpRequest": ["private void handleRequestBody(HttpEntityEnclosingRequestBase httpRequest) {", "\t\thttpRequest.setEntity(entity);"]}
{"httpRequest": ["private void handleCookies(HttpRequestBase httpRequest) {", "\t\t\thttpRequest.addHeader(COOKIE, Cookies.serialize(cookies));"]}
{"server": ["public static AsyncHttpClient defaultAsyncHttpClient(EmbeddedServer<?> server) {", "\t\treturn newAsyncHttpClient(configuration, server);"]}
{"Result": "Method without Parameter"}
{"inputs": ["public static <T, U> List<U> map(Collection<T> inputs, Mapper<T, U> mapper) {", "\t\tif (inputs == null) {", "\t\tList<U> outputs = new ArrayList<>(inputs.size());", "\t\tfor (T input : inputs) {", "\t\t\toutputs.add(mapper.apply(input));"], "mapper": ["public static <T, U> List<U> map(Collection<T> inputs, Mapper<T, U> mapper) {", "\t\t\toutputs.add(mapper.apply(input));"]}
{"inputs": ["public static <T> List<T> concat(List<T> inputs, T newValue) {", "\t\tList<T> outputs = new ArrayList<>(inputs.size() + 1);", "\t\toutputs.addAll(inputs);"], "newValue": ["public static <T> List<T> concat(List<T> inputs, T newValue) {", "\t\toutputs.add(newValue);"]}
{"list": ["static <T> List<T> filter(List<T> list, Predicate<T> predicate) {", "\t\tfor (T current : list) {", "\t\t\tif (predicate.apply(current)) {", "\t\t\t\tresults.add(current);"], "predicate": ["static <T> List<T> filter(List<T> list, Predicate<T> predicate) {", "\t\t\tif (predicate.apply(current)) {"]}
{"duration": ["public static DefaultHttpResponse of(long duration, int status, String body, Collection<HttpHeader> headers) {", "\t\treturn new DefaultHttpResponse(duration, status, body, headers);"], "status": ["public static DefaultHttpResponse of(long duration, int status, String body, Collection<HttpHeader> headers) {", "\t\treturn new DefaultHttpResponse(duration, status, body, headers);"], "body": ["public static DefaultHttpResponse of(long duration, int status, String body, Collection<HttpHeader> headers) {", "\t\treturn new DefaultHttpResponse(duration, status, body, headers);"], "headers": ["public static DefaultHttpResponse of(long duration, int status, String body, Collection<HttpHeader> headers) {", "\t\treturn new DefaultHttpResponse(duration, status, body, headers);"]}
{"klass": ["private static EmbeddedJetty instantiate(Class<?> klass) {", "\t\tfinal EmbeddedJettyConfiguration configuration = extractConfiguration(klass);", "\t\treturn configuration == null ? new EmbeddedJetty() : new EmbeddedJetty(configuration);"]}
{"server": ["public static OkHttpClient defaultOkHttpClient(EmbeddedServer<?> server) {", "\t\treturn newOkHttpClient(configuration, server);"]}
{"server": ["\tpublic static OkHttpClient newOkHttpClient(EmbeddedServer<?> server, okhttp3.OkHttpClient client) {", "\t\treturn new OkHttpClient(HttpClientConfiguration.defaultConfiguration(), server, client);"], "client": ["\tpublic static OkHttpClient newOkHttpClient(EmbeddedServer<?> server, okhttp3.OkHttpClient client) {", "\t\treturn new OkHttpClient(HttpClientConfiguration.defaultConfiguration(), server, client);"]}
{"type": ["public static List<Field> findAllFields(Class<?> type) {", "\t\tif (type != null) {", "\t\t\taddAll(fields, type.getDeclaredFields());", "\t\t\tif (type.getSuperclass() != null) {", "\t\t\t\tfields.addAll(findAllFields(type.getSuperclass()));"]}
{"type": ["private static List<Field> findStaticFields(Class<?> type) {", "\t\treturn filter(asList(type.getDeclaredFields()), STATIC_FIELD_PREDICATE);"]}
{"type": ["private static List<Method> findStaticMethods(Class<?> type) {", "\t\treturn filter(asList(type.getDeclaredMethods()), STATIC_METHOD_PREDICATE);"]}
{"type": ["public static List<Field> findStaticFieldsAnnotatedWith(Class<?> type, Class<? extends Annotation> klass) {", "\t\tList<Field> fields = findStaticFields(type);", "\t\treturn filter(fields, new FieldAnnotatedWithPredicate(klass));"], "klass": ["public static List<Field> findStaticFieldsAnnotatedWith(Class<?> type, Class<? extends Annotation> klass) {", "\t\treturn filter(fields, new FieldAnnotatedWithPredicate(klass));"]}
{"type": ["public static List<Method> findStaticMethodsAnnotatedWith(Class<?> type, Class<? extends Annotation> klass) {", "\t\tList<Method> methods = findStaticMethods(type);", "\t\treturn filter(methods, new MethodAnnotatedWithPredicate(klass));"], "klass": ["public static List<Method> findStaticMethodsAnnotatedWith(Class<?> type, Class<? extends Annotation> klass) {", "\t\treturn filter(methods, new MethodAnnotatedWithPredicate(klass));"]}
{"instance": ["public static void setter(Object instance, Field field, Object value) {", "\t\t\tfield.set(instance, value);"], "field": ["public static void setter(Object instance, Field field, Object value) {", "\t\t\tif (!field.isAccessible()) {", "\t\t\t\tfield.setAccessible(true);", "\t\t\tfield.set(instance, value);", "\t\t\t\tfield.setAccessible(false);"], "value": ["public static void setter(Object instance, Field field, Object value) {", "\t\t\tfield.set(instance, value);"]}
{"target": ["\tpublic static <T> T getter(Object target, Field field) {", "\t\t\treturn (T) field.get(target);"], "field": ["\tpublic static <T> T getter(Object target, Field field) {", "\t\t\tif (!field.isAccessible()) {", "\t\t\t\tfield.setAccessible(true);", "\t\t\treturn (T) field.get(target);", "\t\t\t\tfield.setAccessible(false);"]}
{"method": ["\tpublic static <T> T invoke(Method method) {", "\t\t\tif (!method.isAccessible()) {", "\t\t\t\tmethod.setAccessible(true);", "\t\t\treturn (T) method.invoke(null);", "\t\t\t\tmethod.setAccessible(false);"]}
{"date": ["public static String format(Date date, String pattern) {", "\t\treturn df(pattern).format(date);"], "pattern": ["public static String format(Date date, String pattern) {", "\t\treturn df(pattern).format(date);"]}
{"time": ["static String formatTime(long time, String pattern) {", "\t\tdate.setTime(time);"], "pattern": ["static String formatTime(long time, String pattern) {", "\t\treturn format(date, pattern);"]}
{"builder": ["private void handleHeaders(Request.Builder builder) {", "\t\t\tbuilder.addHeader(h.getName(), h.serializeValues());"]}
{"value": ["static boolean isBlank(String value) {", "\t\tif (value == null) {", "\t\tfor (char character : value.toCharArray()) {", "\t\t\tif (!Character.isWhitespace(character)) {"]}
{"value": ["public static String removePrefix(String value, String prefix) {", "\t\tif (value == null || prefix == null || prefix.length() > value.length()) {", "\t\t\treturn value;", "\t\treturn value.startsWith(prefix) ? value.substring(prefix.length()) : value;"], "prefix": ["public static String removePrefix(String value, String prefix) {", "\t\tif (value == null || prefix == null || prefix.length() > value.length()) {", "\t\treturn value.startsWith(prefix) ? value.substring(prefix.length()) : value;"]}
{"separator": ["public static String join(String separator, Collection<String> values) {", "\t\t\t\tbuilder.append(separator);"], "values": ["public static String join(String separator, Collection<String> values) {", "\t\tfor (String value : values) {", "\t\t\tbuilder.append(value);"]}
{"builder": ["private void handleQueryParameters(RequestBuilder builder) {", "\t\t\tbuilder.addQueryParam(p.getEncodedName(), p.getEncodedValue());"]}
{"builder": ["private void handleBody(RequestBuilder builder) {", "\t\t\thandleRequestBody(builder);", "\t\t\thandleFormParameters(builder);"]}
{"builder": ["private void handleFormParameters(RequestBuilder builder) {", "\t\t\tbuilder.addFormParam(p.getName(), p.getValue());"]}
{"builder": ["private void handleCookies(RequestBuilder builder) {", "\t\t\tbuilder.addHeader(HttpHeaders.COOKIE, Cookies.serialize(cookies));"]}
{"builder": ["private void handleHeaders(RequestBuilder builder) {", "\t\t\tbuilder.addHeader(header.getName(), header.serializeValues());"]}
{"name": ["public ToStringBuilder append(String name, Map<?, ?> map) {", "\t\treturn appendFormattedValue(name, sb.toString());"], "map": ["public ToStringBuilder append(String name, Map<?, ?> map) {", "\t\tfor (Map.Entry<?, ?> entry : map.entrySet()) {", "\t\t\tsb.append(entry.getKey()).append(FIELD_VALUE_SEPARATOR).append(formatValue(entry.getValue()));"]}
{"name": ["public <T> ToStringBuilder append(String name, Iterable<T> values) {", "\t\treturn appendFormattedValue(name, pending.append(CLOSE_ARRAY).toString());"], "values": ["public <T> ToStringBuilder append(String name, Iterable<T> values) {", "\t\tfor (T value : values) {", "\t\t\tpending.append(formatValue(value));"]}
{"name": ["private ToStringBuilder appendFormattedValue(String name, Object value) {", "\t\tsb.append(name).append(FIELD_VALUE_SEPARATOR).append(value);"], "value": ["private ToStringBuilder appendFormattedValue(String name, Object value) {", "\t\tsb.append(name).append(FIELD_VALUE_SEPARATOR).append(value);"]}
{"dialogId": ["protected  SIPDialog getDialogFromDistributedCache(String dialogId) {", "\t\t\tgetStackLogger().logDebug(\"sipStack \" + this + \" checking if the dialog \" + dialogId + \" is present in the distributed cache\");", "\t\t\tsipDialog = sipCache.getDialog(dialogId);", "\t\t\tgetStackLogger().logError(\"sipStack \" + this + \" problem getting dialog \" + dialogId + \" from the distributed cache\", e);", "\t\tif(sipDialog != null) {\t\t\t", "\t\t\t\tgetStackLogger().logDebug(\"sipStack \" + this + \" dialog \" + dialogId + \" was present in the distributed cache, initializing it after the load\");", "\t\t\t((HASipDialog)sipDialog).initAfterLoad(this);", "\t\treturn sipDialog;"]}
{"dialog": ["protected  void putDialogIntoDistributedCache(SIPDialog dialog) {", "\t\tString dialogId = dialog.getDialogId();\t", "\t\t\tsipCache.putDialog(dialog);"]}
{"dialogId": ["protected  void removeDialogFromDistributedCache(String dialogId) {", "\t\t\tgetStackLogger().logDebug(\"sipStack \" + this + \" removing the dialog \" + dialogId + \" from the distributed cache\");", "\t\t\tsipCache.removeDialog(dialogId);", "\t\t\tgetStackLogger().logError(\"sipStack \" + this + \" problem removing dialog \" + dialogId + \" from the distributed cache\", e);"]}
{"sipStackImpl": ["public void initAfterLoad(ClusteredSipStack sipStackImpl) {", "\t\tIterator<SipProviderImpl> providers = sipStackImpl.getSipProviders();", "\t\tsetStack((SIPTransactionStack)sipStackImpl);"]}
{"transaction": ["\tpublic boolean addTransaction(SIPTransaction transaction) {\t\t", "\t\tif(transaction instanceof ServerTransaction) {", "\t\treturn super.addTransaction(transaction);"]}
{"entry": ["public void printEntry(final Entry entry) throws IOException {", "        if (entry != null) {", "            entry.toLDIF(buffer, 77);"]}
{"connection": ["public final void load(final LDAPInterface connection,", "                            record.processChange(connection);"], "inputStream": ["                           final InputStream inputStream,", "        final FormatReader reader = openReader(inputStream, logger);"], "ignoreErrors": ["                           final boolean ignoreErrors,", "                        if (!ignoreErrors || !e.mayContinueReading()) {", "                        if (!ignoreErrors) {"], "logger": ["                           final FormatLogger logger) {", "        final FormatReader reader = openReader(inputStream, logger);", "        if (reader != null) {", "                        final LDIFChangeRecord record = reader.nextRecord();", "                            logger.logError(\"Error parsing directory entry read from the input stream\", e);", "                            logger.logError(\"Error loading directory entry into the LDAP directory server\", e);", "                logger.logError(\"I/O error reading directory entry from input stream\", e);", "                    reader.close();", "                    logger.logError(\"I/O error closing the input stream reader\", e);"]}
{"connection": ["public final void dump(final LDAPInterface connection,", "                    final SearchResult result = connection.search(request);"], "base": ["                           final String base,", "                    final SearchRequest request = new SearchRequest(base, SearchScope.SUB, Filter.create(filter));"], "filter": ["                           final String filter,", "                    final SearchRequest request = new SearchRequest(base, SearchScope.SUB, Filter.create(filter));", "                    final SearchResult result = connection.search(request);", "                    if (result.getResultCode() == ResultCode.SUCCESS) {", "                        final List<SearchResultEntry> entries = result.getSearchEntries();"], "outputStream": ["                           final OutputStream outputStream,", "        final FormatWriter ldapWriter = createWriter(outputStream, logger);"], "logger": ["                           final FormatLogger logger) {", "        final FormatWriter ldapWriter = createWriter(outputStream, logger);", "        if (ldapWriter == null) {", "            logger.logError(\"Error creating writer for output stream\");", "                                ldapWriter.printEntry(entry);", "                            logger.logInfo(\"Search did not return any directory entries\");", "                        logger.logError(\"Search operation failed\");", "                    logger.logError(\"Error searching the LDAP directory\", e);", "                    ldapWriter.close();", "                logger.logError(\"Error writing directory entry to the output stream\", e);"]}
{"Result": "Method without Parameter"}
{"component": ["    public void configureComponent(final Object component,", "        converter.processConfiguration(converterLookup, component, containerRealm, configuration,"], "configuration": ["                                   final PlexusConfiguration configuration,", "        final String serverType = getServerType(configuration);", "        if (!serverType.startsWith(\"dependency-\")) {", "            addServerDependenciesToClassRealm(serverType, expressionEvaluator, containerRealm);", "        converter.processConfiguration(converterLookup, component, containerRealm, configuration,"], "expressionEvaluator": ["                                   final ExpressionEvaluator expressionEvaluator,", "            addServerDependenciesToClassRealm(serverType, expressionEvaluator, containerRealm);", "                expressionEvaluator, listener);"], "containerRealm": ["                                   final ClassRealm containerRealm,", "            addServerDependenciesToClassRealm(serverType, expressionEvaluator, containerRealm);", "        converterLookup.registerConverter(new ClassRealmConverter(containerRealm));", "        converter.processConfiguration(converterLookup, component, containerRealm, configuration,"], "listener": ["                                   final ConfigurationListener listener)", "                expressionEvaluator, listener);"]}
{"serverType": ["private void addServerDependenciesToClassRealm(final String serverType,", "        final Collection<Artifact> classpathElements = getServerDependencies(serverType, expressionEvaluator);"], "expressionEvaluator": ["                                                   final ExpressionEvaluator expressionEvaluator,", "        final Collection<Artifact> classpathElements = getServerDependencies(serverType, expressionEvaluator);", "        if (classpathElements != null) {", "            for (final URL url : buildURLs(classpathElements)) {", "                containerRealm.addURL(url);"], "containerRealm": ["                                                   final ClassRealm containerRealm)", "                containerRealm.addURL(url);"]}
{"classpathElements": ["private List<URL> buildURLs(final Collection<Artifact> classpathElements)", "        final List<URL> urls = new ArrayList<URL>(classpathElements.size());", "        for (final Artifact classpathElement : classpathElements) {", "                final URL url = classpathElement.getFile().toURI().toURL();", "                urls.add(url);", "                throw new ComponentConfigurationException(\"Unable to access project dependency: \" + classpathElement, e);"]}
{"serverType": ["private Collection<Artifact> getServerDependencies(final String serverType,", "            request.setArtifact(getServerArtifact(serverType));"], "expressionEvaluator": ["                                                       final ExpressionEvaluator expressionEvaluator)", "            final MavenProject project = (MavenProject) expressionEvaluator.evaluate(\"${project}\");", "            final String localRepo = (String) expressionEvaluator.evaluate(\"${settings.localRepository}\");"]}
{"serverType": ["private Artifact getServerArtifact(final String serverType)", "        if (serverType.startsWith(\"gav-\")) {", "            int index = serverType.indexOf(\"-\", 4);", "                String[] gav = serverType.substring(index + 1).split(\":\");", "            throw new ComponentConfigurationException(\"Invalid server type: \" + serverType);", "                    MessageFormat.format(DEFAULT_ARTIFACT_ID_FORMAT, serverType),"]}
{"configuration": ["private String getServerType(final PlexusConfiguration configuration) {", "        for (final PlexusConfiguration cfg : configuration.getChildren()) {", "            if (cfg.getName().equals(SERVER_TYPE_ATTRIBUTE)) {", "                if (pattern.matcher(cfg.getValue()).matches()) {", "                    return cfg.getValue();"]}
{"outputStream": ["    protected FormatWriter createWriter(final OutputStream outputStream,", "            return new DSMLFormatWriter(outputStream);"], "logger": ["                                        final FormatLogger logger) {", "            logger.logError(\"Could not create and intialise the DSML writer\", e);"]}
{"inputStream": ["    protected FormatReader openReader(final InputStream inputStream,", "            return new DSMLFormatReader(inputStream);"], "logger": ["                                      final FormatLogger logger) {", "            logger.logError(\"Error parsing DSML file\", e);", "            logger.logError(\"Error processing DSML file\", e);", "            logger.logError(\"Error reading DSML file\", e);"]}
{"name": ["    public void configure(final String name, final Object value, final Logger logger) {", "        if (ROOT.equals(name)) {", "        } else if (OBJECT_CLASSES.equals(name)) {", "        } else if (AUTH_DN.equals(name)) {", "        } else if (PASSWD.equals(name)) {", "        } else if (WORK_DIR.equals(name)) {", "        } else if (LDIF_FILE.equals(name)) {", "        } else if (LDAP_PORT.equals(name)) {"], "value": ["    public void configure(final String name, final Object value, final Logger logger) {", "            if (value instanceof String) {", "                root = (String) value;", "                logger.logInfo(\"Configured root DN for directory server: \" + root);", "            if (value instanceof String[]) {", "                objectClasses = (String[]) value;", "                logger.logInfo(\"Configured object classes for root DN: \" + objectClasses);", "            if (value instanceof String) {", "                authDn = (String) value;", "                logger.logInfo(\"Configured admin identity for directory server: \" + authDn);", "            if (value instanceof String) {", "                passwd = (String) value;", "                logger.logInfo(\"Configured admin credentials for directory server: \" + passwd);", "            if (value instanceof File) {", "                workingDirectory = (File) value;", "                logger.logInfo(\"Configured working directory for directory server: \" + workingDirectory);", "            if (value instanceof File) {", "                ldifFile = (File) value;", "                logger.logInfo(\"Configured LDIF seed data source for directory server: \" + ldifFile);", "            if (value instanceof Integer) {", "                serverPort = (Integer) value;", "                logger.logInfo(\"Configured TCP port for directory server: \" + serverPort);"], "logger": ["    public void configure(final String name, final Object value, final Logger logger) {", "                logger.logInfo(\"Configured root DN for directory server: \" + root);", "                logger.logInfo(\"Configured object classes for root DN: \" + objectClasses);", "                logger.logInfo(\"Configured admin identity for directory server: \" + authDn);", "                logger.logInfo(\"Configured admin credentials for directory server: \" + passwd);", "                logger.logInfo(\"Configured working directory for directory server: \" + workingDirectory);", "                logger.logInfo(\"Configured LDIF seed data source for directory server: \" + ldifFile);", "                logger.logInfo(\"Configured TCP port for directory server: \" + serverPort);"]}
{"logger": ["    public void start(final Logger logger) {", "            logger.logInfo(\"Starting UnboundID server\");", "            logger.logInfo(\"Started UnboundID server\");", "            logger.logError(\"Could not launch embedded UnboundID directory server\", e);", "            logger.logError(\"Could not launch embedded UnboundID directory server\", e);"]}
{"logger": ["    public void stop(final Logger logger) {", "        logger.logInfo(\"Stopping UnboundID server\");", "        logger.logInfo(\"Stopped UnboundID server\");"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"logger": ["    public void start(final Logger logger) {", "            logger.logInfo(\"Starting ApacheDS server\");", "            logger.logInfo(\"Started ApacheDS server\");", "            logger.logError(\"Error starting ApacheDS server e\");"]}
{"logger": ["    public void stop(final Logger logger) {", "            logger.logInfo(\"Stopping ApacheDS server\");", "            logger.logInfo(\"Stopped ApacheDS server\");", "            logger.logError(\"Error stopping ApacheDS server\", e);"]}
{"partition": ["private void createRoot(final Partition partition) throws Exception {", "            service.getAdminSession().lookup(partition.getSuffixDn());"]}
{"logger": ["    public void start(final Logger logger) {", "            logger.logInfo(\"Starting OpenDJ server\");", "            logger.logInfo(\"Started OpenDJ server\");", "            logger.logError(\"Error starting OpenDJ server\", e);"]}
{"logger": ["    public void stop(final Logger logger) {", "        logger.logInfo(\"Stopping OpenDJ server\");", "        logger.logInfo(\"Stopped OpenDJ server\");"]}
{"entry": ["public void printEntry(final Entry entry) throws IOException {", "        buffer.append(entry.getDN());", "        final String[] values = entry.getAttributeValues(\"objectclass\");", "        for (final Attribute attribute : entry.getAttributes()) {", "            final String name = attribute.getName();", "            if (!name.equals(\"objectclass\")) {", "                buffer.append(name);", "                for (final String value : attribute.getValues()) {", "                    buffer.append(value);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"metricBuilder": ["protected void sendMetric(MetricBuilder metricBuilder) throws ReportingException {", "      Response response = client.pushMetrics(metricBuilder);", "      if (response.getStatusCode() / 100 != 2) {", "        LOGGER.error(\"Kairos DB reported error. Status code: \" + response.getStatusCode());", "        LOGGER.error(\"Error message: \" + response.getErrors());", "        LOGGER.debug(\"Kairos DB returned OK. Status code: \" + response.getStatusCode());"]}
{"metric": ["  public void report(Metric metric) throws ReportingException {", "      kairosMetricConverter.add(metric);"]}
{"reader": ["public static GeometryTypeInfo readGeometryType(ByteReader reader) {", "\t\tbyte byteOrderValue = reader.readByte();", "\t\treader.setByteOrder(byteOrder);", "\t\tlong unsignedGeometryTypeCode = reader.readUnsignedInt();"]}
{"reader": ["public static Point readPoint(ByteReader reader, boolean hasZ, boolean hasM) {", "\t\tdouble x = reader.readDouble();", "\t\tdouble y = reader.readDouble();", "\t\t\tdouble z = reader.readDouble();", "\t\t\tdouble m = reader.readDouble();"], "hasZ": ["public static Point readPoint(ByteReader reader, boolean hasZ, boolean hasM) {", "\t\tPoint point = new Point(hasZ, hasM, x, y);", "\t\tif (hasZ) {"], "hasM": ["public static Point readPoint(ByteReader reader, boolean hasZ, boolean hasM) {", "\t\tPoint point = new Point(hasZ, hasM, x, y);", "\t\tif (hasM) {"]}
{"reader": ["public static LineString readLineString(ByteReader reader, boolean hasZ,", "\t\tint numPoints = reader.readInt();", "\t\t\tPoint point = readPoint(reader, hasZ, hasM);", "\t\t\tlineString.addPoint(point);"], "hasZ": ["public static LineString readLineString(ByteReader reader, boolean hasZ,", "\t\tLineString lineString = new LineString(hasZ, hasM);", "\t\t\tPoint point = readPoint(reader, hasZ, hasM);", "\t\t\tlineString.addPoint(point);"], "hasM": ["\t\t\tboolean hasM) {", "\t\tLineString lineString = new LineString(hasZ, hasM);", "\t\t\tPoint point = readPoint(reader, hasZ, hasM);", "\t\t\tlineString.addPoint(point);", "\t\treturn lineString;"]}
{"reader": ["public static Polygon readPolygon(ByteReader reader, boolean hasZ,", "\t\tint numRings = reader.readInt();", "\t\t\tLineString ring = readLineString(reader, hasZ, hasM);", "\t\t\tpolygon.addRing(ring);"], "hasZ": ["public static Polygon readPolygon(ByteReader reader, boolean hasZ,", "\t\tPolygon polygon = new Polygon(hasZ, hasM);", "\t\t\tLineString ring = readLineString(reader, hasZ, hasM);", "\t\t\tpolygon.addRing(ring);"], "hasM": ["\t\t\tboolean hasM) {", "\t\tPolygon polygon = new Polygon(hasZ, hasM);", "\t\t\tLineString ring = readLineString(reader, hasZ, hasM);", "\t\t\tpolygon.addRing(ring);", "\t\treturn polygon;"]}
{"reader": ["public static MultiPoint readMultiPoint(ByteReader reader, boolean hasZ,", "\t\tint numPoints = reader.readInt();", "\t\t\tPoint point = readGeometry(reader, Point.class);", "\t\t\tmultiPoint.addPoint(point);"], "hasZ": ["public static MultiPoint readMultiPoint(ByteReader reader, boolean hasZ,", "\t\tMultiPoint multiPoint = new MultiPoint(hasZ, hasM);"], "hasM": ["\t\t\tboolean hasM) {", "\t\tMultiPoint multiPoint = new MultiPoint(hasZ, hasM);", "\t\t\tmultiPoint.addPoint(point);", "\t\treturn multiPoint;"]}
{"reader": ["public static MultiLineString readMultiLineString(ByteReader reader,", "\t\tint numLineStrings = reader.readInt();", "\t\t\tLineString lineString = readGeometry(reader, LineString.class);", "\t\t\tmultiLineString.addLineString(lineString);"], "hasZ": ["\t\t\tboolean hasZ, boolean hasM) {", "\t\tMultiLineString multiLineString = new MultiLineString(hasZ, hasM);"], "hasM": ["\t\t\tboolean hasZ, boolean hasM) {", "\t\tMultiLineString multiLineString = new MultiLineString(hasZ, hasM);", "\t\t\tmultiLineString.addLineString(lineString);", "\t\treturn multiLineString;"]}
{"reader": ["public static MultiPolygon readMultiPolygon(ByteReader reader,", "\t\tint numPolygons = reader.readInt();", "\t\t\tPolygon polygon = readGeometry(reader, Polygon.class);", "\t\t\tmultiPolygon.addPolygon(polygon);"], "hasZ": ["\t\t\tboolean hasZ, boolean hasM) {", "\t\tMultiPolygon multiPolygon = new MultiPolygon(hasZ, hasM);"], "hasM": ["\t\t\tboolean hasZ, boolean hasM) {", "\t\tMultiPolygon multiPolygon = new MultiPolygon(hasZ, hasM);", "\t\t\tmultiPolygon.addPolygon(polygon);", "\t\treturn multiPolygon;"]}
{"reader": ["\t\t\tByteReader reader, boolean hasZ, boolean hasM) {", "\t\tint numGeometries = reader.readInt();", "\t\t\tGeometry geometry = readGeometry(reader, Geometry.class);", "\t\t\tgeometryCollection.addGeometry(geometry);"], "hasZ": ["\t\t\tByteReader reader, boolean hasZ, boolean hasM) {", "\t\t\t\thasZ, hasM);"], "hasM": ["\t\t\tByteReader reader, boolean hasZ, boolean hasM) {", "\t\tGeometryCollection<Geometry> geometryCollection = new GeometryCollection<Geometry>(", "\t\t\t\thasZ, hasM);", "\t\t\tgeometryCollection.addGeometry(geometry);", "\t\treturn geometryCollection;"]}
{"reader": ["public static CircularString readCircularString(ByteReader reader,", "\t\tint numPoints = reader.readInt();", "\t\t\tPoint point = readPoint(reader, hasZ, hasM);", "\t\t\tcircularString.addPoint(point);"], "hasZ": ["\t\t\tboolean hasZ, boolean hasM) {", "\t\tCircularString circularString = new CircularString(hasZ, hasM);", "\t\t\tPoint point = readPoint(reader, hasZ, hasM);", "\t\t\tcircularString.addPoint(point);"], "hasM": ["\t\t\tboolean hasZ, boolean hasM) {", "\t\tCircularString circularString = new CircularString(hasZ, hasM);", "\t\t\tPoint point = readPoint(reader, hasZ, hasM);", "\t\t\tcircularString.addPoint(point);", "\t\treturn circularString;"]}
{"reader": ["public static CompoundCurve readCompoundCurve(ByteReader reader,", "\t\tint numLineStrings = reader.readInt();", "\t\t\tLineString lineString = readGeometry(reader, LineString.class);", "\t\t\tcompoundCurve.addLineString(lineString);"], "hasZ": ["\t\t\tboolean hasZ, boolean hasM) {", "\t\tCompoundCurve compoundCurve = new CompoundCurve(hasZ, hasM);"], "hasM": ["\t\t\tboolean hasZ, boolean hasM) {", "\t\tCompoundCurve compoundCurve = new CompoundCurve(hasZ, hasM);", "\t\t\tcompoundCurve.addLineString(lineString);", "\t\treturn compoundCurve;"]}
{"reader": ["public static CurvePolygon<Curve> readCurvePolygon(ByteReader reader,", "\t\tint numRings = reader.readInt();", "\t\t\tCurve ring = readGeometry(reader, Curve.class);", "\t\t\tcurvePolygon.addRing(ring);"], "hasZ": ["\t\t\tboolean hasZ, boolean hasM) {", "\t\tCurvePolygon<Curve> curvePolygon = new CurvePolygon<Curve>(hasZ, hasM);"], "hasM": ["\t\t\tboolean hasZ, boolean hasM) {", "\t\tCurvePolygon<Curve> curvePolygon = new CurvePolygon<Curve>(hasZ, hasM);", "\t\t\tcurvePolygon.addRing(ring);", "\t\treturn curvePolygon;"]}
{"reader": ["public static PolyhedralSurface readPolyhedralSurface(ByteReader reader,", "\t\tint numPolygons = reader.readInt();", "\t\t\tPolygon polygon = readGeometry(reader, Polygon.class);", "\t\t\tpolyhedralSurface.addPolygon(polygon);"], "hasZ": ["\t\t\tboolean hasZ, boolean hasM) {", "\t\tPolyhedralSurface polyhedralSurface = new PolyhedralSurface(hasZ, hasM);"], "hasM": ["\t\t\tboolean hasZ, boolean hasM) {", "\t\tPolyhedralSurface polyhedralSurface = new PolyhedralSurface(hasZ, hasM);", "\t\t\tpolyhedralSurface.addPolygon(polygon);", "\t\treturn polyhedralSurface;"]}
{"reader": ["public static TIN readTIN(ByteReader reader, boolean hasZ, boolean hasM) {", "\t\tint numPolygons = reader.readInt();", "\t\t\tPolygon polygon = readGeometry(reader, Polygon.class);", "\t\t\ttin.addPolygon(polygon);"], "hasZ": ["public static TIN readTIN(ByteReader reader, boolean hasZ, boolean hasM) {", "\t\tTIN tin = new TIN(hasZ, hasM);"], "hasM": ["public static TIN readTIN(ByteReader reader, boolean hasZ, boolean hasM) {", "\t\tTIN tin = new TIN(hasZ, hasM);", "\t\t\ttin.addPolygon(polygon);", "\t\treturn tin;"]}
{"reader": ["public static Triangle readTriangle(ByteReader reader, boolean hasZ,", "\t\tint numRings = reader.readInt();", "\t\t\tLineString ring = readLineString(reader, hasZ, hasM);", "\t\t\ttriangle.addRing(ring);"], "hasZ": ["public static Triangle readTriangle(ByteReader reader, boolean hasZ,", "\t\tTriangle triangle = new Triangle(hasZ, hasM);", "\t\t\tLineString ring = readLineString(reader, hasZ, hasM);", "\t\t\ttriangle.addRing(ring);"], "hasM": ["\t\t\tboolean hasM) {", "\t\tTriangle triangle = new Triangle(hasZ, hasM);", "\t\t\tLineString ring = readLineString(reader, hasZ, hasM);", "\t\t\ttriangle.addRing(ring);", "\t\treturn triangle;"]}
{"writer": ["public static void writeGeometry(ByteWriter writer, Geometry geometry)", "\t\tbyte byteOrder = writer.getByteOrder() == ByteOrder.BIG_ENDIAN ? (byte) 0", "\t\twriter.writeByte(byteOrder);", "\t\twriter.writeInt(GeometryCodes.getCode(geometry));", "\t\t\twritePoint(writer, (Point) geometry);", "\t\t\twriteLineString(writer, (LineString) geometry);", "\t\t\twritePolygon(writer, (Polygon) geometry);", "\t\t\twriteMultiPoint(writer, (MultiPoint) geometry);", "\t\t\twriteMultiLineString(writer, (MultiLineString) geometry);", "\t\t\twriteMultiPolygon(writer, (MultiPolygon) geometry);", "\t\t\twriteGeometryCollection(writer, (GeometryCollection<?>) geometry);", "\t\t\twriteCircularString(writer, (CircularString) geometry);", "\t\t\twriteCompoundCurve(writer, (CompoundCurve) geometry);", "\t\t\twriteCurvePolygon(writer, (CurvePolygon<?>) geometry);", "\t\t\twritePolyhedralSurface(writer, (PolyhedralSurface) geometry);", "\t\t\twriteTIN(writer, (TIN) geometry);", "\t\t\twriteTriangle(writer, (Triangle) geometry);"], "geometry": ["public static void writeGeometry(ByteWriter writer, Geometry geometry)", "\t\twriter.writeInt(GeometryCodes.getCode(geometry));", "\t\tGeometryType geometryType = geometry.getGeometryType();", "\t\t\twritePoint(writer, (Point) geometry);", "\t\t\twriteLineString(writer, (LineString) geometry);", "\t\t\twritePolygon(writer, (Polygon) geometry);", "\t\t\twriteMultiPoint(writer, (MultiPoint) geometry);", "\t\t\twriteMultiLineString(writer, (MultiLineString) geometry);", "\t\t\twriteMultiPolygon(writer, (MultiPolygon) geometry);", "\t\t\twriteGeometryCollection(writer, (GeometryCollection<?>) geometry);", "\t\t\twriteCircularString(writer, (CircularString) geometry);", "\t\t\twriteCompoundCurve(writer, (CompoundCurve) geometry);", "\t\t\twriteCurvePolygon(writer, (CurvePolygon<?>) geometry);", "\t\t\twritePolyhedralSurface(writer, (PolyhedralSurface) geometry);", "\t\t\twriteTIN(writer, (TIN) geometry);", "\t\t\twriteTriangle(writer, (Triangle) geometry);"]}
{"writer": ["public static void writePoint(ByteWriter writer, Point point)", "\t\twriter.writeDouble(point.getX());", "\t\twriter.writeDouble(point.getY());", "\t\t\twriter.writeDouble(point.getZ());", "\t\t\twriter.writeDouble(point.getM());"], "point": ["public static void writePoint(ByteWriter writer, Point point)", "\t\twriter.writeDouble(point.getX());", "\t\twriter.writeDouble(point.getY());", "\t\tif (point.hasZ()) {", "\t\t\twriter.writeDouble(point.getZ());", "\t\tif (point.hasM()) {", "\t\t\twriter.writeDouble(point.getM());"]}
{"writer": ["public static void writeLineString(ByteWriter writer, LineString lineString)", "\t\twriter.writeInt(lineString.numPoints());", "\t\t\twritePoint(writer, point);"], "lineString": ["public static void writeLineString(ByteWriter writer, LineString lineString)", "\t\twriter.writeInt(lineString.numPoints());", "\t\tfor (Point point : lineString.getPoints()) {", "\t\t\twritePoint(writer, point);"]}
{"writer": ["public static void writePolygon(ByteWriter writer, Polygon polygon)", "\t\twriter.writeInt(polygon.numRings());", "\t\t\twriteLineString(writer, ring);"], "polygon": ["public static void writePolygon(ByteWriter writer, Polygon polygon)", "\t\twriter.writeInt(polygon.numRings());", "\t\tfor (LineString ring : polygon.getRings()) {", "\t\t\twriteLineString(writer, ring);"]}
{"writer": ["public static void writeMultiPoint(ByteWriter writer, MultiPoint multiPoint)", "\t\twriter.writeInt(multiPoint.numPoints());", "\t\t\twriteGeometry(writer, point);"], "multiPoint": ["public static void writeMultiPoint(ByteWriter writer, MultiPoint multiPoint)", "\t\twriter.writeInt(multiPoint.numPoints());", "\t\tfor (Point point : multiPoint.getPoints()) {", "\t\t\twriteGeometry(writer, point);"]}
{"writer": ["public static void writeMultiLineString(ByteWriter writer,", "\t\twriter.writeInt(multiLineString.numLineStrings());", "\t\t\twriteGeometry(writer, lineString);"], "multiLineString": ["\t\t\tMultiLineString multiLineString) throws IOException {", "\t\twriter.writeInt(multiLineString.numLineStrings());", "\t\tfor (LineString lineString : multiLineString.getLineStrings()) {", "\t\t\twriteGeometry(writer, lineString);"]}
{"writer": ["public static void writeMultiPolygon(ByteWriter writer,", "\t\twriter.writeInt(multiPolygon.numPolygons());", "\t\t\twriteGeometry(writer, polygon);"], "multiPolygon": ["\t\t\tMultiPolygon multiPolygon) throws IOException {", "\t\twriter.writeInt(multiPolygon.numPolygons());", "\t\tfor (Polygon polygon : multiPolygon.getPolygons()) {", "\t\t\twriteGeometry(writer, polygon);"]}
{"writer": ["public static void writeGeometryCollection(ByteWriter writer,", "\t\twriter.writeInt(geometryCollection.numGeometries());", "\t\t\twriteGeometry(writer, geometry);"], "geometryCollection": ["\t\t\tGeometryCollection<?> geometryCollection) throws IOException {", "\t\twriter.writeInt(geometryCollection.numGeometries());", "\t\tfor (Geometry geometry : geometryCollection.getGeometries()) {", "\t\t\twriteGeometry(writer, geometry);"]}
{"writer": ["public static void writeCircularString(ByteWriter writer,", "\t\twriter.writeInt(circularString.numPoints());", "\t\t\twritePoint(writer, point);"], "circularString": ["\t\t\tCircularString circularString) throws IOException {", "\t\twriter.writeInt(circularString.numPoints());", "\t\tfor (Point point : circularString.getPoints()) {", "\t\t\twritePoint(writer, point);"]}
{"writer": ["public static void writeCompoundCurve(ByteWriter writer,", "\t\twriter.writeInt(compoundCurve.numLineStrings());", "\t\t\twriteGeometry(writer, lineString);"], "compoundCurve": ["\t\t\tCompoundCurve compoundCurve) throws IOException {", "\t\twriter.writeInt(compoundCurve.numLineStrings());", "\t\tfor (LineString lineString : compoundCurve.getLineStrings()) {", "\t\t\twriteGeometry(writer, lineString);"]}
{"writer": ["public static void writeCurvePolygon(ByteWriter writer,", "\t\twriter.writeInt(curvePolygon.numRings());", "\t\t\twriteGeometry(writer, ring);"], "curvePolygon": ["\t\t\tCurvePolygon<?> curvePolygon) throws IOException {", "\t\twriter.writeInt(curvePolygon.numRings());", "\t\tfor (Curve ring : curvePolygon.getRings()) {", "\t\t\twriteGeometry(writer, ring);"]}
{"writer": ["public static void writePolyhedralSurface(ByteWriter writer,", "\t\twriter.writeInt(polyhedralSurface.numPolygons());", "\t\t\twriteGeometry(writer, polygon);"], "polyhedralSurface": ["\t\t\tPolyhedralSurface polyhedralSurface) throws IOException {", "\t\twriter.writeInt(polyhedralSurface.numPolygons());", "\t\tfor (Polygon polygon : polyhedralSurface.getPolygons()) {", "\t\t\twriteGeometry(writer, polygon);"]}
{"writer": ["public static void writeTIN(ByteWriter writer, TIN tin) throws IOException {", "\t\twriter.writeInt(tin.numPolygons());", "\t\t\twriteGeometry(writer, polygon);"], "tin": ["public static void writeTIN(ByteWriter writer, TIN tin) throws IOException {", "\t\twriter.writeInt(tin.numPolygons());", "\t\tfor (Polygon polygon : tin.getPolygons()) {", "\t\t\twriteGeometry(writer, polygon);"]}
{"writer": ["public static void writeTriangle(ByteWriter writer, Triangle triangle)", "\t\twriter.writeInt(triangle.numRings());", "\t\t\twriteLineString(writer, ring);"], "triangle": ["public static void writeTriangle(ByteWriter writer, Triangle triangle)", "\t\twriter.writeInt(triangle.numRings());", "\t\tfor (LineString ring : triangle.getRings()) {", "\t\t\twriteLineString(writer, ring);"]}
{"geometry": ["public static int getCode(Geometry geometry) {", "\t\tint code = getCode(geometry.getGeometryType());", "\t\tif (geometry.hasZ()) {", "\t\tif (geometry.hasM()) {"]}
{"geometryType": ["public static int getCode(GeometryType geometryType) {", "\t\tswitch (geometryType) {", "\t\t\t\t\t\t\t+ geometryType);"]}
{"code": ["public static GeometryType getGeometryType(int code) {", "\t\tint geometryTypeCode = code % 1000;", "\t\t\t\t\t\"Unsupported Geometry code for type retrieval: \" + code);"]}
{"Result": "Method without Parameter"}
{"l": ["public static long gcd(List<Long> l) {", "        if (l.isEmpty()) {", "        BigInteger gcd = BigInteger.valueOf(l.get(0));", "        for (Long num : l.subList(1, l.size())) {", "            gcd = gcd.gcd(BigInteger.valueOf(num));", "        return gcd.longValue();"]}
{"str": ["    public static String abbreviate(String str, int max) {", "        if (str == null) {", "        } else if (str.length() <= max) {", "            return str;", "            return str.substring(0, max - 3) + \"...\";"], "max": ["    public static String abbreviate(String str, int max) {", "        } else if (str.length() <= max) {", "            return str.substring(0, max - 3) + \"...\";"]}
{"string": ["public static org.jmxtrans.agent.util.json.JsonValue value(String string) {", "    return string == null ? NULL : new JsonString(string);"]}
{"Result": "Method without Parameter"}
{"string": ["public static org.jmxtrans.agent.util.json.JsonValue parse(String string) {", "    if (string == null) {", "    new JsonParser(handler).parse(string);"]}
{"settings": ["public static String getString(Map<String, String> settings, String name, String defaultValue) {", "        if (settings.containsKey(name)) {", "            return settings.get(name);"], "name": ["public static String getString(Map<String, String> settings, String name, String defaultValue) {", "        if (settings.containsKey(name)) {", "            return settings.get(name);"], "defaultValue": ["public static String getString(Map<String, String> settings, String name, String defaultValue) {", "            return defaultValue;"]}
{"string": ["  public static JsonObject readFrom(String string) {", "    return org.jmxtrans.agent.util.json.JsonValue.readFrom(string).asObject();"]}
{"name": ["public org.jmxtrans.agent.util.json.JsonValue get(String name) {", "    if (name == null) {", "    int index = indexOf(name);", "    return index != -1 ? values.get(index) : null;"]}
{"Result": "Method without Parameter"}
{"property": ["protected String resolvePlaceholder(String property, String defaultValue) throws IllegalStateException {", "        String environmentVariableStyleProperty = property.toUpperCase();", "        if (externalProperties.containsKey(property)) {", "            result = externalProperties.get(property);", "        } else if (System.getProperties().containsKey(property)) {", "            result = System.getProperty(property);", "        } else if (System.getenv().containsKey(property)) {", "            result = System.getenv(property);", "            throw new IllegalStateException(\"Property '\" + property + \"' not found in System properties nor in Environment variables\");", "        return result;"], "defaultValue": ["protected String resolvePlaceholder(String property, String defaultValue) throws IllegalStateException {", "        } else if (defaultValue != null) {", "            result = defaultValue;", "        return result;"]}
{"Result": "Method without Parameter"}
{"string": ["  public static JsonArray readFrom(String string) {", "    return org.jmxtrans.agent.util.json.JsonValue.readFrom(string).asArray();"]}
{"value": ["public JsonArray add(org.jmxtrans.agent.util.json.JsonValue value) {", "    if (value == null) {", "    values.add(value);"]}
{"index": ["public JsonArray set(int index, org.jmxtrans.agent.util.json.JsonValue value) {", "    values.set(index, value);"], "value": ["public JsonArray set(int index, org.jmxtrans.agent.util.json.JsonValue value) {", "    if (value == null) {", "    values.set(index, value);"]}
{"index": ["public org.jmxtrans.agent.util.json.JsonValue get(int index) {", "    return values.get(index);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"event": ["private void processEvent(final Object event)", "\t    System.out.println(\"Processing event: \" + event.toString());", "\t    for (final EventHandler handler : getConsumersFor(event.getClass()))", "\t\t\t    \t\thandler.handle(event);", "\t\t\t    \t\t\tSystem.out.println(\"Event handler failed. Re-publishing event: \" + event.toString());", "\t\t\t    \t\t\teventQueue.publish(event);"]}
{"event": ["private void publishEvent(Object event)", "\t\t\teventBus.publish(event);"]}
{"name": ["private void publishEvent(String name, Object event)", "\t\tEventBus eventBus = getEventBus(name);", "\t\tif (eventBus == null)", "\t\t\tthrow new RuntimeException(\"Unknown event bus name: \" + name);", "\t\teventBus.publish(event);"], "event": ["private void publishEvent(String name, Object event)", "\t\teventBus.publish(event);"]}
{"child": ["public void removeChild(final String child) {", "        final String replaced = sb.replace(child, \"\");"]}
{"tag": ["private void addInWffIdMap(final AbstractHtml tag) {", "        initialSet.add(tag);"]}
{"key": ["protected boolean addToAttributeValueMap(final String key,", "            final String previousValue = attributeValueMap.put(key, value);"], "value": ["            final String value) {", "            final String previousValue = attributeValueMap.put(key, value);", "            if (!Objects.equals(previousValue, value)) {"]}
{"sharedObjects": ["            final Collection<AbstractHtml5SharedObject> sharedObjects) {", "        for (final AbstractHtml5SharedObject sharedObject : sharedObjects) {", "            final AttributeValueChangeListener valueChangeListener = sharedObject", "            if (valueChangeListener != null) {", "                valueChangeListener.valueChanged(event);"]}
{"map": ["protected boolean addAllToAttributeValueMap(final Map<String, String> map) {", "        if (map != null && map.size() > 0) {", "                getAttributeValueMap().putAll(map);"]}
{"Result": "Method without Parameter"}
{"sharedObjects": ["            final Collection<AbstractHtml5SharedObject> sharedObjects,", "            for (final AbstractHtml5SharedObject sharedObject : sharedObjects) {", "                final PushQueue pushQueue = sharedObject", "                if (pushQueue != null) {", "                    pushQueue.push();"], "listenerInvoked": ["            final boolean listenerInvoked) {", "        if (listenerInvoked) {"]}
{"key": ["protected boolean removeFromAttributeValueMap(final String key,", "            final boolean removed = getAttributeValueMap().remove(key, value);"], "value": ["            final String value) {", "            final boolean removed = getAttributeValueMap().remove(key, value);", "            if (removed) {"]}
{"value": ["protected boolean addToAttributeValueSet(final String value) {", "            final boolean added = getAttributeValueSet().add(value);", "            if (added) {"]}
{"values": ["protected void addAllToAttributeValueSet(final Collection<String> values) {", "        if (values != null) {", "                final boolean added = getAttributeValueSet().addAll(values);", "                if (added) {"]}
{"values": ["            final Collection<String> values) {", "            final boolean removedAll = getAttributeValueSet().removeAll(values);", "            if (removedAll) {"]}
{"Result": "Method without Parameter"}
{"valueChangeListener": ["            final AttributeValueChangeListener valueChangeListener) {", "        valueChangeListeners.add(valueChangeListener);"]}
{"Result": "Method without Parameter"}
{"r": ["public void setR(final int r) {", "        if (r < 0 || r > 255) {", "        this.r = r;", "        rgba = \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";"]}
{"g": ["public void setG(final int g) {", "        if (g < 0 || g > 255) {", "        this.g = g;", "        rgba = \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";"]}
{"b": ["public void setB(final int b) {", "        if (b < 0 || b > 255) {", "        this.b = b;", "        rgba = \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";"]}
{"a": ["public void setA(final float a) {", "        if (a < 0 || a > 1) {", "        this.a = a;", "        rgba = \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";"]}
{"Result": "Method without Parameter"}
{"inputString": ["public static String getFirstSubstring(final String inputString,", "        if (!inputString.contains(startingWith)", "                || !inputString.contains(endingWith)) {", "        final int startIndex = inputString.indexOf(startingWith);", "        if (!((startIndex + 1) < inputString.length())) {", "        final int endIndex = inputString.indexOf(endingWith, startIndex + 1)", "        return inputString.substring(startIndex, endIndex);"], "startingWith": ["            final String startingWith, final String endingWith) {", "        if (!inputString.contains(startingWith)", "        final int startIndex = inputString.indexOf(startingWith);", "        if (!((startIndex + 1) < inputString.length())) {", "        final int endIndex = inputString.indexOf(endingWith, startIndex + 1)", "        if (startIndex > endIndex || startIndex < 0 || endIndex < 0) {", "        return inputString.substring(startIndex, endIndex);"], "endingWith": ["            final String startingWith, final String endingWith) {", "                || !inputString.contains(endingWith)) {", "        final int endIndex = inputString.indexOf(endingWith, startIndex + 1)"]}
{"inputArray": ["public static String[] cloneArray(final String[] inputArray) {", "        final String[] array = new String[inputArray.length];", "        System.arraycopy(inputArray, 0, array, 0, inputArray.length);"]}
{"string": ["public static boolean containsWhitespace(final String string) {", "        for (int i = 0; i < string.length(); i++) {", "            if (Character.isWhitespace(string.charAt(i))) {"]}
{"s": ["public static String strip(final String s) {", "        for (first = 0; first < s.length(); first++) {", "            if (!Character.isWhitespace(s.charAt(first))) {", "        for (last = s.length(); last > first; last--) {", "            if (!Character.isWhitespace(s.charAt(last - 1))) {", "        return s.substring(first, last);"]}
{"Result": "Method without Parameter"}
{"updateClient": ["protected void addInnerHtmls(final boolean updateClient,", "            if (listener != null && updateClient) {"]}
{"children": ["public boolean removeChildren(final Collection<AbstractHtml> children) {", "            result = this.children.removeAll(children);", "        return result;"]}
{"child": ["public boolean removeChild(final AbstractHtml child) {", "            removed = children.remove(child);", "            if (removed) {", "                initNewSharedObjectInAllNestedTagsAndSetSuperParentNull(child);", "                            new ChildTagRemoveListener.Event(this, child));", "        return removed;"]}
{"children": ["public void appendChildren(final Collection<AbstractHtml> children) {", "                    children.size());", "            for (final AbstractHtml child : children) {", "                final AbstractHtml previousParent = child.parent;", "                addChild(child, false);", "                final ChildMovedEvent event = new ChildMovedEvent(", "                        previousParent, this, child);", "                movedOrAppended.add(event);"]}
{"Result": "Method without Parameter"}
{"attributeName": ["public AbstractAttribute getAttributeByName(final String attributeName) {", "                result = attributesMap.get(attributeName);", "        return result;"]}
{"attributes": ["private void markOwnerTag(final AbstractAttribute[] attributes) {", "        if (attributes == null) {", "        for (final AbstractAttribute abstractAttribute : attributes) {", "            abstractAttribute.setOwnerTag(this);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"childTag": ["public boolean containsChild(final AbstractHtml childTag) {", "            return children.contains(childTag);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"updateClient": ["    protected void setAttributeValue(final boolean updateClient,", "            super.replaceAllInAttributeValueSet(updateClient, allValues);"], "value": ["            final String value) {", "        if (value != null) {", "            final Collection<String> allValues = extractValues(value);", "            super.replaceAllInAttributeValueSet(updateClient, allValues);"]}
{"updateClient": ["protected void replaceAllInAttributeValueSet(final boolean updateClient,", "            super.replaceAllInAttributeValueSet(updateClient, allValues);"]}
{"sessionId": ["public final void addWebSocketPushListener(final String sessionId,", "        sessionIdWsListeners.put(sessionId, wsListener);"], "wsListener": ["            final WebSocketPushListener wsListener) {", "        sessionIdWsListeners.put(sessionId, wsListener);", "        wsListeners.push(wsListener);", "        this.wsListener = wsListener;"]}
{"sessionId": ["public final void removeWebSocketPushListener(final String sessionId) {", "        final WebSocketPushListener removed = sessionIdWsListeners", "                .remove(sessionId);", "        wsListeners.remove(removed);"]}
{"enable": ["public final void removeFromContext(final boolean enable, final On... ons) {", "                removeFromBrowserContextOnTabClose = enable;", "                removePrevFromBrowserContextOnTabInit = enable;"]}
{"Result": "Method without Parameter"}
{"value": ["protected final void setNonceForWffScript(final String value) {", "        if (value != null) {", "                nonceForWffScriptTag = new Nonce(value);", "                        wffScript.addAttributes(nonceForWffScriptTag);", "                nonceForWffScriptTag.setValue(value);"]}
{"borderStyle": ["public Border setBorderStyle(final BorderStyle borderStyle) {", "        if (borderStyle == BorderStyle.INITIAL", "                || borderStyle == BorderStyle.INHERIT) {", "                    + borderStyle.getCssValue());", "        if (borderStyle != null) {", "            cssValueBuilder.append(borderStyle.getCssValue()).append(' ');", "        this.borderStyle = borderStyle;"]}
{"uuid": ["public void setValue(final UUID uuid) {", "        if (uuid != null) {", "            super.setAttributeValue(uuid.toString());", "            this.uuid = uuid;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"cssProperty": ["public boolean contains(final CssProperty cssProperty) {", "            return cssProperties.contains(cssProperty);"]}
{"rebuild": ["Map<String, CssProperty> getCssPropertiesAsMap(final boolean rebuild) {", "        if (rebuild || !loadedOnce) {", "                if (rebuild || !loadedOnce) {"]}
{"attribute": ["            final AbstractAttribute attribute) throws NullValueException {", "        if (attribute == null) {", "        for (final AbstractHtml ownerTag : attribute.getOwnerTags()) {", "            if (browserPage.contains(ownerTag)) {", "                tags.add(ownerTag);"]}
{"attribute": ["            final AbstractAttribute attribute) {", "        if (attribute == null) {", "        for (final AbstractHtml ownerTag : attribute.getOwnerTags()) {", "            if (browserPage.contains(ownerTag)) {", "                return ownerTag;"]}
{"parallel": ["            final boolean parallel) {", "            return buildAllAttributesStream(parallel)"]}
{"parallel": ["            final boolean parallel) {", "                parallel).filter(tag -> tag.getAttributes() != null)"]}
{"parallel": ["            final boolean parallel, final AbstractHtml... fromTags)", "            return getAllNestedChildrenIncludingParent(parallel, fromTags)"]}
{"tag": ["public boolean exists(final AbstractHtml tag)", "        if (tag == null) {", "        if (NoTag.class.isAssignableFrom(tag.getClass())) {", "        return browserPage.contains(tag);"]}
{"attribute": ["public boolean exists(final AbstractAttribute attribute)", "        if (attribute == null) {", "        for (final AbstractHtml ownerTag : attribute.getOwnerTags()) {", "            if (browserPage.contains(ownerTag)) {"]}
{"parallel": ["            final boolean parallel, final AbstractHtml... fromTags) {", "                parallel, fromTags).filter(tag -> tag.getAttributes() != null)"]}
{"Result": "Method without Parameter"}
{"bytes": ["private void writeByChunk(final byte[] bytes) throws IOException {", "        if (bytes.length == 0) {", "        if (chunkSize < bytes.length && chunkSize > 0) {", "            int remaining = bytes.length;", "                    os.write(bytes, offset, chunkSize);", "                    os.write(bytes, offset, remaining);", "            os.write(bytes);"]}
{"contextPath": ["public EmbeddedTomcat setContextPath(String contextPath) {", "\t\tif (contextPath == null", "\t\t\t\t|| !contextPath.equals(\"\") && !contextPath.startsWith(\"/\")) {", "\t\tthis.contextPath = contextPath;"]}
{"contextFile": ["public EmbeddedTomcat setContextFile(String contextFile) {", "\t\t\tthis.contextFileURL = new File(contextFile).toURI().toURL();"]}
{"contextFile": ["\tpublic EmbeddedTomcat addContextEnvironmentAndResourceFromFile(String contextFile) {", "\t\t\tsetContextFile(new File(contextFile).toURI().toURL());"]}
{"filter": ["public static <T> Filter<T> filter(final Path.Filter filter, final Content.Type<T> contentType) {"], "contentType": ["public static <T> Filter<T> filter(final Path.Filter filter, final Content.Type<T> contentType) {", "\t\t\t\treturn ct == contentType && filter.matches(id);"]}
{"f1": ["public static <T> Filter<T> or(final Filter<T> f1, final Filter<T> f2) {", "\t\t\t\treturn f1.matches(id, ct) || f2.matches(id, ct);", "\t\t\t\treturn f1.matchesSubpath(id) || f2.matchesSubpath(id);", "\t\t\t\treturn f1.toString() + \"|\" + f2.toString();"], "f2": ["public static <T> Filter<T> or(final Filter<T> f1, final Filter<T> f2) {", "\t\t\t\treturn f1.matches(id, ct) || f2.matches(id, ct);", "\t\t\t\treturn f1.matchesSubpath(id) || f2.matchesSubpath(id);", "\t\t\t\treturn f1.toString() + \"|\" + f2.toString();"]}
{"Result": "Method without Parameter"}
{"token": ["private boolean isLineSpace(Token token) {", "\t\treturn token.kind == Token.Kind.Indent || token.kind == Token.Kind.LineComment;"]}
{"v": ["protected String parseString(String v) {", "\t\tv = v.substring(1, v.length() - 1);"]}
{"Result": "Method without Parameter"}
{"root": ["protected Command.Template parse(Command.Descriptor root, String[] args, int index) {", "\t\t\t\toptions.add(parseLongOption(root, args[index]));", "\t\t\t} else if (isCommand(arg, root.getCommands())) {", "\t\t\t\tCommand.Descriptor cmd = getCommandDescriptor(arg, root.getCommands());", "\t\t\t\tsub = parse(cmd, args, index + 1);", "\t\tCommand.Options optionMap = new OptionsMap(options, root.getOptionDescriptors());", "\t\treturn new ConcreteTemplate(root, optionMap, arguments, sub);"], "args": ["protected Command.Template parse(Command.Descriptor root, String[] args, int index) {", "\t\twhile (index < args.length) {", "\t\t\tString arg = args[index];", "\t\t\tif (isLongOption(arg)) {", "\t\t\t\toptions.add(parseLongOption(root, args[index]));", "\t\t\t} else if (isCommand(arg, root.getCommands())) {", "\t\t\t\tCommand.Descriptor cmd = getCommandDescriptor(arg, root.getCommands());", "\t\t\t\tsub = parse(cmd, args, index + 1);", "\t\t\t\targuments.add(arg);", "\t\treturn new ConcreteTemplate(root, optionMap, arguments, sub);"], "index": ["protected Command.Template parse(Command.Descriptor root, String[] args, int index) {", "\t\twhile (index < args.length) {", "\t\t\tString arg = args[index];", "\t\t\tif (isLongOption(arg)) {", "\t\t\t\toptions.add(parseLongOption(root, args[index]));", "\t\t\t} else if (isCommand(arg, root.getCommands())) {", "\t\t\t\tCommand.Descriptor cmd = getCommandDescriptor(arg, root.getCommands());", "\t\t\t\tsub = parse(cmd, args, index + 1);", "\t\t\t\targuments.add(arg);", "\t\t\tindex = index + 1;", "\t\treturn new ConcreteTemplate(root, optionMap, arguments, sub);"]}
{"str": ["private static Object parseData(String str) {", "\t\tif (str.equals(\"true\")) {", "\t\t} else if (str.equals(\"false\")) {", "\t\t} else if (Character.isDigit(str.charAt(0))) {", "\t\t\treturn Integer.parseInt(str);", "\t\t\treturn str;"]}
{"Result": "Method without Parameter"}
{"descriptors": ["private static int determineCommandNameWidth(List<Command.Descriptor> descriptors) {", "\t\tfor (Command.Descriptor d : descriptors) {", "\t\t\tmax = Math.max(max, d.getName().length());", "\t\treturn max;"]}
{"files": ["private ZipFile createZipFile(List<Path.Entry<?>> files) throws IOException {", "\t\tfor (int i = 0; i != files.size(); ++i) {", "\t\t\tPath.Entry<?> file = files.get(i);", "\t\t\taddPaths(file.id().parent(),paths,zf);", "\t\t\tString filename = file.id().toString() + \".\" + file.contentType().getSuffix();", "\t\t\tbyte[] contents = readFileContents(file);", "\t\t\tzf.add(new ZipEntry(filename), contents);"]}
{"file": ["private byte[] readFileContents(Path.Entry<?> file) throws IOException {", "\t\tInputStream in = file.inputStream();"]}
{"filter": ["private Content.Filter createFilter(String filter) {", "\t\tString[] split = filter.split(\"\\\\.\");", "\t\treturn Content.filter(split[0], contentType);"]}
{"i": ["\tpublic void write(int i) throws IOException {", "\t\t\toutput.write(i & 0xFF);", "\t\t\twrite_un(i & 0xFF,8);"]}
{"w": ["public void write_u32(int w) throws IOException {", "\t\twrite_u8((w >> 24) & 0xFF);", "\t\twrite_u8((w >> 16) & 0xFF);", "\t\twrite_u8((w >> 8) & 0xFF);", "\t\twrite_u8(w & 0xFF);"]}
{"bits": ["public void write_un(int bits, int n) throws IOException {", "\t\t\tboolean bit = (bits & mask) != 0;", "\t\t\twrite_bit(bit);"], "n": ["public void write_un(int bits, int n) throws IOException {", "\t\tfor(int i=0;i<n;++i) {"]}
{"output": ["public static void printSyntacticMarkers(PrintStream output, Collection<Path.Entry<?>> sources, Path.Entry<?> target) throws IOException {", "\t\t\tprintSyntacticMarkers(output, sources, items.get(i));"], "sources": ["public static void printSyntacticMarkers(PrintStream output, Collection<Path.Entry<?>> sources, Path.Entry<?> target) throws IOException {", "\t\t\tprintSyntacticMarkers(output, sources, items.get(i));"], "target": ["public static void printSyntacticMarkers(PrintStream output, Collection<Path.Entry<?>> sources, Path.Entry<?> target) throws IOException {", "\t\tList<SyntacticItem.Marker> items = extractSyntacticMarkers(target);", "\t\tfor (int i = 0; i != items.size(); ++i) {", "\t\t\tprintSyntacticMarkers(output, sources, items.get(i));"]}
{"output": ["private static void printSyntacticMarkers(PrintStream output, Collection<Path.Entry<?>> sources, SyntacticItem.Marker marker) {", "\t\t\toutput.println(source.location() + \":\" + line.lineNumber + \": \" + marker.getMessage());", "\t\t\tprintLineHighlight(output, line);", "\t\t\toutput.println(source.location() + \":?: \" + marker.getMessage());"], "sources": ["private static void printSyntacticMarkers(PrintStream output, Collection<Path.Entry<?>> sources, SyntacticItem.Marker marker) {", "\t\tPath.Entry<?> source = getSourceEntry(sources,marker.getSource());"], "marker": ["private static void printSyntacticMarkers(PrintStream output, Collection<Path.Entry<?>> sources, SyntacticItem.Marker marker) {", "\t\tPath.Entry<?> source = getSourceEntry(sources,marker.getSource());", "\t\tSpan span = marker.getTarget().getAncestor(AbstractCompilationUnit.Attribute.Span.class);", "\t\t\toutput.println(source.location() + \":\" + line.lineNumber + \": \" + marker.getMessage());", "\t\t\toutput.println(source.location() + \":?: \" + marker.getMessage());"]}
{"Result": "Method without Parameter"}
{"kind": ["\tpublic <T extends SyntacticItem> T getParent(Class<T> kind) {", "\t\treturn parent.getParent(this, kind);"]}
{"kind": ["\tpublic <T extends SyntacticItem> List<T> getParents(Class<T> kind) {", "\t\treturn parent.getParents(this, kind);"]}
{"kind": ["\tpublic <T extends SyntacticItem> T getAncestor(Class<T> kind) {", "\t\treturn parent.getAncestor(this, kind);"]}
{"lhs": ["public static int[] append(int lhs, int[] rhs) {", "\t\trs[0] = lhs;", "\t\tSystem.arraycopy(rhs, 0, rs, 1, rhs.length);", "\t\treturn rs;"], "rhs": ["public static int[] append(int lhs, int[] rhs) {", "\t\tint[] rs = new int[rhs.length+1];", "\t\tSystem.arraycopy(rhs, 0, rs, 1, rhs.length);"]}
{"first": ["public static int[] append(int first, int second, int[] rhs) {", "\t\trs[0] = first;", "\t\tSystem.arraycopy(rhs, 0, rs, 2, rhs.length);"], "second": ["public static int[] append(int first, int second, int[] rhs) {", "\t\trs[1] = second;", "\t\tSystem.arraycopy(rhs, 0, rs, 2, rhs.length);", "\t\treturn rs;"], "rhs": ["public static int[] append(int first, int second, int[] rhs) {", "\t\tint[] rs = new int[rhs.length+2];", "\t\tSystem.arraycopy(rhs, 0, rs, 2, rhs.length);"]}
{"lhs": ["public static int[] append(int[] lhs, int[] rhs) {", "\t\tint[] rs = java.util.Arrays.copyOf(lhs, lhs.length + rhs.length);", "\t\tSystem.arraycopy(rhs, 0, rs, lhs.length, rhs.length);"], "rhs": ["public static int[] append(int[] lhs, int[] rhs) {", "\t\tint[] rs = java.util.Arrays.copyOf(lhs, lhs.length + rhs.length);", "\t\tSystem.arraycopy(rhs, 0, rs, lhs.length, rhs.length);"]}
{"type": ["public static <T> T[] append(Class<T> type, T lhs, T... rhs) {", "\t\tT[] rs = (T[]) Array.newInstance(type, rhs.length+1);"], "lhs": ["public static <T> T[] append(Class<T> type, T lhs, T... rhs) {", "\t\trs[0] = lhs;", "\t\treturn rs;"]}
{"lhs": ["public static <T> void addAll(T[] lhs, Collection<T> rhs) {", "\t\tfor(int i=0;i!=lhs.length;++i) {", "\t\t\trhs.add(lhs[i]);"], "rhs": ["public static <T> void addAll(T[] lhs, Collection<T> rhs) {", "\t\t\trhs.add(lhs[i]);"]}
{"items": ["public static String[] toStringArray(Collection<String> items) {", "\t\tString[] result = new String[items.size()];", "\t\tfor(String s : items) {", "\t\t\tresult[i++] = s;", "\t\treturn result;"]}
{"items": ["public static int[] toIntArray(Collection<Integer> items) {", "\t\tint[] result = new int[items.size()];", "\t\tfor (Integer v : items) {", "\t\t\tresult[i++] = v;", "\t\treturn result;"]}
{"children": ["public static <T extends S, S extends Comparable<S>> T[] sortAndRemoveDuplicates(T[] children) {", "\t\tint r = isSortedAndUnique(children);", "\t\tswitch (r) {", "\t\t\treturn children;", "\t\t\treturn ArrayUtils.sortedRemoveDuplicates(children);", "\t\t\tchildren = Arrays.copyOf(children, children.length);"]}
{"children": ["public static <T extends Comparable<T>> int isSortedAndUnique(T[] children) {", "\t\tfor (int i = 1; i < children.length; ++i) {", "\t\t\tint c = children[i - 1].compareTo(children[i]);", "\t\t\tif (c == 0) {", "\t\t\t} else if (c > 0) {"]}
{"lhs": ["public static <S,T extends Comparable<S>> int compareTo(T[] lhs, T[] rhs) {", "\t\tif(lhs.length != rhs.length) {", "\t\t\treturn lhs.length - rhs.length;", "\t\t\tfor(int i=0;i!=lhs.length;++i) {", "\t\t\t\tint r = lhs[i].compareTo((S) rhs[i]);", "\t\t\t\tif(r != 0) {", "\t\t\t\t\treturn r;"], "rhs": ["public static <S,T extends Comparable<S>> int compareTo(T[] lhs, T[] rhs) {", "\t\tif(lhs.length != rhs.length) {", "\t\t\treturn lhs.length - rhs.length;", "\t\t\t\tint r = lhs[i].compareTo((S) rhs[i]);", "\t\t\t\tif(r != 0) {", "\t\t\t\t\treturn r;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"global": ["private void activateDefaultPlugins(Configuration global) {", "\t\tList<Path.ID> plugins = global.matchAll(Trie.fromString(\"plugins/*\"));", "\t\t\tUTF8 activator = global.get(UTF8.class, id);", "\t\t\t\tClass<?> c = Class.forName(activator.toString());", "\t\t\t\tModule.Activator instance = (Module.Activator) c.newInstance();", "\t\t\t\tinstance.start(context);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"name": ["private static Configuration readConfigFile(String name, String dir, Configuration.Schema... schemas) throws IOException {", "\t\tPath.Entry<ConfigFile> config = root.get(Trie.fromString(name), ConfigFile.ContentType);"], "dir": ["private static Configuration readConfigFile(String name, String dir, Configuration.Schema... schemas) throws IOException {", "\t\tDirectoryRoot root = new DirectoryRoot(dir, BOOT_REGISTRY);"]}
{"module": ["public <T extends Module> T getInstance(Class<T> module) {", "\t\treturn (T) instances.get(module);"]}
{"Result": "Method without Parameter"}
{"loader": ["private void activateModules(URLClassLoader loader) {", "\t\t\t\tClass c = loader.loadClass(module.getActivator());", "\t\t\t\tModule.Activator self = (Module.Activator) c.newInstance();", "\t\t\t\tModule instance = self.start(context);", "\t\t\t\tinstances.put(c, instance);"]}
{"output": ["public void outputSourceError(PrintStream output, boolean brief) {", "\t\t\toutput.println(\"syntax error: \" + getMessage());", "\t\t\toutput.println(\"syntax error: \" + getMessage());", "\t\t\tprintBriefError(output,entry,enclosing,getMessage());", "\t\t\tprintFullError(output,entry,enclosing,getMessage());"], "brief": ["public void outputSourceError(PrintStream output, boolean brief) {", "\t\t} else if(brief) {"]}
{"task": ["private boolean ready(Build.Task task) {", "\t\tPath.Entry<?> target = task.getTarget();", "\t\tfor(Path.Entry<?> s : task.getSources()) {", "\t\t\tif(s.lastModified() > target.lastModified()) {"]}
{"args": ["public static Map<String,Object> parseOptions(List<String> args, OptArg... options) {\r", "\t\tIterator<String> iter = args.iterator();\r"]}
{"str": ["private static Map<String, Object> splitConfig(String str) {\r", "\t\tString[] splits = str.split(\",\");\r"]}
{"child": ["\tpublic <T extends SyntacticItem> T getParent(SyntacticItem child, Class<T> kind) {", "\t\t\t\t\tif(parent.get(j) == child) {"], "kind": ["\tpublic <T extends SyntacticItem> T getParent(SyntacticItem child, Class<T> kind) {", "\t\t\tif(kind.isInstance(parent)) {"]}
{"child": ["\tpublic <T extends SyntacticItem> T getAncestor(SyntacticItem child, Class<T> kind) {", "\t\tif (kind.isInstance(child)) {", "\t\t\treturn (T) child;", "\t\t\t\t\tif (parent.get(j) == child && !(parent instanceof AbstractCompilationUnit.Ref)) {"], "kind": ["\tpublic <T extends SyntacticItem> T getAncestor(SyntacticItem child, Class<T> kind) {", "\t\tif (kind.isInstance(child)) {", "\t\t\t\t\t\tT tmp = getAncestor(parent, kind);", "\t\t\t\t\t\tif (tmp != null) {", "\t\t\t\t\t\t\treturn tmp;"]}
{"item": ["private static SyntacticItem substitute(SyntacticItem item, SyntacticItem from, SyntacticItem to,", "\t\tSyntacticItem sItem = mapping.get(item);", "\t\tif (sItem != null) {", "\t\t\treturn sItem;", "\t\t} else if (item == from) {", "\t\t\tSyntacticItem nItem = item;", "\t\t\tSyntacticItem[] children = item.getAll();", "\t\t\t\t\tnItem = item.clone(nChildren);", "\t\t\tmapping.put(item, nItem);", "\t\t\treturn nItem;"], "from": ["private static SyntacticItem substitute(SyntacticItem item, SyntacticItem from, SyntacticItem to,", "\t\t} else if (item == from) {", "\t\t\t\tfor (int i = 0; i != children.length; ++i) {", "\t\t\t\t\t\tSyntacticItem nChild = substitute(child, from, to, mapping);", "\t\t\t\t\t\tif (nChild != child && children == nChildren) {", "\t\t\t\t\t\tnChildren[i] = nChild;", "\t\t\t\tif (children != nChildren) {", "\t\t\t\t\tnItem = item.clone(nChildren);", "\t\t\tmapping.put(item, nItem);", "\t\t\treturn nItem;"], "to": ["private static SyntacticItem substitute(SyntacticItem item, SyntacticItem from, SyntacticItem to,", "\t\t\treturn to;", "\t\t\t\tfor (int i = 0; i != children.length; ++i) {", "\t\t\t\t\t\tSyntacticItem nChild = substitute(child, from, to, mapping);", "\t\t\t\t\t\tif (nChild != child && children == nChildren) {", "\t\t\t\t\t\tnChildren[i] = nChild;", "\t\t\t\tif (children != nChildren) {", "\t\t\t\t\tnItem = item.clone(nChildren);", "\t\t\tmapping.put(item, nItem);", "\t\t\treturn nItem;"], "mapping": ["\t\t\tMap<SyntacticItem, SyntacticItem> mapping) {", "\t\tSyntacticItem sItem = mapping.get(item);", "\t\t\t\tfor (int i = 0; i != children.length; ++i) {", "\t\t\t\t\t\tSyntacticItem nChild = substitute(child, from, to, mapping);", "\t\t\t\t\t\tif (nChild != child && children == nChildren) {", "\t\t\t\t\t\tnChildren[i] = nChild;", "\t\t\t\tif (children != nChildren) {", "\t\t\t\t\tnItem = item.clone(nChildren);", "\t\t\tmapping.put(item, nItem);", "\t\t\treturn nItem;"]}
{"file": ["private Content.Type<?> getContentType(String file) {", "\t\t\tif (file.endsWith(suffix)) {"]}
{"file": ["public Path.Entry<?> getEntry(String file, Content.Type<?> ct) throws IOException {", "\t\tfile = file.replace(\".\" + ct.getSuffix(), \"\");"], "ct": ["public Path.Entry<?> getEntry(String file, Content.Type<?> ct) throws IOException {", "\t\tfile = file.replace(\".\" + ct.getSuffix(), \"\");", "\t\treturn project.getParent().getLocalRoot().get(id, ct);"]}
{"entry": ["private void inspect(Path.Entry<?> entry, Content.Type<?> ct, boolean garbage) throws IOException {", "\t\tObject o = entry.read();", "\t\t\tinspectBinaryFile(readAllBytes(entry.inputStream()));"], "ct": [], "garbage": ["private void inspect(Path.Entry<?> entry, Content.Type<?> ct, boolean garbage) throws IOException {", "\t\t\tnew SyntacticHeapPrinter(new PrintWriter(out), garbage).print((SyntacticHeap) o);"]}
{"bytes": ["private void inspectBinaryFile(byte[] bytes) {", "\t\tfor (int i = 0; i < bytes.length; i += width) {", "\t\t\t\tif(j+i < bytes.length) {", "\t\t\t\t\tout.print(String.format(\"%02X \", bytes[i+j]));", "\t\t\t\tif(j+i < bytes.length) {", "\t\t\t\t\tchar c = (char) bytes[i+j];", "\t\t\t\t\tif(c >= 32 && c < 128) {", "\t\t\t\t\t\tout.print(c);"]}
{"Result": "Method without Parameter"}
{"id": ["public static Trie fromString(Path.ID id) {", "\t\tif(id instanceof Trie) {", "\t\t\treturn ((Trie)id);", "\t\tfor(int i=0;i!=id.size();++i) {", "\t\t\tr = r.append(id.get(i));", "\t\treturn r;"]}
{"descriptors": ["public static Command.Descriptor DESCRIPTOR(List<Command.Descriptor> descriptors) {", "\t\t\t\treturn descriptors;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"msg": ["private void syntaxError(String msg, int index) {", "\t\tthrow new SyntacticException(msg, entry, new ConfigFile.Attribute.Span(null,index,index));"], "index": ["private void syntaxError(String msg, int index) {", "\t\tthrow new SyntacticException(msg, entry, new ConfigFile.Attribute.Span(null,index,index));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"ic": ["      InstructionContext ic,", "    stack_types.set(ic.getInstruction().getPosition(), inFrame);", "    return ic.execute(inFrame, executionPredecessors, icv, ev);"], "inFrame": ["      Frame inFrame,", "    stack_types.set(ic.getInstruction().getPosition(), inFrame);", "    return ic.execute(inFrame, executionPredecessors, icv, ev);"], "executionPredecessors": ["      ArrayList<InstructionContext> executionPredecessors,", "    return ic.execute(inFrame, executionPredecessors, icv, ev);"], "icv": ["      InstConstraintVisitor icv,", "    return ic.execute(inFrame, executionPredecessors, icv, ev);"], "ev": ["      ExecutionVisitor ev) {", "    return ic.execute(inFrame, executionPredecessors, icv, ev);"]}
{"arr": ["protected String[] add_string(String[] arr, String new_string) {", "    String[] new_arr = new String[arr.length + 1];", "    for (int ii = 0; ii < arr.length; ii++) {", "      new_arr[ii] = arr[ii];"], "new_string": ["protected String[] add_string(String[] arr, String new_string) {", "    new_arr[arr.length] = new_string;", "    return new_arr;"]}
{"a": ["  protected final String get_attribute_name(Attribute a) {", "    int con_index = a.getNameIndex();"]}
{"mgen": ["  protected final @Nullable Attribute get_stack_map_table_attribute(MethodGen mgen) {", "    for (Attribute a : mgen.getCodeAttributes()) {", "      if (is_stack_map_table(a)) {", "        return a;"]}
{"mgen": ["  protected final @Nullable Attribute get_local_variable_type_table_attribute(MethodGen mgen) {", "    for (Attribute a : mgen.getCodeAttributes()) {", "      if (is_local_variable_type_table(a)) {", "        return a;"]}
{"offset": ["protected final StackMapEntry find_stack_map_equal(int offset) {", "      if (running_offset > offset) {", "      if (running_offset == offset) {"]}
{"offset": ["protected final int find_stack_map_index_before(int offset) {", "      if (running_offset >= offset) {"]}
{"offset": ["protected final @IndexOrLow(\"stack_map_table\") int find_stack_map_index_after(int offset) {", "      if (running_offset > offset) {"]}
{"il": ["protected final void build_unitialized_NEW_map(InstructionList il) {", "    il.setPositions();", "              uninitialized_NEW_map.put(il.findHandle(i), i);", "              uninitialized_NEW_map.put(il.findHandle(i), i);"]}
{"old_offset": ["private final void update_NEW_object_stack_map_entries(int old_offset, int new_offset) {", "              if (old_offset == smt.getIndex()) {", "              if (old_offset == smt.getIndex()) {"], "new_offset": ["private final void update_NEW_object_stack_map_entries(int old_offset, int new_offset) {", "                smt.setIndex(new_offset);", "                smt.setIndex(new_offset);"]}
{"il": ["protected final void update_uninitialized_NEW_offsets(InstructionList il) {", "    il.setPositions();"]}
{"mgen": ["  protected final void set_current_stack_map_table(MethodGen mgen, int java_class_version) {", "    smta = (StackMap) get_stack_map_table_attribute(mgen);", "    if (smta != null) {", "      stack_map_table = ((StackMap) (smta.copy(smta.getConstantPool()))).getStackMap();", "          smta.getTag(), smta.getLength(), smta.getNameIndex());", "      mgen.removeCodeAttribute(smta);"], "java_class_version": ["  protected final void set_current_stack_map_table(MethodGen mgen, int java_class_version) {", "      if (java_class_version > Const.MAJOR_1_6) {"]}
{"prefix": ["protected final void print_stack_map_table(String prefix) {", "    debug_instrument.log(\"%nStackMap(%s) %s items:%n\", prefix, stack_map_table.length);"]}
{"mgen": ["protected final void create_new_stack_map_attribute(MethodGen mgen) throws IOException {", "    mgen.addCodeAttribute(map_table);"]}
{"t": ["  protected static @ClassGetName String typeToClassGetName(Type t) {", "    if (t instanceof ObjectType) {", "      return ((ObjectType) t).getClassName();", "    } else if (t instanceof BasicType) {", "      return t.toString();", "      return t.getSignature().replace('/', '.');"]}
{"t": ["protected final StackMapType generate_StackMapType_from_Type(Type t) {", "    switch (t.getType()) {", "            Const.ITEM_Object, pool.addClass(typeToClassGetName(t)), pool.getConstantPool());", "        throw new RuntimeException(\"Invalid type: \" + t + t.getType());"]}
{"smt": ["protected final Type generate_Type_from_StackMapType(StackMapType smt) {", "    switch (smt.getType()) {", "        assert false : \"Invalid StackMapType: \" + smt + smt.getType();", "        throw new RuntimeException(\"Invalid StackMapType: \" + smt + smt.getType());"]}
{"mgen": ["      MethodGen mgen, String local_name, Type local_type) {", "    LocalVariableGen[] locals = mgen.getLocalVariables();", "      if (new_offset < mgen.getMaxLocals()) {", "        mgen.setMaxLocals(mgen.getMaxLocals() + local_type.getSize());", "      lv_new = mgen.addLocalVariable(local_name, local_type, new_offset, null, null);", "      lv_new = mgen.addLocalVariable(local_name, local_type, new_offset, null, null);", "      mgen.setMaxLocals(mgen.getMaxLocals() + local_type.getSize());", "    adjust_code_for_locals_change(mgen, new_offset, local_type.getSize());", "    debug_instrument.log(\"New LocalVariableTable:%n%s%n\", mgen.getLocalVariableTable(pool));"], "local_name": ["      MethodGen mgen, String local_name, Type local_type) {", "      lv_new = mgen.addLocalVariable(local_name, local_type, new_offset, null, null);", "      lv_new = mgen.addLocalVariable(local_name, local_type, new_offset, null, null);"], "local_type": ["      MethodGen mgen, String local_name, Type local_type) {", "        mgen.setMaxLocals(mgen.getMaxLocals() + local_type.getSize());", "      lv_new = mgen.addLocalVariable(local_name, local_type, new_offset, null, null);", "      lv_new = mgen.addLocalVariable(local_name, local_type, new_offset, null, null);", "        lv.setIndex(lv.getIndex() + local_type.getSize());", "      mgen.setMaxLocals(mgen.getMaxLocals() + local_type.getSize());", "    adjust_code_for_locals_change(mgen, new_offset, local_type.getSize());", "    update_full_frame_stack_map_entries(new_offset, local_type, locals);"]}
{"mg": ["protected final StackTypes bcel_calc_stack_types(MethodGen mg) {", "      vr = stackver.do_stack_ver(mg);", "      System.out.printf(\"Warning: StackVer exception for %s.%s%n\", mg.getClassName(), mg.getName());", "    if (vr != VerificationResult.VR_OK) {", "          \"Warning: StackVer failed for %s.%s: %s%n\", mg.getClassName(), mg.getName(), vr);", "    assert vr == VerificationResult.VR_OK : \" vr failed \" + vr;"]}
{"m": ["static String accessFlagsToString(Method m) {", "    int flags = m.getAccessFlags();"]}
{"il": ["public static String instructionListToString(InstructionList il, ConstantPoolGen pool) {", "    for (Iterator<InstructionHandle> i = il.iterator(); i.hasNext(); ) {", "      InstructionHandle handle = i.next();", "      out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");"], "pool": ["public static String instructionListToString(InstructionList il, ConstantPoolGen pool) {", "      out.append(handle.getInstruction().toString(pool.getConstantPool()) + \"\\n\");"]}
{"a": ["public static String attributeNameToString(Attribute a) {", "    ConstantPool pool = a.getConstantPool();", "    int conIndex = a.getNameIndex();"]}
{"mgen": ["public static void checkMgen(MethodGen mgen) {", "      mgen.toString(); // ensure it can be formatted without exceptions", "      mgen.getLineNumberTable(mgen.getConstantPool());", "      InstructionList ilist = mgen.getInstructionList();", "      CodeExceptionGen[] exceptionHandlers = mgen.getExceptionHandlers();", "                + mgen.getClassName()", "                + mgen.getName();", "      MethodGen nmg = new MethodGen(mgen.getMethod(), mgen.getClassName(), mgen.getConstantPool());", "      nmg.getLineNumberTable(mgen.getConstantPool());", "                  \"failure while checking method %s.%s%n\", mgen.getClassName(), mgen.getName()),"]}
{"gen": ["public static void checkMgens(final ClassGen gen) {", "    Method[] methods = gen.getMethods();", "      checkMgen(new MethodGen(method, gen.getClassName(), gen.getConstantPool()));", "      dumpMethods(gen);"]}
{"Result": "Method without Parameter"}
{"gen": ["static void dumpMethods(ClassGen gen) {", "    System.out.printf(\"Class %s methods:%n\", gen.getClassName());", "    for (Method m : gen.getMethods()) {", "      System.out.printf(\"  %s%n\", m);"]}
{"mg": ["public static void addToStart(MethodGen mg, InstructionList newList) {", "    InstructionList il = mg.getInstructionList();", "    mg.setMaxStack();", "    mg.setMaxLocals();"], "newList": ["public static void addToStart(MethodGen mg, InstructionList newList) {", "    InstructionHandle newStart = il.insert(newList);", "          it.updateTarget(oldStart, newStart);"]}
{"pool": ["public static String getConstantString(ConstantPool pool, int index) {", "    Constant c = pool.getConstant(index);", "      return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";"], "index": ["public static String getConstantString(ConstantPool pool, int index) {", "    Constant c = pool.getConstant(index);", "    assert c != null : \"Bad index \" + index + \" into pool\";", "    if (c instanceof ConstantUtf8) {", "      return ((ConstantUtf8) c).getBytes();", "    } else if (c instanceof ConstantClass) {", "      ConstantClass cc = (ConstantClass) c;", "      return cc.getBytes(pool) + \" [\" + cc.getNameIndex() + \"]\";", "      throw new Error(\"unexpected constant \" + c + \" of class \" + c.getClass());"]}
{"mg": ["public static void resetLocalsToFormals(MethodGen mg) {", "    Type @SameLen({\"argTypes\", \"mg.getArgumentTypes()\"}) [] argTypes = mg.getArgumentTypes();", "        argNames = mg.getArgumentNames();", "    mg.setMaxLocals(0);", "    mg.removeLocalVariables();", "    if (!mg.isStatic()) {", "      mg.addLocalVariable(\"this\", new ObjectType(mg.getClassName()), null, null);", "      mg.addLocalVariable(argNames[ii], argTypes[ii], null, null);", "    mg.setMaxLocals();"]}
{"type": ["public static Class<?> typeToClass(Type type) {", "    String classname = typeToClassgetname(type);", "      return ReflectionPlume.classForName(classname);", "      throw new RuntimeException(\"can't find class for \" + classname, e);"]}
{"types": ["public static Type[] postpendToArray(Type[] types, Type newType) {", "    if (types.length == Integer.MAX_VALUE) {", "      throw new Error(\"array \" + types + \" is too large to extend\");", "    Type[] newTypes = new Type[types.length + 1];", "    System.arraycopy(types, 0, newTypes, 0, types.length);"], "newType": ["public static Type[] postpendToArray(Type[] types, Type newType) {", "    newTypes[types.length] = newType;", "    return newTypes;"]}
{"offset": [], "f": ["public void set(@IndexFor({\"loc_arr\", \"os_arr\"}) int offset, Frame f) {", "    OperandStack os = f.getStack();", "    loc_arr[offset] = (LocalVariables) (f.getLocals().clone());"]}
{"mg": ["protected final void insert_at_method_start(MethodGen mg, InstructionList new_il) {", "    InstructionList il = mg.getInstructionList();", "    insert_before_handle(mg, il.getStart(), new_il, false);"], "new_il": ["protected final void insert_at_method_start(MethodGen mg, InstructionList new_il) {", "    insert_before_handle(mg, il.getStart(), new_il, false);"]}
{"start": ["private void print_il(InstructionHandle start, String label) {", "      InstructionHandle tih = start;", "      while (tih != null) {", "        debug_instrument.log(\"inst: %s %n\", tih);", "        if (tih.hasTargeters()) {", "          for (InstructionTargeter it : tih.getTargeters()) {", "            debug_instrument.log(\"targeter: %s %n\", it);", "        tih = tih.getNext();"], "label": ["private void print_il(InstructionHandle start, String label) {", "      print_stack_map_table(label);"]}
{"Result": "Method without Parameter"}
{"stack": ["protected final StackMapType[] calculate_live_stack_types(OperandStack stack) {", "    int ss = stack.size();", "    for (int ii = 0; ii < ss; ii++) {", "      stack_map_types[ii] = generate_StackMapType_from_Type(stack.peek(ss - ii - 1));", "    return stack_map_types;"]}
{"skipBlocks": ["private static final int find(boolean skipBlocks, String s, char toFind, int from) {", "\t\t\t} else if (skipBlocks && (c == '{')) {", "\t\t\t} else if (skipBlocks && (c == '}')) {"], "s": ["private static final int find(boolean skipBlocks, String s, char toFind, int from) {", "\t\tfor (int i = from; i < s.length(); i++) {", "\t\t\tchar c = s.charAt(i);", "\t\t\tif (c == '\\\\') {", "\t\t\tif ((open == 0) && (c == toFind)) {", "\t\t\t} else if (skipBlocks && (c == '{')) {", "\t\t\t} else if (skipBlocks && (c == '}')) {"], "toFind": ["private static final int find(boolean skipBlocks, String s, char toFind, int from) {", "\t\t\tif ((open == 0) && (c == toFind)) {"], "from": ["private static final int find(boolean skipBlocks, String s, char toFind, int from) {", "\t\tfor (int i = from; i < s.length(); i++) {"]}
{"output": [], "offset": ["    public int read(final byte[] output, final int offset, final int length) throws TTransportException {", "        int index = offset;", "        int space = length - offset;", "        while (space > 0) {"], "length": ["    public int read(final byte[] output, final int offset, final int length) throws TTransportException {", "        int space = length - offset;"]}
{"Result": "Method without Parameter"}
{"url": ["public WebSocketClient newClient(final URI url, final WebSocketCallback callback) {", "        String protocol = url.getScheme();", "        final WebSocketClientHandler clientHandler = new WebSocketClientHandler(bootstrap, url, callback);"], "callback": ["public WebSocketClient newClient(final URI url, final WebSocketCallback callback) {", "        final WebSocketClientHandler clientHandler = new WebSocketClientHandler(bootstrap, url, callback);", "                pipeline.addLast(\"ws-handler\", clientHandler);", "        return clientHandler;"]}
{"adNative": ["private boolean canUseThisAd(NativeAd adNative) {", "        if (adNative != null) {", "            if (adNative instanceof NativeContentAd) {", "                NativeContentAd ad = (NativeContentAd) adNative;", "                logoImage = ad.getLogo();", "                header = ad.getHeadline();", "                body = ad.getBody();", "            } else if (adNative instanceof NativeAppInstallAd) {", "                NativeAppInstallAd ad = (NativeAppInstallAd) adNative;", "                logoImage = ad.getIcon();", "                header = ad.getHeadline();", "                body = ad.getBody();"]}
{"adPos": ["public synchronized AdView getAdForIndex(int adPos) {", "        if(adPos >= 0 && mPrefetchedAds.size() > adPos)", "            return mPrefetchedAds.get(adPos);"]}
{"adView": ["private synchronized void onFailedToLoad(AdView adView, int errorCode) {", "        mPrefetchedAds.remove(adView);", "        onAdFailed(mNoOfFetchedAds - 1, errorCode, adView);"], "errorCode": ["private synchronized void onFailedToLoad(AdView adView, int errorCode) {", "        Log.i(TAG, \"onAdFailedToLoad \" + errorCode);", "        onAdFailed(mNoOfFetchedAds - 1, errorCode, adView);"]}
{"Result": "Method without Parameter"}
{"fetchedAdsCount": ["public int getAdsCountToPublish(int fetchedAdsCount, int sourceItemsCount){", "        if(fetchedAdsCount <= 0 || getNoOfDataBetweenAds() <= 0) return 0;", "        expected = Math.min(fetchedAdsCount, expected);"], "sourceItemsCount": ["public int getAdsCountToPublish(int fetchedAdsCount, int sourceItemsCount){", "        if(sourceItemsCount > 0 && sourceItemsCount >= getOffsetValue()+1)", "            expected = (sourceItemsCount - getOffsetValue()) / getNoOfDataBetweenAds() + 1;"]}
{"position": ["public int getOriginalContentPosition(int position, int fetchedAdsCount, int sourceItemsCount) {", "        int adSpacesCount = (getAdIndex(position) + 1);", "        int originalPosition = position - Math.min(adSpacesCount, noOfAds);"], "fetchedAdsCount": ["public int getOriginalContentPosition(int position, int fetchedAdsCount, int sourceItemsCount) {", "        int noOfAds = getAdsCountToPublish(fetchedAdsCount, sourceItemsCount);"], "sourceItemsCount": ["public int getOriginalContentPosition(int position, int fetchedAdsCount, int sourceItemsCount) {", "        int noOfAds = getAdsCountToPublish(fetchedAdsCount, sourceItemsCount);", "        int originalPosition = position - Math.min(adSpacesCount, noOfAds);", "        return originalPosition;"]}
{"position": ["public int getAdIndex(int position) {", "        if(position >= getOffsetValue())", "            index = (position - getOffsetValue()) / (getNoOfDataBetweenAds()+1);"]}
{"position": ["public boolean isAdAvailable(int position, int fetchedAdsCount) {", "        int adIndex = getAdIndex(position);", "        return position >= firstAdPos && adIndex >= 0 && adIndex < getLimitOfAds() && adIndex < fetchedAdsCount;"], "fetchedAdsCount": ["public boolean isAdAvailable(int position, int fetchedAdsCount) {", "        if(fetchedAdsCount == 0) return false;", "        return position >= firstAdPos && adIndex >= 0 && adIndex < getLimitOfAds() && adIndex < fetchedAdsCount;"]}
{"position": ["public boolean hasToFetchAd(int position, int fetchingAdsCount){", "        int adIndex = getAdIndex(position);", "        return  position >= firstAdPos && adIndex >= 0 && adIndex < getLimitOfAds() && adIndex >= fetchingAdsCount;"], "fetchingAdsCount": ["public boolean hasToFetchAd(int position, int fetchingAdsCount){", "        return  position >= firstAdPos && adIndex >= 0 && adIndex < getLimitOfAds() && adIndex >= fetchingAdsCount;"]}
{"type": ["public static TypeMirror getWildcardType(String type, String elementType, Elements elements,", "    TypeElement arrayList = elements.getTypeElement(type);", "    return types.getDeclaredType(arrayList, types.getWildcardType(elType, null));"], "elementType": ["public static TypeMirror getWildcardType(String type, String elementType, Elements elements,", "    TypeMirror elType = elements.getTypeElement(elementType).asType();"], "elements": ["public static TypeMirror getWildcardType(String type, String elementType, Elements elements,", "    TypeElement arrayList = elements.getTypeElement(type);", "    TypeMirror elType = elements.getTypeElement(elementType).asType();"], "types": ["                                           Types types) {", "    return types.getDeclaredType(arrayList, types.getWildcardType(elType, null));"]}
{"element": ["public static TypeMirror hasGenericsTypeArgumentOf(Element element, String typeToCheck,", "    if (element.asType().getKind() != TypeKind.DECLARED", "        || !(element.asType() instanceof DeclaredType)) {", "      ProcessorMessage.error(element, \"The field %s in %s doesn't have generic type arguments!\",", "          element.getSimpleName(), element.asType().toString());", "    DeclaredType declaredType = (DeclaredType) element.asType();", "      ProcessorMessage.error(element, \"The field %s in %s doesn't have generic type arguments!\",", "          element.getSimpleName(), element.asType().toString());", "      ProcessorMessage.error(element, \"The field %s in %s has more than 1 generic type argument!\",", "          element.getSimpleName(), element.asType().toString());", "        ProcessorMessage.error(element,", "            element.getSimpleName(), typeToCheck, element.asType().toString());"], "typeToCheck": ["public static TypeMirror hasGenericsTypeArgumentOf(Element element, String typeToCheck,", "    if (typeToCheck != null) {", "      if (!isOfType(argument, typeToCheck, elements, types)) {", "            element.getSimpleName(), typeToCheck, element.asType().toString());"], "elements": ["                                                     Elements elements, Types types) {", "      if (!isOfType(argument, typeToCheck, elements, types)) {"], "types": ["                                                     Elements elements, Types types) {", "      if (!isOfType(argument, typeToCheck, elements, types)) {"]}
{"packageName": ["public JavaWriter emitPackage(String packageName) throws IOException {", "    if (packageName.isEmpty()) {", "      out.write(packageName);", "      this.packagePrefix = packageName + \".\";"]}
{"type": ["public String compressType(String type) {", "    Matcher m = TYPE_PATTERN.matcher(type);", "      boolean found = m.find(pos);", "      int typeStart = found ? m.start() : type.length();", "      sb.append(type, pos, typeStart);", "      if (!found) {", "      String name = m.group(0);", "      String imported = importedTypes.get(name);", "      if (imported != null) {", "        sb.append(imported);", "      } else if (isClassInPackage(name, packagePrefix)) {", "        String compressed = name.substring(packagePrefix.length());", "        if (isAmbiguous(compressed)) {", "          sb.append(name);", "          sb.append(compressed);", "      } else if (isClassInPackage(name, \"java.lang.\")) {", "        sb.append(name.substring(\"java.lang.\".length()));", "        sb.append(name);", "      pos = m.end();"]}
{"isStatic": ["public JavaWriter beginInitializer(boolean isStatic) throws IOException {", "    if (isStatic) {"]}
{"Result": "Method without Parameter"}
{"comment": ["public JavaWriter emitSingleLineComment(String comment, Object... args) throws IOException {", "    out.write(String.format(comment, args));"]}
{"value": ["private JavaWriter emitAnnotationValue(Object value) throws IOException {", "    if (value instanceof Object[]) {", "      for (Object o : ((Object[]) value)) {", "        out.write(o.toString());", "      out.write(value.toString());"]}
{"Result": "Method without Parameter"}
{"raw": ["public static String type(Class<?> raw, String... parameters) {", "      return raw.getCanonicalName();", "    if (raw.getTypeParameters().length != parameters.length) {", "    result.append(raw.getCanonicalName());"]}
{"modifiers": ["private void emitModifiers(Set<Modifier> modifiers) throws IOException {", "    if (modifiers.isEmpty()) {", "    if (!(modifiers instanceof EnumSet)) {", "      modifiers = EnumSet.copyOf(modifiers);", "    for (Modifier modifier : modifiers) {", "      out.append(modifier.toString()).append(' ');"]}
{"e": ["private PsiClass getPsiClassFromContext(AnActionEvent e) {", "    PsiFile psiFile = e.getData(LangDataKeys.PSI_FILE);", "    Editor editor = e.getData(PlatformDataKeys.EDITOR);"]}
{"methodName": ["private void findAndRemoveMethod(String methodName, String... arguments) {", "    PsiMethod[] methods = psiClass.findMethodsByName(methodName, false);", "    for (PsiMethod method : methods) {", "      PsiParameterList parameterList = method.getParameterList();", "      if (parameterList.getParametersCount() == arguments.length) {", "        PsiParameter[] parameters = parameterList.getParameters();", "          if (!parameters[i].getType().getCanonicalText().equals(arguments[i])) {", "          method.delete();"]}
{"Result": "Method without Parameter"}
{"elementFactory": ["private void makeClassImplementParcelable(PsiElementFactory elementFactory, JavaCodeStyleManager styleManager) {", "        elementFactory.createReferenceFromText(implementsType, psiClass);"], "styleManager": ["private void makeClassImplementParcelable(PsiElementFactory elementFactory, JavaCodeStyleManager styleManager) {", "      styleManager.shortenClassReferences(implementsList.add(implementsReference));"]}
{"element": ["private boolean isClass(Element element) {", "    if (element.getKind() == ElementKind.CLASS) {", "      if (element.getModifiers().contains(Modifier.ABSTRACT)) {", "        ProcessorMessage.error(element,", "                + \"that implements all abstract methods with @%s\", element.getSimpleName(),", "      if (element.getModifiers().contains(Modifier.PRIVATE)) {", "        ProcessorMessage.error(element, \"The private class %s is annotated with @%s. \"", "            element.getSimpleName(), ParcelablePlease.class.getSimpleName());", "      ProcessorMessage.error(element,", "          element.getSimpleName(), ParcelablePlease.class.getSimpleName());"]}
{"type": ["public static boolean isTypeOf(TypeMirror type, Class<?> clazz) {", "    return type.toString().equals(clazz.getCanonicalName());"], "clazz": ["public static boolean isTypeOf(TypeMirror type, Class<?> clazz) {", "    return type.toString().equals(clazz.getCanonicalName());"]}
{"type": ["public static Class<?> isTypeOf(TypeMirror type, List<Class<?>> classList) {", "      if (isTypeOf(type, c)) {"], "classList": ["public static Class<?> isTypeOf(TypeMirror type, List<Class<?>> classList) {", "    for (Class<?> c : classList) {", "      if (isTypeOf(type, c)) {", "        return c;"]}
{"elementUtils": ["public static String getPackageName(Elements elementUtils, TypeElement type) throws IOException {", "    PackageElement pkg = elementUtils.getPackageOf(type);"], "type": ["public static String getPackageName(Elements elementUtils, TypeElement type) throws IOException {", "    PackageElement pkg = elementUtils.getPackageOf(type);", "    if (!pkg.isUnnamed()) {", "      return pkg.getQualifiedName().toString();"]}
{"elementUtils": ["public static String getBinaryName(Elements elementUtils, TypeElement type) throws IOException {", "    String packageName = getPackageName(elementUtils, type);"], "type": ["public static String getBinaryName(Elements elementUtils, TypeElement type) throws IOException {", "    String packageName = getPackageName(elementUtils, type);", "    String qualifiedName = type.getQualifiedName().toString();", "    if (packageName.length() > 0) {", "      return packageName + '.' + qualifiedName.substring(packageName.length() + 1).replace('.', '$');"]}
{"jw": ["private void generateWriteToParcel(JavaWriter jw, String originClass,", "    jw.beginMethod(\"void\", \"writeToParcel\", EnumSet.of(Modifier.PUBLIC, Modifier.STATIC),", "      jw.emitEmptyLine();", "      gen.generateWriteToParcel(field, jw);", "    jw.endMethod();"], "originClass": ["private void generateWriteToParcel(JavaWriter jw, String originClass,", "        originClass, PARAM_SOURCE, \"Parcel\", PARAM_PARCEL, \"int\", PARAM_FLAGS);"], "fields": ["      List<ParcelableField> fields) throws IOException {", "    for (ParcelableField field : fields) {", "      FieldCodeGen gen = field.getCodeGenerator();", "      if (gen == null) { // Already checked before, but let's check it again", "        ProcessorMessage.error(field.getElement(),", "            field.getFieldName(),", "        throw new IOException(\"Unparcelable Field \" + field.getFieldName());", "      gen.generateWriteToParcel(field, jw);"]}
{"type": ["private boolean isPublicClass(DeclaredType type) {", "    Element element = type.asElement();"]}
{"type": ["private boolean hasPublicEmptyConstructor(DeclaredType type) {", "    Element element = type.asElement();"]}
{"r0c0": ["    final double r0c0,", "    sum += r0c0 * ((r1c1 * r2c2) - (r1c2 * r2c1));"], "r0c1": ["    final double r0c1,", "    sum -= r0c1 * ((r1c0 * r2c2) - (r1c2 * r2c0));"], "r0c2": ["    final double r0c2,", "    sum += r0c2 * ((r1c0 * r2c1) - (r1c1 * r2c0));"], "r1c0": ["    final double r1c0,", "    sum -= r0c1 * ((r1c0 * r2c2) - (r1c2 * r2c0));", "    sum += r0c2 * ((r1c0 * r2c1) - (r1c1 * r2c0));"], "r1c1": ["    final double r1c1,", "    sum += r0c0 * ((r1c1 * r2c2) - (r1c2 * r2c1));", "    sum += r0c2 * ((r1c0 * r2c1) - (r1c1 * r2c0));"], "r1c2": ["    final double r1c2,", "    sum += r0c0 * ((r1c1 * r2c2) - (r1c2 * r2c1));", "    sum -= r0c1 * ((r1c0 * r2c2) - (r1c2 * r2c0));"], "r2c0": ["    final double r2c0,", "    sum -= r0c1 * ((r1c0 * r2c2) - (r1c2 * r2c0));", "    sum += r0c2 * ((r1c0 * r2c1) - (r1c1 * r2c0));", "    return sum;"], "r2c1": ["    final double r2c1,", "    sum += r0c0 * ((r1c1 * r2c2) - (r1c2 * r2c1));", "    sum += r0c2 * ((r1c0 * r2c1) - (r1c1 * r2c0));"], "r2c2": ["    final double r2c2)", "    sum += r0c0 * ((r1c1 * r2c2) - (r1c2 * r2c1));", "    sum -= r0c1 * ((r1c0 * r2c2) - (r1c2 * r2c0));"]}
{"scanConfig": ["public R findBy(ClassFileScanConfiguration scanConfig, SearchCriteria criteria) {\r", "\t\tscanConfig = scanConfig.createCopy();\r"], "criteria": ["public R findBy(ClassFileScanConfiguration scanConfig, SearchCriteria criteria) {\r", "\t\tcriteria = criteria.createCopy();\r"]}
{"Result": "Method without Parameter"}
{"input": ["    public static List<byte[]> getBinaryMultiBulkReply(byte[] input) {", "                new RedisInputStream(new ByteArrayInputStream(input)));"]}
{"Result": "Method without Parameter"}
{"key": ["    byte[] rawKey(Object key) {", "        Assert.notNull(key, \"non null key required\");", "        return keySerializer().serialize(key);"]}
{"hashKey": ["    <HK> byte[] rawHashKey(HK hashKey) {", "        Assert.notNull(hashKey, \"non null hash key required\");", "        return hashKeySerializer().serialize(hashKey);"]}
{"rawValues": ["    Set<TypedTuple<V>> deserializeTupleValues(Set<Tuple> rawValues) {", "        Set<TypedTuple<V>> set = new LinkedHashSet<TypedTuple<V>>(rawValues.size());", "        for (Tuple rawValue : rawValues) {", "            set.add(new DefaultTypedTuple(valueSerializer().deserialize(rawValue.getValue()), rawValue.getScore()));"]}
{"rawKeys": ["    <T> Set<T> deserializeHashKeys(Set<byte[]> rawKeys) {", "        return SerializationUtils.deserialize(rawKeys, hashKeySerializer());"]}
{"rawValues": ["    <T> List<T> deserializeHashValues(List<byte[]> rawValues) {", "        return SerializationUtils.deserialize(rawValues, hashValueSerializer());"]}
{"entries": ["    <HK, HV> Map<HK, HV> deserializeHashMap(Map<byte[], byte[]> entries) {", "        if (entries == null) {", "        Map<HK, HV> map = new LinkedHashMap<HK, HV>(entries.size());", "        for (Map.Entry<byte[], byte[]> entry : entries.entrySet()) {", "            map.put((HK) deserializeHashKey(entry.getKey()), (HV) deserializeHashValue(entry.getValue()));"]}
{"entries": ["<HK, HV> Map<HK, List<HV>> deserializeHashList(Map<byte[], List<byte[]>> entries) {", "        if (entries == null) {", "        Map<HK, List<HV>> map = new LinkedHashMap<HK, List<HV>>(entries.size());", "        for (Map.Entry<byte[], List<byte[]>> entry : entries.entrySet()) {", "            map.put((HK) deserializeHashKey(entry.getKey()), (List<HV>) deserializeHashValues(entry.getValue()));"]}
{"entries": ["<HK, HV> Map<HK, Set<HV>> deserializeHashSet(Map<byte[], Set<byte[]>> entries) {", "        if (entries == null) {", "        Map<HK, Set<HV>> map = new LinkedHashMap<HK, Set<HV>>(entries.size());", "        for (Map.Entry<byte[], Set<byte[]>> entry : entries.entrySet()) {", "            map.put((HK) deserializeHashKey(entry.getKey()), (Set<HV>) deserializeValues(entry.getValue()));"]}
{"domainAddress": ["public static List<GatewayAddress> asListFromDomain(final String domainAddress) {", "        if (domainAddress == null) {", "        GatewayAddress domain = new GatewayAddress(0, domainAddress);", "            addresses = InetAddress.getAllByName(domain.getHost());", "            throw new IllegalArgumentException(\"invalid domain '\" + domain + \"' \" + e.getMessage());", "            list.add(new GatewayAddress(id++, address.getHostAddress(), domain.getPort()));"]}
{"address": ["public static String parseHost(final String address) {", "        int ep = address.indexOf(\":\");", "            throw new IllegalArgumentException(\"invalid address '\" + address + \"'\");", "        return address.substring(0, ep).trim();"]}
{"address": ["public static int parsePort(final String address) {", "        int sp = address.indexOf(\":\");", "        if (sp == -1 && sp + 1 >= address.length()) {", "            throw new IllegalArgumentException(\"not found port '\" + address + \"'\");", "            return Integer.parseInt(address.substring(sp + 1, address.length()).trim());", "            throw new IllegalArgumentException(\"bad port number '\" + address + \"'\");"]}
{"key": ["public void set(final String key, final String value) {", "        set(SafeEncoder.encode(key), SafeEncoder.encode(value));"], "value": ["public void set(final String key, final String value) {", "        set(SafeEncoder.encode(key), SafeEncoder.encode(value));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"tryCount": ["String toExecuteInfo(final int tryCount, final long startedTime, final GatewayServer server,", "        sb.append(\"retry=\").append(tryCount).append(\", \");"], "startedTime": ["String toExecuteInfo(final int tryCount, final long startedTime, final GatewayServer server,", "        final long executedTime = System.currentTimeMillis() - startedTime;", "        sb.append(\"time=\").append(executedTime).append(\", \");"], "server": ["String toExecuteInfo(final int tryCount, final long startedTime, final GatewayServer server,", "        sb.append(\"gateway=\").append(server);"], "redis": ["                         final RedisCluster redis) {", "        if (redis != null) {", "            sb.append(\", \").append(\"connect=\").append(redis.connectInfo());"]}
{"master": ["public void setquorum(PartitionGroupServer master, int q,", "        master.setQuorum(q, quorumMembers);"], "q": ["public void setquorum(PartitionGroupServer master, int q,", "        master.setQuorum(q, quorumMembers);"], "quorumMembers": ["            String quorumMembers) throws MgmtSetquorumException,", "        master.setQuorum(q, quorumMembers);"]}
{"path": ["public static void checkPermission(String path, LockType type) throws MgmtZooKeeperException {", "            znodePermission.get().checkPermission(path, type);"], "type": ["public static void checkPermission(String path, LockType type) throws MgmtZooKeeperException {", "            znodePermission.get().checkPermission(path, type);"]}
{"first": ["private byte[][] joinParameters(byte[] first, byte[][] rest) {", "        result[0] = first;", "        for (int i = 0; i < rest.length; i++) {"], "rest": ["private byte[][] joinParameters(byte[] first, byte[][] rest) {", "        byte[][] result = new byte[rest.length + 1][];", "        for (int i = 0; i < rest.length; i++) {", "            result[i + 1] = rest[i];", "        return result;"]}
{"key": ["public void expireAt(final byte[] key, final long millisecondsTimestamp) {", "        sendCommand(Command.EXPIREAT, key, RedisProtocol.toByteArray(millisecondsTimestamp));"], "millisecondsTimestamp": ["public void expireAt(final byte[] key, final long millisecondsTimestamp) {", "        sendCommand(Command.EXPIREAT, key, RedisProtocol.toByteArray(millisecondsTimestamp));"]}
{"key": ["public void decrBy(final byte[] key, final long integer) {", "        sendCommand(Command.DECRBY, key, RedisProtocol.toByteArray(integer));"], "integer": ["public void decrBy(final byte[] key, final long integer) {", "        sendCommand(Command.DECRBY, key, RedisProtocol.toByteArray(integer));"]}
{"key": ["public void incrBy(final byte[] key, final long integer) {", "        sendCommand(Command.INCRBY, key, RedisProtocol.toByteArray(integer));"], "integer": ["public void incrBy(final byte[] key, final long integer) {", "        sendCommand(Command.INCRBY, key, RedisProtocol.toByteArray(integer));"]}
{"key": ["public void zaddBinary(final byte[] key, Map<Double, byte[]> scoreMembers) {", "        args.add(key);"], "scoreMembers": ["public void zaddBinary(final byte[] key, Map<Double, byte[]> scoreMembers) {", "        ArrayList<byte[]> args = new ArrayList<byte[]>(scoreMembers.size() * 2 + 1);", "        for (Map.Entry<Double, byte[]> entry : scoreMembers.entrySet()) {", "            args.add(RedisProtocol.toByteArray(entry.getKey()));", "            args.add(entry.getValue());"]}
{"key": ["public void zrangeByScore(final byte[] key, final byte[] min, final byte[] max) {", "        sendCommand(Command.ZRANGEBYSCORE, key, min, max);"], "min": ["public void zrangeByScore(final byte[] key, final byte[] min, final byte[] max) {", "        sendCommand(Command.ZRANGEBYSCORE, key, min, max);"], "max": ["public void zrangeByScore(final byte[] key, final byte[] min, final byte[] max) {", "        sendCommand(Command.ZRANGEBYSCORE, key, min, max);"]}
{"key": ["public void zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max, final int offset,", "        sendCommand(Command.ZRANGEBYSCORE, key, min, max, Keyword.LIMIT.raw, RedisProtocol.toByteArray(offset), RedisProtocol.toByteArray(count), Keyword.WITHSCORES.raw);"], "min": ["public void zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max, final int offset,", "        sendCommand(Command.ZRANGEBYSCORE, key, min, max, Keyword.LIMIT.raw, RedisProtocol.toByteArray(offset), RedisProtocol.toByteArray(count), Keyword.WITHSCORES.raw);"], "max": ["public void zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max, final int offset,", "        sendCommand(Command.ZRANGEBYSCORE, key, min, max, Keyword.LIMIT.raw, RedisProtocol.toByteArray(offset), RedisProtocol.toByteArray(count), Keyword.WITHSCORES.raw);"], "offset": ["public void zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max, final int offset,", "        sendCommand(Command.ZRANGEBYSCORE, key, min, max, Keyword.LIMIT.raw, RedisProtocol.toByteArray(offset), RedisProtocol.toByteArray(count), Keyword.WITHSCORES.raw);"], "count": ["                                        final int count) {", "        sendCommand(Command.ZRANGEBYSCORE, key, min, max, Keyword.LIMIT.raw, RedisProtocol.toByteArray(offset), RedisProtocol.toByteArray(count), Keyword.WITHSCORES.raw);"]}
{"Result": "Method without Parameter"}
{"parameter": ["public void configSet(final byte[] parameter, final byte[] value) {", "        sendCommand(Command.CONFIG, Keyword.SET.raw, parameter, value);"], "value": ["public void configSet(final byte[] parameter, final byte[] value) {", "        sendCommand(Command.CONFIG, Keyword.SET.raw, parameter, value);"]}
{"key": ["public void getbit(byte[] key, long offset) {", "        sendCommand(Command.GETBIT, key, RedisProtocol.toByteArray(offset));"], "offset": ["public void getbit(byte[] key, long offset) {", "        sendCommand(Command.GETBIT, key, RedisProtocol.toByteArray(offset));"]}
{"key": ["public void getrange(byte[] key, long startOffset, long endOffset) {", "        sendCommand(Command.GETRANGE, key, RedisProtocol.toByteArray(startOffset), RedisProtocol.toByteArray(endOffset));"], "startOffset": ["public void getrange(byte[] key, long startOffset, long endOffset) {", "        sendCommand(Command.GETRANGE, key, RedisProtocol.toByteArray(startOffset), RedisProtocol.toByteArray(endOffset));"], "endOffset": ["public void getrange(byte[] key, long startOffset, long endOffset) {", "        sendCommand(Command.GETRANGE, key, RedisProtocol.toByteArray(startOffset), RedisProtocol.toByteArray(endOffset));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"session": ["public void register(Session session, int ops) throws ClosedChannelException {", "        if (sessions.containsKey(session.getID())) {", "            selKey = session.getChannel().register(selector, ops, session);", "            Logger.error(\"Error while register channel to selector. {}\", session, e);", "        session.setSelectionKey(selKey);"], "ops": ["public void register(Session session, int ops) throws ClosedChannelException {", "            selKey = session.getChannel().register(selector, ops, session);"]}
{"name": ["public void addDefaultHeader(final String name, final String value) {", "        Validate.notEmpty(name, \"header name cannot be empty\");", "        this.defaultHeaders.put(name, value);"], "value": ["public void addDefaultHeader(final String name, final String value) {", "        Validate.notNull(value, \"header value cannot be null, use an empty string instead\");", "        this.defaultHeaders.put(name, value);"]}
{"nrRequestsPredicate": ["public void receivedTimes(final Matcher<Integer> nrRequestsPredicate) {", "        Validate.notNull(nrRequestsPredicate, \"predicate cannot be null\");", "        this.requestManager.evaluateVerification(predicates, nrRequestsPredicate);"]}
{"key": ["public String getValue(final String key) {", "        Validate.notEmpty(key, \"key cannot be empty\");", "        final List<String> allValues = this.getValues(key);", "        return allValues != null ? allValues.get(0) : null;"]}
{"key": ["public List<String> getValues(final String key) {", "        Validate.notEmpty(key, \"name cannot be empty\");", "        final List<String> result = (List<String>) values.get(key.toLowerCase());"]}
{"builder": ["static void addEncoding(final Request.Builder builder, final HttpExchange httpExchange) {", "                    builder.encoding(Charset.forName(matcher.group(1)));"], "httpExchange": ["static void addEncoding(final Request.Builder builder, final HttpExchange httpExchange) {", "        final String contentType = httpExchange.getRequestHeaders().getFirst(\"Content-Type\");"]}
{"defaultEncoding": ["public Stubbing createStubbing(final Charset defaultEncoding, final int defaultStatus,", "        return new Stubbing(defaultEncoding, defaultStatus, defaultHeaders);"], "defaultStatus": ["public Stubbing createStubbing(final Charset defaultEncoding, final int defaultStatus,", "        return new Stubbing(defaultEncoding, defaultStatus, defaultHeaders);"], "defaultHeaders": ["            final MultiMap defaultHeaders) {", "        return new Stubbing(defaultEncoding, defaultStatus, defaultHeaders);"]}
{"claims": ["public static String encode(JSONObject claims, String secret) {", "        String encodedClaims = encodeJson(claims);", "        String secureBits = new StringBuilder(encodedHeader).append(TOKEN_SEP).append(encodedClaims).toString();"], "secret": ["public static String encode(JSONObject claims, String secret) {", "        String sig = sign(secret, secureBits);"]}
{"date": ["private Date copyDate(Date date) {", "        return (date != null) ? new Date(date.getTime()) : null;"]}
{"data": ["public String createToken(Map<String, Object> data, TokenOptions options) {", "        if ((data == null || data.size() == 0) && (options == null || (!options.isAdmin() && !options.isDebug()))) {", "            validateToken(\"TokenGenerator.createToken\", data, isAdminToken);", "            if (data != null && data.size() > 0) {", "                claims.put(\"d\", new JSONObject(data));"], "options": ["public String createToken(Map<String, Object> data, TokenOptions options) {", "        if ((data == null || data.size() == 0) && (options == null || (!options.isAdmin() && !options.isDebug()))) {", "            boolean isAdminToken = (options != null && options.isAdmin());", "            if (options != null) {", "                if (options.getExpires() != null) {", "                    claims.put(\"exp\", options.getExpires().getTime() / 1000);", "                if (options.getNotBefore() != null) {", "                    claims.put(\"nbf\", options.getNotBefore().getTime() / 1000);", "                if (options.isAdmin()) {", "                    claims.put(\"admin\", options.isAdmin());", "                if (options.isDebug()) {", "                    claims.put(\"debug\", options.isDebug());"]}
{"errorCode": ["Dialog getErrorDialog(int errorCode, int requestCode) {", "        final Dialog dialog = GoogleApiAvailability.getInstance().getErrorDialog(activity, errorCode, requestCode);"], "requestCode": ["Dialog getErrorDialog(int errorCode, int requestCode) {", "        final Dialog dialog = GoogleApiAvailability.getInstance().getErrorDialog(activity, errorCode, requestCode);", "        dialog.setOnDismissListener(new DialogInterface.OnDismissListener() {", "        return dialog;"]}
{"signInRequestCode": ["void connectAndRequestGoogleAccount(int signInRequestCode, int errorResolutionRequestCode) {", "            requestGoogleAccount(signInRequestCode);", "            this.signInRequestCode = signInRequestCode;"], "errorResolutionRequestCode": ["void connectAndRequestGoogleAccount(int signInRequestCode, int errorResolutionRequestCode) {", "            this.errorResolutionRequestCode = errorResolutionRequestCode;"]}
{"Result": "Method without Parameter"}
{"request": ["  public boolean invalidateIfNecessary(BaragonRequest request) {", "    if (request.getLoadBalancerService().getEdgeCacheDomains().isEmpty()) {", "      for (String edgeCacheDNS : request.getLoadBalancerService().getEdgeCacheDomains()) {", "        List<CloudflareZone> matchingZones = getCloudflareZone(edgeCacheDNS);", "        if (matchingZones.isEmpty()) {", "        for (CloudflareZone matchingZone : matchingZones) {", "          String zoneId = matchingZone.getId();", "          Optional<CloudflareDnsRecord> matchingDnsRecord = getCloudflareDnsRecord(edgeCacheDNS, zoneId);", "          if (!matchingDnsRecord.isPresent()) {", "          if (!matchingDnsRecord.get().isProxied()) {", "            LOG.warn(\"`edgeCacheDNS` was defined on the request, but {} is not a proxied DNS record!\", edgeCacheDNS);", "          String cacheTag = String.format(", "              request.getLoadBalancerService().getServiceId()", "          LOG.debug(\"Sending cache purge request against {} for {} to Cloudflare...\", matchingDnsRecord.get().getName(), cacheTag);", "          allSucceeded = cf.purgeEdgeCache(zoneId, Collections.singletonList(cacheTag)) && allSucceeded;", "      return allSucceeded;", "      LOG.error(\"Unable to invalidate Cloudflare cache for request {}\", request, e);"]}
{"baseUrl": ["public Optional<BaragonServiceStatus> getBaragonServiceStatus(String baseUrl) {", "    final String uri = String.format(STATUS_FORMAT, baseUrl);", "    return getSingle(uri, \"status\", \"\", BaragonServiceStatus.class);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"loadBalancerGroupName": ["public Collection<String> getOccupiedBasePaths(String loadBalancerGroupName) {", "    final String requestUri = String.format(LOAD_BALANCER_ALL_BASE_PATHS_FORMAT, getBaseUrl(), loadBalancerGroupName);", "    return getCollection(requestUri, \"occupied base paths\", STRING_COLLECTION);"]}
{"requestId": ["public Optional<BaragonResponse> getRequest(String requestId) {", "    final String uri = String.format(REQUEST_ID_FORMAT, getBaseUrl(), requestId);", "    return getSingle(uri, \"request\", requestId, BaragonResponse.class);"]}
{"Result": "Method without Parameter"}
{"trafficSource": ["private void guaranteeRegistered(TrafficSource trafficSource,", "    guaranteeHasAllTargets(trafficSource, targetGroup, targets, baragonAgents);"], "targetGroup": ["                                   TargetGroup targetGroup,", "      guaranteeSameVPC(targetGroup, baragonAgents, loadBalancers);", "    guaranteeHasAllTargets(trafficSource, targetGroup, targets, baragonAgents);"], "targets": ["                                   Collection<TargetDescription> targets,", "    guaranteeHasAllTargets(trafficSource, targetGroup, targets, baragonAgents);"], "baragonAgents": ["                                   Collection<BaragonAgentMetadata> baragonAgents,", "      guaranteeSameVPC(targetGroup, baragonAgents, loadBalancers);", "    guaranteeAzEnabled(baragonAgents, loadBalancers);", "    guaranteeHasAllTargets(trafficSource, targetGroup, targets, baragonAgents);"], "loadBalancers": ["                                   Collection<LoadBalancer> loadBalancers) {", "      guaranteeSameVPC(targetGroup, baragonAgents, loadBalancers);", "    guaranteeAzEnabled(baragonAgents, loadBalancers);"]}
{"trafficSource": ["private void deregisterRemovableTargets(TrafficSource trafficSource,", "    Collection<TargetDescription> removableTargets = listRemovableTargets(trafficSource, baragonGroup, targets, agents);"], "baragonGroup": ["                                          BaragonGroup baragonGroup,", "    Collection<TargetDescription> removableTargets = listRemovableTargets(trafficSource, baragonGroup, targets, agents);"], "targetGroup": ["                                          TargetGroup targetGroup,", "            && isLastHealthyInstance(removableTarget, targetGroup)) {", "          LOG.info(\"Will not de-register target {} because it is last healthy instance in {}\", removableTarget, targetGroup);", "              .withTargetGroupArn(targetGroup.getTargetGroupArn())", "          LOG.info(\"De-registered target {} from target group {}\", removableTarget, targetGroup);", "            removableTarget, targetGroup, acexn);", "            .of(\"targetGroup\", targetGroup.getTargetGroupName()));"], "agents": ["                                          Collection<BaragonAgentMetadata> agents,", "    Collection<TargetDescription> removableTargets = listRemovableTargets(trafficSource, baragonGroup, targets, agents);", "    for (TargetDescription removableTarget : removableTargets) {", "            && isLastHealthyInstance(removableTarget, targetGroup)) {", "          LOG.info(\"Will not de-register target {} because it is last healthy instance in {}\", removableTarget, targetGroup);", "              .withTargets(removableTarget));", "          LOG.info(\"De-registered target {} from target group {}\", removableTarget, targetGroup);", "            removableTarget, targetGroup, acexn);"], "targets": ["                                          Collection<TargetDescription> targets) {", "    Collection<TargetDescription> removableTargets = listRemovableTargets(trafficSource, baragonGroup, targets, agents);"]}
{"targetGroup": ["private void guaranteeSameVPC(TargetGroup targetGroup,", "    String vpcId = targetGroup.getVpcId();", "          LOG.error(\"Agent {} not on same VPC as its target group {}\", agent, targetGroup);", "          throw new IllegalStateException(String.format(\"Agent %s not on same VPC as its target group %s\", agent, targetGroup));", "        LOG.error(\"Load balancer {} on different VPC from target group {}\", loadBalancer, targetGroup);", "        throw new IllegalStateException(String.format(\"Load balancer %s on different VPC from target group %s\", loadBalancer, targetGroup));"], "agents": ["                                Collection<BaragonAgentMetadata> agents,", "    for (BaragonAgentMetadata agent : agents) {", "      if (agent.getEc2().getVpcId().isPresent()) {", "        if (! agent.getEc2().getVpcId().get().equals(vpcId)) {", "          LOG.error(\"Agent {} not on same VPC as its target group {}\", agent, targetGroup);", "          throw new IllegalStateException(String.format(\"Agent %s not on same VPC as its target group %s\", agent, targetGroup));", "        LOG.error(\"Agent {} not assigned to a VPC\", agent);", "        throw new IllegalStateException(String.format(\"Agent %s not assigned to a VPC\", agent));"], "loadBalancers": ["                                Collection<LoadBalancer> loadBalancers) {", "    for (LoadBalancer loadBalancer : loadBalancers) {", "      if (!vpcId.equals(loadBalancer.getVpcId())) {", "        LOG.error(\"Load balancer {} on different VPC from target group {}\", loadBalancer, targetGroup);", "        throw new IllegalStateException(String.format(\"Load balancer %s on different VPC from target group %s\", loadBalancer, targetGroup));"]}
{"trafficSource": ["private void guaranteeHasAllTargets(TrafficSource trafficSource,", "        if ((trafficSource.getRegisterBy() == RegisterBy.INSTANCE_ID && agent.getEc2().getInstanceId().isPresent())", "            || (trafficSource.getRegisterBy() == RegisterBy.PRIVATE_IP && agent.getEc2().getPrivateIp().isPresent())) {", "          String id = trafficSource.getRegisterBy() == RegisterBy.INSTANCE_ID ? agent.getEc2().getInstanceId().get() : agent.getEc2().getPrivateIp().get();", "          if (agentShouldRegisterInTargetGroup(id, targets)) {", "                .withId(id));"], "targetGroup": ["                                      TargetGroup targetGroup,", "            LOG.info(\"Will register agent {} to target in group {}\", agent, targetGroup);", "            .withTargetGroupArn(targetGroup.getTargetGroupArn())", "        LOG.info(\"Registered targets {} onto target group {}\", targetDescriptions, targetGroup);", "        LOG.error(\"Failed to register targets {} onto target group {}\", targetDescriptions, targetGroup);", "            \"targetGroup\", targetGroup.toString()));"], "targets": ["                                      Collection<TargetDescription> targets,", "          if (agentShouldRegisterInTargetGroup(id, targets)) {"], "baragonAgents": ["                                      Collection<BaragonAgentMetadata> baragonAgents) {", "    for (BaragonAgentMetadata agent : baragonAgents) {", "        if ((trafficSource.getRegisterBy() == RegisterBy.INSTANCE_ID && agent.getEc2().getInstanceId().isPresent())", "            || (trafficSource.getRegisterBy() == RegisterBy.PRIVATE_IP && agent.getEc2().getPrivateIp().isPresent())) {", "          String id = trafficSource.getRegisterBy() == RegisterBy.INSTANCE_ID ? agent.getEc2().getInstanceId().get() : agent.getEc2().getPrivateIp().get();", "          if (agentShouldRegisterInTargetGroup(id, targets)) {", "                .withId(id));", "            LOG.info(\"Will register agent {} to target in group {}\", agent, targetGroup);", "            LOG.debug(\"Agent {} is already registered\", agent);", "        LOG.error(\"Could not create request to register agent {} due to error\", agent, exn);", "        exceptionNotifier.notify(exn, ImmutableMap.of(\"agent\", agent.toString()));"]}
{"href": ["public void setHref(String href) {", "\t\tif (href.contains(\"%7B\")) {", "\t\t\t\thref = URLDecoder.decode(href, \"UTF-8\");", "\t\tthis.href = new UriTemplate(href);"]}
{"contextObject": ["static MemberKey newInstance(Object contextObject, String name) {", "        if (contextObject instanceof Class<?>) {", "            Class<?> clazz = (Class<?>) contextObject;", "            if (clazz.isEnum() && (\"values\".equals(name) || Reflections.isConstantName(clazz, name))) {", "                return new MemberKey(clazz, name);", "        return new MemberKey(contextObject.getClass(), name);"], "name": ["static MemberKey newInstance(Object contextObject, String name) {", "            if (clazz.isEnum() && (\"values\".equals(name) || Reflections.isConstantName(clazz, name))) {", "                return new MemberKey(clazz, name);", "        return new MemberKey(contextObject.getClass(), name);"]}
{"lineSeparator": ["private void lineSeparatorFound(String lineSeparator) {", "        flushLineSeparator(lineSeparator);"]}
{"Result": "Method without Parameter"}
{"tagType": ["private String extractContent(MustacheTagType tagType, String buffer) {", "        switch (tagType) {"], "buffer": ["private String extractContent(MustacheTagType tagType, String buffer) {", "            return buffer.trim();", "            return (buffer.charAt(0) == ((String) EngineConfigurationKey.START_DELIMITER", "                    .getDefaultValue()).charAt(0) ? buffer.substring(1,", "                    buffer.length() - 1).trim() : buffer.substring(1).trim());", "            return buffer.substring(1).trim();", "            return buffer.trim();"]}
{"container": ["            ContainerSegmentBase container) {", "        lines.add(readSegmentLines(lines, null, container));"]}
{"configuration": ["public static Pattern newMustacheTagPattern(Configuration configuration) {", "        regex.append(Pattern.quote(configuration", "        regex.append(Pattern.quote(configuration"]}
{"delegate": ["public static <T> Decorator<T> decorate(T delegate, Map<String, Function<T, Object>> mappings, String delegateKey,", "        return IterableDecorator.isIterable(delegate)", "                ? new IterableDecorator<>(delegate, ImmutableMap.copyOf(mappings), delegateKey, configuration)", "                : new Decorator<>(delegate, ImmutableMap.copyOf(mappings), delegateKey, configuration);"], "mappings": ["public static <T> Decorator<T> decorate(T delegate, Map<String, Function<T, Object>> mappings, String delegateKey,", "                ? new IterableDecorator<>(delegate, ImmutableMap.copyOf(mappings), delegateKey, configuration)", "                : new Decorator<>(delegate, ImmutableMap.copyOf(mappings), delegateKey, configuration);"], "delegateKey": ["public static <T> Decorator<T> decorate(T delegate, Map<String, Function<T, Object>> mappings, String delegateKey,", "                ? new IterableDecorator<>(delegate, ImmutableMap.copyOf(mappings), delegateKey, configuration)", "                : new Decorator<>(delegate, ImmutableMap.copyOf(mappings), delegateKey, configuration);"], "configuration": ["            Configuration configuration) {", "                ? new IterableDecorator<>(delegate, ImmutableMap.copyOf(mappings), delegateKey, configuration)", "                : new Decorator<>(delegate, ImmutableMap.copyOf(mappings), delegateKey, configuration);"]}
{"instance": ["    public static <T> T unwrap(T instance) {", "        return instance instanceof Decorator ? unwrap(((Decorator<T>) instance).delegate) : instance;"]}
{"Result": "Method without Parameter"}
{"locator": ["public MustacheEngineBuilder addTemplateLocator(TemplateLocator locator) {", "        checkArgumentNotNull(locator);", "        this.templateLocators.add(locator);"]}
{"resolver": ["public MustacheEngineBuilder addResolver(Resolver resolver) {", "        checkArgumentNotNull(resolver);", "        this.resolvers.add(resolver);"]}
{"callback": ["            EngineBuiltCallback callback) {", "        checkArgumentNotNull(callback);", "        this.engineReadyCallbacks.add(callback);"]}
{"converter": ["public MustacheEngineBuilder addValueConverter(ValueConverter converter) {", "        checkArgumentNotNull(converter);", "        this.valueConverters.add(converter);"]}
{"converter": ["public MustacheEngineBuilder addContextConverter(ContextConverter converter) {", "        checkArgumentNotNull(converter);", "        this.contextConverters.add(converter);"]}
{"text": ["public static String capitalizeFully(String text, Character delimiter) {", "        if (isEmpty(text)) {", "            return text;", "        text = text.toLowerCase();"], "delimiter": ["public static String capitalizeFully(String text, Character delimiter) {", "            if (delimiter.equals(ch)) {"]}
{"options": ["protected void append(Options options, CharSequence sequence) {", "        if (textSupport == null || isUnescapeVariable(options)) {", "            options.append(sequence);", "                        options.getAppendable());"], "sequence": ["protected void append(Options options, CharSequence sequence) {", "            options.append(sequence);", "                textSupport.appendEscapedHtml(sequence.toString(),"]}
{"Result": "Method without Parameter"}
{"container": ["private void push(ContainerSegmentBase container) {", "        containerStack.addFirst(container);", "        LOGGER.trace(\"Push {} [name: {}]\", container.getType(),", "                container.getContent());"]}
{"segment": ["private void addSegment(SegmentBase segment) {", "        containerStack.peekFirst().addSegment(segment);", "        LOGGER.trace(\"Add {}\", segment);"]}
{"Result": "Method without Parameter"}
{"name": ["static Iterator<String> splitHelperName(String name, Segment segment) {", "        for (int i = 0; i < name.length(); i++) {", "            if (name.charAt(i) == ' ') {", "                        buffer.append(name.charAt(i));", "                        && Strings.isStringLiteralSeparator(name.charAt(i))) {", "                        && Strings.isListLiteralStart(name.charAt(i))) {", "                        && Strings.isListLiteralEnd(name.charAt(i))) {", "                buffer.append(name.charAt(i));"], "segment": ["static Iterator<String> splitHelperName(String name, Segment segment) {", "                        segment);"]}
{"delegateType": ["public static <T> Builder<T> decorate(Class<T> delegateType) {", "        return decorate(o -> (delegateType.isAssignableFrom(Decorator.unwrap(o).getClass())));"]}
{"Result": "Method without Parameter"}
{"clazz": ["static Field findField(Class<?> clazz, String name) {", "        checkArgumentNotNull(clazz);", "        for (Field field : SecurityActions.getFields(clazz)) {", "            if (field.getName().equals(name)) {", "                found = field;", "        LOGGER.debug(\"Field {} {}found on type: {}\", name, found != null ? \"\" : \"not \", clazz.getName());", "        return found;"], "name": ["static Field findField(Class<?> clazz, String name) {", "        checkArgumentNotNull(name);", "            if (field.getName().equals(name)) {", "        LOGGER.debug(\"Field {} {}found on type: {}\", name, found != null ? \"\" : \"not \", clazz.getName());"]}
{"builder": ["public static void registerHelpers(ConfigurationExtensionBuilder builder, Map<String, Helper> helpers) {", "        Checker.checkArgumentsNotNull(builder, helpers);", "            registerHelper(builder, entry.getKey(), entry.getValue());"], "helpers": ["public static void registerHelpers(ConfigurationExtensionBuilder builder, Map<String, Helper> helpers) {", "        Checker.checkArgumentsNotNull(builder, helpers);", "        for (Entry<String, Helper> entry : helpers.entrySet()) {", "            registerHelper(builder, entry.getKey(), entry.getValue());"]}
{"builder": ["public static void registerHelper(ConfigurationExtensionBuilder builder, String name, Helper helper) {", "        Checker.checkArgumentsNotNull(builder, name, helper);", "            builder.registerHelper(name, helper);"], "name": ["public static void registerHelper(ConfigurationExtensionBuilder builder, String name, Helper helper) {", "        Checker.checkArgumentsNotNull(builder, name, helper);", "            builder.registerHelper(name, helper);"], "helper": ["public static void registerHelper(ConfigurationExtensionBuilder builder, String name, Helper helper) {", "        Checker.checkArgumentsNotNull(builder, name, helper);", "            builder.registerHelper(name, helper);"]}
{"container": ["            AbstractContainerSegment container) {", "        for (Segment segment : container) {", "            if (!SegmentType.LINE_SEPARATOR.equals(segment.getType())) {", "                currentLine.add(segment);", "                currentLine.add(segment);"]}
{"keyPart": ["public void invalidateFragments(final String keyPart) {", "        if (fragments == null || keyPart == null) {", "        fragments.invalidate(fragmentKey -> fragmentKey.getKey().contains(keyPart));"]}
{"value": ["protected TemporalAccessor getFormattableObject(Object value,", "        if (value instanceof TemporalAccessor) {", "            return (TemporalAccessor) value;", "        } else if (value instanceof Date) {", "            return LocalDateTime.ofInstant(((Date) value).toInstant(),", "        } else if (value instanceof Calendar) {", "            return LocalDateTime.ofInstant(((Calendar) value).toInstant(),", "        } else if (value instanceof Number) {", "                    Instant.ofEpochMilli(((Number) value).longValue()),", "            throw valueNotAFormattableObject(value, tagInfo);"], "locale": [], "timeZone": ["            Locale locale, TimeZone timeZone, MustacheTagInfo tagInfo) {", "                    timeZone.toZoneId());", "                    timeZone.toZoneId());", "                    timeZone.toZoneId());"], "tagInfo": ["            Locale locale, TimeZone timeZone, MustacheTagInfo tagInfo) {", "            throw valueNotAFormattableObject(value, tagInfo);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"key": ["public <T> boolean containsKey(StorageKey<T> key) {", "    return storage.getItem(key.name()) != null;"]}
{"key": ["public <T> void put(StorageKey<T> key, T value) throws SerializationException, StorageQuotaExceededException {", "      String data = StorageUtils.serialize(key.getClazz(), value);", "      String oldData = storage.getItem(key.name());", "      storage.setItem(key.name(), data);", "      T oldValue = cache.put(key, value);", "      fireEvent(StorageChangeEvent.ChangeType.PUT, key, value, oldValue, data, oldData);", "        throw new StorageQuotaExceededException(key, e);"], "value": ["public <T> void put(StorageKey<T> key, T value) throws SerializationException, StorageQuotaExceededException {", "    if(value == null){", "      String data = StorageUtils.serialize(key.getClazz(), value);", "      storage.setItem(key.name(), data);", "      T oldValue = cache.put(key, value);", "      fireEvent(StorageChangeEvent.ChangeType.PUT, key, value, oldValue, data, oldData);"]}
{"key": ["public <T extends Serializable> void remove(StorageKey<T> key) {", "    String data = storage.getItem(key.name());", "    storage.removeItem(key.name());", "    T value = cache.remove(key);", "    fireEvent(StorageChangeEvent.ChangeType.REMOVE, key, null, value, null, data);"]}
{"keyName": ["  public static <T> StorageKey<T> objectKey(String keyName){", "    return new StorageKey<>(keyName, Object.class);"]}
{"keyName": ["public static <T extends IsSerializable> StorageKey<T> isSerializableKey(String keyName){", "      return new StorageKey<>(keyName, IsSerializable.class);"]}
{"keyName": ["public static <T extends Serializable> StorageKey<T> serializableKey(String keyName){", "      return new StorageKey<>(keyName, Serializable.class);"]}
{"typedArray": ["private void obtainSize(@NonNull final TypedArray typedArray) {", "                typedArray.getInt(R.styleable.FloatingActionButton_size, defaultSize.getValue()));"]}
{"typedArray": ["private void obtainColor(@NonNull final TypedArray typedArray) {", "        color = typedArray.getColor(R.styleable.FloatingActionButton_android_color, defaultColor);"]}
{"typedArray": ["private void obtainActivatedColor(@NonNull final TypedArray typedArray) {", "        activatedColor = typedArray"]}
{"typedArray": ["private void obtainPressedColor(@NonNull final TypedArray typedArray) {", "        pressedColor = typedArray"]}
{"typedArray": ["private void obtainDisabledColor(@NonNull final TypedArray typedArray) {", "        disabledColor = typedArray"]}
{"typedArray": ["private void obtainIcon(@NonNull final TypedArray typedArray) {", "        Drawable icon = typedArray.getDrawable(R.styleable.FloatingActionButton_android_icon);"]}
{"typedArray": ["private void obtainVisibilityAnimationDuration(@NonNull final TypedArray typedArray) {", "        int duration = typedArray"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"color": ["private Drawable createBackgroundDrawable(@ColorInt final int color) {", "        drawable.getPaint().setColor(color);"]}
{"Result": "Method without Parameter"}
{"visibility": ["private void animateVisibility(final int visibility, final long duration) {", "        AnimatorListener listener = createVisibilityAnimatorListener(visibility);", "        float targetScale = visibility == View.VISIBLE ? 1 : 0;", "        visibilityAnimator =", "                        .setDuration(animationDuration).setListener(listener);"], "duration": ["private void animateVisibility(final int visibility, final long duration) {", "        long animationDuration = Math.round(Math.abs(getScaleX() - targetScale) * duration);", "                        .setDuration(animationDuration).setListener(listener);"]}
{"visibility": ["private AnimatorListener createVisibilityAnimatorListener(final int visibility) {", "                if (visibility == View.VISIBLE) {", "                    FloatingActionButton.super.setVisibility(visibility);", "                FloatingActionButton.super.setVisibility(visibility);"]}
{"size": ["public final void setSize(@NonNull final Size size) {", "        Condition.INSTANCE.ensureNotNull(size, \"The size may not be null\");", "        this.size = size;"]}
{"typedArray": ["private void obtainThickness(@NonNull final TypedArray typedArray) {", "        thickness = typedArray"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"savedInstanceState": ["private void handleSavedInstanceState(@Nullable final Bundle savedInstanceState) {", "        if (savedInstanceState != null) {", "                    savedInstanceState.getBoolean(FLOATING_ACTION_BUTTONS_VISIBLE_EXTRA);"]}
{"typedArray": ["private void obtainText(@NonNull final TypedArray typedArray) {", "        setText(typedArray.getText(R.styleable.Chip_android_text));"]}
{"typedArray": ["private void obtainTextColor(@NonNull final TypedArray typedArray) {", "        setTextColor(typedArray.getColor(R.styleable.Chip_android_textColor, defaultColor));"]}
{"typedArray": ["private void obtainColor(@NonNull final TypedArray typedArray) {", "        setColor(typedArray.getColor(R.styleable.Chip_android_color, defaultColor));"]}
{"typedArray": ["private void obtainIcon(@NonNull final TypedArray typedArray) {", "        setIcon(typedArray.getDrawable(R.styleable.Chip_android_icon));"]}
{"typedArray": ["private void obtainClosable(@NonNull final TypedArray typedArray) {", "        setClosable(typedArray.getBoolean(R.styleable.Chip_closable, false));"]}
{"typedArray": ["private void obtainCloseIcon(@NonNull final TypedArray typedArray) {", "        Drawable icon = typedArray.getDrawable(R.styleable.Chip_closeButtonIcon);"]}
{"listener": ["public final void addCloseListener(@NonNull final CloseListener listener) {", "        Condition.INSTANCE.ensureNotNull(listener, \"The listener may not be null\");", "        listeners.add(listener);"]}
{"listener": ["public final void removeCloseListener(@NonNull final CloseListener listener) {", "        Condition.INSTANCE.ensureNotNull(listener, \"The listener may not be null\");", "        listeners.remove(listener);"]}
{"color": ["public final void setColor(@ColorInt final int color) {", "        this.color = color;", "        getBackground().setColorFilter(color, PorterDuff.Mode.SRC_IN);"]}
{"closable": ["public final void setClosable(final boolean closable) {", "        this.closable = closable;", "        if (closable) {"]}
{"Result": "Method without Parameter"}
{"scripts": ["public static ScriptEngine getEngine(Collection<InputStream> scripts) {", "\t\tfor (InputStream script : scripts) {", "\t\t\tevaluate(engine, script);"]}
{"Result": "Method without Parameter"}
{"klass": ["public static boolean isPresent(String klass) {", "\t\thasText(klass, \"Class name must not be empty\");", "\t\t\tClass.forName(klass);"]}
{"importingClassMetadata": ["\tpublic static <T> T getAnnotationValue(AnnotationMetadata importingClassMetadata, Class annotationClass, String name, T defaultValue) {", "\t\tMap<String, Object> attributes = importingClassMetadata.getAnnotationAttributes(annotationClass.getName());"], "annotationClass": ["\tpublic static <T> T getAnnotationValue(AnnotationMetadata importingClassMetadata, Class annotationClass, String name, T defaultValue) {", "\t\tMap<String, Object> attributes = importingClassMetadata.getAnnotationAttributes(annotationClass.getName());"], "name": ["\tpublic static <T> T getAnnotationValue(AnnotationMetadata importingClassMetadata, Class annotationClass, String name, T defaultValue) {", "\t\treturn attributes != null && attributes.containsKey(name) ? (T) attributes.get(name) : defaultValue;"], "defaultValue": ["\tpublic static <T> T getAnnotationValue(AnnotationMetadata importingClassMetadata, Class annotationClass, String name, T defaultValue) {", "\t\treturn attributes != null && attributes.containsKey(name) ? (T) attributes.get(name) : defaultValue;"]}
{"name": ["public static InputStream getStream(String name) {", "\t\tInputStream stream = getInputStreamWithResolver(resolver, name);", "\t\tif (stream == null) {", "\t\t\tthrow new MustacheIOException(\"Unable to locate {}\" + name);", "\t\treturn stream;"]}
{"names": ["public static InputStream getFirstAvailableStream(Collection<String> names) {", "\t\tfor (String name : names) {", "\t\t\t\tInputStream stream = getInputStreamWithResolver(resolver, name);", "\t\t\t\tif (stream != null) {", "\t\t\t\t\treturn stream;", "\t\tthrow new MustacheIOException(\"Unable to locate one of: \" + names);"]}
{"template": ["public String render(String template, Map<String, Object> model) {", "\t\t\treturn (String) invocable.invokeFunction(\"render\", template, model, partials);"], "model": ["public String render(String template, Map<String, Object> model) {", "\t\t\treturn (String) invocable.invokeFunction(\"render\", template, model, partials);"]}
{"aliases": ["public void addAliases(Map<String, String> aliases) {", "\t\tnotNull(aliases, \"Aliases must not be null\");", "\t\tfor (Map.Entry<String, String> entry : aliases.entrySet()) {", "\t\t\taddAlias(entry.getKey(), entry.getValue());"]}
{"key": ["public void addAlias(String key, String value) {", "\t\t\t\tnotNull(key, \"Key must not be null\"),"], "value": ["public void addAlias(String key, String value) {", "\t\t\t\tnotNull(value, \"Value must not be null\")"]}
{"id": ["    public final synchronized ChronosListener getListener(final int id) {", "        ChronosListener chronosListener = mListeners.get(id);", "        if (chronosListener == null) {", "            chronosListener = new ChronosListener(id);", "            mListeners.put(id, chronosListener);", "        return chronosListener;"]}
{"operation": ["            @NonNull final ChronosOperation<Output> operation) {", "        return ChronosService.getInstance().runSync(operation, false);"]}
{"method": ["    private static boolean isCallback(@NonNull final Method method,", "        if (method.getName().equals(methodName)) {", "            if (method.getReturnType() == Void.TYPE) {", "                final Class<?>[] parameters = method.getParameterTypes();"], "resultClass": ["            @NonNull final Class<?> resultClass,", "                if (parameters.length == 1 && parameters[0].isAssignableFrom(resultClass)) {"], "methodName": ["            @NonNull final String methodName) {", "        if (method.getName().equals(methodName)) {"]}
{"serviceListener": ["public final void onResume(@NonNull final Object serviceListener) {", "        mServiceListener = serviceListener;"]}
{"operationResult": ["    public final void onEventMainThread(@Nullable final ChronosOperationResult<?> operationResult) {", "        if (operationResult == null) {", "        final int operationId = operationResult.getId();", "            } else if (mUntaggedRequests.contains(operationResult.getId())) {", "            } else if (operationResult.isBroadcast()) {", "            final OperationDelivery<?> operationDelivery = new OperationDelivery<>(operationResult,"]}
{"operation": ["public final int invoke(@NonNull final ChronosOperation<?> operation,", "        final int id = ChronosService.getInstance().runAsync(operation, broadcastResult);"], "broadcastResult": ["            final boolean broadcastResult) {", "        final int id = ChronosService.getInstance().runAsync(operation, broadcastResult);", "        mUntaggedRequests.add(id);", "        return id;"]}
{"operation": ["public final int invoke(@NonNull final ChronosOperation<?> operation, @NonNull final String tag,", "        final int id = ChronosService.getInstance().runAsync(operation, broadcastResult);"], "tag": ["public final int invoke(@NonNull final ChronosOperation<?> operation, @NonNull final String tag,", "        logd(\"invoking tagged operation, tag=\" + tag);", "        final Integer savedId = mTaggedRequests.get(tag);", "        if (savedId != null && isRunning(savedId)) {", "            logd(\"operation with tag=\" + tag + \" is running, do nothing\");", "            return savedId;", "        logd(\"operation with tag=\" + tag + \" is not running, start it\");", "        mTaggedRequests.put(tag, id);"], "broadcastResult": ["            final boolean broadcastResult) {", "        final int id = ChronosService.getInstance().runAsync(operation, broadcastResult);", "        mTaggedRequests.put(tag, id);", "        return id;"]}
{"id": ["public final boolean cancel(final int id, final boolean mayInterrupt) {", "        if (mUntaggedRequests.contains(id) || mTaggedRequests.containsValue(id)) {", "            return RunningOperationStorage.getInstance().cancel(id, mayInterrupt);"], "mayInterrupt": ["public final boolean cancel(final int id, final boolean mayInterrupt) {", "            return RunningOperationStorage.getInstance().cancel(id, mayInterrupt);"]}
{"tag": ["public final boolean cancel(@NonNull final String tag, final boolean mayInterrupt) {", "        final Integer id = mTaggedRequests.get(tag);", "        if (id != null) {", "            return cancel(id, mayInterrupt);"], "mayInterrupt": ["public final boolean cancel(@NonNull final String tag, final boolean mayInterrupt) {", "            return cancel(id, mayInterrupt);"]}
{"tag": ["    public final boolean isRunning(@NonNull final String tag) {", "        final Integer id = mTaggedRequests.get(tag);", "        if (id != null) {", "            return isRunning(id);"]}
{"operationResult": ["private void onOperationFinished(@NonNull final OperationDelivery<?> operationResult) {", "        logd(\"onOperationFinished \" + operationResult);", "                storeResult(operationResult);", "                deliverResult(operationResult);"]}
{"operationDelivery": ["private void storeResult(@NonNull final OperationDelivery<?> operationDelivery) {", "        logd(\"store delivery \" + operationDelivery);", "        mStoredResults.add(new SoftReference<OperationDelivery<?>>(operationDelivery));"]}
{"operationDelivery": ["private void deliverResult(@NonNull final OperationDelivery<?> operationDelivery) {", "        logd(\"deliver delivery \" + operationDelivery);", "        switch (operationDelivery.getDeliveryMode()) {", "                deliverResult(operationDelivery.getResult(), Chronos.OWN_CALLBACK_METHOD_NAME,", "                deliverResult(operationDelivery.getResult(), Chronos.BROADCAST_CALLBACK_METHOD_NAME,"]}
{"operationResult": ["    private void deliverResult(@NonNull final ChronosOperationResult<?> operationResult,", "        final Class resultClass = operationResult.getClass();", "                    callbackMethod.invoke(mServiceListener, operationResult);", "                    \"Operation result (id=\" + operationResult.getId() + \"; class=\" + operationResult"], "methodName": ["            @NonNull final String methodName, final boolean warnIfNoCallback) {", "            if (isCallback(method, resultClass, methodName)) {", "                    \"public void \" + methodName + \"(\" + resultClass.getName()"], "warnIfNoCallback": ["            @NonNull final String methodName, final boolean warnIfNoCallback) {", "        if (warnIfNoCallback && callbackMethod == null) {"]}
{"message": ["private void logd(@NonNull final String message) {", "            Log.d(LOG_TAG, this.toString() + \" \" + message);"]}
{"id": ["private synchronized boolean cancel(final int id, final boolean mayInterrupt,", "        final RunningOperation runningOperation = mRunningOperations.get(id);", "        if (runningOperation != null) {", "                mRunningOperations.remove(id);", "            mCancelledOperations.add(id);", "            return runningOperation.cancel(mayInterrupt);"], "mayInterrupt": ["private synchronized boolean cancel(final int id, final boolean mayInterrupt,", "            return runningOperation.cancel(mayInterrupt);"], "removeOperation": ["            final boolean removeOperation) {", "            if (removeOperation) {"]}
{"id": ["synchronized final void operationStarted(final int id, @NonNull final ChronosOperation<?> operation,", "        mRunningOperations.put(id, new RunningOperation(operation, future));"], "operation": ["synchronized final void operationStarted(final int id, @NonNull final ChronosOperation<?> operation,", "        mRunningOperations.put(id, new RunningOperation(operation, future));"], "future": ["            @NonNull final Future<?> future", "        mRunningOperations.put(id, new RunningOperation(operation, future));"]}
{"mayInterrupt": ["synchronized final void cancelAll(final boolean mayInterrupt) {", "            cancel(key, mayInterrupt, false);"]}
{"id": ["    synchronized final boolean isOperationCancelled(final int id) {", "        return mCancelledOperations.contains(Integer.valueOf(id));"]}
{"operation": ["private static <Output> void silentRun(@NonNull final ChronosOperation<Output> operation,", "            final Output output = operation.run();"], "operationResult": ["            @NonNull final ChronosOperationResult<Output> operationResult) {", "            operationResult.setOutput(output);", "            operationResult.setException(e);"]}
{"operation": ["            @NonNull final ChronosOperation<Output> operation, final boolean broadcastResult) {", "        final Class<? extends ChronosOperationResult<Output>> resultClass = operation", "        operationResult.setOperation(operation);"], "broadcastResult": ["            @NonNull final ChronosOperation<Output> operation, final boolean broadcastResult) {", "        operationResult.setBroadcast(broadcastResult);"]}
{"operation": ["final <Output> int runAsync(@NonNull final ChronosOperation<Output> operation,", "        final ChronosOperationResult<Output> result = createEmptyResult(operation, broadcastResult);", "            RunningOperationStorage.getInstance().operationStarted(id, operation,", "                            silentRun(operation, result);"], "broadcastResult": ["            final boolean broadcastResult) {", "        final ChronosOperationResult<Output> result = createEmptyResult(operation, broadcastResult);", "        final int id = result.getId();", "                            silentRun(operation, result);", "                            mEventBus.post(result);"]}
{"operation": ["            @NonNull final ChronosOperation<Output> operation, final boolean broadcastResult) {", "        final ChronosOperationResult<Output> result = createEmptyResult(operation, broadcastResult);", "        silentRun(operation, result);"], "broadcastResult": ["            @NonNull final ChronosOperation<Output> operation, final boolean broadcastResult) {", "        final ChronosOperationResult<Output> result = createEmptyResult(operation, broadcastResult);", "        silentRun(operation, result);", "        mEventBus.post(result);", "        return result;"]}
{"result": ["public void onOperationFinished(final SimpleOperation.Result result) {", "        if (result.isSuccessful()) {", "            mData = result.getOutput();", "            mTextOutput.setText(result.getErrorMessage());"]}
{"main": ["class main {", "protected static void main(Main main, String... args) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"eventHandlers": ["public void initialize(Map<String, List<EventHandler>> eventHandlers, URI uri) {", "    this.eventHandlers = eventHandlers;"], "uri": ["public void initialize(Map<String, List<EventHandler>> eventHandlers, URI uri) {", "    EventListener listener = new EventListener(uri);", "    executorService.submit(listener);"]}
{"childName": ["protected MBeanServerConnection getMBeanServerConnection(String childName) {", "    MBeanConnectionInfo connInfo = connections.get(childName);", "    if (connInfo == null) {", "      connections.put(childName, connInfo);", "    long childPid = main.getFirstJavaChildPid(childName);", "    if (childPid > 0 && childPid != connInfo.childPid && connInfo.connector != null) {", "        connInfo.connector.close();", "    if (childPid > 0) {", "        if (connInfo.connector == null) {", "          connInfo.connector = DeployerControl.getJMXConnector(childPid);", "        if (connInfo.connector != null && connInfo.server == null) {", "          connInfo.server = connInfo.connector.getMBeanServerConnection();", "          connInfo.childPid = childPid;", "          connInfo.connector.close();", "    return connInfo.server;"]}
{"childName": ["protected void closeMBeanServerConnection(String childName) {", "    MBeanConnectionInfo connInfo = connections.get(childName);", "    if (connInfo != null && connInfo.connector != null) {", "        connInfo.connector.close();"]}
{"context": ["protected void init(Context context) {", "    LayoutInflater.from(context).inflate(R.layout.fake_search_view, this, true);"]}
{"args": ["public static void main(String[] args) throws Throwable {", "            Object res = startup.invoke(instance, new Object[]{args});", "            int rc = (Integer) res;", "            if (rc != 0) {", "                System.exit(rc);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"tableName": ["public Table findTable(String tableName) {\r", "\t\tif (tableName == null) {\r", "\t\tif (tableName.isEmpty()) {\r", "\t\t\t\tif (table.originalName.equals(tableName)) {\r", "\t\t\t\t+ tableName);\r"]}
{"tableOriginalName": ["public Bean findBean(String tableOriginalName) {\r", "\t\t\t\tif (bean.table.originalName.equals(tableOriginalName)) {\r", "\t\tthrow new BeanNotFoundException(\"invalid table reference : \" + tableOriginalName);\r"]}
{"bean": ["public List<ViewProperty> getReferenceProperties(Bean bean) {\r", "\t\tfor (int i = 0; i < bean.cardinality; i++) {\r", "\t\t\tProperty property = bean.properties.get(i);\r", "\t\t\tresult.addAll(property.viewProperties);\r"]}
{"oneToMany": ["private List<ViewProperty> getVisibleProperties(OneToMany oneToMany) {\r", "\t\treturn getViewPropertiesExcludingField(oneToMany.referenceBean, oneToMany.referenceProperty.name);\r"]}
{"target": ["public void update(Versionable target, Versionable source) {\r", "        target.setDirty(source.getDirty());\r", "        target.setMajorVersion(source.getMajorVersion());\r", "        target.setMidVersion(source.getMidVersion());\r", "        target.setMinorVersion(source.getMinorVersion());\r", "        target.setModifierId(source.getModifierId());\r", "        target.setReason(source.getReason());\r", "        target.setModificationTime(source.getModificationTime());\r", "        target.setHistoryList(source.getHistoryList());\r", "            target.updateHistory();\r"], "source": ["public void update(Versionable target, Versionable source) {\r", "        target.setDirty(source.getDirty());\r", "        target.setMajorVersion(source.getMajorVersion());\r", "        target.setMidVersion(source.getMidVersion());\r", "        target.setMinorVersion(source.getMinorVersion());\r", "        target.setModifierId(source.getModifierId());\r", "        target.setReason(source.getReason());\r", "        target.setModificationTime(source.getModificationTime());\r", "        target.setHistoryList(source.getHistoryList());\r"]}
{"history": ["public void addHistory(History history) {\r", "        getHistoryList().add(history);\r"]}
{"session": ["    public void customize(Session session) throws Exception {", "            connector = (JNDIConnector) session.getLogin().getConnector(); // possible CCE", "                    = (JNDIConnector) session.getLogin().getConnector();", "                    = (JNDIConnector) ((DatabaseLogin) ((ServerSession) session)", "            session.getLogin().setConnector(connector);"]}
{"name": ["public RequirementSpecNodeServer addSpecNode(String name,", "                name, description, scope);"], "description": ["            String description, String scope) throws Exception {", "                name, description, scope);"], "scope": ["            String description, String scope) throws Exception {", "        RequirementSpecNodeServer sns = new RequirementSpecNodeServer(", "                name, description, scope);", "        sns.write2DB();", "                        .findRequirementSpecNode(sns.getRequirementSpecNodePK()));", "        return sns;"]}
{"Result": "Method without Parameter"}
{"typename": ["public static IssueType getType(String typename) {\r", "            if (type.getTypeName().equals(typename)) {\r"]}
{"s": ["    public static VmSetting getSetting(String s) {\r", "        PARAMETERS.put(\"setting\", s);\r"]}
{"name": ["public static DataEntry getStringField(String name, String expected,\r", "        de.setEntryName(name);\r"], "expected": ["public static DataEntry getStringField(String name, String expected,\r", "        if (expected != null) {\r", "                    .setPropertyValue(expected);\r"], "matchCase": ["            boolean matchCase) {\r", "                    .setPropertyValue(matchCase ? \"true\" : \"false\");\r"]}
{"name": ["public static DataEntry getBooleanField(String name) {\r", "        de.setEntryName(name);\r"]}
{"name": ["public static DataEntry getNumericField(String name, Float min, Float max) {\r", "        de.setEntryName(name);\r"], "min": ["public static DataEntry getNumericField(String name, Float min, Float max) {\r", "            if (dep.getPropertyName().equals(\"property.min\") && min != null) {\r", "                dep.setPropertyValue(min.toString());\r"], "max": ["public static DataEntry getNumericField(String name, Float min, Float max) {\r", "            if (dep.getPropertyName().equals(\"property.max\") && max != null) {\r", "                dep.setPropertyValue(max.toString());\r"]}
{"w": ["private void displayWorkflow(Workflow w) {\r", "        Graph graph = new Graph(w.getWorkflowName(), Graph.DIGRAPH);\r", "        w.getWorkflowStepList().forEach(step -> {\r"]}
{"Result": "Method without Parameter"}
{"c": ["private static void walkComponentTree(Component c, Consumer<Component> visitor) {\r", "        visitor.accept(c);\r", "        if (c instanceof HasComponents) {\r", "            for (Component child : ((HasComponents) c)) {\r", "                walkComponentTree(child, visitor);\r"], "visitor": ["private static void walkComponentTree(Component c, Consumer<Component> visitor) {\r", "        visitor.accept(c);\r", "                walkComponentTree(child, visitor);\r"]}
{"filename": ["    public OutputStream receiveUpload(String filename,", "                    filename.substring(filename.lastIndexOf('.')));"], "MIMEType": []}
{"Result": "Method without Parameter"}
{"descriptor": ["    protected <D extends FileDescriptor> D toFileDescriptor(Descriptor descriptor, Class<D> type, String path, ScannerContext context) {", "        if (descriptor == null) {", "        return migrateOrCast(descriptor, type, context);"], "type": ["    protected <D extends FileDescriptor> D toFileDescriptor(Descriptor descriptor, Class<D> type, String path, ScannerContext context) {", "            D result = context.getStore().create(type);", "            result.setFileName(path);", "            return result;", "        return migrateOrCast(descriptor, type, context);"], "path": ["    protected <D extends FileDescriptor> D toFileDescriptor(Descriptor descriptor, Class<D> type, String path, ScannerContext context) {", "            result.setFileName(path);"], "context": ["    protected <D extends FileDescriptor> D toFileDescriptor(Descriptor descriptor, Class<D> type, String path, ScannerContext context) {", "            D result = context.getStore().create(type);", "        return migrateOrCast(descriptor, type, context);"]}
{"cause": ["  public static BlockscoreError getBlockscoreError(@NotNull final RetrofitError cause) {", "    Object rawError = cause.getBodyAs(BlockscoreError.class);"]}
{"answers": ["  public void score(@NotNull final AnswerSet answers) {", "    QuestionSet scoredSet = restAdapter.scoreQuestionSet(getId(), answers);", "    expired = scoredSet.isExpired();", "    score = scoredSet.getScore();"]}
{"stream": ["public <D extends MD5Descriptor> D digest(InputStream stream, DigestOperation<D> digestOperation) throws IOException {", "        DigestInputStream digestInputStream = new DigestInputStream(stream, md5Digest);"], "digestOperation": ["public <D extends MD5Descriptor> D digest(InputStream stream, DigestOperation<D> digestOperation) throws IOException {", "        D md5Descriptor = digestOperation.execute(digestInputStream);"]}
{"path": ["public boolean accepts(String path) {", "            result = matches(path, includeFilePatterns);", "            result = result && !matches(path, excludeFilePatterns);"]}
{"questionId": ["public void addAnswer(int questionId, int answerId) {", "    QuestionAnswerPair answerPair = new QuestionAnswerPair(questionId, answerId);"], "answerId": ["public void addAnswer(int questionId, int answerId) {", "    QuestionAnswerPair answerPair = new QuestionAnswerPair(questionId, answerId);", "    answers.add(answerPair);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"timeLimit": ["public QuestionSet createQuestionSet(long timeLimit) {", "    queryOptions.put(\"time_limit\", String.valueOf(timeLimit));"]}
{"questionSetId": ["public QuestionSet retrieveQuestionSet(@NotNull final String questionSetId) {", "    QuestionSet questionSet = restAdapter.retrieveQuestionSet(questionSetId);", "    questionSet.setAdapter(restAdapter);", "    return questionSet;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"entityType": ["public PaginatedResult<WatchlistHit> searchWatchlists(EntityType entityType, Double similarityThreshold) {", "    if (entityType != null) {", "      queryOptions.put(\"match_type\", String.valueOf(entityType));"], "similarityThreshold": ["public PaginatedResult<WatchlistHit> searchWatchlists(EntityType entityType, Double similarityThreshold) {", "    if (similarityThreshold != null) {", "      queryOptions.put(\"similarity_threshold\", String.valueOf(similarityThreshold));"]}
{"dateOfBirth": ["  public Candidate setDateOfBirth(@Nullable final Date dateOfBirth) {", "    if (dateOfBirth == null) {", "    this.dateOfBirth = new Date(dateOfBirth.getTime());"]}
{"address": ["public Candidate setAddress(@NotNull final Address address) {", "    this.addressStreet1 = address.getStreet1();", "    this.addressStreet2 = address.getStreet2();", "    this.addressCity = address.getCity();", "    this.addressSubdivision = address.getSubdivision();", "    this.addressPostalCode = address.getPostalCode();", "    this.addressCountryCode = address.getCountryCode();"]}
{"id": ["  public Person retrievePerson(@NotNull final String id) {", "    Person person = restAdapter.retrievePerson(id);", "    person.setAdapter(restAdapter);", "    return person;"]}
{"id": ["  public Candidate retrieveCandidate(@NotNull final String id) {", "    Candidate candidate = restAdapter.retrieveCandidate(id);", "    candidate.setAdapter(restAdapter);", "    return candidate;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"expectedSuperClass": ["protected <T> Class<T> getTypeParameter(Class<?> expectedSuperClass, int genericTypeParameterIndex) {", "        if (!thisClass.getSuperclass().equals(expectedSuperClass)) {"], "genericTypeParameterIndex": ["protected <T> Class<T> getTypeParameter(Class<?> expectedSuperClass, int genericTypeParameterIndex) {", "        Type typeParameter = ((ParameterizedType) genericSuperclass).getActualTypeArguments()[genericTypeParameterIndex];", "        if (typeParameter instanceof ParameterizedType) {", "            return (Class<T>) ((ParameterizedType) typeParameter).getRawType();", "        return (Class<T>) typeParameter;"]}
{"name": ["protected String getStringProperty(String name, String defaultValue) {", "        Object value = properties.get(name);", "        return value != null ? value.toString() : defaultValue;"], "defaultValue": ["protected String getStringProperty(String name, String defaultValue) {", "        return value != null ? value.toString() : defaultValue;"]}
{"name": ["protected Boolean getBooleanProperty(String name, Boolean defaultValue) {", "        Object value = properties.get(name);", "        return value != null ? Boolean.valueOf(value.toString()) : defaultValue;"], "defaultValue": ["protected Boolean getBooleanProperty(String name, Boolean defaultValue) {", "        return value != null ? Boolean.valueOf(value.toString()) : defaultValue;"]}
{"directory": ["protected String getDirectoryPath(File directory, File entry) {", "        if (entry.equals(directory)) {", "            String directoryPath = directory.getAbsolutePath();"], "entry": ["protected String getDirectoryPath(File directory, File entry) {", "        if (entry.equals(directory)) {", "            String filePath = entry.getAbsolutePath();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"target": ["private void sync(Collection<FileDescriptor> target, Map<String, FileDescriptor> after) {", "        Map<String, FileDescriptor> before = getCache(target);", "        all.putAll(before);", "            boolean hasBefore = before.containsKey(key);", "            if (hasBefore && !hasAfter) {", "                target.remove(fileDescriptor);", "            } else if (!hasBefore && hasAfter) {", "                target.add(fileDescriptor);"], "after": ["private void sync(Collection<FileDescriptor> target, Map<String, FileDescriptor> after) {", "        all.putAll(after);", "            boolean hasAfter = after.containsKey(key);", "            if (hasBefore && !hasAfter) {", "            } else if (!hasBefore && hasAfter) {"]}
{"fileDescriptors": ["private Map<String, FileDescriptor> getCache(Iterable<FileDescriptor> fileDescriptors) {", "        for (FileDescriptor fileDescriptor : fileDescriptors) {", "            cache.put(fileDescriptor.getFileName(), fileDescriptor);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"_name": ["    public StringValue getParameterValue(final String _name)", "        final List<StringValue> values = this.parameters.get(_name);", "        return (values != null && !values.isEmpty()) ? values.get(0)"]}
{"_name": ["    public void setParameterValues(final String _name,", "        this.parameters.put(_name, _value);", "            Context.getThreadContext().getParameters().put(_name, ParameterUtil.stringValues2Array(_value));", "            EFapsRequestParametersAdapter.LOG.error(\"Could not set parameter '{}' in Context.\", _name);"], "_value": ["                                   final List<StringValue> _value)", "        this.parameters.put(_name, _value);", "            Context.getThreadContext().getParameters().put(_name, ParameterUtil.stringValues2Array(_value));"]}
{"_key": ["public void setParameterValue(final String _key,", "        setParameterValues(_key, list);"], "_value": ["                                  final String _value)", "        list.add(StringValue.valueOf(_value));"]}
{"_key": ["public void addParameterValue(final String _key,", "        List<StringValue> list = this.parameters.get(_key);", "        if (list == null) {", "            this.parameters.put(_key, list);", "        list.add(StringValue.valueOf(_value));", "            Context.getThreadContext().getParameters().put(_key, ParameterUtil.stringValues2Array(list));", "            EFapsRequestParametersAdapter.LOG.error(\"Could not add parameter '{}' in Context.\", _key);"], "_value": ["                                  final String _value)", "        list.add(StringValue.valueOf(_value));"]}
{"Result": "Method without Parameter"}
{"_key": ["protected Object getValue4Wizard(final String _key)", "        if (para != null && para.containsKey(_key)) {", "            final String[] value = para.get(_key);", "            ret = value[0];"]}
{"_oid": ["public String registerOID(final String _oid)", "        getUiID2Oid().put(ret, _oid);"]}
{"_wicketId": ["    public Component newNodeComponent(final String _wicketId,", "        return new Node<UIStructurBrowser>(_wicketId, this, _model)", "            protected Component createContent(final String _wicketId,", "                return newContentComponent(_wicketId, _model);"], "_model": ["                                      final IModel<UIStructurBrowser> _model)", "        return new Node<UIStructurBrowser>(_wicketId, this, _model)", "                                              final IModel<UIStructurBrowser> _model)", "                return newContentComponent(_wicketId, _model);"]}
{"_wicketId": ["    public Component newSubtree(final String _wicketId,", "        return new SubElement(_wicketId, this, _model);"], "_model": ["                                final IModel<UIStructurBrowser> _model)", "        return new SubElement(_wicketId, this, _model);"]}
{"indexFlavors": ["public static Set<IndexFlavor> complementOf(final Set<IndexFlavor> indexFlavors) {", "        set.removeAll(indexFlavors);"]}
{"first": ["public static Set<IndexFlavor> of(final IndexFlavor first, final IndexFlavor... rest) {", "        set.add(first);"]}
{"key": ["    public V put(final K key, final V value) {", "        entries.add(new Entry(key, value));"], "value": ["    public V put(final K key, final V value) {", "        entries.add(new Entry(key, value));", "        return value;"]}
{"key": ["    public V remove(final Object key) {", "            if (key.equals(entry.getKey())) {"]}
{"_id": ["public String getRandom4ID(final Long _id)", "        this.random2id.put(rid, _id);"]}
{"Result": "Method without Parameter"}
{"_sortdirection": ["public void setSortDirection(final SortDirection _sortdirection)", "        this.sortDirection = _sortdirection;", "                            _sortdirection.getValue());"]}
{"_markupsIds": ["public void setColumnOrder(final String _markupsIds)", "        final StringTokenizer tokens = new StringTokenizer(_markupsIds, \";\");"]}
{"Result": "Method without Parameter"}
{"_tag": ["    protected void onComponentTag(final ComponentTag _tag)", "        super.onComponentTag(_tag);", "            _tag.put(\"class\", \"sortLabelAsc\");", "            _tag.put(\"class\", \"sortLabelDsc\");"]}
{"_markupStream": ["    public void onComponentTagBody(final MarkupStream _markupStream,", "        replaceComponentTagBody(_markupStream, _openTag, this.header);"], "_openTag": ["                                      final ComponentTag _openTag)", "        replaceComponentTagBody(_markupStream, _openTag, this.header);"]}
{"Result": "Method without Parameter"}
{"name": ["public static Config getConfig(String name, IConfigFactory factory) {", "    if (name == null) {", "    Config got = configs.get(name);", "    if (got == null) {", "      log(true, \"No Config instance named \" + name + \"... requesting a new one\", null);", "      synchronized (name.intern()) {", "        got = configs.get(name);", "        if (got == null) {", "          got = factory == null ? load(name) : factory.createConfig(name);", "          if (got == null) {", "          configs.put(name, got);", "    return got;"], "factory": ["public static Config getConfig(String name, IConfigFactory factory) {", "          got = factory == null ? load(name) : factory.createConfig(name);", "            log(false, \"Factory \" + factory + \" returned a null Config\", null);", "                \"Invalid Config returned by \" + factory + \" factory: null\");"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"_clazz": ["protected CharSequence getDataLine(final Classification _clazz, final IClassificationFilter _filter)", "        if (_clazz.hasAccess(null, AccessTypeEnums.SHOW.getAccessType())) {", "            js.append(\",\\n{id:'\").append(_clazz.getUUID()).append(\"', name:'\")", "                .append(StringEscapeUtils.escapeEcmaScript(_clazz.getLabel())).append(\"', parent:'\")", "                .append(_clazz.isRoot() ? \"root\" : _clazz.getParentClassification().getUUID()).append(\"', selected:\")", "                .append(_filter.contains(_clazz.getUUID())).append(\"}\");", "            for (final Classification childClazz: _clazz.getChildClassifications()) {", "                js.append(getDataLine(childClazz, _filter));"], "_filter": ["protected CharSequence getDataLine(final Classification _clazz, final IClassificationFilter _filter)", "                .append(_filter.contains(_clazz.getUUID())).append(\"}\");", "                js.append(getDataLine(childClazz, _filter));"]}
{"_instance": ["public void execute(final Instance _instance)", "            child.addChildren(child, type.getChildClassifications(), clazz.selectedUUID, _instance);"]}
{"Result": "Method without Parameter"}
{"_parent": ["private void addChildren(final UIClassification _parent,", "                final UIClassification childUI = new UIClassification(child.getUUID(), _parent.mode, false);", "                childUI.addChildren(childUI, child.getChildClassifications(), _selectedUUID, _instance);", "                _parent.children.add(childUI);", "                childUI.setParent(_parent);", "        Collections.sort(_parent.children, new Comparator<UIClassification>()"], "_children": ["                             final Set<Classification> _children,", "        for (final Classification child : _children) {", "            if (!child.isAbstract()) {", "                final Instance inst = AbstractInstanceObject.getInstance4Create(child);", "                access = child.hasAccess(inst, getMode() == TargetMode.CREATE", "            if (access) {", "                final UIClassification childUI = new UIClassification(child.getUUID(), _parent.mode, false);", "                if (_selectedUUID.contains(child.getUUID())) {", "                childUI.addChildren(childUI, child.getChildClassifications(), _selectedUUID, _instance);", "                _parent.children.add(childUI);", "                childUI.setParent(_parent);"], "_selectedUUID": ["                             final Set<UUID> _selectedUUID,", "                if (_selectedUUID.contains(child.getUUID())) {", "                childUI.addChildren(childUI, child.getChildClassifications(), _selectedUUID, _instance);"], "_instance": ["                             final Instance _instance)", "                childUI.addChildren(childUI, child.getChildClassifications(), _selectedUUID, _instance);"]}
{"_instance": ["public Map<UUID, String> getClassInstanceKeys(final Instance _instance)", "                queryBldr.addWhereAttrEqValue(classType.getRelLinkAttributeName(), _instance.getId());", "                    subQueryBldr.addWhereAttrEqValue(subClassType.getLinkAttributeName(), _instance.getId());"]}
{"Result": "Method without Parameter"}
{"highlightExpression": ["public ViewDocumentRequestBuilder addHighlightExpressions(final String highlightExpression, final String... highlightExpressions) {", "        this.highlightExpressions.add(highlightExpression);"]}
{"startTag": ["public ViewDocumentRequestBuilder addStartTags(final String startTag, final String... startTags) {", "        this.startTags.add(startTag);"]}
{"endTag": ["public ViewDocumentRequestBuilder addEndTags(final String endTag, final String... endTags) {", "        this.endTags.add(endTag);"]}
{"_markupId": ["public Component getLazyLoadComponent(final String _markupId,", "        return new WebMarkupContainer(_markupId)"], "_html": ["                                          final String _html)", "                replaceComponentTagBody(_markupStream, _openTag, _html);"]}
{"_markupId": ["public Component getLoadingComponent(final String _markupId)", "        return new Label(_markupId, \"<img alt=\\\"Loading...\\\" src=\\\"\" + RequestCycle.get().urlFor(handler) + \"\\\"/>\")"]}
{"_target": []}
{"_element": ["public void insertBefore(final IWizardElement _element)", "                this.elements.add(i, _element);"]}
{"Result": "Method without Parameter"}
{"_element": ["public void addParameters(final IWizardElement _element,", "        this.parameters.put(_element, _parameters);"], "_parameters": ["                              final Map<String, String[]> _parameters)", "        this.parameters.put(_element, _parameters);"]}
{"Result": "Method without Parameter"}
{"_uiclass": ["public void addClassElements(final UIClassification _uiclass,", "        this.elements.addAll(getClassElements(_uiclass, _instanceKeys));"], "_instanceKeys": ["                                 final Map<UUID, String> _instanceKeys)", "        this.elements.addAll(getClassElements(_uiclass, _instanceKeys));"]}
{"_uiclass": ["public void updateClassElements(final UIClassification _uiclass)", "        addClassElements(_uiclass, uuid2InstanceKey);"]}
{"_formElement": ["private boolean addCell2FormRow(final FormElement _formElement,", "                _formElement.addValue(evaluateFieldSet(_query, _field, fieldInstance));", "                _formElement.addValue(cell);", "                _formElement.addValue(cell);", "                _formElement.addValue(evaluateUIProvider(_query, _field, fieldInstance, attr));"], "_query": ["                                    final PrintQuery _query,", "            attr = _query.getAttribute4Attribute(_field.getAttribute());", "            attr = _query.getAttribute4Select(_field.getSelect());", "        final Instance fieldInstance = evaluateFieldInstance(_query, _field);", "                _query.getAttribute(_field.getAttribute());", "                _query.getSelect(_field.getSelect());", "                _query.getPhrase(_field.getName());", "            addHidden(evaluateUIProvider(_query, _field, fieldInstance, attr));", "                _formElement.addValue(evaluateFieldSet(_query, _field, fieldInstance));", "                _formElement.addValue(evaluateUIProvider(_query, _field, fieldInstance, attr));"], "_field": ["                                    final Field _field)", "        if (_field.getAttribute() != null) {", "            attr = _query.getAttribute4Attribute(_field.getAttribute());", "        } else if (_field.getSelect() != null) {", "            attr = _query.getAttribute4Select(_field.getSelect());", "        final Instance fieldInstance = evaluateFieldInstance(_query, _field);", "        if (_field.isHiddenDisplay(getMode())) {", "            if (_field.getAttribute() != null) {", "                _query.getAttribute(_field.getAttribute());", "            } else if (_field.getSelect() != null) {", "                _query.getSelect(_field.getSelect());", "            } else if (_field.getPhrase() != null) {", "                _query.getPhrase(_field.getName());", "            addHidden(evaluateUIProvider(_query, _field, fieldInstance, attr));", "            if (_field instanceof FieldSet) {", "                _formElement.addValue(evaluateFieldSet(_query, _field, fieldInstance));", "            } else if (_field instanceof FieldCommand) {", "                final UICmdField cell = new UICmdField(this, (FieldCommand) _field, getInstance());", "            } else if (_field instanceof FieldPicker) {", "                                UIValue.get(_field, attr, null).setClassObject(this).setInstance(getInstance())", "                final UIPicker picker = new UIPicker((FieldPicker) _field, cell);", "                _formElement.addValue(evaluateUIProvider(_query, _field, fieldInstance, attr));"]}
{"_print": ["private UIField evaluateUIProvider(final PrintQuery _print,", "            value = _print.<Object>getAttribute(_field.getAttribute());", "            value = _print.<Object>getSelect(_field.getSelect());", "            value = _print.getPhrase(_field.getName());", "            value = _print.getMsgPhrase(new SelectBuilder(getBaseSelect4MsgPhrase(_field)), _field.getMsgPhrase());"], "_field": ["                                       final Field _field,", "        if (_field.getAttribute() != null) {", "            value = _print.<Object>getAttribute(_field.getAttribute());", "        } else if (_field.getSelect() != null) {", "            value = _print.<Object>getSelect(_field.getSelect());", "        } else if (_field.getPhrase() != null) {", "            value = _print.getPhrase(_field.getName());", "        } else if (_field.getMsgPhrase() != null) {", "            value = _print.getMsgPhrase(new SelectBuilder(getBaseSelect4MsgPhrase(_field)), _field.getMsgPhrase());", "        final UIField uiField = new UIField(this, _fieldInstance.getKey(), UIValue.get(_field, _attr, value)"], "_fieldInstance": ["                                       final Instance _fieldInstance,", "        final UIField uiField = new UIField(this, _fieldInstance.getKey(), UIValue.get(_field, _attr, value)", "                        .setInstance(_fieldInstance)"], "_attr": ["                                       final Attribute _attr)", "        final UIField uiField = new UIField(this, _fieldInstance.getKey(), UIValue.get(_field, _attr, value)"]}
{"_query": ["private UIFieldSet evaluateFieldSet(final PrintQuery _query,", "        final Map<?, ?> tmp = (Map<?, ?>) _query.getAttributeSet(_field.getAttribute());", "            fieldins.addAll(_query.getInstances4Attribute(_field.getAttribute()));"], "_field": ["                                        final Field _field,", "        final AttributeSet attrSet = AttributeSet.find(getInstance().getType().getName(), _field.getAttribute());", "        final Map<?, ?> tmp = (Map<?, ?>) _query.getAttributeSet(_field.getAttribute());", "            fieldins.addAll(_query.getInstances4Attribute(_field.getAttribute()));", "                        UIValue.get(_field, getInstance().getType().getAttribute(_field.getAttribute()), null));", "        for (final String attrName : ((FieldSet) _field).getOrder()) {", "            final Attribute child = attrSet.getAttribute(attrName);", "            final UIFieldSetColHeader column = new UIFieldSetColHeader(_field.getLabel(), child, _field);", "            ret.addHeader(column);", "            for (final String attrName : ((FieldSet) _field).getOrder()) {", "                final Attribute child = attrSet.getAttribute(attrName);", "                Iterator<?> valIter = values.get(attrName);", "                if (valIter == null) {", "                    final List<?> tmplist = (List<?>) tmp.get(attrName);", "                    valIter = tmplist.iterator();", "                    values.put(attrName, valIter);", "                final UIValue uiValue = UIValue.get(_field, child, valIter.hasNext() ? valIter.next() : null);", "                                new UIFieldSetValue(this, rowInstance.getKey(), ret, uiValue));"], "_fieldInstance": ["                                        final Instance _fieldInstance)", "        final UIFieldSet ret = new UIFieldSet(this, _fieldInstance,"]}
{"_uiclass": ["private List<Element> getClassElements(final UIClassification _uiclass,", "        if (_uiclass.isSelected() && !_uiclass.isRoot()) {", "            if (_uuid2InstanceKey.containsKey(_uiclass.getClassificationUUID())) {", "                                _uuid2InstanceKey.get(_uiclass.getClassificationUUID()));", "                fieldform = new UIFieldForm(getCommandUUID(), _uiclass);", "                    fieldform.setMode(TargetMode.CREATE);", "            ret.add(new Element(ElementType.SUBFORM, fieldform));", "        for (final UIClassification child : _uiclass.getChildren()) {", "            ret.addAll(getClassElements(child, _uuid2InstanceKey));"], "_uuid2InstanceKey": ["                                           final Map<UUID, String> _uuid2InstanceKey)", "            if (_uuid2InstanceKey.containsKey(_uiclass.getClassificationUUID())) {", "                                _uuid2InstanceKey.get(_uiclass.getClassificationUUID()));", "            ret.addAll(getClassElements(child, _uuid2InstanceKey));"]}
{"_menuItem": ["private CharSequence getSubMenuItem(final UIMenuItem _menuItem,", "        if (_menuItem.getChildren().isEmpty()) {", "                .append(getEventJs(_menuItem))", "        for (final UIMenuItem childItem : _menuItem.getChildren()) {", "            if (!childItem.getChildren().isEmpty()) {", "                .append(getImage(childItem, node3))", "                .append(StringEscapeUtils.escapeEcmaScript(StringEscapeUtils.escapeHtml4(childItem.getLabel())))", "                .append(getSubMenuItem(childItem, node2, node3));"], "_parentNode": ["                                        final String _parentNode,", "                .append(_parentNode).append(\");\\n\")"], "_titleNode": ["                                        final String _titleNode)", "            js.append(\" on(\").append(_titleNode).append(\", \\\"click\\\", function(evt) {\\n\")", "                .append(\" on(\").append(_titleNode).append(\", \\\"click\\\", function(evt) {\\n\")"]}
{"_menuItem": ["private CharSequence getEventJs(final UIMenuItem _menuItem)", "        this.menuItems.put(key, _menuItem);", "        switch (_menuItem.getTarget()) {", "                popupSettings.setHeight(_menuItem.getWindowHeight());", "                popupSettings.setWidth(_menuItem.getWindowWidth());"]}
{"_menuItem": ["private CharSequence getImage(final UIMenuItem _menuItem,", "        final String label = _menuItem.getLabel();", "        if (StringUtils.isNotEmpty(_menuItem.getImage()) && _menuItem.getImage().endsWith(\".svg\")) {", "                querBldr.addWhereAttrEqValue(CIAdminUserInterface.Image.Name, _menuItem.getImage());"], "_node": ["                                  final String _node)", "                        .append(\"}, \").append(_node).append(\");\\n\");", "                .append(\"}, \").append(_node).append(\");\\n\");"]}
{"_class": ["protected AjaxEventBehavior getBehavior(final Class<? extends Behavior> _class)", "            final List<? extends Behavior> behaviors = _item.getBehaviors(_class);", "            if (CollectionUtils.isNotEmpty(behaviors)) {", "                _visit.stop((AjaxEventBehavior) behaviors.get(0));"]}
{"_headingmodel": ["public void addComponents(final Model<UIHeading> _headingmodel)", "        if (_headingmodel.getObject().getLevel() == 0) {", "            container.add(AttributeModifier.replace(\"class\", \"eFapsHeading\" + _headingmodel.getObject().getLevel()));", "        container.add(new Label(\"heading\", _headingmodel.getObject().getLabel()));", "                return _headingmodel.getObject().getLevel() > 0 && _headingmodel.getObject().isCollapsible();", "                _tag.put(\"name\", _headingmodel.getObject().getName());", "                return _headingmodel.getObject().getLevel() > 0 && _headingmodel.getObject().isCollapsible();"]}
{"_node": ["    public Iterator<? extends UIStructurBrowser> getChildren(final UIStructurBrowser _node)", "        if (_node.isParent() && !_node.hasChildren()) {", "            _node.addChildren();", "        return _node.getChildren().iterator();"]}
{"tokenProxy": ["        final TokenProxy<BE, BT> tokenProxy,", "        return responseParser.parseResponse(tokenProxy, returnType, backendCaller.makeRequest(getAuthenticationToken(tokenProxy)));"], "returnType": ["        final Class<U> returnType,", "        return responseParser.parseResponse(tokenProxy, returnType, backendCaller.makeRequest(getAuthenticationToken(tokenProxy)));"], "backendCaller": ["        final BackendCaller<? super BE, ? super BT> backendCaller", "        return responseParser.parseResponse(tokenProxy, returnType, backendCaller.makeRequest(getAuthenticationToken(tokenProxy)));"]}
{"tokenProxy": ["        final TokenProxy<BE, BT> tokenProxy,", "        return responseParser.parseResponse(tokenProxy, typeReference, backendCaller.makeRequest(getAuthenticationToken(tokenProxy)));"], "typeReference": ["        final TypeReference<U> typeReference,", "        return responseParser.parseResponse(tokenProxy, typeReference, backendCaller.makeRequest(getAuthenticationToken(tokenProxy)));"], "backendCaller": ["        final BackendCaller<? super BE, ? super BT> backendCaller", "        return responseParser.parseResponse(tokenProxy, typeReference, backendCaller.makeRequest(getAuthenticationToken(tokenProxy)));"]}
{"tokenProxy": ["        final TokenProxy<BE, BT> tokenProxy,", "        return responseParser.parseResponse(tokenProxy, backendCaller.makeRequest(getAuthenticationToken(tokenProxy)));"], "backendCaller": ["        final BackendCaller<? super BE, ? super BT> backendCaller", "        return responseParser.parseResponse(tokenProxy, backendCaller.makeRequest(getAuthenticationToken(tokenProxy)));"]}
{"tokenProxy": ["        final TokenProxy<BE, BT> tokenProxy,", "        return responseParser.unsafeParseResponse(tokenProxy, type, backendCaller.makeRequest(getAuthenticationToken(tokenProxy)));"], "type": ["        final JavaType type,", "        return responseParser.unsafeParseResponse(tokenProxy, type, backendCaller.makeRequest(getAuthenticationToken(tokenProxy)));"], "backendCaller": ["        final BackendCaller<? super BE, ? super BT> backendCaller", "        return responseParser.unsafeParseResponse(tokenProxy, type, backendCaller.makeRequest(getAuthenticationToken(tokenProxy)));"]}
{"body": ["    public Object fromBody(final TypedInput body, final Type type) throws ConversionException {", "            return converter.fromBody(body, type);"], "type": ["    public Object fromBody(final TypedInput body, final Type type) throws ConversionException {", "            return converter.fromBody(body, type);"]}
{"_component": ["    public void renderHead(final Component _component,", "        super.renderHead(_component, _response);"], "_response": ["                           final IHeaderResponse _response)", "        super.renderHead(_component, _response);", "        _response.render(AbstractEFapsHeaderItem.forJavaScript(AjaxFieldUpdateBehavior.JS));"]}
{"_target": ["    protected void onError(final AjaxRequestTarget _target)", "                _target.add(msg.getReporter());", "            modal.show(_target);"]}
{"_job": ["public ExecutionBridge launch(final IJob _job,", "        this.executorService.execute(new JobRunnable(_job, bridge));"], "_jobName": ["                                  final String _jobName)", "        if (_jobName == null) {", "            bridge.setJobName(_jobName);"]}
{"referencePrefix": ["public AddToTextIndexRequestBuilder addReferencePrefixes(final String referencePrefix, final String... referencePrefixes) {", "        this.referencePrefixes.add(referencePrefix);"]}
{"metadatum": ["public AddToTextIndexRequestBuilder addAdditionalMetadata(final Object metadatum, final Object... metadata) {", "        this.additionalMetadata.add(metadatum);"]}
{"category0": ["public QueryProfileRequestBuilder addPromotionCategories(final String category0, final String... categories) {", "        promotionCategories.add(category0);"]}
{"category0": ["public QueryProfileRequestBuilder addSynonymCategories(final String category0, final String... categories) {", "        synonymCategories.add(category0);"]}
{"category0": ["public QueryProfileRequestBuilder addBlacklistCategories(final String category0, final String... categories) {", "        blacklistCategories.add(category0);"]}
{"_target": ["public void initiate(final IPartialPageRequestHandler _target)", "            _target.prependJavaScript(getCallBackScript(url));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"_url": ["protected CharSequence getCallBackScript(final String _url)", "            .append(\"node.src='\").append(_url).append(\"';\")"]}
{"_application": ["public void sendKeepAlive(final Application _application)", "        final ConcurrentMap<String, IKey> sessionId2key = _application.getMetaData(ConnectionRegistry.SESSION2KEY);", "        final ConcurrentMap<String, Long> keepalive = _application.getMetaData(ConnectionRegistry.KEEPALIVE);", "                        final IWebSocketConnectionRegistry registry = WebSocketSettings.Holder.get(", "                                        _application).getConnectionRegistry();", "                        final IWebSocketConnection conn = registry.getConnection(_application, entry.getKey(), key);", "                        if (conn != null) {", "                                conn.sendMessage(KeepAliveBehavior.MSG);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"_markupStream": ["    public void onComponentTagBody(final MarkupStream _markupStream,", "        super.replaceComponentTagBody(_markupStream, _openTag, value);"], "_openTag": ["                                      final ComponentTag _openTag)", "            final ComponentTag tmpTag = new ComponentTag(_openTag);", "                behavior.onComponentTag(this, tmpTag);", "            final IValueMap map = tmpTag.getAttributes();", "        super.replaceComponentTagBody(_markupStream, _openTag, value);"]}
{"Result": "Method without Parameter"}
{"_instanceKey": ["public static EmbeddedLink getDashboardLink(final String _instanceKey,", "        final EmbeddedLink ret = new EmbeddedLink(_instanceKey);", "        ret.setTagHtml(TAG.DASHBOARD.getHtml());", "        ret.setIdentifier(_identifier);", "        return ret;"], "_identifier": ["                                                final String _identifier)", "        ret.setIdentifier(_identifier);"]}
{"tokenProxy": ["<T> T parseResponse(final TokenProxy<?, ?> tokenProxy, final Class<T> clazz, final Response response) {", "        return unsafeParseResponse(tokenProxy, objectMapper.constructType(clazz), response);"], "clazz": ["<T> T parseResponse(final TokenProxy<?, ?> tokenProxy, final Class<T> clazz, final Response response) {", "        return unsafeParseResponse(tokenProxy, objectMapper.constructType(clazz), response);"], "response": ["<T> T parseResponse(final TokenProxy<?, ?> tokenProxy, final Class<T> clazz, final Response response) {", "        return unsafeParseResponse(tokenProxy, objectMapper.constructType(clazz), response);"]}
{"tokenProxy": ["<T> T parseResponse(final TokenProxy<?, ?> tokenProxy, final TypeReference<T> typeReference, final Response response) {", "        return unsafeParseResponse(tokenProxy, objectMapper.getTypeFactory().constructType(typeReference), response);"], "typeReference": ["<T> T parseResponse(final TokenProxy<?, ?> tokenProxy, final TypeReference<T> typeReference, final Response response) {", "        return unsafeParseResponse(tokenProxy, objectMapper.getTypeFactory().constructType(typeReference), response);"], "response": ["<T> T parseResponse(final TokenProxy<?, ?> tokenProxy, final TypeReference<T> typeReference, final Response response) {", "        return unsafeParseResponse(tokenProxy, objectMapper.getTypeFactory().constructType(typeReference), response);"]}
{"tokenProxy": ["<T> T unsafeParseResponse(final TokenProxy<?, ?> tokenProxy, final JavaType type, final Response response) {", "        checkRefresh(tokenProxy, response);"], "type": ["<T> T unsafeParseResponse(final TokenProxy<?, ?> tokenProxy, final JavaType type, final Response response) {", "            return objectMapper.readValue(response.getBody().in(), type);"], "response": ["<T> T unsafeParseResponse(final TokenProxy<?, ?> tokenProxy, final JavaType type, final Response response) {", "        checkRefresh(tokenProxy, response);", "            return objectMapper.readValue(response.getBody().in(), type);"]}
{"tokenProxy": ["InputStream parseResponse(final TokenProxy<?, ?> tokenProxy, final Response response) {", "        checkRefresh(tokenProxy, response);"], "response": ["InputStream parseResponse(final TokenProxy<?, ?> tokenProxy, final Response response) {", "        checkRefresh(tokenProxy, response);", "            return response.getBody().in();"]}
{"_eventType": ["    protected List<EventDefinition> getEvents(final EventType _eventType)", "        return Field.get(this.fieldId).getEvents(_eventType);"]}
{"_tag": ["protected void onComponentTagInternal(final ComponentTag _tag)", "        _tag.put(\"name\", getConfig().getName());", "        _tag.append(\"style\", \"text-align:\" + getConfig().getAlign(), \";\");"]}
{"Result": "Method without Parameter"}
{"_component": ["    public void onComponentTag(final Component _component,", "        super.onComponentTag(_component, _tag);"], "_tag": ["                               final ComponentTag _tag)", "        super.onComponentTag(_component, _tag);", "            if (_tag.getAttribute(\"class\") != null) {", "                value += _tag.getAttribute(\"class\");", "            _tag.put(\"dndType\", this.dndType);", "            _tag.put(\"class\", value);"]}
{"_component": ["    public void renderHead(final Component _component,", "        super.renderHead(_component, _response);", "                .append(\"var nSrc = new dojo.dnd.Source(dom.byId('\").append(_component.getMarkupId(true)).append(\"'),\")"], "_response": ["                           final IHeaderResponse _response)", "        super.renderHead(_component, _response);", "        _response.render(RequireHeaderItem.forClasses(DojoClasses.DnDSource, DojoClasses.parser));", "            _response.render(OnDojoReadyHeaderItem.forScript(DojoWrapper.require(js, DojoClasses.aspect,"]}
{"_selectCmdUUID": ["public void setDefault(final UUID _selectCmdUUID)", "            if (_selectCmdUUID == null && childItem.isDefaultSelected()", "                            || _selectCmdUUID != null && _selectCmdUUID.equals(childItem.getCommandUUID())) {"]}
{"_cmdName": ["public static String getLabel(final String _cmdName,", "        if (DBProperties.hasProperty(_cmdName + \".Button.\" + _keytype)) {", "            ret = DBProperties.getProperty(_cmdName + \".Button.\" + _keytype);"], "_keytype": ["                                   final String _keytype)", "        if (DBProperties.hasProperty(_cmdName + \".Button.\" + _keytype)) {", "            ret = DBProperties.getProperty(_cmdName + \".Button.\" + _keytype);", "            ret = DBProperties.getProperty(\"default.Button.\" + _keytype);", "        return ret;"]}
{"_wicketId": ["protected Component getEditableComp(final String _wicketId,", "                ret = new SnippletField(_wicketId, Model.of(html),  _uiField);", "                ret = new DropDownField(_wicketId, Model.of(_uiField), choices);", "                ret = new RadioField(_wicketId, Model.of(_uiField), radios);", "                ret = new CheckBoxField(_wicketId, Model.of(_uiField), checkBoxes);", "                ret = new AjaxPickerButton(_wicketId, Model.<IPickable>of(_uiField));", "                ret = new NumberField(_wicketId, Model.of(_uiField), _uiField.getFieldConfiguration());", "                ret = new UploadField(_wicketId, Model.of(_uiField), false);", "                ret = new UploadField(_wicketId, Model.of(_uiField), true);"], "_uiField": ["                                        final AbstractUIField _uiField)", "        switch (_uiField.getFieldConfiguration().getUIType()) {", "                if (!_uiField.getFieldConfiguration().isHideLabel()) {", "                    _uiField.getFieldConfiguration().evalLabel(_uiField.getValue(), _uiField.getInstance());", "                final String html = String.valueOf(_uiField.getValue().getEditValue(", "                                _uiField.getParent().getMode()));", "                ret = new SnippletField(_wicketId, Model.of(html),  _uiField);", "                final List<DropDownOption> choices = DropDownOption.getChoices(_uiField.getValue()", "                                .getEditValue(_uiField.getParent().getMode()));", "                ret = new DropDownField(_wicketId, Model.of(_uiField), choices);", "                final List<RadioOption> radios = RadioOption.getChoices(_uiField.getValue()", "                                .getEditValue(_uiField.getParent().getMode()));", "                ret = new RadioField(_wicketId, Model.of(_uiField), radios);", "                final List<CheckBoxOption> checkBoxes = CheckBoxOption.getChoices(_uiField,", "                                _uiField.getValue().getEditValue(_uiField.getParent().getMode()));", "                ret = new CheckBoxField(_wicketId, Model.of(_uiField), checkBoxes);", "                ret = new AjaxPickerButton(_wicketId, Model.<IPickable>of(_uiField));", "                ret = new NumberField(_wicketId, Model.of(_uiField), _uiField.getFieldConfiguration());", "                ret = new UploadField(_wicketId, Model.of(_uiField), false);", "                ret = new UploadField(_wicketId, Model.of(_uiField), true);", "        return ret;"]}
{"Result": "Method without Parameter"}
{"_date": ["public List<StringValue> getDateAsString(final List<StringValue> _date,", "        final List<DateTime> dates = getDateList(_date, _hour, _minute, _ampm);"], "_hour": ["                                             final List<StringValue> _hour,", "        final List<DateTime> dates = getDateList(_date, _hour, _minute, _ampm);"], "_minute": ["                                             final List<StringValue> _minute,", "        final List<DateTime> dates = getDateList(_date, _hour, _minute, _ampm);"], "_ampm": ["                                             final List<StringValue> _ampm)", "        final List<DateTime> dates = getDateList(_date, _hour, _minute, _ampm);", "        for (final DateTime date : dates) {", "            ret.add(StringValue.valueOf(date.toString(isofmt)));"]}
{"_date": ["public List<DateTime> getDateList(final List<StringValue> _date,", "        if (_date != null) {", "            for (final StringValue date : _date) {", "                if (!date.isNull() && !date.isEmpty()) {", "                    final MutableDateTime mdt = fmt.parseMutableDateTime(date.toString());", "                        mdt.setHourOfDay(hour);", "                                    mdt.setHourOfDay(0);", "                                    mdt.setHourOfDay(hour + 12);", "                            mdt.setMinuteOfHour(minute);", "                    ret.add(mdt.toDateTime());"], "_hour": ["                                      final List<StringValue> _hour,", "            if (_hour != null) {", "                hourIter = _hour.iterator();"], "_minute": ["                                      final List<StringValue> _minute,", "            if (_minute != null) {", "                minuteIter = _minute.iterator();"], "_ampm": ["                                      final List<StringValue> _ampm)", "            if (_ampm != null) {", "                ampmIter = _ampm.iterator();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"_target": ["    public void onClick(final AjaxRequestTarget _target)", "                _target.appendJavaScript(js);"]}
{"_tag": ["    protected void onComponentTag(final ComponentTag _tag)", "        super.onComponentTag(_tag);", "                _tag.put(\"action\", \"\");"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"_filterConfig": ["    public void init(final FilterConfig _filterConfig)", "        super.init(_filterConfig);"]}
{"_request": ["    protected void doFilter(final HttpServletRequest _request,", "        if (isLoggedIn(_request)) {", "            _chain.doFilter(_request, _response);", "            doAuthenticate(_request, _response, _chain);"], "_response": ["                            final HttpServletResponse _response,", "            _chain.doFilter(_request, _response);", "            doAuthenticate(_request, _response, _chain);"], "_chain": ["                            final FilterChain _chain)", "            _chain.doFilter(_request, _response);", "            doAuthenticate(_request, _response, _chain);"]}
{"_name": ["protected boolean checkLogin(final String _name,", "                if (this.loginHandler.checkLogin(_name, _passwd) != null) {"], "_passwd": ["                                 final String _passwd)", "                if (this.loginHandler.checkLogin(_name, _passwd) != null) {"]}
{"_target": ["    public void onRequest(final AjaxRequestTarget _target)", "        _target.appendJavaScript(snip.toString());"]}
{"_uiGrid": ["protected CharSequence getPersistenceScript(final UIGrid _uiGrid)", "        if (Context.getThreadContext().containsUserAttribute(_uiGrid.getCacheKey(CacheKey.GRIDX))) {", "            final Set<Long> colIds = _uiGrid.getColumns()", "                            _uiGrid.getCacheKey(CacheKey.GRIDX))));", "                .append(_uiGrid.getCacheKey(CacheKey.GRIDX)).append(\"', value);\")"]}
{"_dojoClasses": ["protected CharSequence getPrintMenuItems(final Set<DojoClass> _dojoClasses)", "        Collections.addAll(_dojoClasses, DojoClasses.MenuItem);"]}
{"_dojoClasses": ["protected CharSequence getMenu(final Set<DojoClass> _dojoClasses)", "            Collections.addAll(_dojoClasses, DojoClasses.MenuBar, DojoClasses.DropDownMenu, DojoClasses.MenuItem,"]}
{"_menu": ["protected CharSequence getSubMenu(final AbstractMenu _menu,", "        for (final AbstractCommand child : _menu.getCommands()) {", "            if (child.hasAccess(uiGrid.getCommand().getTargetMode(), uiGrid.getInstance())) {", "                if (child instanceof AbstractMenu) {", "                    js.append(getSubMenu((AbstractMenu) child, var));", "                        .append(getMenuItem(child, false))", "            .append(\"label: \\\"\").append(StringEscapeUtils.escapeEcmaScript(_menu.getLabelProperty())).append(\"\\\",\\n\")"], "_parent": ["                                      final String _parent)", "        js.append(_parent).append(\".addChild(new PopupMenuBarItem({\\n\")"]}
{"_uiGrid": ["public static CharSequence getDataJS(final UIGrid _uiGrid)", "        for (final GridRow row : _uiGrid.getValues()) {", "            ret.append(getRowJS(row, String.valueOf(i)));"]}
{"_uiGrid": ["public static CharSequence getDataReloadJS(final UIGrid _uiGrid)", "        final StringBuilder js = new StringBuilder()", "            .append(\"var items = \").append(GridXComponent.getDataJS(_uiGrid));", "        if (!_uiGrid.isColumnsUpToDate()) {", "            _uiGrid.setColumnsUpToDate(true);", "            js.append(\"array.forEach(grid.structure, function(entry){\\n\");", "            for (final GridColumn column : _uiGrid.getColumns()) {", "                if (column.getDataType() != null) {", "                    js.append(\"if ('\").append(column.getField().getId()).append(\"'== entry.id) {\\n\")", "                        .append(\"entry.dataType='\").append(column.getDataType()).append(\"';\\n\")", "                        .append(\"entry.comparator = grid.comparators.\").append(column.getDataType()).append(\";\\n\")", "                if (_uiGrid.getFilterList().stream()", "                                .filter(filter -> filter.getFieldId() == column.getField().getId())", "                        .append(\" = registry.byId('\").append(\"fttd_\" + column.getField().getId()).append(\"');\\n\")", "                            .append(column.getField().getId()).append(\"'));\\n\")", "            js.append(\"});\\n\")", "        js.append(\"grid.model.clearCache();\\n\")", "        return DojoWrapper.require(js, DojoClasses.registry, DojoClasses.array, DojoClasses.dom, DojoClasses.query);"]}
{"Result": "Method without Parameter"}
{"_target": ["    protected void onEvent(final AjaxRequestTarget _target)", "        modal.show(_target);"]}
{"_rowInstance": ["public void addValue(final Instance _rowInstance,", "        this.instKey2row.get(_rowInstance.getKey()).add(_uiFieldSetValue);"], "_uiFieldSetValue": ["                         final UIFieldSetValue _uiFieldSetValue)", "        this.instKey2row.get(_rowInstance.getKey()).add(_uiFieldSetValue);"]}
{"_inputName": ["public int getIndex(final String _inputName)", "        if (this.indexes.containsKey(_inputName)) {", "            ret = this.indexes.get(_inputName) + 1;", "        this.indexes.put(_inputName, ret);"]}
{"Result": "Method without Parameter"}
{"_uiClass": ["private void addChildren(final UIClassification _uiClass,", "        if (_force || _uiClass.isExpanded()) {", "            getModelObject().add(_uiClass);", "            for (final UIClassification child : _uiClass.getChildren()) {", "                addChildren(child, _force);"], "_force": ["                             final boolean _force)", "        if (_force || _uiClass.isExpanded()) {", "                addChildren(child, _force);"]}
{"_cmdId": ["public static CharSequence getHelp(final long _cmdId)", "            ret = provider.getHelp(_cmdId);"]}
{"_instance": ["protected UIStructurBrowser getNewStructurBrowser(final Instance _instance,", "            uuid = Menu.getTypeTreeMenu(_instance.getType()).getUUID();", "        final UIStructurBrowser ret = new UIStructurBrowser(uuid, _instance == null ? null : _instance.getKey(), false,"], "_strucBrwsr": ["                                                      final UIStructurBrowser _strucBrwsr)", "        if (_strucBrwsr.getTable() == null) {", "            uuid = _strucBrwsr.getCommandUUID();", "                        _strucBrwsr.getSortDirection());"]}
{"Result": "Method without Parameter"}
{"_expand": ["    protected void expand(final boolean _expand)", "            if ((isRoot() || _expand)"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"_instance": ["protected boolean checkForAllowChildren(final Instance _instance)", "                            ParameterValues.INSTANCE, _instance,"]}
{"_status": ["public void executeListener(final ExecutionStatus _status,", "        setExecutionStatus(_status);"], "_uiID2Oid": ["                                final Map<String, String> _uiID2Oid)", "                            ParameterValues.OIDMAP4UI,  _uiID2Oid);"]}
{"Result": "Method without Parameter"}
{"_hostComponent": ["    public final void bind(final Component _hostComponent)", "        Args.notNull(_hostComponent, \"hostComponent\");", "                            + \", but component \" + _hostComponent + \" wants to be attached too\");", "        this.component = _hostComponent;", "        this.component.setOutputMarkupId(true);"]}
{"_indexSearch": ["private DataTable<Element, Void> getDataTable(final IndexSearch _indexSearch)", "        if (_indexSearch.getSearch() == null || _indexSearch.getSearch().getResultFields().isEmpty()) {", "            for (final Entry<String, Collection<String>> entry : _indexSearch.getSearch().getResultFields()", "                columns.add(new ResultColumn(_indexSearch.getSearch().getResultLabel().get(entry.getKey()), entry", "        final DataTable<Element, Void> ret = new DataTable<>(\"table\", columns, _indexSearch", "                        .getDataProvider(), _indexSearch.getSearch() == null ? 100", "                                        : _indexSearch.getSearch().getNumHits());"]}
{"_others": ["public List<Return> executeEvents(final Object _others,", "        final List<Return> ret = executeEvents(EventType.UI_FIELD_CMD, _others, _uiID2Oid);"], "_uiID2Oid": ["                                      final Map<String, String> _uiID2Oid)", "        final List<Return> ret = executeEvents(EventType.UI_FIELD_CMD, _others, _uiID2Oid);", "        return ret;"]}
{"_script": ["public String getRenderedContent(final String _script,", "        final List<Return> returns = executeEvents(_script, _uiID2Oid);"], "_uiID2Oid": ["                                     final Map<String, String> _uiID2Oid)", "        final List<Return> returns = executeEvents(_script, _uiID2Oid);", "        for (final Return oneReturn : returns) {", "            if (oneReturn.contains(ReturnValues.SNIPLETT)) {", "                snip.append(oneReturn.get(ReturnValues.SNIPLETT));"]}
{"_uuid": ["private AbstractCommand getCommand(final UUID _uuid)", "        AbstractCommand cmd = Command.get(_uuid);", "        if (cmd == null) {", "            cmd = Menu.get(_uuid);", "            if (cmd == null) {", "                cmd = Search.get(_uuid);", "        return cmd;"]}
{"_cmdObject": ["private String getLabel(final ICmdUIObject _cmdObject,", "        if (DBProperties.hasProperty(_cmdObject.getCommand().getName()  + \".Button.\" + _keytype)) {", "            ret = DBProperties.getProperty(_cmdObject.getCommand().getName() + \".Button.\" + _keytype);"], "_keytype": ["                            final String _keytype)", "        if (DBProperties.hasProperty(_cmdObject.getCommand().getName()  + \".Button.\" + _keytype)) {", "            ret = DBProperties.getProperty(_cmdObject.getCommand().getName() + \".Button.\" + _keytype);", "            ret = DBProperties.getProperty(\"default.Button.\" + _keytype);", "        return ret;"]}
{"Result": "Method without Parameter"}
{"_start": ["public Iterator<IExecutionBridge> getJobsPage(final int _start,", "        return new ArrayList<>(this.executionBridges.subList(_start, min)).iterator();"], "_size": ["                                                  final int _size)", "        final int min = Math.min(_size, this.executionBridges.size());"]}
{"_jobName": ["public IExecutionBridge getBridge4Job(final String _jobName,", "            if (bridge.getJobName().equals(_jobName)) {"], "_prune": ["                                          final boolean _prune)", "                if (_prune && ret.isFinished()) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"index0": ["public QueryRequestBuilder addIndexes(final ResourceIdentifier index0, final ResourceIdentifier... indexes) {", "        this.indexes.add(index0);"]}
{"_cmdId": ["public static IModel<ICmdUIObject> getModel(final Long _cmdId,", "        return Model.<ICmdUIObject>of(UICmdObject.get(_cmdId).setInstance(_instance));"], "_instance": ["                                                final Instance _instance)", "        return Model.<ICmdUIObject>of(UICmdObject.get(_cmdId).setInstance(_instance));"]}
{"_form": ["    protected void addComponents(final FormContainer _form)", "        this.form = _form;"]}
{"Result": "Method without Parameter"}
{"_target": ["private boolean convertDateFieldValues(final AjaxRequestTarget _target)", "            showDialog(_target, html.toString(), true, false);"]}
{"_target": []}
{"_target": ["    public void onError(final AjaxRequestTarget _target)", "                    _target.prependJavaScript(DojoWrapper.require(js, DojoClasses.dom, DojoClasses.domClass));", "                    _target.add(msg.getReporter());", "        showDialog(_target, html.toString(), true, false);"]}
{"_target": ["private boolean validateFieldValues(final AjaxRequestTarget _target)", "            ret = evalFormElement(_target, html, uiform);", "            showDialog(_target, html.toString(), true, false);"]}
{"_target": ["private boolean evalFormElement(final AjaxRequestTarget _target,", "                final boolean tmp = evalFormElement(_target, _html, uiFieldForm);", "                ret = ret ? tmp : ret;", "        return ret;"], "_html": ["                                    final StringBuilder _html,", "                final boolean tmp = evalFormElement(_target, _html, uiFieldForm);", "                ret = ret ? tmp : ret;", "        return ret;"], "_uiform": ["                                    final UIForm _uiform)", "        for (final Element element : _uiform.getElements()) {", "            if (element.getType().equals(ElementType.FORM)) {", "                final FormElement formElement = (FormElement) element.getElement();", "                for (final Iterator<FormRow> uiRowIter = formElement.getRowModels(); uiRowIter.hasNext();) {", "                    for (final IUIElement object : uiRowIter.next().getValues()) {", "            } else if (element.getType().equals(ElementType.SUBFORM)) {", "                final UIFieldForm uiFieldForm = (UIFieldForm) element.getElement();", "                final boolean tmp = evalFormElement(_target, _html, uiFieldForm);", "                ret = ret ? tmp : ret;", "            } else if (element.getType().equals(ElementType.TABLE)) {", "                final UIFieldTable uiFieldTable = (UIFieldTable) element.getElement();", "                final List<UITableHeader> headers = uiFieldTable.getHeaders();", "                for (final UIRow uiRow : uiFieldTable.getValues()) {", "                    uiRow.getUserinterfaceId();", "                    final Iterator<UITableHeader> headerIter = headers.iterator();", "                    for (final IFilterable filterable : uiRow.getCells()) {", "                        headerIter.next();", "        return ret;"]}
{"_target": ["private boolean validateForm(final AjaxRequestTarget _target,", "                showDialog(_target, key, sniplett, goOn);"], "_other": ["                                 final Map<String, String[]> _other,", "            tuplets.add(_other);"], "_classifications": ["                                 final List<Classification> _classifications)", "            if (_classifications.size() > 0) {", "                tuplets.add(_classifications);"]}
{"_target": ["private boolean checkForRequired(final AjaxRequestTarget _target)", "                        _target.add(label);", "                showDialog(_target, \"MandatoryDialog\", false, false);"]}
{"Result": "Method without Parameter"}
{"_target": ["private void showDialog(final AjaxRequestTarget _target,", "                public void onClose(final AjaxRequestTarget _target)", "                        _target.appendJavaScript(getExecuteScript());", "        modal.show(_target);"], "_key": ["                            final String _key,", "                                _key, _isSniplett, _goOnButton);"], "_isSniplett": ["                            final boolean _isSniplett,", "                                _key, _isSniplett, _goOnButton);"], "_goOnButton": ["                            final boolean _goOnButton)", "                                _key, _isSniplett, _goOnButton);", "        if (_goOnButton) {"]}
{"_filterConfig": ["    public void init(final FilterConfig _filterConfig)", "        super.init(_filterConfig);", "        final String root = \"/\" + _filterConfig.getServletContext().getServletContextName() + \"/\";", "        this.notLoggedInForward = \"/\" + _filterConfig.getInitParameter(TransactionFilter.INIT_PARAM_URL_LOGIN_PAGE);"]}
{"resourceTypes": ["public static Set<ResourceType> complementOf(final Set<ResourceType> resourceTypes) {", "        set.removeAll(resourceTypes);"]}
{"first": ["public static Set<ResourceType> of(final ResourceType first, final ResourceType... rest) {", "        set.add(first);"]}
{"_uiField": ["private boolean isCheckOut(final AbstractUIField _uiField)", "        return StringUtils.containsIgnoreCase(_uiField.getFieldConfiguration().getField().getReference(),"]}
{"_uiField": ["private boolean hasAccess2Menu(final AbstractUIField _uiField)", "        final Menu menu = Menu.getTypeTreeMenu(_uiField.getInstance().getType());", "        return menu != null && menu.hasAccess(_uiField.getParent().getMode(), _uiField.getInstance())", "                        && (!((AbstractUIPageObject) _uiField.getParent()).getAccessMap().containsKey(", "                                        _uiField.getInstance())", "                        || ((AbstractUIPageObject) _uiField.getParent()).getAccessMap().containsKey(", "                                        _uiField.getInstance())", "                                        && ((AbstractUIPageObject) _uiField.getParent()).getAccessMap().get(", "                                                        _uiField.getInstance()));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"_sessionId": ["public static void removePages4Session(final String _sessionId)", "        final Query query = queryFactory.from(StoredPage.class).having(\"sessionId\").eq(_sessionId).build();"]}
{"_tag": ["    protected void onComponentTag(final ComponentTag _tag)", "        _tag.setName(\"a\");", "        super.onComponentTag(_tag);", "        onComponentTagInternal(_tag);"]}
{"Result": "Method without Parameter"}
{"_request": ["private EFapsSession getEFapsSession(final Request _request)", "        final EFapsSession session = (EFapsSession) sessionStore.lookup(_request);", "        return session;"]}
{"_cycle": ["    public void onBeginRequest(final RequestCycle _cycle)", "        final EFapsSession session = getEFapsSession(_cycle.getRequest());"]}
{"_cycle": ["    public void onEndRequest(final RequestCycle _cycle)", "        final EFapsSession session = getEFapsSession(_cycle.getRequest());"]}
{"_userName": ["public static void registerUserSession(final String _userName,", "                            new UserSession().setUserName(_userName).setSessionId(_sessionId), -1,", "                            new UserSession().setUserName(_userName).setSessionId(_sessionId));", "        RegistryManager.registerLogin4History(_userName, _sessionId);"], "_sessionId": ["                                           final String _sessionId)", "            RegistryManager.getCache().put(_sessionId,", "                            new UserSession().setUserName(_userName).setSessionId(_sessionId), -1,", "            RegistryManager.getCache().put(_sessionId,", "                            new UserSession().setUserName(_userName).setSessionId(_sessionId));", "        RegistryManager.registerLogin4History(_userName, _sessionId);"]}
{"_session": ["public static void registerActivity(final EFapsSession _session)", "        if (_session.isLogedIn() && RegistryManager.getCache().containsKey(_session.getId())) {", "            final UserSession userSession = RegistryManager.getCache().get(_session.getId());", "                _session.invalidate();"]}
{"_sessionId": ["public static void addMsgConnection(final String _sessionId,", "        if (RegistryManager.getCache().containsKey(_sessionId)) {", "            RegistryManager.getCache().get(_sessionId).setConnectionKey(_key);", "        RegistryManager.LOG.debug(\"Added Message Connection for Session: {}\", _sessionId);"], "_key": ["                                        final IKey _key)", "            RegistryManager.getCache().get(_sessionId).setConnectionKey(_key);"]}
{"_sessionId": ["public static void invalidateSession(final String _sessionId)", "        if (RegistryManager.getCache().containsKey(_sessionId)) {", "            RegistryManager.getCache().get(_sessionId).markInvalid();"]}
{"_sessionId": ["public static void removeUserSession(final String _sessionId)", "        if (RegistryManager.getCache().containsKey(_sessionId)) {", "                            RegistryManager.getCache().get(_sessionId).getUserName(), _sessionId);", "            RegistryManager.getCache().remove(_sessionId);"]}
{"Result": "Method without Parameter"}
{"_login": ["public static List<IWebSocketConnection> getConnections4User(final String _login)", "        final CacheQuery<?> query = searchManager.getQuery(qbldr.keyword().onField(\"userName\").matching(_login)"]}
{"_sessionId": ["public static IWebSocketConnection getConnection4Session(final String _sessionId)", "        if (RegistryManager.getCache().containsKey(_sessionId)) {", "            final UserSession userSession = RegistryManager.getCache().get(_sessionId);", "            if (userSession.getConnectionKey() != null) {", "                                userSession.getSessionId(), userSession.getConnectionKey());"]}
{"Result": "Method without Parameter"}
{"_commandUUID": ["protected void initialize(final UUID _commandUUID,", "        if (_commandUUID != null) {", "            final AbstractCommand command = getCommand(_commandUUID);", "            this.cmdUUID = command.getUUID();", "            setMode(command.getTargetMode());", "            this.target = command.getTarget();", "            this.submit = command.isSubmit();", "            if (command.getTargetSearch() != null && !(this instanceof UIMenuItem)) {", "                this.cmdUUID = command.getTargetSearch().getDefaultCommand().getUUID();", "                if (command.hasEvents(EventType.UI_COMMAND_EXECUTE)) {"], "_openerId": ["                              final String _openerId)", "        this.openerId = _openerId;"]}
{"Result": "Method without Parameter"}
{"_eventType": ["public List<Return> executeEvents(final EventType _eventType,", "        if (command.hasEvents(_eventType)) {", "            ret = command.executeEvents(_eventType, param);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"_uiValue": ["public String evalLabel(final UIValue _uiValue,", "            if (_uiValue != null && _uiValue.getAttribute() != null) {", "                                                .getAttribute(_uiValue.getAttribute().getName()) != null) {", "                    key = _fieldInst.getType().getAttribute(_uiValue.getAttribute().getName()).getLabelKey();", "                } else if (_uiValue.getInstance() != null", "                                && _uiValue.getInstance().getType()", "                                                .getAttribute(_uiValue.getAttribute().getName()) != null) {", "                    key = _uiValue.getInstance().getType().getAttribute(_uiValue.getAttribute().getName())", "                    key = _uiValue.getAttribute().getLabelKey();"], "_fieldInst": ["                            final Instance _fieldInst)", "                if (_fieldInst != null && _fieldInst.isValid()", "                                && _fieldInst.getType()", "                    key = _fieldInst.getType().getAttribute(_uiValue.getAttribute().getName()).getLabelKey();"]}
{"Result": "Method without Parameter"}
{"_fieldName": ["public static FieldConfiguration getSimFieldConfig(final String _fieldName)", "        final Field field = new Field(0, \"\", _fieldName);", "        final FieldConfiguration ret = new FieldConfiguration(0)", "                return field;", "        return ret;"]}
{"Result": "Method without Parameter"}
{"_target": []}
{"_model": ["protected void initialize(final IModel<T> _model,", "        if (_model == null) {", "            link = new ButtonLink<>(\"button\", _model);", "        add(link);", "        link.add(new ButtonImage(\"icon\", _reference));", "        link.add(new Label(\"label\", _label == null ? \"\" : _label));"], "_reference": ["                              final EFapsContentReference _reference,", "        link.add(new ButtonImage(\"icon\", _reference));"], "_label": ["                              final String _label)", "        link.add(new Label(\"label\", _label == null ? \"\" : _label));"]}
{"_input": ["    public Iterator<Map<String, String>> getChoices(final String _input)", "            final List<Return> returns = this.autoComplete.getAutoCompletion(_input, uiID2Oid);"]}
{"Result": "Method without Parameter"}
{"_req": ["    protected void doGet(final HttpServletRequest _req,", "        String fileName = _req.getRequestURI();"], "_resp": ["                         final HttpServletResponse _resp)", "                    _resp.setContentType(getServletContext().getMimeType(file.getName()));", "                    _resp.setContentLength((int) file.length());", "                    _resp.setDateHeader(\"Last-Modified\", System.currentTimeMillis());", "                    _resp.setDateHeader(\"Expires\", System.currentTimeMillis());", "                    _resp.addHeader(\"Content-Disposition\", \"inline; filename=\\\"\" + file.getName() + \"\\\"\");", "                    _resp.setHeader(\"Cache-Control\", \"max-age=10\");", "                    IOUtils.copy(input, _resp.getOutputStream());"]}
{"Result": "Method without Parameter"}
{"_instance": ["private CharSequence getSubMenues(final Instance _instance)", "        HelpServlet.LOG.debug(\"Reading Submenues for OID: {}\", _instance.getOid());", "        queryBldr.addWhereAttrEqValue(\"FromLink\", _instance.getId());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"_uitableHeader": ["public void addFilterList(final UITableHeader _uitableHeader,", "        final TableFilter filter = new TableFilter(_uitableHeader, _list);", "        this.filters.put(_uitableHeader.getFieldName(), filter);", "        final UITableHeader orig = getHeader4Id(_uitableHeader.getFieldId());"], "_list": ["                              final Set<?> _list)", "        final TableFilter filter = new TableFilter(_uitableHeader, _list);", "        this.filters.put(_uitableHeader.getFieldName(), filter);"]}
{"_uitableHeader": ["public void addFilterClassifcation(final UITableHeader _uitableHeader,", "        final TableFilter filter = new TableFilter(_uitableHeader, _uiClassification);", "        this.filters.put(_uitableHeader.getFieldName(), filter);", "        final UITableHeader orig = getHeader4Id(_uitableHeader.getFieldId());"], "_uiClassification": ["                                       final UIClassification _uiClassification)", "        final TableFilter filter = new TableFilter(_uitableHeader, _uiClassification);", "        this.filters.put(_uitableHeader.getFieldName(), filter);"]}
{"_uitableHeader": ["public TableFilter getFilter(final UITableHeader _uitableHeader)", "        TableFilter ret = this.filters.get(_uitableHeader.getFieldName());", "            ret = new TableFilter(_uitableHeader);", "            this.filters.put(_uitableHeader.getFieldName(), ret);", "        return ret;"]}
{"_uitableHeader": ["public List<String> getFilterPickList(final UITableHeader _uitableHeader)", "                if (cell.belongsTo(_uitableHeader.getFieldId())) {"]}
{"_type": ["private List<Status> getStatus4Type(final Type _type)", "        final StatusGroup grp = Status.get(_type.getUUID());", "            for (final Type type : _type.getChildTypes()) {", "                ret.addAll(getStatus4Type(type));"]}
{"Result": "Method without Parameter"}
{"_uiTableHeader": ["public void removeFilter(final UITableHeader _uiTableHeader)", "        this.filters.remove(_uiTableHeader.getFieldName());", "        final UITableHeader orig = getHeader4Id(_uiTableHeader.getFieldId());"]}
{"_column": ["protected GridCell getCell(final GridColumn _column,", "                    _column.setDataType(\"date\");", "                    _column.setDataType(\"datetime\");", "                    _column.setDataType(\"number\");", "                    _column.setDataType(\"enum\");", "                    _column.setEnumValues(enumValues.keySet());", "                        .setFieldConfig(_column.getFieldConfig());"], "_uiValue": ["                           final UIValue _uiValue,", "        if (_fields.containsKey(_uiValue.getField().getId())) {", "            jsField = _fields.get(_uiValue.getField().getId());", "            jsField = new JSField(_uiValue);", "            final IComponentFactory fact = jsField.getFactory();", "                _fields.put(_uiValue.getField().getId(), null);", "                _fields.put(_uiValue.getField().getId(), jsField);", "                    final Map<String, ?> enumValues = (Map<String, ?>) _uiValue.getReadOnlyValue(TargetMode.VIEW);", "        if (jsField == null) {", "            jsField.setValue(_uiValue);", "            value = jsField.getFactory().getStringValue(jsField);", "        return  new GridCell().setValue(value)"], "_sortValue": ["                           final Object _sortValue,", "                        .setSortValue(_sortValue)"], "_fields": ["                           final Map<Long, JSField> _fields)", "        if (_fields.containsKey(_uiValue.getField().getId())) {", "            jsField = _fields.get(_uiValue.getField().getId());", "                _fields.put(_uiValue.getField().getId(), null);", "                _fields.put(_uiValue.getField().getId(), jsField);"]}
{"Result": "Method without Parameter"}
{"_field": ["protected IFilter getFilter4Field(final Field _field)", "        switch (_field.getFilter().getType()) {", "                ret = new ListFilter(_field.getId());", "                ret = new MapFilter(_field.getId());", "                ret = new ClassificationFilter(_field.getId());", "                        return _field.getId();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"_filter": ["public boolean isDateFilter(final IFilter _filter) throws EFapsException", "        final Field field = Field.get(_filter.getFieldId());"]}
{"_rowId": ["public GridRow getRow4Id(final String _rowId)", "        final String[] rowIds = _rowId.split(\"-\");"]}
{"_uiGrid": ["public static File print(final UIGrid _uiGrid)", "            UIGrid.LOG.debug(\"Print method executed for {}\", _uiGrid);", "            param.put(ParameterValues.CLASS, _uiGrid);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"_nodes": ["private boolean dimFilterApplied(final List<DimTreeNode> _nodes)", "        final List<DimTreeNode> nodes = _nodes == null ? getDimensionProvider().getRootList() : _nodes;", "        for (final DimTreeNode node : nodes) {", "            if (node.getStatus() != null) {", "            ret = dimFilterApplied(node.getChildren());", "            if (ret) {", "        return ret;"]}
{"_updateDim": ["private void fillDimensionProvider(final boolean _updateDim)", "        if (_updateDim && dims.isEmpty()) {", "                    } else if (_updateDim) {"]}
{"parents": ["private Map<String, Object> buildHierarchyParameters(final List<String> parents, final List<String> children) {", "        if (parents != null) {", "            for (final String parent : parents) {", "                parameters.put(\"parents\", parent);"], "children": ["private Map<String, Object> buildHierarchyParameters(final List<String> parents, final List<String> children) {", "        if (children != null) {", "            for (final String child : children) {", "                parameters.put(\"children\", child);"]}
{"fileResource": ["public static boolean rootElementMatches(FileResource fileResource, String path, String expectedRootElement) throws IOException {", "        try (InputStream stream = fileResource.createStream()) {"], "path": ["public static boolean rootElementMatches(FileResource fileResource, String path, String expectedRootElement) throws IOException {", "            LOGGER.warn(\"Cannot parse XML file '{}'.\", path);"], "expectedRootElement": ["public static boolean rootElementMatches(FileResource fileResource, String path, String expectedRootElement) throws IOException {", "                        return expectedRootElement.equals(rootElement);"]}
{"Result": "Method without Parameter"}
{"key": ["protected void refreshTTL(String key, CacheEntry ce) {", "        final String KEY = calcCacheKey(key);", "                    jedis.expire(SafeEncoder.encode(KEY), (int) TTL);"], "ce": ["protected void refreshTTL(String key, CacheEntry ce) {", "        final long TTL = ce.getExpireAfterAccess();"]}
{"toBeCloned": ["public static Object tryClone(Object toBeCloned) {", "        if (toBeCloned == null) {", "        if (toBeCloned instanceof Cloneable) {", "                clonedObj = method.invoke(toBeCloned);", "                    clonedObj = toBeCloned;", "            clonedObj = toBeCloned;", "        return clonedObj;"]}
{"Result": "Method without Parameter"}
{"cacheProps": ["public AbstractCache setCacheProperties(Properties cacheProps) {", "        this.cacheProps = cacheProps != null ? new Properties(cacheProps) : new Properties();"]}
{"key": ["protected String getCacheProperty(String key) {", "        return cacheProps != null ? cacheProps.getProperty(key) : null;"]}
{"key": ["protected String calcCacheKey(String key) {", "            return key;", "            return getName() + \":\" + key;"]}
{"name": ["protected Properties getCacheProperties(String name) {", "        return cacheProperties != null ? cacheProperties.get(name) : null;"]}
{"key": ["    public void set(String key, Object entry, long expireAfterWrite, long expireAfterAccess) {", "                localCache.set(key, entry, expireAfterWrite, expireAfterAccess);", "                remoteCache.set(key, entry, expireAfterWrite, expireAfterAccess);"], "entry": ["    public void set(String key, Object entry, long expireAfterWrite, long expireAfterAccess) {", "                localCache.set(key, entry, expireAfterWrite, expireAfterAccess);", "                remoteCache.set(key, entry, expireAfterWrite, expireAfterAccess);"], "expireAfterWrite": ["    public void set(String key, Object entry, long expireAfterWrite, long expireAfterAccess) {", "                localCache.set(key, entry, expireAfterWrite, expireAfterAccess);", "                remoteCache.set(key, entry, expireAfterWrite, expireAfterAccess);"], "expireAfterAccess": ["    public void set(String key, Object entry, long expireAfterWrite, long expireAfterAccess) {", "                localCache.set(key, entry, expireAfterWrite, expireAfterAccess);", "                remoteCache.set(key, entry, expireAfterWrite, expireAfterAccess);"]}
{"key": ["    public void delete(String key) {", "                localCache.delete(key);", "                remoteCache.delete(key);"]}
{"key": ["public void deleteLocal(String key) {", "                localCache.delete(key);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"e": ["public String getLabelForElement(FormCheckerElement e, Map<String, String> attribs) {", "\t\treturn config.getFormBuilder().getLabelForElement(e, new TagAttributes(attribs), firstRun);"], "attribs": ["public String getLabelForElement(FormCheckerElement e, Map<String, String> attribs) {", "\t\treturn config.getFormBuilder().getLabelForElement(e, new TagAttributes(attribs), firstRun);"]}
{"Result": "Method without Parameter"}
{"formAction": ["\tfinal public String generateGenericForm(String formAction, ", "\t\treturn this.generateGenericForm(formAction, firstRun, form, req, config.properties);"], "firstRun": ["\t\t\tboolean firstRun, FormCheckerForm form, Request req, FormCheckerConfig config) {", "\t\treturn this.generateGenericForm(formAction, firstRun, form, req, config.properties);"], "form": ["\t\t\tboolean firstRun, FormCheckerForm form, Request req, FormCheckerConfig config) {", "\t\treturn this.generateGenericForm(formAction, firstRun, form, req, config.properties);"], "req": ["\t\t\tboolean firstRun, FormCheckerForm form, Request req, FormCheckerConfig config) {", "\t\treturn this.generateGenericForm(formAction, firstRun, form, req, config.properties);"], "config": ["\t\t\tboolean firstRun, FormCheckerForm form, Request req, FormCheckerConfig config) {", "\t\treturn this.generateGenericForm(formAction, firstRun, form, req, config.properties);"]}
{"firstRun": ["String generateHtmlForElement(boolean firstRun, MessageSource messageSource, FormCheckerElement elem, boolean html5Validation) {", "\t\tValidationResult vr = getErrors(elem, firstRun);", "\t\tif (!vr.isValid()) {", "\t\t\tinputStruct.setErrors(formatError(messageSource.getMessage(vr)));", "\t\t\tinputStruct.setLabel(getLabelForElement(elem, getLabelAttributes(elem), firstRun));", "\t\treturn getCompleteRenderedInput(inputStruct, elem, firstRun);"], "messageSource": ["String generateHtmlForElement(boolean firstRun, MessageSource messageSource, FormCheckerElement elem, boolean html5Validation) {", "\t\t\tinputStruct.setErrors(formatError(messageSource.getMessage(vr)));", "\t\tinputStruct.setInput(elem.getInputTag(attribs, messageSource, html5Validation));"], "elem": ["String generateHtmlForElement(boolean firstRun, MessageSource messageSource, FormCheckerElement elem, boolean html5Validation) {", "\t\tValidationResult vr = getErrors(elem, firstRun);", "\t\tboolean displayLabel = !StringUtils.isEmpty(elem.getDescription());", "\t\t\tinputStruct.setLabel(getLabelForElement(elem, getLabelAttributes(elem), firstRun));", "\t\taddAttributesToInputFields(attribs, elem);", "\t\tinputStruct.setInput(elem.getInputTag(attribs, messageSource, html5Validation));", "\t\tif (!StringUtils.isEmpty(elem.getHelpText())) {", "\t\t\tinputStruct.setHelp(getHelpTag(elem.getHelpText(), elem));", "\t\treturn getCompleteRenderedInput(inputStruct, elem, firstRun);"], "html5Validation": ["String generateHtmlForElement(boolean firstRun, MessageSource messageSource, FormCheckerElement elem, boolean html5Validation) {", "\t\tinputStruct.setInput(elem.getInputTag(attribs, messageSource, html5Validation));"]}
{"inputStruct": ["public String getCompleteRenderedInput(InputElementStructure inputStruct, FormCheckerElement elem,", "\t\telemHtml.append(inputStruct.getErrors());", "\t\telemHtml.append(labelWrapper.start).append(inputStruct.getLabel()).append(labelWrapper.end);", "\t\telemHtml.append(inputStruct.getInput());", "\t\telemHtml.append(inputStruct.getHelp());"], "elem": ["public String getCompleteRenderedInput(InputElementStructure inputStruct, FormCheckerElement elem,", "\t\tWrapper elementWrapper = getWrapperForElem(elem, firstRun);", "\t\tWrapper labelWrapper = getWrapperForLabel(elem);", "\t\telemHtml.append(labelWrapper.start).append(inputStruct.getLabel()).append(labelWrapper.end);", "\t\tWrapper inputWrapper = getWrapperForInput(elem);", "\t\telemHtml.append(inputWrapper.start);", "\t\telemHtml.append(inputWrapper.end);"], "firstRun": ["\t\t\tboolean firstRun) {", "\t\tWrapper elementWrapper = getWrapperForElem(elem, firstRun);", "\t\telemHtml.append(elementWrapper.start);", "\t\telemHtml.append(elementWrapper.end);"]}
{"name": ["public String getElement(String name) {", "\t\treturn formBuilder.generateHtmlForElement(fc.firstRun, fc.config.getProperties(), form.getElement(name), this.form.isHtml5Validation());"]}
{"embeddedWebContext": ["public static ApplicationContext registerAppContext(String embeddedWebContext, ApplicationContext appContext) {\r", "        return appContextMap.put(embeddedWebContext, appContext);\r"], "appContext": ["public static ApplicationContext registerAppContext(String embeddedWebContext, ApplicationContext appContext) {\r", "        return appContextMap.put(embeddedWebContext, appContext);\r"]}
{"name": ["\tpublic static SelectInput build(String name, LinkedHashMap<String, String> possibleNames) {", "\t\tSelectInput si = SelectInput.build(name);", "\t\tsi.setPossibleValues(possibleNames);", "\t\treturn si;"], "possibleNames": ["\tpublic static SelectInput build(String name, LinkedHashMap<String, String> possibleNames) {", "\t\tsi.setPossibleValues(possibleNames);"]}
{"tagAttributes": ["protected String buildAllAttributes(TagAttributes tagAttributes, MessageSource messageSource, boolean html5Validation) {", "\t\tallAttribs.append(AttributeUtils.buildAttributes(tagAttributes));"], "messageSource": ["protected String buildAllAttributes(TagAttributes tagAttributes, MessageSource messageSource, boolean html5Validation) {", "\t\t\tallAttribs.append(buildFcRequiredMessage(messageSource));"], "html5Validation": ["protected String buildAllAttributes(TagAttributes tagAttributes, MessageSource messageSource, boolean html5Validation) {", "\t\tif (html5Validation) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"converter": ["public static <D> CursorConverter<List<D>> listConverter(final CursorConverter<D> converter) {", "    return new ListConverter<>(converter);"]}
{"Result": "Method without Parameter"}
{"p": ["public RemoteProfile getProfileOf(SPFPerson p) {", "\t\tif (p == null) {", "\t\treturn new RemoteProfile(p, mInterface);"]}
{"listener": ["public void setChangeListener(OnChangeListener listener) {", "        changeListener = listener;", "        if (changeListener != null) {"]}
{"schema": ["public static DocumentBuilderFactory getDocumentBuilderFactory(final String schema)", "\t\tfactory.setAttribute(SCHEMA_SOURCE_KEY, schema);"]}
{"xml": ["public static DOMSource getDOMSource(final File xml, final ErrorHandler errorHandler)", "\t\treturn new DOMSource(parse(xml, errorHandler));"], "errorHandler": ["public static DOMSource getDOMSource(final File xml, final ErrorHandler errorHandler)", "\t\treturn new DOMSource(parse(xml, errorHandler));"]}
{"xsd": ["public static Schema getSchema(final File xsd, final ErrorHandler errorHandler)", "\t\treturn schemaFactory.newSchema(xsd);"], "errorHandler": ["public static Schema getSchema(final File xsd, final ErrorHandler errorHandler)", "\t\tschemaFactory.setErrorHandler(errorHandler);"]}
{"xml": ["public static Document parse(final File xml, final ErrorHandler errorHandler)", "\t\tfinal DocumentBuilderFactory factory = getDocumentBuilderFactory(xml.getName());", "\t\treturn builder.parse(xml);"], "errorHandler": ["public static Document parse(final File xml, final ErrorHandler errorHandler)", "\t\tbuilder.setErrorHandler(errorHandler);"]}
{"xsd": ["public static void validateSchema(final File xsd, final File xml,", "\t\tfinal Schema schemaXSD = getSchema(xsd, errorHandler);"], "xml": ["public static void validateSchema(final File xsd, final File xml,", "\t\tvalidator.validate(getDOMSource(xml, errorHandler));"], "errorHandler": ["\t\tfinal ErrorHandler errorHandler)", "\t\tfinal Schema schemaXSD = getSchema(xsd, errorHandler);", "\t\tfinal Validator validator = schemaXSD.newValidator();", "\t\tvalidator.validate(getDOMSource(xml, errorHandler));"]}
{"SchemaUrl": ["public static boolean validateSchema(final String SchemaUrl, final String XmlDocumentUrl)", "\t\tfactory.setAttribute(SCHEMA_SOURCE_KEY, SchemaUrl);"], "XmlDocumentUrl": ["public static boolean validateSchema(final String SchemaUrl, final String XmlDocumentUrl)", "\t\tbuilder.parse(XmlDocumentUrl);"]}
{"child": ["public boolean addChild(final SimpleTag child)", "\t\treturn getChildren().add(child);"]}
{"name": ["public String removeAttribute(final String name)", "\t\t\tgetAttributes().remove(name);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"service": ["public void addServiceIfNotPresent(WiFiP2pService service) {", "        if (service == null) {", "                    && element.getDevice().equals(service.getDevice())", "                    && element.getInstanceName().equals(service.getInstanceName())) {", "            serviceList.add(service);"]}
{"device": ["public WiFiP2pService getServiceByDevice(WifiP2pDevice device) {", "        if (device == null) {", "        WfdLog.d(TAG, \"groupownerdevice passed to getServiceByDevice: \" + device.deviceName + \", \" + device.deviceAddress);", "            WfdLog.d(TAG, \"element passed : \" + device.deviceName + \", \" + device.deviceAddress);", "            if (element.getDevice().deviceAddress.equals(device.deviceAddress)) {", "                WfdLog.d(TAG, \"getServiceByDevice if satisfied : \" + device.deviceAddress + \", \" + element.getDevice().deviceAddress);"]}
{"intent": ["    public int onStartCommand(Intent intent, int flags, int startId) {", "        if (intent == null) {", "        String action = intent.getAction();"], "flags": [], "startId": []}
{"appIdentifier": ["List<SPFTrigger> getAllTriggers(String appIdentifier) {", "\t\tString[] whereArgs = { appIdentifier };", "\t\tCursor c = getReadableDatabase().query(Contract.TABLE_NAME, null, where, whereArgs, null, null, null);"]}
{"appPackageName": ["boolean deleteAllTriggerOf(String appPackageName) {", "\t\tString[] whereArgs = { appPackageName };", "\t\tint c = getReadableDatabase().delete(Contract.TABLE_NAME, where, whereArgs);", "\t\treturn c > 0;"]}
{"id": ["boolean deleteTrigger(long id, String appPackageName) {", "\t\tString[] whereArgs = { appPackageName, Long.toString(id) };", "\t\tint count = getReadableDatabase().delete(Contract.TABLE_NAME, where, whereArgs);", "\t\treturn count > 0;"], "appPackageName": ["boolean deleteTrigger(long id, String appPackageName) {", "\t\tString[] whereArgs = { appPackageName, Long.toString(id) };"]}
{"triggerId": ["SPFTrigger getTrigger(long triggerId, String appPackageName) {", "\t\tString[] whereArgs = { Long.toString(triggerId), appPackageName };"], "appPackageName": ["SPFTrigger getTrigger(long triggerId, String appPackageName) {", "\t\tString[] whereArgs = { Long.toString(triggerId), appPackageName };", "\t\tCursor c = getReadableDatabase().query(Contract.TABLE_NAME, null, where, whereArgs, null, null, null);"]}
{"accessToken": ["public AppAuth validateAccess(String accessToken, Permission permission) throws TokenNotValidException, PermissionDeniedException {", "\t\tif (accessToken == null) {", "\t\tappAuth = mAppRegistry.getAppAuthorization(accessToken);", "\t\tif ((appAuth.getPermissionCode() & permission.getCode()) == 0) {", "\t\treturn appAuth;"], "permission": ["public AppAuth validateAccess(String accessToken, Permission permission) throws TokenNotValidException, PermissionDeniedException {", "\t\tif ((appAuth.getPermissionCode() & permission.getCode()) == 0) {"]}
{"xmlString": ["public static <T> T toObjectWithXStream(final String xmlString,", "\t\treturn toObjectWithXStream(null, xmlString, aliases);"], "aliases": ["\t\tfinal Map<String, Class<?>> aliases)", "\t\treturn toObjectWithXStream(null, xmlString, aliases);"]}
{"xstream": ["\tpublic static <T> T toObjectWithXStream(XStream xstream, final String xmlString,", "\t\tif (xstream == null)", "\t\t\t\txstream.alias(alias.getKey(), alias.getValue());", "\t\treturn (T)xstream.fromXML(xmlString);"], "xmlString": ["\tpublic static <T> T toObjectWithXStream(XStream xstream, final String xmlString,", "\t\treturn (T)xstream.fromXML(xmlString);"], "aliases": ["\t\tfinal Map<String, Class<?>> aliases)", "\t\tif (aliases != null)", "\t\t\tfor (final Map.Entry<String, Class<?>> alias : aliases.entrySet())", "\t\t\t\txstream.alias(alias.getKey(), alias.getValue());"]}
{"xmlString": ["public static String toJson(final String xmlString, final Map<String, Class<?>> aliases)", "\t\tfinal Object object = XmlToObjectExtensions.toObjectWithXStream(xmlString);", "\t\tfinal String json = xstream.toXML(object);", "\t\treturn json;"], "aliases": ["public static String toJson(final String xmlString, final Map<String, Class<?>> aliases)", "\t\tif (aliases != null)", "\t\t\tfor (final Map.Entry<String, Class<?>> alias : aliases.entrySet())", "\t\t\t\txstream.alias(alias.getKey(), alias.getValue());"]}
{"methodName": ["public Object invokeMethod(String methodName, Object[] args, Type retType) throws ServiceInvocationException {", "\t\tcheckCurrentThread(methodName);", "\t\tUtils.notNull(methodName);", "\t\tInvocationRequest request = new InvocationRequest(mServiceDescriptor.getAppIdentifier(), mServiceDescriptor.getServiceName(), methodName, payload);"], "args": ["public Object invokeMethod(String methodName, Object[] args, Type retType) throws ServiceInvocationException {", "\t\tUtils.notNull(args);", "\t\tmInvocationTarget.prepareArguments(args);", "\t\tString payload = GsonHelper.gson.toJson(args);", "\t\tInvocationRequest request = new InvocationRequest(mServiceDescriptor.getAppIdentifier(), mServiceDescriptor.getServiceName(), methodName, payload);", "\t\tInvocationResponse response = mInvocationTarget.executeService(request);", "\t\tif (!response.isResult()) {", "\t\t\tthrow new ServiceInvocationException(response.getErrorMessage());", "\t\t\treturn GsonHelper.gson.fromJson(response.getPayload(), retType);"], "retType": ["public Object invokeMethod(String methodName, Object[] args, Type retType) throws ServiceInvocationException {", "\t\t} else if (retType.equals(void.class)) {", "\t\t\treturn GsonHelper.gson.fromJson(response.getPayload(), retType);"]}
{"methodName": ["private void checkCurrentThread(String methodName) {", "\t\t\tLog.w(TAG, String.format(WRONG_THREAD_MSG, mServiceDescriptor.getServiceName(), methodName));"]}
{"tag": ["public static void logCall(String tag, String methodName, Object... args) {", "\t\t\tLog.d(tag, \"method call: \" + methodName + \"(\" + (args != null ? TextUtils.join(\",\", args) : \"\") + \")\");"], "methodName": ["public static void logCall(String tag, String methodName, Object... args) {", "\t\t\tLog.d(tag, \"method call: \" + methodName + \"(\" + (args != null ? TextUtils.join(\",\", args) : \"\") + \")\");"]}
{"is": ["private static <T> T loadObject(final InputStream is) throws IOException", "\t\tfinal String xmlString = ReadFileExtensions.inputStream2String(is);", "\t\tfinal T object = XmlToObjectExtensions.toObjectWithXStream(xmlString);", "\t\treturn object;"]}
{"tagname": ["public static String newTag(final String tagname, final String value,", "\t\txmlTag.append(\"<\").append(tagname);", "\t\txmlTag.append(\"</\").append(tagname).append(\">\");"], "value": ["public static String newTag(final String tagname, final String value,", "\t\txmlTag.append(value);"], "attributes": ["\t\tfinal Map<String, String> attributes)", "\t\tif (attributes != null && !attributes.isEmpty())", "\t\t\tfor (final Map.Entry<String, String> attributte : attributes.entrySet())", "\t\t\t\txmlTag.append(attributte.getKey());", "\t\t\t\txmlTag.append(\"\\\"\").append(attributte.getValue()).append(\"\\\"\");", "\t\t\t\tif (count != attributes.size())"]}
{"queryJSON": ["public boolean matches(String queryJSON) {", "\t\t\tqueryContainer = QueryContainer.fromJSON(queryJSON);", "\t\tSPFQuery query = queryContainer.getQuery();", "\t\tString callerApp = queryContainer.getCallerAppId();", "\t\tString userUID = queryContainer.getUserUID();"]}
{"request": ["public InvocationResponse dispatchInvocation(InvocationRequest request) {", "\t\tString appName = request.getAppName();", "\t\tString serviceName = request.getServiceName();", "\t\t\treturn proxy.executeService(request);"]}
{"serviceInterface": ["public <T> void unregisterService(Class<? super T> serviceInterface) {", "\t\tUtils.notNull(serviceInterface, \"serviceInterface must not be null\");", "\t\tServiceValidator.validateInterface(serviceInterface, ServiceValidator.TYPE_PUBLISHED);", "\t\tServiceInterface svcInterface = serviceInterface.getAnnotation(ServiceInterface.class);"]}
{"queryInfo": ["private String generateQueryId(QueryInfo queryInfo) {", "\t\tqueryInfo.setQueryId(queryId);"]}
{"uniqueIdentifier": ["void onInstanceLost(String uniqueIdentifier) {", "\t\tlog(TAG, \"instance lost \" + uniqueIdentifier);", "\t\tList<String> queriesIds = results.get(uniqueIdentifier);", "\t\tif (queriesIds == null) {", "\t\tfor (String queryId : queriesIds) {", "\t\t\targs[0] = queryId;", "\t\t\targs[1] = uniqueIdentifier;", "\t\t\tMessage msg = handler.obtainMessage(SearchMessages.RESULT_LOST,", "\t\t\t\t\targs);", "\t\t\t\t\t+ queryId);", "\t\t\thandler.sendMessage(msg);"]}
{"queryId": ["void stopSearch(String queryId) {", "\t\tQueryInfo info = queries.get(queryId);", "\t\tif(info !=  null){", "\t\t\tstopSearch(info);"]}
{"appIdentifier": ["void stopAllSearches(String appIdentifier) {", "\t\t\tif (queryInfo.getAppName().equals(appIdentifier)) {"]}
{"context": ["public static void connect(final Context context, final ConnectionListener listener) {", "\t\tComponent.load(context, DESCRIPTOR, asBase(listener));"], "listener": ["public static void connect(final Context context, final ConnectionListener listener) {", "\t\tComponent.load(context, DESCRIPTOR, asBase(listener));"]}
{"field": ["private <E> View createStandardDisplayView(ProfileField<E> field, E currentValue, ViewGroup viewContainer) {", "\t\tString friendlyFieldName = mHelper.getFriendlyNameOfField(field);", "\t\t((TextView) result.findViewById(R.id.profile_field_key)).setText(friendlyFieldName);", "\t\tString fieldValue = mHelper.convertToFriendlyString(field, currentValue);", "\t\tsetUpCircleView(result, field, null);"], "currentValue": ["private <E> View createStandardDisplayView(ProfileField<E> field, E currentValue, ViewGroup viewContainer) {", "\t\tString fieldValue = mHelper.convertToFriendlyString(field, currentValue);", "\t\t((TextView) result.findViewById(R.id.profile_field_value)).setText(fieldValue);"], "viewContainer": ["private <E> View createStandardDisplayView(ProfileField<E> field, E currentValue, ViewGroup viewContainer) {", "\t\tView result = mInflater.inflate(R.layout.profileview_field_listelement, viewContainer, false);", "\t\t((TextView) result.findViewById(R.id.profile_field_key)).setText(friendlyFieldName);", "\t\t((TextView) result.findViewById(R.id.profile_field_value)).setText(fieldValue);", "\t\tsetUpCircleView(result, field, null);", "\t\treturn result;"]}
{"field": ["private <E> View createSpinner(MultipleChoicheProfileField<E> field, E currentValue, FieldValueListener<E> listener, ViewGroup container) {", "\t\tString friendlyName = mHelper.getFriendlyNameOfField(field);", "\t\t((TextView) result.findViewById(R.id.profileedit_field_identifier)).setText(friendlyName);", "\t\tArrayAdapter<E> adapter = new ArrayAdapter<E>(mContext, android.R.layout.simple_list_item_1, field.getChoiches());", "\t\tint index = indexOf(field.getChoiches(), currentValue);", "\t\tspinner.setOnItemSelectedListener(new OnItemSelectedAdapter<E>(field, listener, adapter));", "\t\tsetUpCircleView(result, field, listener);"], "currentValue": ["private <E> View createSpinner(MultipleChoicheProfileField<E> field, E currentValue, FieldValueListener<E> listener, ViewGroup container) {", "\t\tint index = indexOf(field.getChoiches(), currentValue);", "\t\tif (index >= 0) {", "\t\t\tspinner.setSelection(index, false);"], "listener": ["private <E> View createSpinner(MultipleChoicheProfileField<E> field, E currentValue, FieldValueListener<E> listener, ViewGroup container) {", "\t\tspinner.setOnItemSelectedListener(new OnItemSelectedAdapter<E>(field, listener, adapter));", "\t\tsetUpCircleView(result, field, listener);"], "container": ["private <E> View createSpinner(MultipleChoicheProfileField<E> field, E currentValue, FieldValueListener<E> listener, ViewGroup container) {", "\t\tView result = mInflater.inflate(R.layout.profileedit_field_multiplechoiche, container, false);", "\t\t((TextView) result.findViewById(R.id.profileedit_field_identifier)).setText(friendlyName);", "\t\tSpinner spinner = (Spinner) result.findViewById(R.id.profileedit_field_multiple_value);", "\t\tsetUpCircleView(result, field, listener);", "\t\treturn result;"]}
{"field": ["\tprivate <E> View createDateView(final DateProfileField field, Date currentValue, final FieldValueListener<Date> listener, ViewGroup container) {", "\t\tString friendlyName = mHelper.getFriendlyNameOfField(field);", "\t\t((TextView) result.findViewById(R.id.profileedit_field_identifier)).setText(friendlyName);", "\t\t\tdateToShow = mHelper.convertToFriendlyString(field, currentValue);", "\t\t\t\t\t\tString newDateString = mHelper.convertToFriendlyString(field, newDate);", "\t\t\t\t\t\tlistener.onFieldValueChanged(field, newDate);", "\t\tsetUpCircleView(result, (ProfileField<E>) field, (FieldValueListener<E>) listener);"], "currentValue": ["\tprivate <E> View createDateView(final DateProfileField field, Date currentValue, final FieldValueListener<Date> listener, ViewGroup container) {", "\t\tif (currentValue == null) {", "\t\t\tdateToShow = mHelper.convertToFriendlyString(field, currentValue);", "\t\tdateTextView.setText(dateToShow);"], "listener": ["\tprivate <E> View createDateView(final DateProfileField field, Date currentValue, final FieldValueListener<Date> listener, ViewGroup container) {", "\t\t\t\t\t\tlistener.onFieldValueChanged(field, newDate);", "\t\tsetUpCircleView(result, (ProfileField<E>) field, (FieldValueListener<E>) listener);"], "container": ["\tprivate <E> View createDateView(final DateProfileField field, Date currentValue, final FieldValueListener<Date> listener, ViewGroup container) {", "\t\tView result = mInflater.inflate(R.layout.profileedit_field_date, container, false);", "\t\t((TextView) result.findViewById(R.id.profileedit_field_identifier)).setText(friendlyName);", "\t\tfinal TextView dateTextView = (TextView) result.findViewById(R.id.profileedit_field_date_text);", "\t\tsetUpCircleView(result, (ProfileField<E>) field, (FieldValueListener<E>) listener);", "\t\treturn result;"]}
{"field": ["\tprivate <E> View createTagView(TagProfileField field, String[] currentValue, FieldValueListener<E> listener, ViewGroup container, boolean editable) {", "\t\tString friendlyName = mHelper.getFriendlyNameOfField(field);", "\t\t((TextView) result.findViewById(R.id.profileedit_field_identifier)).setText(friendlyName);", "\t\t\tpicker.setChangeListener(new OnChangeListenerAdapter(field, (FieldValueListener<String[]>) listener));", "\t\tsetUpCircleView(result, (ProfileField<E>) field, listener);"], "currentValue": ["\tprivate <E> View createTagView(TagProfileField field, String[] currentValue, FieldValueListener<E> listener, ViewGroup container, boolean editable) {", "\t\tif (currentValue != null) {", "\t\t\tpicker.setInitialTags(Arrays.asList(currentValue));"], "listener": ["\tprivate <E> View createTagView(TagProfileField field, String[] currentValue, FieldValueListener<E> listener, ViewGroup container, boolean editable) {", "\t\t\tpicker.setChangeListener(new OnChangeListenerAdapter(field, (FieldValueListener<String[]>) listener));", "\t\tsetUpCircleView(result, (ProfileField<E>) field, listener);"], "container": ["\tprivate <E> View createTagView(TagProfileField field, String[] currentValue, FieldValueListener<E> listener, ViewGroup container, boolean editable) {", "\t\tView result = mInflater.inflate(editable ? R.layout.profileedit_field_tag : R.layout.profileview_tag_field, container, false);", "\t\t((TextView) result.findViewById(R.id.profileedit_field_identifier)).setText(friendlyName);", "\t\tTagsPicker picker = (TagsPicker) result.findViewById(R.id.profileedit_tags_picker);", "\t\tsetUpCircleView(result, (ProfileField<E>) field, listener);", "\t\treturn result;"], "editable": ["\tprivate <E> View createTagView(TagProfileField field, String[] currentValue, FieldValueListener<E> listener, ViewGroup container, boolean editable) {", "\t\tView result = mInflater.inflate(editable ? R.layout.profileedit_field_tag : R.layout.profileview_tag_field, container, false);", "\t\tpicker.setEditable(editable);", "\t\tif (editable) {"]}
{"field": ["private <E> View createStandardEditView(ProfileField<E> field, E currentValue, FieldValueListener<E> listener, ViewGroup container) {", "\t\tString friendlyName = mHelper.getFriendlyNameOfField(field);", "\t\t((TextView) result.findViewById(R.id.profileedit_field_identifier)).setText(friendlyName);", "\t\teditText.addTextChangedListener(new OnEditorActionAdapter<>(listener, field));", "\t\t\teditText.setText(mHelper.convertToFriendlyString(field, currentValue));", "\t\tsetUpCircleView(result, field, listener);"], "currentValue": ["private <E> View createStandardEditView(ProfileField<E> field, E currentValue, FieldValueListener<E> listener, ViewGroup container) {", "\t\tif (currentValue != null) {", "\t\t\teditText.setText(mHelper.convertToFriendlyString(field, currentValue));"], "listener": ["private <E> View createStandardEditView(ProfileField<E> field, E currentValue, FieldValueListener<E> listener, ViewGroup container) {", "\t\teditText.addTextChangedListener(new OnEditorActionAdapter<>(listener, field));", "\t\tsetUpCircleView(result, field, listener);"], "container": ["private <E> View createStandardEditView(ProfileField<E> field, E currentValue, FieldValueListener<E> listener, ViewGroup container) {", "\t\tView result = mInflater.inflate(R.layout.profileedit_field_standard, container, false);", "\t\t((TextView) result.findViewById(R.id.profileedit_field_identifier)).setText(friendlyName);", "\t\tEditText editText = (EditText) result.findViewById(R.id.profileedit_field_value);", "\t\tsetUpCircleView(result, field, listener);", "\t\treturn result;"]}
{"uniqueIdentifier": ["public final void sendNotification(String uniqueIdentifier, SPFActionSendNotification action) {", "        if (uniqueIdentifier == null || action == null) {", "        sendNotification(uniqueIdentifier, actionJSON);"], "action": ["public final void sendNotification(String uniqueIdentifier, SPFActionSendNotification action) {", "        if (uniqueIdentifier == null || action == null) {", "        String actionJSON = action.toJSON();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"field": ["public String getFriendlyNameOfField(ProfileField<?> field) {", "\t\tString name = getStringFromResource(PROFILE_FIELD_PREFIX + field.getIdentifier());", "\t\t\treturn field.getIdentifier();"]}
{"Result": "Method without Parameter"}
{"context": ["public static synchronized void initialize(Context context, int goIntent, boolean isAutonomous,", "        if (context == null || factory == null) {", "        SPF.initialize(context, goIntent, isAutonomous, factory);"], "goIntent": ["public static synchronized void initialize(Context context, int goIntent, boolean isAutonomous,", "        SPF.initialize(context, goIntent, isAutonomous, factory);"], "isAutonomous": ["public static synchronized void initialize(Context context, int goIntent, boolean isAutonomous,", "        SPF.initialize(context, goIntent, isAutonomous, factory);"], "factory": ["                                               ProximityMiddleware.Factory factory) {", "        if (context == null || factory == null) {", "        SPF.initialize(context, goIntent, isAutonomous, factory);"]}
{"code": ["public void broadcastEvent(final int code, final Bundle payload) {", "            Log.d(TAG, \"Broadcasting event \" + code + \" with payload \" + payload);", "                    listener.onEvent(code, payload);"], "payload": ["public void broadcastEvent(final int code, final Bundle payload) {", "            Log.d(TAG, \"Broadcasting event \" + code + \" with payload \" + payload);", "                    listener.onEvent(code, payload);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"source": ["public void beginCrop(Uri source) {", "        Crop.of(source, destination).asSquare().start(this.getActivity());"]}
{"resultCode": ["public void handleCrop(int resultCode, Intent result) {", "        if (resultCode == Activity.RESULT_OK) {", "        } else if (resultCode == Crop.RESULT_ERROR) {"], "result": ["public void handleCrop(int resultCode, Intent result) {", "            Uri uri = Crop.getOutput(result);", "            resultView.setImageURI(uri);", "                inputStream = new FileInputStream(uri.getPath());", "            Toast.makeText(this.getActivity(), Crop.getError(result).getMessage(), Toast.LENGTH_SHORT).show();"]}
{"object": ["public static <T> String toJson(final T object, final boolean newMapper)", "\t\tfinal String json = mapper.writeValueAsString(object);", "\t\treturn json;"], "newMapper": ["public static <T> String toJson(final T object, final boolean newMapper)", "\t\tfinal ObjectMapper mapper = ObjectMapperFactory.getObjectMapper(newMapper);", "\t\tfinal String json = mapper.writeValueAsString(object);"]}
{"tag": ["public void addTag(String tag) {", "\t\ttb.setText(tag);", "\t\ttags.add(tag.toString());"]}
{"tags": ["public void setTags(List<String> tags) {", "\t\tthis.tags.clear();", "\t\tfor (String tag : tags) {", "\t\t\taddTag(tag);"]}
{"trigger": ["public long saveTrigger(SPFTrigger trigger, String appPackageName) {", "        trigger = mTriggerTable.saveTrigger(trigger, appPackageName);"], "appPackageName": ["public long saveTrigger(SPFTrigger trigger, String appPackageName) {", "        trigger = mTriggerTable.saveTrigger(trigger, appPackageName);", "        if (trigger != null) {", "                mHandler.postAddTrigger(trigger);", "            return trigger.getId();"]}
{"id": ["public boolean deleteTrigger(long id, String appPackageName) {", "        boolean success = mTriggerTable.deleteTrigger(id, appPackageName);", "                mHandler.postRemoveTrigger(id);"], "appPackageName": ["public boolean deleteTrigger(long id, String appPackageName) {", "        boolean success = mTriggerTable.deleteTrigger(id, appPackageName);", "        if (success) {", "        return success;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"name": ["public String addAttribute(final String name, final String value)", "\t\treturn getAttributes().put(name, value);"], "value": ["public String addAttribute(final String name, final String value)", "\t\treturn getAttributes().put(name, value);"]}
{"request": ["public InvocationResponse invokeMethod(InvocationRequest request) {", "\t\tString methodName = request.getMethodName();", "\t\t\tparams = deserializeParameters(request.getPayload(), m.getGenericParameterTypes());"]}
{"selection": ["public void setSelection(String[] selection) {", "\t\tfor (String sel : selection) {", "\t\t\t\tif (mItems[j].equals(sel)) {"]}
{"selectedIndicies": ["public void setSelection(int[] selectedIndicies) {", "\t\tfor (int index : selectedIndicies) {", "\t\t\tif (index >= 0 && index < mSelection.length) {", "\t\t\t\tthrow new IllegalArgumentException(\"Index \" + index + \" is out of bounds.\");"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"object": ["public static <T> String toJsonQuietly(final T object)", "\t\t\treturn ObjectToJsonExtensions.toJson(object);", "\t\t\t\t\t+ object.toString() + \"\\n\","]}
{"context": ["protected static <C extends Component<C, I>, I extends IInterface> void load(final Context context, final Descriptor<C, I> descriptor, final ConnectionCallback<C> callback) {", "\t\tUtils.notNull(context, \"context must not be null\");", "\t\tif (AccessTokenManager.get(context).hasToken()) {", "\t\t\tbindToService(context, descriptor, callback);", "\t\t\tAccessTokenManager.get(context).requireAccessToken(context, new AccessTokenManager.RegistrationCallback() {", "\t\t\t\t\tbindToService(context, descriptor, callback);"], "descriptor": ["protected static <C extends Component<C, I>, I extends IInterface> void load(final Context context, final Descriptor<C, I> descriptor, final ConnectionCallback<C> callback) {", "\t\tUtils.notNull(descriptor, \"context must not be null\");", "\t\t\tbindToService(context, descriptor, callback);", "\t\t\t\t\tLog.d(\"Component\" , \"Access Toekn: \" + descriptor);", "\t\t\t\t\tbindToService(context, descriptor, callback);"], "callback": ["protected static <C extends Component<C, I>, I extends IInterface> void load(final Context context, final Descriptor<C, I> descriptor, final ConnectionCallback<C> callback) {", "\t\t\tbindToService(context, descriptor, callback);", "\t\t\t\t\tbindToService(context, descriptor, callback);", "\t\t\t\t\tcallback.onError(errorMsg);"]}
{"context": ["private static <C extends Component<C, I>, I extends IInterface> void bindToService(final Context context, final Descriptor<C, I> descriptor, final ConnectionCallback<C> callback) {", "\t\t\t\tC instance = descriptor.createInstance(context, service, this, callback);", "\t\tif (!context.bindService(intent, connection, Context.BIND_AUTO_CREATE)) {"], "descriptor": ["private static <C extends Component<C, I>, I extends IInterface> void bindToService(final Context context, final Descriptor<C, I> descriptor, final ConnectionCallback<C> callback) {", "\t\tintent.setAction(descriptor.getActionName());", "\t\t\t\tI service = descriptor.castInterface(binder);", "\t\t\t\tC instance = descriptor.createInstance(context, service, this, callback);"], "callback": ["private static <C extends Component<C, I>, I extends IInterface> void bindToService(final Context context, final Descriptor<C, I> descriptor, final ConnectionCallback<C> callback) {", "\t\t\t\tC instance = descriptor.createInstance(context, service, this, callback);", "\t\t\t\tcallback.onServiceReady(instance);", "\t\t\t\tcallback.onDisconnect();", "\t\t\tcallback.onError(new SPFError(SPFError.SPF_NOT_INSTALLED_ERROR_CODE));"]}
{"Result": "Method without Parameter"}
{"err": ["protected void handleError(SPFError err) {", "\t\tif (err.codeEquals(SPFError.TOKEN_NOT_VALID_ERROR_CODE)) {", "\t\tmCallback.onError(err);"]}
{"triggers2": ["public void refreshTriggers(List<SPFTrigger> triggers2) {", "\t\tfor (SPFTrigger trg : triggers2) {", "\t\t\ttriggers.put(trg.getId(), trg);"]}
{"persona": ["boolean addPersona(SPFPersona persona) {", "\t\tvalues.put(Contract.COLUMN_PERSONA, persona.getIdentifier());", "\t\t\tif (setValue(ProfileField.IDENTIFIER.getIdentifier(), id, persona.getIdentifier())) {", "\t\t\t\taddCircleToFieldsInternal(DefaultCircles.PUBLIC, ProfileField.IDENTIFIER, persona, db);", "\t\t\t\taddCircleToFieldsInternal(DefaultCircles.PUBLIC, ProfileField.DISPLAY_NAME, persona, db);", "\t\t\t\tremovePersona(persona);"]}
{"persona": ["boolean removePersona(SPFPersona persona) {", "\t\tif (persona.getIdentifier().equals(\"default\")) {", "\t\tString[] selectionArgs = { persona.getIdentifier() };", "\t\t\tdeleteFieldsOf(persona, db);", "\t\t\tdeleteVisibilityOf(persona, db);"]}
{"descriptor": ["public boolean registerService(SPFServiceDescriptor descriptor) {", "\t\tString appId = descriptor.getAppIdentifier();", "\t\tString serviceName = descriptor.getServiceName();", "\t\tfor (String verb : descriptor.getConsumedVerbs()) {", "\t\t\tif (!registerServiceInternal(verb, serviceName, appId)) {", "\t\t\tLog.v(TAG, \"Registered service as Activity consumer: \" + descriptor.getServiceName());"]}
{"appId": ["AppAuth getAppAuthorizationByAppId(String appId) {", "\t\tString args[] = { appId };", "\t\tCursor c = mRegistryTable.getReadableDatabase().query(Contract.TABLE_NAME, null, where, args, null, null, null);"]}
{"descriptor": ["public String registerApplication(AppDescriptor descriptor, SPFPersona persona) {", "\t\tcv.put(Contract.COLUMN_APP_NAME, descriptor.getAppName());", "\t\tcv.put(Contract.COLUMN_APP_IDENTIFIER, descriptor.getAppIdentifier());", "\t\tcv.put(Contract.COLUMN_PERMISSION_CODE, descriptor.getPermissionCode());"], "persona": ["public String registerApplication(AppDescriptor descriptor, SPFPersona persona) {", "\t\tcv.put(Contract.COLUMN_PERSONA, persona.getIdentifier());"]}
{"appIdentifier": ["public boolean unregisterApplication(String appIdentifier) {", "\t\tString[] whereArgs = { appIdentifier };", "\t\tif (mRegistryTable.getWritableDatabase().delete(Contract.TABLE_NAME, where, whereArgs) == 0) {", "\t\tif (SPF.get().getServiceRegistry().unregisterAllServicesOfApp(appIdentifier)) {", "\t\t\ti.putExtra(DEREGISTERED_APP, appIdentifier);"]}
{"appIdentifier": ["public SPFPersona getPersonaOf(String appIdentifier) {", "\t\tString[] selectionArgs = { appIdentifier };", "\t\tCursor c = db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy);"]}
{"msg": ["void onMessageReceived(final WfdMessage msg) {", "                if (msg.getReceiverId().equals(myIdentifier)) {", "                    handle(msg);", "                    route(msg);"]}
{"device": ["public void addClientIfNotPresent(DeviceGuiElement device) {", "                    && element.getName().equals(device.getName())", "                    && element.getAddress().equals(device.getAddress())) {", "            clients.add(device);"]}
{"Result": "Method without Parameter"}
{"field": ["public <E> E getFieldValue(ProfileField<E> field) {", "        if (field == null) {", "        String val = mFields.getString(field.getIdentifier());", "        return val == null ? null : ProfileFieldConverter.forField(field).fromStorageString(val);"]}
{"Result": "Method without Parameter"}
{"tag": ["public void stopSearch(int tag) {", "\t\tString queryId = mTagToId.get(tag);", "\t\tmTagToId.delete(tag);", "\t\tif (queryId != null && mCallbacks.remove(queryId) != null) {", "\t\t\tmSearchInterface.stopSearch(queryId);"]}
{"Result": "Method without Parameter"}
{"identifier": []}
{"auth": ["public ProfileFieldContainer getProfileFieldBulk(PersonAuth auth, SPFPersona persona, String[] fields) {", "\t\treturn mProfileTable.getProfileFieldBulk(persona, fields, auth);"], "persona": ["public ProfileFieldContainer getProfileFieldBulk(PersonAuth auth, SPFPersona persona, String[] fields) {", "\t\treturn mProfileTable.getProfileFieldBulk(persona, fields, auth);"], "fields": ["public ProfileFieldContainer getProfileFieldBulk(PersonAuth auth, SPFPersona persona, String[] fields) {", "\t\treturn mProfileTable.getProfileFieldBulk(persona, fields, auth);"]}
{"persona": ["public BaseInfo getBaseInfo(SPFPersona persona) {", "\t\tProfileFieldContainer pfc = getProfileFieldBulk(persona, ProfileField.IDENTIFIER, ProfileField.DISPLAY_NAME);"]}
{"xml": ["public static NodeList getNodeList(final String xml, final String xpathExpression)", "\t\tfinal Document doc = builder.parse(xml);", "\t\tfinal Object result = expr.evaluate(doc, XPathConstants.NODESET);"], "xpathExpression": ["public static NodeList getNodeList(final String xml, final String xpathExpression)", "\t\tfinal XPathExpression expr = xpath.compile(xpathExpression);", "\t\tfinal Object result = expr.evaluate(doc, XPathConstants.NODESET);"]}
{"callbackInterface": ["public static <E> E onMainThread(Class<E> callbackInterface, final E callback) {", "\t\tUtils.notNull(callbackInterface, \"callbackInterface must not be null\");", "\t\tObject proxy = Proxy.newProxyInstance(callbackInterface.getClassLoader(), new Class<?>[] { callbackInterface }, new InvocationHandler() {", "\t\treturn callbackInterface.cast(proxy);"], "callback": ["public static <E> E onMainThread(Class<E> callbackInterface, final E callback) {", "\t\tUtils.notNull(callback, \"callback must not be null\");", "\t\tfinal String tag = callback.getClass().getSimpleName();", "\t\t\t\t\t\t\tmethod.invoke(callback, args);"]}
{"receivedTkn": ["public PersonAuth getPersonAuthFrom(String receivedTkn) {", "\t\tif (receivedTkn.equals(\"\")) {", "\t\tString[] selectionArgs = { receivedTkn, Integer.toString(REQUEST_ACCEPTED) };"]}
{"targetUid": ["public String createEntryForSentRequest(String targetUid, String password) throws GeneralSecurityException {", "\t\tString user_uuid = targetUid;", "\t\tinsertNewEntry(user_uuid, token, request_status);"], "password": ["public String createEntryForSentRequest(String targetUid, String password) throws GeneralSecurityException {", "\t\treturn TokenCipher.encryptToken(token, password);"]}
{"fr": ["public boolean createEntryForReceivedRequest(ContactRequest fr) {", "\t\tString user_uuid = fr.getUserIdentifier();", "\t\tString receive_token = fr.getAccessToken();"]}
{"userUID": ["public int entryExistsFor(String userUID) {", "\t\tString[] selectionArgs = { userUID };", "\t\tCursor cursor = db.query(RelationshipEntry.TABLE_PERSON_AUTH, columns, selection, selectionArgs, /* groupBy */null, /* having */null, /* orderBy */"]}
{"targetUID": ["public boolean confirmRequest(String targetUID, String password) throws GeneralSecurityException, WrongPassphraseException {", "\t\tString[] selectionArgs = { targetUID };", "\t\tCursor c = db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy, limit);", "\t\t\t\treturn commitConfirmation(targetUID, password, decryptedTkn);"], "password": ["public boolean confirmRequest(String targetUID, String password) throws GeneralSecurityException, WrongPassphraseException {", "\t\t\tString decryptedTkn = TokenCipher.decryptToken(token, password);", "\t\t\tif (decryptedTkn != null) {", "\t\t\t\treturn commitConfirmation(targetUID, password, decryptedTkn);"]}
{"tagName": ["  public void addClosingTag(String tagName)", "    _xml.addClosingTag(tagName);"]}
{"tagName": ["  public void addEmptyTag(String tagName)", "    _xml.addEmptyTag(tagName);"]}
{"tagName": ["  public void addOpeningTag(String tagName, Map attributes)", "    _xml.addOpeningTag(tagName, attributes);"], "attributes": ["  public void addOpeningTag(String tagName, Map attributes)", "    _xml.addOpeningTag(tagName, attributes);"]}
{"file": ["public static boolean deleteFile(File file) throws IOException", "    if(!file.exists())", "    File[] files = file.listFiles();", "        if(childFile.equals(file))", "    return file.delete();"]}
{"namespace": ["public static File createTempDirectory(String namespace, String name) throws IOException", "    File dir = File.createTempFile(namespace, \"\");"], "name": ["public static File createTempDirectory(String namespace, String name) throws IOException", "    File tempDir = new File(dir, name);", "    createNewDirectory(tempDir);", "    return tempDir.getCanonicalFile();"]}
{"proxy": ["  public static Object getProxiedObject(Object proxy)", "    if(Proxy.isProxyClass(proxy.getClass()))", "      InvocationHandler invocationHandler = Proxy.getInvocationHandler(proxy);", "      if(invocationHandler instanceof ObjectProxy)", "        ObjectProxy objectProxy = (ObjectProxy) invocationHandler;", "        return getProxiedObject(objectProxy.getProxiedObject());", "        return proxy;", "      return proxy;"]}
{"clazz": ["public static Class forName(Class clazz, ClassLoader classLoader)", "    if(clazz == null)", "    if(clazz.getClassLoader() == null || clazz.getClassLoader().equals(classLoader))", "      return clazz;", "      return forName(clazz.getName(), classLoader);"], "classLoader": ["public static Class forName(Class clazz, ClassLoader classLoader)", "    if(classLoader == null)", "    if(clazz.getClassLoader() == null || clazz.getClassLoader().equals(classLoader))", "      return forName(clazz.getName(), classLoader);"]}
{"m": ["  public static String computeSignature(Method m)", "    sb.append(m.getName()).append('(');", "    Class[] parameterTypes = m.getParameterTypes();"]}
{"algorithm": ["private static OneWayMessageDigestCodec createWellKnownInstance(String algorithm,", "      return new OneWayMessageDigestCodec(algorithm, password, codec);"], "password": ["                                                                  String password,", "      return new OneWayMessageDigestCodec(algorithm, password, codec);"], "codec": ["                                                                  OneWayCodec codec)", "      return new OneWayMessageDigestCodec(algorithm, password, codec);"]}
{"Result": "Method without Parameter"}
{"path": ["public static URLBuilder createFromPath(String path)", "    res.setPath(path);"]}
{"url": ["public static URL addQueryParameter(URL url, String name, String value)", "    URLBuilder ub = createFromURL(url);", "    ub.addQueryParameter(name, value);", "    return ub;"], "name": ["public static URL addQueryParameter(URL url, String name, String value)", "    ub.addQueryParameter(name, value);"], "value": ["public static URL addQueryParameter(URL url, String name, String value)", "    ub.addQueryParameter(name, value);"]}
{"name": ["  public String getParameter(String name)", "    String[] params = getParameterValues(name);", "    if(params == null)", "    return params[0];"]}
{"name": ["private void addQueryParameter(String name, String value)", "    _query.append(encode(name));"], "value": ["private void addQueryParameter(String name, String value)", "    _query.append(encode(value));"]}
{"parameters": ["public void addParameters(Map<String, String[]> parameters)", "    for(Map.Entry<String, String[]> entry : parameters.entrySet())", "      addParameters(entry.getKey(), entry.getValue());"]}
{"name": ["public void addIndexedParameter(String name, int value, int index)", "    addParameter(getIndexedParamName(name, index), value);"], "value": ["public void addIndexedParameter(String name, int value, int index)", "    addParameter(getIndexedParamName(name, index), value);"], "index": ["public void addIndexedParameter(String name, int value, int index)", "    addParameter(getIndexedParamName(name, index), value);"]}
{"uri": ["public void addQuery(URI uri)", "      addQuery(uri.getRawQuery(), false);"]}
{"query": ["private void validateQuery(String query) throws URISyntaxException", "    if(query.length() == 0)", "    Iterator<String> iter = SS.splitToIterator(query);", "    while(iter.hasNext())", "      String s = iter.next();", "      if(s.length() > 0)", "        int idx = s.indexOf('=');", "        if(idx == -1)", "          throw new URISyntaxException(query, \"missing equal sign in \" + s);", "        if(s.lastIndexOf('=') != idx)", "          throw new URISyntaxException(query, \"extra equal sign in \" + s);"]}
{"query": ["public void addQuery(Query query)", "    if(query == null)", "      if(!query.getEncoding().equals(getEncoding()))", "      addQuery(query.getQuery(), false);"]}
{"Result": "Method without Parameter"}
{"name": ["public String[] replaceParameter(String name, String value)", "    String[] v = map.put(name, new String[] { value });"], "value": ["public String[] replaceParameter(String name, String value)", "    String[] v = map.put(name, new String[] { value });", "    return v;"]}
{"o": [], "method": ["  public Object invoke(Object o, Method method, Object[] objects)", "      return method.invoke(_object, objects);", "        log.error(method.toString(), throwable);"], "objects": ["  public Object invoke(Object o, Method method, Object[] objects)", "      return method.invoke(_object, objects);"]}
{"o": ["public static Object createShutdownProxy(Object o,", "      interfaces = ReflectUtils.extractAllInterfaces(o);", "    return Proxy.newProxyInstance(o.getClass().getClassLoader(),", "                                  interfaces,", "                                  new ShutdownProxy(o, shutdown));"], "interfaces": ["                                           Class[] interfaces,", "    if(interfaces == null)", "                                  interfaces,"], "shutdown": ["                                           Shutdown shutdown)", "                                  new ShutdownProxy(o, shutdown));"]}
{"o": ["public static boolean convertToBoolean(Object o)", "    if(o == null)", "    if(o instanceof Boolean)", "      return (Boolean) o;", "    return convertToBoolean(o.toString());"]}
{"th": ["public static String getStackTrace(Throwable th)", "    th.printStackTrace(pw);"]}
{"path": ["public static String removeTrailingSlash(String path)", "    if(path.endsWith(\"/\"))", "      return path.substring(0, path.length() - 1);", "      return path;"]}
{"timeout": ["  public void waitForShutdown(Object timeout)", "    pendingCallsCount.waitForCounter(timeout);"]}
{"tagName": ["  public void addEmptyTag(String tagName, Map attributes)", "    _xml.append('<').append(tagName);"], "attributes": ["  public void addEmptyTag(String tagName, Map attributes)", "    addAttributes(attributes);"]}
{"attrName": ["private void addAttribute(String attrName, String attrValue)", "    if(attrName == null)", "    _xml.append(attrName).append(\"=\\\"\");"], "attrValue": ["private void addAttribute(String attrName, String attrValue)", "    _xml.append(XMLUtils.xmlEncode(attrValue)).append('\"');"]}
{"attributes": ["private void addAttributes(Map attributes)", "    if(attributes == null)", "    Iterator iter = attributes.keySet().iterator();", "      Object attrValue = attributes.get(attrName);", "      if(attrValue != null)", "        addAttribute(attrName, attrValue.toString());"]}
{"url": ["public static ResourceInfo extractInfo(URL url) throws IOException", "    URLConnection urlConnection = url.openConnection();"]}
{"resource": ["  public InternalResource chroot(InternalResource resource)", "    String path = resource.getPath();", "    if(resource.isDirectory())", "      return (InternalResource) resource.chroot(\"..\").createRelative(resource.getFilename());"]}
{"resource": ["  public InternalResource[] list(InternalResource resource, final ResourceFilter filter)", "    String path = PathUtils.addTrailingSlash(resource.getPath());", "      public boolean accept(Resource resource)", "        boolean res = filter.accept(resource);", "        if(res)", "          resources.add(resource);", "        return res;"], "filter": ["  public InternalResource[] list(InternalResource resource, final ResourceFilter filter)", "        boolean res = filter.accept(resource);"]}
{"relativePath": ["  public Resource chroot(String relativePath)", "    return _resourceProvider.chroot((InternalResource) createRelative(relativePath));"]}
{"file": ["public static Resource create(File file)", "      String path = file.getCanonicalPath();", "      if(file.isDirectory())", "      throw new IllegalArgumentException(\"invalid file \" + file, e);"]}
{"Result": "Method without Parameter"}
{"commands": ["public static ExternalCommand create(List<String> commands)", "    ExternalCommand ec = new ExternalCommand(new ProcessBuilder(commands));", "    return ec;"]}
{"Result": "Method without Parameter"}
{"workingDirectory": ["public static ExternalCommand execute(File workingDirectory,", "      return executeWithTimeout(workingDirectory, command, 0, args);"], "command": ["                                        String command,", "      return executeWithTimeout(workingDirectory, command, 0, args);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"tagName": ["  public void addTag(String tagName,", "    addTag(tagName, String.valueOf(value), attrName, attrValue);"], "value": ["                     int value,", "    addTag(tagName, String.valueOf(value), attrName, attrValue);"], "attrName": ["                     String attrName,", "    addTag(tagName, String.valueOf(value), attrName, attrValue);"], "attrValue": ["                     String attrValue)", "    addTag(tagName, String.valueOf(value), attrName, attrValue);"]}
{"tagName": ["  public void addTag(String tagName, int value, Map attributes)", "    addTag(tagName, String.valueOf(value), attributes);"], "value": ["  public void addTag(String tagName, int value, Map attributes)", "    addTag(tagName, String.valueOf(value), attributes);"], "attributes": ["  public void addTag(String tagName, int value, Map attributes)", "    addTag(tagName, String.valueOf(value), attributes);"]}
{"block": ["public static String indentBlock(String block, Indent indent)", "    BufferedReader br = new BufferedReader(new StringReader(block));", "      while((line = br.readLine()) != null)", "        sb.append(indent).append(line).append('\\n');"], "indent": ["public static String indentBlock(String block, Indent indent)", "        sb.append(indent).append(line).append('\\n');"]}
{"clock": ["public static long toEndTime(Clock clock, Object timeout)", "    if(clock == null)", "    return t.futureTimeMillis(clock);"], "timeout": ["public static long toEndTime(Clock clock, Object timeout)", "    Timespan t = toTimespan(timeout);", "    if(t == null)", "    if(t.getDurationInMilliseconds() == 0)", "    return t.futureTimeMillis(clock);"]}
{"entry": ["public RAMEntry add(RAMEntry entry)", "    _directoryContent.put(entry.name(), entry);", "    return entry;"]}
{"name": ["public RAMDirectory mkdir(String name) throws IOException", "    RAMEntry entry = getEntry(name);", "    if(entry instanceof RAMDirectory)", "      RAMDirectory ramDirectory = (RAMDirectory) entry;", "      return ramDirectory;", "      if(entry == null)", "        RAMDirectory directory = new RAMDirectory(_clock, name);", "        return (RAMDirectory) add(directory);", "        throw new IOException(\"File exists: \" + name);"]}
{"codec": ["public static String encodeString(OneWayCodec codec, String s)", "      return codec.encode(s.getBytes(\"UTF-8\"));"], "s": ["public static String encodeString(OneWayCodec codec, String s)", "      return codec.encode(s.getBytes(\"UTF-8\"));"]}
{"codec": ["public static String decodeString(Codec codec, String s)", "      return new String(codec.decode(s), \"UTF-8\");"], "s": ["public static String decodeString(Codec codec, String s)", "      return new String(codec.decode(s), \"UTF-8\");"]}
{"resource": ["public static LeafResource create(Resource resource)", "      resource.getFile();", "      return new LeafResourceImpl(resource);", "      return new LocalCacheLeafResource(resource);"]}
{"array": ["public static <T> T[] reverse(T[] array)", "    if(array == null)", "      return array;", "    int e = array.length - 1;", "      T tmp = array[e];", "      array[e] = array[s];", "      array[s] = tmp;", "    return array;"]}
{"clazz": ["public static <T extends Enum<T>> EnumSet<T> toEnumSet(Class<T> clazz, T... ts)", "    EnumSet<T> res = EnumSet.noneOf(clazz);", "      res.add(t);", "    return res;"]}
{"file": ["public static Properties loadProperties(File file) throws IOException", "    if(file == null)", "    FileReader reader = new FileReader(file);", "      return loadProperties(reader);", "      reader.close();"]}
{"reader": ["public static Properties loadProperties(Reader reader) throws IOException", "    if(reader == null)", "    properties.load(reader);"]}
{"timeUnits": ["public String getAsString(EnumSet<TimeUnit> timeUnits)", "    EnumMap<TimeUnit, Timespan> canonicalTimespans = getAsTimespans(timeUnits);", "      if(canonicalTimespans.containsKey(timeUnit))", "        long duration = canonicalTimespans.get(timeUnit).getDuration();", "        if(duration > 0)", "          sb.append(duration).append(timeUnit.getDisplayChar());", "      if(timeUnits.contains(getTimeUnit()))"]}
{"timespan": ["  public int compareTo(Timespan timespan)", "    if(timespan.getTimeUnit() == getTimeUnit())", "      return LangUtils.compare(getDuration(), timespan.getDuration());", "      return LangUtils.compare(getDurationInMilliseconds(), timespan.getDurationInMilliseconds());"]}
{"sizeUnit": ["public MemorySize truncate(SizeUnit sizeUnit)", "    if (getSizeUnit() == sizeUnit)", "    if (sizeInBytes >= sizeUnit.getBytesCount())", "      return new MemorySize(sizeInBytes / sizeUnit.getBytesCount(), sizeUnit);", "      return ZERO_SIZES.get(sizeUnit);"]}
{"other": ["public MemorySize add(MemorySize other)", "    if(other == null)", "    if(getSizeUnit() == other.getSizeUnit())", "      return new MemorySize(getSize() + other.getSize(), getSizeUnit());", "    return new MemorySize(getSizeInBytes() + other.getSizeInBytes(),"]}
{"memorySize": ["  public int compareTo(MemorySize memorySize)", "    if (memorySize == null)", "    if (getSizeUnit() == memorySize.getSizeUnit())", "      return LangUtils.compare(getSize(), memorySize.getSize());", "    return LangUtils.compare(getSizeInBytes(), memorySize.getSizeInBytes());"]}
{"Result": "Method without Parameter"}
{"callable": ["public static <V> Future<V> execute(Callable<V> callable)", "    FutureTask<V> futureTask = new FutureTask<V>(callable);", "    new Thread(futureTask).start();", "    return futureTask;"]}
{"marker": ["public void addMarker(T marker) {", "        marker.setMarkerManager(this);", "        marker.prepareMarker(markerOptions);", "        markerCache.put(marker, googleMap.addMarker(markerOptions));", "        marker.onAdd();"]}
{"marker": ["public void removeMarker(T marker) {", "        final Marker realMarker = markerCache.get(marker);", "        if (realMarker != null) {", "            realMarker.remove();", "        markerCache.remove(marker);"]}
{"view": ["public static BitmapDescriptor fromView(View view) {", "        view.measure(spec, spec);", "        final int width = view.getMeasuredWidth();", "        final int height = view.getMeasuredHeight();", "        view.layout(0, 0, width, height);", "        view.draw(canvas);"]}
{"file": ["private final static Func1<WatchEvent<?>, Boolean> onlyRelatedTo(final File file) {", "                if (file.isDirectory())", "                        Path basePath = getBasePath(file);", "                        File pFile = new File(basePath.toFile(), p.toString());", "                        ok = pFile.getAbsolutePath().equals(file.getAbsolutePath());"]}
{"watchService": ["private static boolean emitEvents(WatchService watchService,", "        WatchKey key = nextKey(watchService, subscriber, pollDurationMs);"], "subscriber": ["            Subscriber<? super WatchEvent<?>> subscriber, long pollDurationMs,", "        WatchKey key = nextKey(watchService, subscriber, pollDurationMs);", "            if (subscriber.isUnsubscribed())", "                if (subscriber.isUnsubscribed())", "                    subscriber.onNext(event);", "            if (!valid && !subscriber.isUnsubscribed()) {", "                subscriber.onCompleted();"], "pollDurationMs": ["            Subscriber<? super WatchEvent<?>> subscriber, long pollDurationMs,", "        WatchKey key = nextKey(watchService, subscriber, pollDurationMs);", "        if (key != null) {", "            for (WatchEvent<?> event : key.pollEvents()) {", "                    subscriber.onNext(event);", "            boolean valid = key.reset();"], "pollIntervalMs": []}
{"Result": "Method without Parameter"}
{"viewPager": ["public void initWithViewPager(ViewPager viewPager) throws IllegalStateException {", "        if ( viewPager == null ) return;", "        if ( viewPager.getAdapter() == null ) throw new IllegalStateException(\"ViewPager has no adapter set.\");", "            mViewPager = viewPager;", "            mViewPager.addOnPageChangeListener(mOnPageChangeListener);"]}
{"Result": "Method without Parameter"}
{"e": ["private String getMessageFor(Exception e) {", "        if ( e == null ) return TAG + \": No Message.\";", "        return e != null && e.getMessage() != null ? e.getMessage() : e.getClass().getName() + \": No Message.\";"]}
{"Result": "Method without Parameter"}
{"x": ["private static int intValue(char x) {", "        if (x >= '0' && x <= '9')", "            return x - '0';", "        if (x >= 'a' && x <= 'f')", "            return x - 'a' + 10;", "        if (x >= 'A' && x <= 'F')", "            return x - 'A' + 10;", "        throw new RuntimeException(\"Error parsing UUID at character: \" + x);"]}
{"a": ["private static byte mapToByte(char a, char b) {", "        int ai = intValue(a);", "        return (byte) ((ai << 4) | bi);"], "b": ["private static byte mapToByte(char a, char b) {", "        int bi = intValue(b);", "        return (byte) ((ai << 4) | bi);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"key": ["public void setProperty(String key, String value) {", "\t\t\tproperties.put(key, value);", "\t\t\tproperties.remove(key);"], "value": ["public void setProperty(String key, String value) {", "\t\tif(value != null) {", "\t\t\tvalue = value.trim();"]}
{"userId": ["\tpublic void setFacebookUserCredentials(String userId, String token) {", "\t\tsetProperty(SocializeConfig.FACEBOOK_USER_ID, userId);"], "token": ["\tpublic void setFacebookUserCredentials(String userId, String token) {", "\t\tsetProperty(SocializeConfig.FACEBOOK_USER_TOKEN, token);"]}
{"consumerKey": ["public void setSocializeCredentials(String consumerKey, String consumerSecret) {", "\t\tsetProperty(SocializeConfig.SOCIALIZE_CONSUMER_KEY, consumerKey);"], "consumerSecret": ["public void setSocializeCredentials(String consumerKey, String consumerSecret) {", "\t\tsetProperty(SocializeConfig.SOCIALIZE_CONSUMER_SECRET, consumerSecret);"]}
{"other": ["public void merge(Properties other, Set<String> toBeRemoved) {", "\t\tif(other != null && other.size() > 0) {", "\t\t\tSet<Entry<Object, Object>> entrySet = other.entrySet();"], "toBeRemoved": ["public void merge(Properties other, Set<String> toBeRemoved) {", "\t\tif(toBeRemoved != null && toBeRemoved.size() > 0) {", "\t\t\tfor (String key : toBeRemoved) {", "\t\t\t\tproperties.remove(key);", "\t\t\ttoBeRemoved.clear();"]}
{"context": ["protected void doShare(final Activity context, final Entity entity, final ShareType shareType, final ShareAddListener shareAddListener) {", "\t\tshareSystem.addShare(context, session, entity, \"\", shareType, null, new ShareAddListener() {", "\t\t\t\t\thandleNonNetworkShare(context, session, shareType, share, \"\", null, shareAddListener);"], "entity": ["protected void doShare(final Activity context, final Entity entity, final ShareType shareType, final ShareAddListener shareAddListener) {", "\t\tshareSystem.addShare(context, session, entity, \"\", shareType, null, new ShareAddListener() {"], "shareType": ["protected void doShare(final Activity context, final Entity entity, final ShareType shareType, final ShareAddListener shareAddListener) {", "\t\tshareSystem.addShare(context, session, entity, \"\", shareType, null, new ShareAddListener() {", "\t\t\t\t\thandleNonNetworkShare(context, session, shareType, share, \"\", null, shareAddListener);"], "shareAddListener": ["protected void doShare(final Activity context, final Entity entity, final ShareType shareType, final ShareAddListener shareAddListener) {", "\t\t\t\tif(shareAddListener != null) {", "\t\t\t\t\tshareAddListener.onError(error);", "\t\t\t\t\thandleNonNetworkShare(context, session, shareType, share, \"\", null, shareAddListener);"]}
{"activity": ["protected void handleNonNetworkShare(Activity activity, final SocializeSession session, final ShareType shareType, final Share share, String shareText, Location location, final ShareAddListener shareAddListener) {", "\t\tshareSystem.share(activity, session, share, shareText, location, shareType, snListener);"], "session": ["protected void handleNonNetworkShare(Activity activity, final SocializeSession session, final ShareType shareType, final Share share, String shareText, Location location, final ShareAddListener shareAddListener) {", "\t\tshareSystem.share(activity, session, share, shareText, location, shareType, snListener);"], "shareType": ["protected void handleNonNetworkShare(Activity activity, final SocializeSession session, final ShareType shareType, final Share share, String shareText, Location location, final ShareAddListener shareAddListener) {", "\t\tshareSystem.share(activity, session, share, shareText, location, shareType, snListener);"], "share": ["protected void handleNonNetworkShare(Activity activity, final SocializeSession session, final ShareType shareType, final Share share, String shareText, Location location, final ShareAddListener shareAddListener) {", "\t\tSocialNetworkListener snListener = new SocialNetworkListener() {", "\t\t\t\t\tshareAddListener.onCreate(share);", "\t\tshareSystem.share(activity, session, share, shareText, location, shareType, snListener);"], "shareText": ["protected void handleNonNetworkShare(Activity activity, final SocializeSession session, final ShareType shareType, final Share share, String shareText, Location location, final ShareAddListener shareAddListener) {", "\t\tshareSystem.share(activity, session, share, shareText, location, shareType, snListener);"], "location": ["protected void handleNonNetworkShare(Activity activity, final SocializeSession session, final ShareType shareType, final Share share, String shareText, Location location, final ShareAddListener shareAddListener) {", "\t\tshareSystem.share(activity, session, share, shareText, location, shareType, snListener);"], "shareAddListener": ["protected void handleNonNetworkShare(Activity activity, final SocializeSession session, final ShareType shareType, final Share share, String shareText, Location location, final ShareAddListener shareAddListener) {", "\t\t\t\tif(shareAddListener != null) {", "\t\t\t\t\tshareAddListener.onError(SocializeException.wrap(error));", "\t\t\t\tif(shareAddListener != null) {", "\t\t\t\t\tshareAddListener.onCancel();", "\t\t\t\treturn shareAddListener instanceof SocialNetworkListener && ((SimpleShareListener) shareAddListener).onBeforePost(parent, socialNetwork, postData);", "\t\t\t\tif(shareAddListener != null) {", "\t\t\t\t\tshareAddListener.onCreate(share);"]}
{"context": ["public static void addComment (Activity context, Entity entity, String text, CommentAddListener listener) {", "\t\tproxy.addComment(context, entity, text, listener);"], "entity": ["public static void addComment (Activity context, Entity entity, String text, CommentAddListener listener) {", "\t\tproxy.addComment(context, entity, text, listener);"], "text": ["public static void addComment (Activity context, Entity entity, String text, CommentAddListener listener) {", "\t\tproxy.addComment(context, entity, text, listener);"], "listener": ["public static void addComment (Activity context, Entity entity, String text, CommentAddListener listener) {", "\t\tproxy.addComment(context, entity, text, listener);"]}
{"context": ["public static void deleteComment (Activity context, long id, CommentDeleteListener listener) {", "\t\tproxy.deleteComment(context, id, listener);"], "id": ["public static void deleteComment (Activity context, long id, CommentDeleteListener listener) {", "\t\tproxy.deleteComment(context, id, listener);"], "listener": ["public static void deleteComment (Activity context, long id, CommentDeleteListener listener) {", "\t\tproxy.deleteComment(context, id, listener);"]}
{"context": ["public static void addComment (Activity context, Entity entity, String text, CommentOptions commentOptions, CommentAddListener listener, SocialNetwork...networks) {", "\t\tproxy.addComment(context, entity, text, commentOptions, listener, networks);"], "entity": ["public static void addComment (Activity context, Entity entity, String text, CommentOptions commentOptions, CommentAddListener listener, SocialNetwork...networks) {", "\t\tproxy.addComment(context, entity, text, commentOptions, listener, networks);"], "text": ["public static void addComment (Activity context, Entity entity, String text, CommentOptions commentOptions, CommentAddListener listener, SocialNetwork...networks) {", "\t\tproxy.addComment(context, entity, text, commentOptions, listener, networks);"], "commentOptions": ["public static void addComment (Activity context, Entity entity, String text, CommentOptions commentOptions, CommentAddListener listener, SocialNetwork...networks) {", "\t\tproxy.addComment(context, entity, text, commentOptions, listener, networks);"], "listener": ["public static void addComment (Activity context, Entity entity, String text, CommentOptions commentOptions, CommentAddListener listener, SocialNetwork...networks) {", "\t\tproxy.addComment(context, entity, text, commentOptions, listener, networks);"]}
{"context": ["public static void getComment (Activity context, CommentGetListener listener, long id) {", "\t\tproxy.getComment(context, id, listener);"], "listener": ["public static void getComment (Activity context, CommentGetListener listener, long id) {", "\t\tproxy.getComment(context, id, listener);"], "id": ["public static void getComment (Activity context, CommentGetListener listener, long id) {", "\t\tproxy.getComment(context, id, listener);"]}
{"context": ["public static void getComments (Activity context, CommentListListener listener, long...ids) {", "\t\tproxy.getComments(context, listener, ids);"], "listener": ["public static void getComments (Activity context, CommentListListener listener, long...ids) {", "\t\tproxy.getComments(context, listener, ids);"]}
{"context": ["public static void getCommentsByUser (Activity context, User user, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByUser(context, user, start, end, listener);"], "user": ["public static void getCommentsByUser (Activity context, User user, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByUser(context, user, start, end, listener);"], "start": ["public static void getCommentsByUser (Activity context, User user, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByUser(context, user, start, end, listener);"], "end": ["public static void getCommentsByUser (Activity context, User user, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByUser(context, user, start, end, listener);"], "listener": ["public static void getCommentsByUser (Activity context, User user, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByUser(context, user, start, end, listener);"]}
{"context": ["public static void getCommentsByEntity (Activity context, String entityKey, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByEntity(context, entityKey, start, end, listener);"], "entityKey": ["public static void getCommentsByEntity (Activity context, String entityKey, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByEntity(context, entityKey, start, end, listener);"], "start": ["public static void getCommentsByEntity (Activity context, String entityKey, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByEntity(context, entityKey, start, end, listener);"], "end": ["public static void getCommentsByEntity (Activity context, String entityKey, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByEntity(context, entityKey, start, end, listener);"], "listener": ["public static void getCommentsByEntity (Activity context, String entityKey, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByEntity(context, entityKey, start, end, listener);"]}
{"context": ["public static void getCommentsByApplication (Activity context, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByApplication(context, start, end, listener);"], "start": ["public static void getCommentsByApplication (Activity context, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByApplication(context, start, end, listener);"], "end": ["public static void getCommentsByApplication (Activity context, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByApplication(context, start, end, listener);"], "listener": ["public static void getCommentsByApplication (Activity context, int start, int end, CommentListListener listener) {", "\t\tproxy.getCommentsByApplication(context, start, end, listener);"]}
{"context": ["public static void showCommentView(Activity context, Entity entity, OnCommentViewActionListener listener) {", "\t\tproxy.showCommentView(context, entity, listener);"], "entity": ["public static void showCommentView(Activity context, Entity entity, OnCommentViewActionListener listener) {", "\t\tproxy.showCommentView(context, entity, listener);"], "listener": ["public static void showCommentView(Activity context, Entity entity, OnCommentViewActionListener listener) {", "\t\tproxy.showCommentView(context, entity, listener);"]}
{"json": ["public JSONObject parseObject(String json) throws JSONException {", "\t\tjson = json.trim();"]}
{"url": ["public static String openUrl(String url, String method, Bundle params)", "            url = url + \"?\" + encodeUrl(params);", "        Util.logd(\"Facebook-Util\", method + \" URL: \" + url);", "            (HttpURLConnection) new URL(url).openConnection();"], "method": ["public static String openUrl(String url, String method, Bundle params)", "        if (method.equals(\"GET\")) {", "        Util.logd(\"Facebook-Util\", method + \" URL: \" + url);", "        if (!method.equals(\"GET\")) {", "                params.putString(\"method\", method);"], "params": ["public static String openUrl(String url, String method, Bundle params)", "            url = url + \"?\" + encodeUrl(params);", "        Util.logd(\"Facebook-Util\", method + \" URL: \" + url);", "            (HttpURLConnection) new URL(url).openConnection();", "            for (String key : params.keySet()) {", "                Object parameter = params.get(key);", "                if (parameter instanceof byte[]) {", "                    dataparams.putByteArray(key, (byte[])parameter);", "            if (!params.containsKey(\"method\")) {", "                params.putString(\"method\", method);", "            if (params.containsKey(\"access_token\")) {", "                    URLDecoder.decode(params.getString(\"access_token\"));", "                params.putString(\"access_token\", decoded_token);", "            os.write((encodePostBody(params, strBoundary)).getBytes());"]}
{"response": ["public static JSONObject parseJson(String response)", "        if (response.equals(\"false\")) {", "        if (response.equals(\"true\")) {", "        JSONObject json = new JSONObject(response);", "        if (json.has(\"error\")) {", "            JSONObject error = json.getJSONObject(\"error\");", "        if (json.has(\"error_code\") && json.has(\"error_msg\")) {", "            throw new FacebookError(json.getString(\"error_msg\"), \"\",", "                    Integer.parseInt(json.getString(\"error_code\")));", "        if (json.has(\"error_code\")) {", "                    Integer.parseInt(json.getString(\"error_code\")));", "        if (json.has(\"error_msg\")) {", "            throw new FacebookError(json.getString(\"error_msg\"));", "        if (json.has(\"error_reason\")) {", "            throw new FacebookError(json.getString(\"error_reason\"));", "        return json;"]}
{"context": ["public static void showAlert(Context context, String title, String text) {", "        Builder alertBuilder = new Builder(context);", "        alertBuilder.setTitle(title);", "        alertBuilder.setMessage(text);", "        alertBuilder.create().show();"], "title": ["public static void showAlert(Context context, String title, String text) {", "        alertBuilder.setTitle(title);"], "text": ["public static void showAlert(Context context, String title, String text) {", "        alertBuilder.setMessage(text);"]}
{"tag": ["public static void logd(String tag, String msg) {", "            Log.d(tag, msg);"], "msg": ["public static void logd(String tag, String msg) {", "            Log.d(tag, msg);"]}
{"type": ["private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {\r", "        && (type == Object.class || type instanceof TypeVariable<?> || type instanceof Class<?>)) {\r", "    return type;\r"], "value": ["private Type getRuntimeTypeIfMoreSpecific(Type type, Object value) {\r", "    if (value != null\r", "      type = value.getClass();\r"]}
{"entity": ["public void setEntitySafe(Entity entity) {", "\t\tif(StringUtils.isEmpty(entity.getName())) {", "\t\t\tsetEntityKey(entity.getKey());", "\t\t\tsetEntity(entity);"]}
{"id": ["public String buildProfileImageUrl(String id) {", "\t\tbuilder.append(id);"]}
{"bitmap": ["public void onImageChange(Bitmap bitmap) {", "\t\tif(bitmap != null) {", "\t\t\tBitmap scaled = bitmapUtils.getScaledBitmap(bitmap, 200, 200);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"activity": ["public void authorize(Activity activity, final DialogListener listener) {", "        authorize(activity, new String[] {}, DEFAULT_AUTH_ACTIVITY_CODE,"], "listener": ["public void authorize(Activity activity, final DialogListener listener) {", "                listener);"]}
{"activity": ["public void authorize(Activity activity, String[] permissions,", "            singleSignOnStarted = startSingleSignOn(activity, mAppId,", "            startDialogAuth(activity, permissions);"], "permissions": ["public void authorize(Activity activity, String[] permissions,", "                    permissions, activityCode);", "            startDialogAuth(activity, permissions);"], "activityCode": ["            int activityCode, final DialogListener listener) {", "        if (activityCode >= 0) {", "            singleSignOnStarted = startSingleSignOn(activity, mAppId,", "                    permissions, activityCode);", "        if (!singleSignOnStarted) {"], "listener": ["            int activityCode, final DialogListener listener) {", "        mAuthDialogListener = listener;"]}
{"context": ["private boolean validateActivityIntent(Context context, Intent intent) {", "            context.getPackageManager().resolveActivity(intent, 0);", "            context,"], "intent": ["private boolean validateActivityIntent(Context context, Intent intent) {", "            context.getPackageManager().resolveActivity(intent, 0);"]}
{"context": ["public String logout(Context context)", "        Util.clearCookies(context);"]}
{"context": ["public void dialog(Context context, String action, Bundle parameters,", "        if (context.checkCallingOrSelfPermission(Manifest.permission.INTERNET)", "            Util.showAlert(context, \"Error\",", "            new FbDialog(context, url, listener).show();"], "action": ["public void dialog(Context context, String action, Bundle parameters,", "        String endpoint = DIALOG_BASE_URL + action;", "        if (action.equals(LOGIN)) {", "        String url = endpoint + \"?\" + Util.encodeUrl(parameters);"], "parameters": ["public void dialog(Context context, String action, Bundle parameters,", "        parameters.putString(\"display\", \"touch\");", "        parameters.putString(\"redirect_uri\", REDIRECT_URI);", "            parameters.putString(\"type\", \"user_agent\");", "            parameters.putString(\"client_id\", mAppId);", "            parameters.putString(\"app_id\", mAppId);", "            parameters.putString(TOKEN, getAccessToken());", "        String url = endpoint + \"?\" + Util.encodeUrl(parameters);", "            new FbDialog(context, url, listener).show();"], "listener": ["            final DialogListener listener) {", "            new FbDialog(context, url, listener).show();"]}
{"src": ["public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) {", "      String dateFormatAsString = enUsFormat.format(src);", "      return new JsonPrimitive(dateFormatAsString);"], "typeOfSrc": [], "context": []}
{"context": ["\tpublic static void link (Activity context, SocializeAuthListener listener) {", "\t\tproxy.link(context, listener);"], "listener": ["\tpublic static void link (Activity context, SocializeAuthListener listener) {", "\t\tproxy.link(context, listener);"]}
{"context": ["\tpublic static void link (Activity context, SocializeAuthListener listener, String...permissions) {", "\t\tproxy.link(context, listener, permissions);"], "listener": ["\tpublic static void link (Activity context, SocializeAuthListener listener, String...permissions) {", "\t\tproxy.link(context, listener, permissions);"]}
{"context": ["\tpublic static void link (Activity context, String token, boolean verifyPermissions, SocializeAuthListener listener){", "\t\tproxy.link(context, token, verifyPermissions, listener);"], "token": ["\tpublic static void link (Activity context, String token, boolean verifyPermissions, SocializeAuthListener listener){", "\t\tproxy.link(context, token, verifyPermissions, listener);"], "verifyPermissions": ["\tpublic static void link (Activity context, String token, boolean verifyPermissions, SocializeAuthListener listener){", "\t\tproxy.link(context, token, verifyPermissions, listener);"], "listener": ["\tpublic static void link (Activity context, String token, boolean verifyPermissions, SocializeAuthListener listener){", "\t\tproxy.link(context, token, verifyPermissions, listener);"]}
{"context": ["public static void postEntity(final Activity context, final Entity entity, final String text, final SocialNetworkShareListener listener){", "\t\tif(proxy.isLinkedForWrite(context)) {", "\t\t\tproxy.postEntity(context, entity, text, listener);\t", "\t\t\tproxy.linkForWrite(context, new SocializeAuthListener() {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.FACEBOOK, error);", "\t\t\t\t\tproxy.postEntity(context, entity, text, listener);\t", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.FACEBOOK, error);"], "entity": ["public static void postEntity(final Activity context, final Entity entity, final String text, final SocialNetworkShareListener listener){", "\t\t\tproxy.postEntity(context, entity, text, listener);\t", "\t\t\t\t\tproxy.postEntity(context, entity, text, listener);\t"], "text": ["public static void postEntity(final Activity context, final Entity entity, final String text, final SocialNetworkShareListener listener){", "\t\t\tproxy.postEntity(context, entity, text, listener);\t", "\t\t\t\t\tproxy.postEntity(context, entity, text, listener);\t"], "listener": ["public static void postEntity(final Activity context, final Entity entity, final String text, final SocialNetworkShareListener listener){", "\t\t\tproxy.postEntity(context, entity, text, listener);\t", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.FACEBOOK, error);", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onCancel();", "\t\t\t\t\tproxy.postEntity(context, entity, text, listener);\t", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.FACEBOOK, error);"]}
{"context": ["\tpublic static void extendAccessToken(Activity context, SocializeAuthListener listener) {", "\t\tproxy.extendAccessToken(context, listener);"], "listener": ["\tpublic static void extendAccessToken(Activity context, SocializeAuthListener listener) {", "\t\tproxy.extendAccessToken(context, listener);"]}
{"context": ["public static void getCurrentPermissions(Activity context, String token, OnPermissionResult callback) {", "\t\tproxy.getCurrentPermissions(context, token, callback);"], "token": ["public static void getCurrentPermissions(Activity context, String token, OnPermissionResult callback) {", "\t\tproxy.getCurrentPermissions(context, token, callback);"], "callback": ["public static void getCurrentPermissions(Activity context, String token, OnPermissionResult callback) {", "\t\tproxy.getCurrentPermissions(context, token, callback);"]}
{"context": ["public static String[] getHashKeys(Activity context) throws NoSuchAlgorithmException {", "            packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), PackageManager.GET_SIGNATURES);"]}
{"context": ["public static void saveEntity (Activity context, Entity e, EntityAddListener listener) {", "\t\tproxy.saveEntity(context, e, listener);"], "e": ["public static void saveEntity (Activity context, Entity e, EntityAddListener listener) {", "\t\tproxy.saveEntity(context, e, listener);"], "listener": ["public static void saveEntity (Activity context, Entity e, EntityAddListener listener) {", "\t\tproxy.saveEntity(context, e, listener);"]}
{"context": ["public static void getEntity (Activity context, String key, EntityGetListener listener) {", "\t\tproxy.getEntity(context, key, listener);"], "key": ["public static void getEntity (Activity context, String key, EntityGetListener listener) {", "\t\tproxy.getEntity(context, key, listener);"], "listener": ["public static void getEntity (Activity context, String key, EntityGetListener listener) {", "\t\tproxy.getEntity(context, key, listener);"]}
{"context": ["public static void getEntity (Activity context, long id, EntityGetListener listener) {", "\t\tproxy.getEntity(context, id, listener);"], "id": ["public static void getEntity (Activity context, long id, EntityGetListener listener) {", "\t\tproxy.getEntity(context, id, listener);"], "listener": ["public static void getEntity (Activity context, long id, EntityGetListener listener) {", "\t\tproxy.getEntity(context, id, listener);"]}
{"context": ["public static void getEntities (Activity context, int start, int end, EntityListListener listener) {", "\t\tproxy.getEntities(context, start, end, SortOrder.CREATION_DATE, listener);"], "start": ["public static void getEntities (Activity context, int start, int end, EntityListListener listener) {", "\t\tproxy.getEntities(context, start, end, SortOrder.CREATION_DATE, listener);"], "end": ["public static void getEntities (Activity context, int start, int end, EntityListListener listener) {", "\t\tproxy.getEntities(context, start, end, SortOrder.CREATION_DATE, listener);"], "listener": ["public static void getEntities (Activity context, int start, int end, EntityListListener listener) {", "\t\tproxy.getEntities(context, start, end, SortOrder.CREATION_DATE, listener);"]}
{"context": ["public static void getEntities (Activity context, EntityListListener listener, String...keys) {", "\t\tproxy.getEntities(context, SortOrder.CREATION_DATE, listener, keys);\t"], "listener": ["public static void getEntities (Activity context, EntityListListener listener, String...keys) {", "\t\tproxy.getEntities(context, SortOrder.CREATION_DATE, listener, keys);\t"]}
{"activity": [], "menu": [], "v": [], "menuInfo": []}
{"context": ["public static void subscribe (Activity context, Entity e, SubscriptionType type, SubscriptionResultListener listener) {", "\t\tsubscriptionUtils.subscribe(context, e, type, listener);"], "e": ["public static void subscribe (Activity context, Entity e, SubscriptionType type, SubscriptionResultListener listener) {", "\t\tsubscriptionUtils.subscribe(context, e, type, listener);"], "type": ["public static void subscribe (Activity context, Entity e, SubscriptionType type, SubscriptionResultListener listener) {", "\t\tsubscriptionUtils.subscribe(context, e, type, listener);"], "listener": ["public static void subscribe (Activity context, Entity e, SubscriptionType type, SubscriptionResultListener listener) {", "\t\tsubscriptionUtils.subscribe(context, e, type, listener);"]}
{"context": ["public static void isSubscribed (Activity context, Entity e, SubscriptionType type, SubscriptionCheckListener listener) {", "\t\tsubscriptionUtils.isSubscribed(context, e, type, listener);"], "e": ["public static void isSubscribed (Activity context, Entity e, SubscriptionType type, SubscriptionCheckListener listener) {", "\t\tsubscriptionUtils.isSubscribed(context, e, type, listener);"], "type": ["public static void isSubscribed (Activity context, Entity e, SubscriptionType type, SubscriptionCheckListener listener) {", "\t\tsubscriptionUtils.isSubscribed(context, e, type, listener);"], "listener": ["public static void isSubscribed (Activity context, Entity e, SubscriptionType type, SubscriptionCheckListener listener) {", "\t\tsubscriptionUtils.isSubscribed(context, e, type, listener);"]}
{"context": ["public boolean checkRegistrations(Context context, SocializeSession session) {", "\t\t\t\tif(appUtils.isNotificationsAvailable(context)) {", "\t\t\t\t\t\tboolean c2DMRegistered = notificationRegistrationSystem.isRegisteredC2DM(context);", "\t\t\t\t\t\tboolean socRegistered = notificationRegistrationSystem.isRegisteredSocialize(context, session.getUser());", "\t\t\t\t\t\tif(!c2DMRegistered || !socRegistered) {", "\t\t\t\t\t\t\tnotificationRegistrationState.reload(context);", "\t\t\t\t\t\t\tc2DMRegistered = notificationRegistrationSystem.isRegisteredC2DM(context);", "\t\t\t\t\t\t\tsocRegistered = notificationRegistrationSystem.isRegisteredSocialize(context, session.getUser());", "\t\t\t\t\t\t\tif(!c2DMRegistered || !socRegistered) {", "\t\t\t\t\t\t\t\tif(!c2DMRegistered && config.getBooleanProperty(SocializeConfig.GCM_REGISTRATION_ENABLED, true)) {", "\t\t\t\t\t\t\t\t\t\tnotificationRegistrationSystem.registerC2DMAsync(context);", "\t\t\t\t\t\t\t\t\t\tnotificationRegistrationSystem.registerSocialize(context, notificationRegistrationState.getC2DMRegistrationId());"], "session": ["public boolean checkRegistrations(Context context, SocializeSession session) {", "\t\t\t\t\t\tboolean socRegistered = notificationRegistrationSystem.isRegisteredSocialize(context, session.getUser());", "\t\t\t\t\t\t\tsocRegistered = notificationRegistrationSystem.isRegisteredSocialize(context, session.getUser());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"context": ["public static void showShareDialog (Activity context, Entity entity) {", "\t\tproxy.showShareDialog(context, entity, DEFAULT, null, null);"], "entity": ["public static void showShareDialog (Activity context, Entity entity) {", "\t\tproxy.showShareDialog(context, entity, DEFAULT, null, null);"]}
{"context": ["public static void showShareDialog (Activity context, Entity entity, SocialNetworkDialogListener listener) {", "\t\tproxy.showShareDialog(context, entity, DEFAULT, listener, listener);"], "entity": ["public static void showShareDialog (Activity context, Entity entity, SocialNetworkDialogListener listener) {", "\t\tproxy.showShareDialog(context, entity, DEFAULT, listener, listener);"], "listener": ["public static void showShareDialog (Activity context, Entity entity, SocialNetworkDialogListener listener) {", "\t\tproxy.showShareDialog(context, entity, DEFAULT, listener, listener);"]}
{"context": ["public static void shareViaEmail(Activity context, Entity entity, ShareAddListener listener) {", "\t\tproxy.shareViaEmail(context, entity, listener);"], "entity": ["public static void shareViaEmail(Activity context, Entity entity, ShareAddListener listener) {", "\t\tproxy.shareViaEmail(context, entity, listener);"], "listener": ["public static void shareViaEmail(Activity context, Entity entity, ShareAddListener listener) {", "\t\tproxy.shareViaEmail(context, entity, listener);"]}
{"context": ["public static void shareViaGooglePlus(Activity context, Entity entity, ShareAddListener listener) {", "\t\tproxy.shareViaGooglePlus(context, entity, listener);"], "entity": ["public static void shareViaGooglePlus(Activity context, Entity entity, ShareAddListener listener) {", "\t\tproxy.shareViaGooglePlus(context, entity, listener);"], "listener": ["public static void shareViaGooglePlus(Activity context, Entity entity, ShareAddListener listener) {", "\t\tproxy.shareViaGooglePlus(context, entity, listener);"]}
{"context": ["public static void shareViaOther(Activity context, Entity entity, ShareAddListener listener) {", "\t\tproxy.shareViaOther(context, entity, listener);"], "entity": ["public static void shareViaOther(Activity context, Entity entity, ShareAddListener listener) {", "\t\tproxy.shareViaOther(context, entity, listener);"], "listener": ["public static void shareViaOther(Activity context, Entity entity, ShareAddListener listener) {", "\t\tproxy.shareViaOther(context, entity, listener);"]}
{"context": ["public static void shareViaSMS(Activity context, Entity entity, ShareAddListener listener) {", "\t\tproxy.shareViaSMS(context, entity, listener);"], "entity": ["public static void shareViaSMS(Activity context, Entity entity, ShareAddListener listener) {", "\t\tproxy.shareViaSMS(context, entity, listener);"], "listener": ["public static void shareViaSMS(Activity context, Entity entity, ShareAddListener listener) {", "\t\tproxy.shareViaSMS(context, entity, listener);"]}
{"context": ["public static void shareViaSocialNetworks(Activity context, Entity entity, ShareOptions shareOptions, SocialNetworkShareListener listener, SocialNetwork...networks) {", "\t\tproxy.shareViaSocialNetworks(context, entity, shareOptions, listener, networks);"], "entity": ["public static void shareViaSocialNetworks(Activity context, Entity entity, ShareOptions shareOptions, SocialNetworkShareListener listener, SocialNetwork...networks) {", "\t\tproxy.shareViaSocialNetworks(context, entity, shareOptions, listener, networks);"], "shareOptions": ["public static void shareViaSocialNetworks(Activity context, Entity entity, ShareOptions shareOptions, SocialNetworkShareListener listener, SocialNetwork...networks) {", "\t\tproxy.shareViaSocialNetworks(context, entity, shareOptions, listener, networks);"], "listener": ["public static void shareViaSocialNetworks(Activity context, Entity entity, ShareOptions shareOptions, SocialNetworkShareListener listener, SocialNetwork...networks) {", "\t\tproxy.shareViaSocialNetworks(context, entity, shareOptions, listener, networks);"]}
{"context": ["public static void getShare (Activity context, ShareGetListener listener, long id) {", "\t\tproxy.getShare(context, listener, id);"], "listener": ["public static void getShare (Activity context, ShareGetListener listener, long id) {", "\t\tproxy.getShare(context, listener, id);"], "id": ["public static void getShare (Activity context, ShareGetListener listener, long id) {", "\t\tproxy.getShare(context, listener, id);"]}
{"context": ["public static void getShares (Activity context, ShareListListener listener, long...ids) {", "\t\tproxy.getShares(context, listener, ids);"], "listener": ["public static void getShares (Activity context, ShareListListener listener, long...ids) {", "\t\tproxy.getShares(context, listener, ids);"]}
{"context": ["public static void getSharesByUser (Activity context, User user, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByUser(context, user, start, end, listener);"], "user": ["public static void getSharesByUser (Activity context, User user, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByUser(context, user, start, end, listener);"], "start": ["public static void getSharesByUser (Activity context, User user, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByUser(context, user, start, end, listener);"], "end": ["public static void getSharesByUser (Activity context, User user, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByUser(context, user, start, end, listener);"], "listener": ["public static void getSharesByUser (Activity context, User user, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByUser(context, user, start, end, listener);"]}
{"context": ["public static void getSharesByEntity (Activity context, String entityKey, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByEntity(context, entityKey, start, end, listener);"], "entityKey": ["public static void getSharesByEntity (Activity context, String entityKey, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByEntity(context, entityKey, start, end, listener);"], "start": ["public static void getSharesByEntity (Activity context, String entityKey, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByEntity(context, entityKey, start, end, listener);"], "end": ["public static void getSharesByEntity (Activity context, String entityKey, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByEntity(context, entityKey, start, end, listener);"], "listener": ["public static void getSharesByEntity (Activity context, String entityKey, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByEntity(context, entityKey, start, end, listener);"]}
{"context": ["public static void getSharesByApplication (Activity context, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByApplication(context, start, end, listener);"], "start": ["public static void getSharesByApplication (Activity context, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByApplication(context, start, end, listener);"], "end": ["public static void getSharesByApplication (Activity context, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByApplication(context, start, end, listener);"], "listener": ["public static void getSharesByApplication (Activity context, int start, int end, ShareListListener listener) {", "\t\tproxy.getSharesByApplication(context, start, end, listener);"]}
{"context": ["public static void like (Activity context, Entity entity, LikeAddListener listener) {", "\t\tproxy.like(context, entity, listener);"], "entity": ["public static void like (Activity context, Entity entity, LikeAddListener listener) {", "\t\tproxy.like(context, entity, listener);"], "listener": ["public static void like (Activity context, Entity entity, LikeAddListener listener) {", "\t\tproxy.like(context, entity, listener);"]}
{"context": ["public static void like (Activity context, Entity entity, LikeOptions likeOptions, LikeAddListener listener, SocialNetwork...networks) {", "\t\tproxy.like(context, entity, likeOptions, listener, networks);"], "entity": ["public static void like (Activity context, Entity entity, LikeOptions likeOptions, LikeAddListener listener, SocialNetwork...networks) {", "\t\tproxy.like(context, entity, likeOptions, listener, networks);"], "likeOptions": ["public static void like (Activity context, Entity entity, LikeOptions likeOptions, LikeAddListener listener, SocialNetwork...networks) {", "\t\tproxy.like(context, entity, likeOptions, listener, networks);"], "listener": ["public static void like (Activity context, Entity entity, LikeOptions likeOptions, LikeAddListener listener, SocialNetwork...networks) {", "\t\tproxy.like(context, entity, likeOptions, listener, networks);"]}
{"context": ["public static void unlike (Activity context, String entityKey, LikeDeleteListener listener) {", "\t\tproxy.unlike(context, entityKey, listener);"], "entityKey": ["public static void unlike (Activity context, String entityKey, LikeDeleteListener listener) {", "\t\tproxy.unlike(context, entityKey, listener);"], "listener": ["public static void unlike (Activity context, String entityKey, LikeDeleteListener listener) {", "\t\tproxy.unlike(context, entityKey, listener);"]}
{"context": ["public static void getLike (Activity context, String entityKey, LikeGetListener listener) {", "\t\tproxy.getLike(context, entityKey, listener);"], "entityKey": ["public static void getLike (Activity context, String entityKey, LikeGetListener listener) {", "\t\tproxy.getLike(context, entityKey, listener);"], "listener": ["public static void getLike (Activity context, String entityKey, LikeGetListener listener) {", "\t\tproxy.getLike(context, entityKey, listener);"]}
{"context": ["public static void getLike (Activity context, long id, LikeGetListener listener) {", "\t\tproxy.getLike(context, id, listener);"], "id": ["public static void getLike (Activity context, long id, LikeGetListener listener) {", "\t\tproxy.getLike(context, id, listener);"], "listener": ["public static void getLike (Activity context, long id, LikeGetListener listener) {", "\t\tproxy.getLike(context, id, listener);"]}
{"context": ["public static void isLiked(Activity context, String entityKey, IsLikedListener listener) {", "\t\tproxy.getLike(context, entityKey, listener);"], "entityKey": ["public static void isLiked(Activity context, String entityKey, IsLikedListener listener) {", "\t\tproxy.getLike(context, entityKey, listener);"], "listener": ["public static void isLiked(Activity context, String entityKey, IsLikedListener listener) {", "\t\tproxy.getLike(context, entityKey, listener);"]}
{"context": ["public static void getLikesByUser (Activity context, User user, int start, int end, LikeListListener listener) {", "\t\tproxy.getLikesByUser(context, user, start, end, listener);"], "user": ["public static void getLikesByUser (Activity context, User user, int start, int end, LikeListListener listener) {", "\t\tproxy.getLikesByUser(context, user, start, end, listener);"], "start": ["public static void getLikesByUser (Activity context, User user, int start, int end, LikeListListener listener) {", "\t\tproxy.getLikesByUser(context, user, start, end, listener);"], "end": ["public static void getLikesByUser (Activity context, User user, int start, int end, LikeListListener listener) {", "\t\tproxy.getLikesByUser(context, user, start, end, listener);"], "listener": ["public static void getLikesByUser (Activity context, User user, int start, int end, LikeListListener listener) {", "\t\tproxy.getLikesByUser(context, user, start, end, listener);"]}
{"context": ["public static void getLikesByEntity (Activity context, String entityKey, int start, int end, LikeListListener listener) {", "\t\tproxy.getLikesByEntity(context, entityKey, start, end, listener);"], "entityKey": ["public static void getLikesByEntity (Activity context, String entityKey, int start, int end, LikeListListener listener) {", "\t\tproxy.getLikesByEntity(context, entityKey, start, end, listener);"], "start": ["public static void getLikesByEntity (Activity context, String entityKey, int start, int end, LikeListListener listener) {", "\t\tproxy.getLikesByEntity(context, entityKey, start, end, listener);"], "end": ["public static void getLikesByEntity (Activity context, String entityKey, int start, int end, LikeListListener listener) {", "\t\tproxy.getLikesByEntity(context, entityKey, start, end, listener);"], "listener": ["public static void getLikesByEntity (Activity context, String entityKey, int start, int end, LikeListListener listener) {", "\t\tproxy.getLikesByEntity(context, entityKey, start, end, listener);"]}
{"context": []}
{"request": ["protected void collectHeaderParameters(HttpRequest request, HttpParameters out) {", "        HttpParameters headerParams = OAuth.oauthHeaderToParamsMap(request.getHeader(OAuth.HTTP_AUTHORIZATION_HEADER));"], "out": ["protected void collectHeaderParameters(HttpRequest request, HttpParameters out) {", "        out.putAll(headerParams, false);"]}
{"request": ["protected void collectBodyParameters(HttpRequest request, HttpParameters out)", "        String contentType = request.getContentType();", "            InputStream payload = request.getMessagePayload();"], "out": ["protected void collectBodyParameters(HttpRequest request, HttpParameters out)", "            out.putAll(OAuth.decodeForm(payload), true);"]}
{"request": ["protected void collectQueryParameters(HttpRequest request, HttpParameters out) {", "        String url = request.getRequestUrl();"], "out": ["protected void collectQueryParameters(HttpRequest request, HttpParameters out) {", "            out.putAll(OAuth.decodeForm(url.substring(q + 1)), true);"]}
{"writer": ["private JsonWriter newJsonWriter(Writer writer) throws IOException {", "      writer.write(JSON_NON_EXECUTABLE_PREFIX);", "    JsonWriter jsonWriter = new JsonWriter(writer);", "      jsonWriter.setIndent(\"  \");", "    jsonWriter.setSerializeNulls(serializeNulls);", "    return jsonWriter;"]}
{"rawType": ["  private <T> ObjectConstructor<T> newDefaultImplementationConstructor(Class<? super T> rawType) {", "    if (Collection.class.isAssignableFrom(rawType)) {", "      if (SortedSet.class.isAssignableFrom(rawType)) {", "      } else if (Set.class.isAssignableFrom(rawType)) {", "      } else if (Queue.class.isAssignableFrom(rawType)) {", "    if (Map.class.isAssignableFrom(rawType)) {"]}
{"src": ["public static String replaceNewLines(String src, int from, int to) {", "\t\tif(src != null && from > 0 && to < from) {", "\t\t\twhile (src.contains(strFrom)) {", "\t\t\t\tsrc = src.replaceAll(strFrom, strTo);", "\t\treturn src;"], "from": ["public static String replaceNewLines(String src, int from, int to) {", "\t\tif(src != null && from > 0 && to < from) {", "\t\t\tfor (int i = 0; i < from; i++) {"], "to": ["public static String replaceNewLines(String src, int from, int to) {", "\t\tif(src != null && from > 0 && to < from) {", "\t\t\tfor (int i = 0; i < to; i++) {"]}
{"Result": "Method without Parameter"}
{"address": ["public String getSimpleLocation(Address address) {", "\t\tString locality = address.getLocality();", "\t\tString countryName = address.getCountryName();"]}
{"session": ["protected void getUser(final Session session, final AuthProviderListener listener) {", "\t\tRequest.executeMeRequestAsync(session, new Request.GraphUserCallback() {", "\t\t\t\t\thandleResult(session, user, listener);"], "listener": ["protected void getUser(final Session session, final AuthProviderListener listener) {", "\t\t\t\t\thandleError(response.getError().getException(), listener);", "\t\t\t\t\thandleResult(session, user, listener);"]}
{"context": ["public static void getActionsByApplication (Activity context, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByApplication(context, start, end, listener);"], "start": ["public static void getActionsByApplication (Activity context, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByApplication(context, start, end, listener);"], "end": ["public static void getActionsByApplication (Activity context, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByApplication(context, start, end, listener);"], "listener": ["public static void getActionsByApplication (Activity context, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByApplication(context, start, end, listener);"]}
{"context": ["public static void getActionsByUser (Activity context, long userId, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByUser(context, userId, start, end, listener);"], "userId": ["public static void getActionsByUser (Activity context, long userId, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByUser(context, userId, start, end, listener);"], "start": ["public static void getActionsByUser (Activity context, long userId, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByUser(context, userId, start, end, listener);"], "end": ["public static void getActionsByUser (Activity context, long userId, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByUser(context, userId, start, end, listener);"], "listener": ["public static void getActionsByUser (Activity context, long userId, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByUser(context, userId, start, end, listener);"]}
{"context": ["public static void getActionsByEntity (Activity context, String entityKey, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByEntity(context, entityKey, start, end, listener);"], "entityKey": ["public static void getActionsByEntity (Activity context, String entityKey, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByEntity(context, entityKey, start, end, listener);"], "start": ["public static void getActionsByEntity (Activity context, String entityKey, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByEntity(context, entityKey, start, end, listener);"], "end": ["public static void getActionsByEntity (Activity context, String entityKey, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByEntity(context, entityKey, start, end, listener);"], "listener": ["public static void getActionsByEntity (Activity context, String entityKey, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByEntity(context, entityKey, start, end, listener);"]}
{"context": ["public static void getActionsByUserAndEntity (Activity context, long userId, String entityKey, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByUserAndEntity(context, userId, entityKey, start, end, listener);"], "userId": ["public static void getActionsByUserAndEntity (Activity context, long userId, String entityKey, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByUserAndEntity(context, userId, entityKey, start, end, listener);"], "entityKey": ["public static void getActionsByUserAndEntity (Activity context, long userId, String entityKey, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByUserAndEntity(context, userId, entityKey, start, end, listener);"], "start": ["public static void getActionsByUserAndEntity (Activity context, long userId, String entityKey, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByUserAndEntity(context, userId, entityKey, start, end, listener);"], "end": ["public static void getActionsByUserAndEntity (Activity context, long userId, String entityKey, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByUserAndEntity(context, userId, entityKey, start, end, listener);"], "listener": ["public static void getActionsByUserAndEntity (Activity context, long userId, String entityKey, int start, int end, ActionListListener listener) {", "\t\tproxy.getActionsByUserAndEntity(context, userId, entityKey, start, end, listener);"]}
{"empty": ["private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket)", "    if (context != nonempty && context != empty) {"], "nonempty": ["private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket)", "    if (context != nonempty && context != empty) {", "    if (context == nonempty) {"], "closeBracket": ["private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket)", "    out.write(closeBracket);"]}
{"name": ["public JsonWriter name(String name) throws IOException {"]}
{"json": ["public JsonElement parse(Reader json) throws JsonIOException, JsonSyntaxException {\r", "      JsonReader jsonReader = new JsonReader(json);\r", "      JsonElement element = parse(jsonReader);\r", "      if (!element.isJsonNull() && jsonReader.peek() != JsonToken.END_DOCUMENT) {\r", "      return element;\r"]}
{"json": ["public JsonElement parse(JsonReader json) throws JsonIOException, JsonSyntaxException {\r", "    boolean lenient = json.isLenient();\r", "    json.setLenient(true);\r", "      return Streams.parse(json);\r", "      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\r", "      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\", e);\r", "      json.setLenient(lenient);\r"]}
{"context": ["public static void link (Activity context, String token, String secret, SocializeAuthListener listener) {", "\t\tproxy.link(context, token, secret, listener);"], "token": ["public static void link (Activity context, String token, String secret, SocializeAuthListener listener) {", "\t\tproxy.link(context, token, secret, listener);"], "secret": ["public static void link (Activity context, String token, String secret, SocializeAuthListener listener) {", "\t\tproxy.link(context, token, secret, listener);"], "listener": ["public static void link (Activity context, String token, String secret, SocializeAuthListener listener) {", "\t\tproxy.link(context, token, secret, listener);"]}
{"context": ["public static void setCredentials(Context context, String consumerKey, String consumerSecret) {", "\t\tproxy.setCredentials(context, consumerKey, consumerSecret);"], "consumerKey": ["public static void setCredentials(Context context, String consumerKey, String consumerSecret) {", "\t\tproxy.setCredentials(context, consumerKey, consumerSecret);"], "consumerSecret": ["public static void setCredentials(Context context, String consumerKey, String consumerSecret) {", "\t\tproxy.setCredentials(context, consumerKey, consumerSecret);"]}
{"context": ["public static void tweetEntity(final Activity context, final Entity entity, final String text, final SocialNetworkShareListener listener) {", "\t\tif(proxy.isLinked(context)) {", "\t\t\tproxy.tweetEntity(context, entity, text, listener);", "\t\t\tproxy.link(context, new SocializeAuthListener() {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);", "\t\t\t\t\tproxy.tweetEntity(context, entity, text, listener);", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);"], "entity": ["public static void tweetEntity(final Activity context, final Entity entity, final String text, final SocialNetworkShareListener listener) {", "\t\t\tproxy.tweetEntity(context, entity, text, listener);", "\t\t\t\t\tproxy.tweetEntity(context, entity, text, listener);"], "text": ["public static void tweetEntity(final Activity context, final Entity entity, final String text, final SocialNetworkShareListener listener) {", "\t\t\tproxy.tweetEntity(context, entity, text, listener);", "\t\t\t\t\tproxy.tweetEntity(context, entity, text, listener);"], "listener": ["public static void tweetEntity(final Activity context, final Entity entity, final String text, final SocialNetworkShareListener listener) {", "\t\t\tproxy.tweetEntity(context, entity, text, listener);", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onCancel();", "\t\t\t\t\tproxy.tweetEntity(context, entity, text, listener);", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);"]}
{"context": ["public static void get(final Activity context, final String resource, final Map<String, Object> params, final SocialNetworkPostListener listener) {", "\t\tif(proxy.isLinked(context)) {", "\t\t\tproxy.get(context, resource, params, listener);", "\t\t\tproxy.link(context, new SocializeAuthListener() {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);", "\t\t\t\t\tproxy.get(context, resource, params, listener);", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);"], "resource": ["public static void get(final Activity context, final String resource, final Map<String, Object> params, final SocialNetworkPostListener listener) {", "\t\t\tproxy.get(context, resource, params, listener);", "\t\t\t\t\tproxy.get(context, resource, params, listener);"], "params": ["public static void get(final Activity context, final String resource, final Map<String, Object> params, final SocialNetworkPostListener listener) {", "\t\t\tproxy.get(context, resource, params, listener);", "\t\t\t\t\tproxy.get(context, resource, params, listener);"], "listener": ["public static void get(final Activity context, final String resource, final Map<String, Object> params, final SocialNetworkPostListener listener) {", "\t\t\tproxy.get(context, resource, params, listener);", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onCancel();", "\t\t\t\t\tproxy.get(context, resource, params, listener);", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);"]}
{"context": ["public static void tweet(final Activity context, final Tweet tweet, final SocialNetworkListener listener) {", "\t\tif(proxy.isLinked(context)) {", "\t\t\tproxy.tweet(context, tweet, listener);", "\t\t\tproxy.link(context, new SocializeAuthListener() {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);", "\t\t\t\t\tproxy.tweet(context, tweet, listener);", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);"], "tweet": ["public static void tweet(final Activity context, final Tweet tweet, final SocialNetworkListener listener) {"], "listener": ["public static void tweet(final Activity context, final Tweet tweet, final SocialNetworkListener listener) {", "\t\t\tproxy.tweet(context, tweet, listener);", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onCancel();", "\t\t\t\t\tproxy.tweet(context, tweet, listener);", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);"]}
{"context": ["public static void tweetPhoto(final Activity context, final PhotoTweet photo, final SocialNetworkPostListener listener) {", "\t\tif(proxy.isLinked(context)) {", "\t\t\tproxy.tweetPhoto(context, photo, listener);", "\t\t\tproxy.link(context, new SocializeAuthListener() {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);", "\t\t\t\t\tproxy.tweetPhoto(context, photo, listener);", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);"], "photo": ["public static void tweetPhoto(final Activity context, final PhotoTweet photo, final SocialNetworkPostListener listener) {", "\t\t\tproxy.tweetPhoto(context, photo, listener);", "\t\t\t\t\tproxy.tweetPhoto(context, photo, listener);"], "listener": ["public static void tweetPhoto(final Activity context, final PhotoTweet photo, final SocialNetworkPostListener listener) {", "\t\t\tproxy.tweetPhoto(context, photo, listener);", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onCancel();", "\t\t\t\t\tproxy.tweetPhoto(context, photo, listener);", "\t\t\t\t\tif(listener != null) {", "\t\t\t\t\t\tlistener.onNetworkError(context, SocialNetwork.TWITTER, error);"]}
{"bitmap": ["public Bitmap getScaledBitmap(Bitmap bitmap, int scaleToWidth, int scaleToHeight, boolean recycleOriginal, int density) {", "\t\tbitmap.setDensity(density);", "\t\tBitmap original = bitmap;", "\t\t\tint width = bitmap.getWidth();", "\t\t\tint height = bitmap.getHeight();", "\t\t\t\t\tbitmap = bitmapBuilder.scale(bitmap, width, height);", "\t\t\t\t\tbitmap = bitmapBuilder.scale(bitmap, width, height);", "\t\t\t\t\toriginal.recycle();", "\t\treturn bitmap;"], "scaleToWidth": ["public Bitmap getScaledBitmap(Bitmap bitmap, int scaleToWidth, int scaleToHeight, boolean recycleOriginal, int density) {", "\t\tif (scaleToWidth > 0 || scaleToHeight > 0) {", "\t\t\tif (height != scaleToHeight || width != scaleToWidth) {", "\t\t\t\t\tratio = (float) scaleToWidth / (float) width;", "\t\t\t\t\twidth = scaleToWidth;", "\t\t\t\t\tbitmap = bitmapBuilder.scale(bitmap, width, height);", "\t\t\t\t\tif (width > scaleToWidth) {", "\t\t\t\t\t\tint diff = width - scaleToWidth;", "\t\t\t\t\t\tint half = Math.round((float) diff / 2.0f);", "\t\t\t\t\t\tbitmap = bitmapBuilder.crop(bitmap, half, 0, scaleToWidth, height);"], "scaleToHeight": ["public Bitmap getScaledBitmap(Bitmap bitmap, int scaleToWidth, int scaleToHeight, boolean recycleOriginal, int density) {", "\t\tif (scaleToWidth > 0 || scaleToHeight > 0) {", "\t\t\tif (height != scaleToHeight || width != scaleToWidth) {", "\t\t\t\t\tif (height > scaleToHeight) {", "\t\t\t\t\t\tint diff = height - scaleToHeight;", "\t\t\t\t\t\tint half = Math.round((float) diff / 2.0f);", "\t\t\t\t\t\tbitmap = bitmapBuilder.crop(bitmap, 0, half, width, scaleToHeight);", "\t\t\t\t\tratio = (float) scaleToHeight / (float) height;", "\t\t\t\t\theight = scaleToHeight;", "\t\t\t\t\tbitmap = bitmapBuilder.scale(bitmap, width, height);", "\t\t\t\t\twidth = bitmap.getWidth();", "\t\t\t\t\theight = bitmap.getHeight();", "\t\t\t\t\t\tbitmap = bitmapBuilder.crop(bitmap, half, 0, scaleToWidth, height);", "\t\treturn bitmap;"], "recycleOriginal": ["public Bitmap getScaledBitmap(Bitmap bitmap, int scaleToWidth, int scaleToHeight, boolean recycleOriginal, int density) {", "\t\t\t\tif(recycleOriginal) {"], "density": ["public Bitmap getScaledBitmap(Bitmap bitmap, int scaleToWidth, int scaleToHeight, boolean recycleOriginal, int density) {", "\t\tbitmap.setDensity(density);"]}
{"session": ["\tpublic void putAsPostAsync(SocializeSession session, String endpoint, T object, SocializeActionListener listener) {", "\t\tAsyncPutter poster = new AsyncPutter(session, listener);"], "endpoint": ["\tpublic void putAsPostAsync(SocializeSession session, String endpoint, T object, SocializeActionListener listener) {", "\t\trequest.setEndpoint(endpoint);"], "object": ["\tpublic void putAsPostAsync(SocializeSession session, String endpoint, T object, SocializeActionListener listener) {", "\t\trequest.setObject(object);"], "listener": ["\tpublic void putAsPostAsync(SocializeSession session, String endpoint, T object, SocializeActionListener listener) {", "\t\tAsyncPutter poster = new AsyncPutter(session, listener);", "\t\tposter.execute(request);"]}
{"textSize": ["public void setTextSize(int textSize) {", "\t\t\ttextView.setTextSize(android.util.TypedValue.COMPLEX_UNIT_DIP, textSize);", "\t\tthis.textSize = textSize;"]}
{"bitmap": ["public void onImageChange(Bitmap bitmap, String localPath) {", "\t\t\tprofileLayoutView.onImageChange(bitmap);"], "localPath": ["public void onImageChange(Bitmap bitmap, String localPath) {", "\t\t\tUserUtils.getUserSettings(getContext()).setLocalImagePath(localPath);"]}
{"context": ["public static void saveUserAsync(Context context, User user, UserSaveListener listener) {", "\t\tproxy.saveUserAsync(context, user, listener);"], "user": ["public static void saveUserAsync(Context context, User user, UserSaveListener listener) {", "\t\tproxy.saveUserAsync(context, user, listener);"], "listener": ["public static void saveUserAsync(Context context, User user, UserSaveListener listener) {", "\t\tproxy.saveUserAsync(context, user, listener);"]}
{"context": ["public static void getUser(Context context, long id, UserGetListener listener) {", "\t\tproxy.getUser(context, id, listener);"], "id": ["public static void getUser(Context context, long id, UserGetListener listener) {", "\t\tproxy.getUser(context, id, listener);"], "listener": ["public static void getUser(Context context, long id, UserGetListener listener) {", "\t\tproxy.getUser(context, id, listener);"]}
{"context": ["public static void saveUserSettings (Context context, UserSettings userSettings, UserSaveListener listener) {", "\t\tproxy.saveUserSettings(context, userSettings, listener);"], "userSettings": ["public static void saveUserSettings (Context context, UserSettings userSettings, UserSaveListener listener) {", "\t\tproxy.saveUserSettings(context, userSettings, listener);"], "listener": ["public static void saveUserSettings (Context context, UserSettings userSettings, UserSaveListener listener) {", "\t\tproxy.saveUserSettings(context, userSettings, listener);"]}
{"Result": "Method without Parameter"}
{"context": ["\tpublic void authenticate(Activity context) {", "\t\tauthenticate(context, FacebookFacade.DEFAULT_PERMISSIONS, true, false);"]}
{"context": ["public void authenticateForRead(Activity context, boolean sso, String[] permissions) {", "\t\tauthenticate(context, permissions, sso, true);"], "sso": ["public void authenticateForRead(Activity context, boolean sso, String[] permissions) {", "\t\tauthenticate(context, permissions, sso, true);"], "permissions": ["public void authenticateForRead(Activity context, boolean sso, String[] permissions) {", "\t\tauthenticate(context, permissions, sso, true);"]}
{"fieldName": ["\tpublic static final <E extends Object> E getStaticField(String fieldName, Class<?> clazz) throws Exception {\r", "\t\t\tField field = clazz.getField(fieldName);\r", "\t\t\tif(field != null) {\r", "\t\t\t\treturn (E) field.get(null);\r"], "clazz": ["\tpublic static final <E extends Object> E getStaticField(String fieldName, Class<?> clazz) throws Exception {\r", "\t\t\tField field = clazz.getField(fieldName);\r"]}
{"value": ["public static final String getStaticFieldName(Object value, Class<?> clazz) throws Exception {\r", "\t\t\tif(fVal != null && fVal.equals(value)) {\r"], "clazz": ["public static final String getStaticFieldName(Object value, Class<?> clazz) throws Exception {\r", "\t\tField[] fields = clazz.getFields();\r"]}
{"context": ["public static boolean onMessage(Context context, Intent intent) {", "\t\tassertInitialized(context);", "\t\t\t\thandler.onMessage(context, intent);"], "intent": ["public static boolean onMessage(Context context, Intent intent) {", "\t\tBundle messageData = intent.getExtras();", "\t\t\t\thandler.onMessage(context, intent);"]}
{"context": ["public static boolean handleBroadcastIntent(Context context, Intent intent) {", "\t\treturn Socialize.getSocialize().handleBroadcastIntent(context, intent);"], "intent": ["public static boolean handleBroadcastIntent(Context context, Intent intent) {", "\t\treturn Socialize.getSocialize().handleBroadcastIntent(context, intent);"]}
{"source": ["public byte[] encode(byte[] source, int off, int len, byte[] alphabet,", "      int inBuff =", "          ((source[d + off] << 24) >>> 8)", "              | ((source[d + 1 + off] << 24) >>> 16)", "              | ((source[d + 2 + off] << 24) >>> 24);", "      outBuff[e] = alphabet[(inBuff >>> 18)];", "      outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];", "      outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];", "      outBuff[e + 3] = alphabet[(inBuff) & 0x3f];", "      encode3to4(source, d + off, len - d, outBuff, e, alphabet);", "    assert (e == outBuff.length);", "    return outBuff;"], "off": ["public byte[] encode(byte[] source, int off, int len, byte[] alphabet,", "      int inBuff =", "          ((source[d + off] << 24) >>> 8)", "              | ((source[d + 1 + off] << 24) >>> 16)", "              | ((source[d + 2 + off] << 24) >>> 24);", "      outBuff[e] = alphabet[(inBuff >>> 18)];", "      outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];", "      outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];", "      outBuff[e + 3] = alphabet[(inBuff) & 0x3f];", "      encode3to4(source, d + off, len - d, outBuff, e, alphabet);", "    assert (e == outBuff.length);", "    return outBuff;"], "len": ["public byte[] encode(byte[] source, int off, int len, byte[] alphabet,", "    int lenDiv3 = (len + 2) / 3; // ceil(len / 3)", "    int len2 = len - 2;", "    if (d < len) {", "      encode3to4(source, d + off, len - d, outBuff, e, alphabet);"], "alphabet": ["public byte[] encode(byte[] source, int off, int len, byte[] alphabet,", "      outBuff[e] = alphabet[(inBuff >>> 18)];", "      outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];", "      outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];", "      outBuff[e + 3] = alphabet[(inBuff) & 0x3f];", "      encode3to4(source, d + off, len - d, outBuff, e, alphabet);", "    assert (e == outBuff.length);", "    return outBuff;"], "maxLineLength": ["      int maxLineLength) {", "    byte[] outBuff = new byte[len43 // Main 4:3", "        + (len43 / maxLineLength)]; // New lines", "      if (lineLength == maxLineLength) {", "      if (lineLength == maxLineLength) {"]}
{"source": ["public byte[] decode(byte[] source, int off, int len, byte[] decodabet)", "      sbiCrop = (byte) (source[i + off] & 0x7f); // Only the low seven bits", "      sbiDecode = decodabet[sbiCrop];", "      if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better", "        if (sbiDecode >= EQUALS_SIGN_ENC) {", "          if (sbiCrop == EQUALS_SIGN) {", "            byte lastByte = (byte) (source[len - 1 + off] & 0x7f);", "            } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {", "          b4[b4Posn++] = sbiCrop;", "          if (b4Posn == 4) {", "            outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);", "            + \": \" + source[i + off] + \"(decimal)\");", "    if (b4Posn != 0) {", "      if (b4Posn == 1) {", "      outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);", "    byte[] out = new byte[outBuffPosn];", "    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);", "    return out;"], "off": ["public byte[] decode(byte[] source, int off, int len, byte[] decodabet)", "      sbiCrop = (byte) (source[i + off] & 0x7f); // Only the low seven bits", "      sbiDecode = decodabet[sbiCrop];", "      if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better", "        if (sbiDecode >= EQUALS_SIGN_ENC) {", "          if (sbiCrop == EQUALS_SIGN) {", "            byte lastByte = (byte) (source[len - 1 + off] & 0x7f);", "            } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {", "          b4[b4Posn++] = sbiCrop;", "          if (b4Posn == 4) {", "            outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);", "            + \": \" + source[i + off] + \"(decimal)\");", "    if (b4Posn != 0) {", "      if (b4Posn == 1) {", "      outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);", "    byte[] out = new byte[outBuffPosn];", "    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);", "    return out;"], "len": ["public byte[] decode(byte[] source, int off, int len, byte[] decodabet)", "    int len34 = len * 3 / 4;", "    for (i = 0; i < len; i++) {", "            int bytesLeft = len - i;", "            byte lastByte = (byte) (source[len - 1 + off] & 0x7f);", "            } else if ((b4Posn == 3 && bytesLeft > 2)", "                || (b4Posn == 4 && bytesLeft > 1)) {", "            } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {", "            + (len - 1));"], "decodabet": ["public byte[] decode(byte[] source, int off, int len, byte[] decodabet)", "      sbiDecode = decodabet[sbiCrop];", "      if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better", "        if (sbiDecode >= EQUALS_SIGN_ENC) {", "            outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);", "      outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);", "    byte[] out = new byte[outBuffPosn];", "    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);", "    return out;"]}
{"context": ["public static void view (Activity context, Entity e, ViewAddListener listener) {", "\t\tproxy.view(context, e, listener);"], "e": ["public static void view (Activity context, Entity e, ViewAddListener listener) {", "\t\tproxy.view(context, e, listener);"], "listener": ["public static void view (Activity context, Entity e, ViewAddListener listener) {", "\t\tproxy.view(context, e, listener);"]}
{"Result": "Method without Parameter"}
{"form": ["public static HttpParameters decodeForm(String form) {", "        if (isEmpty(form)) {", "        for (String nvp : form.split(\"\\\\&\")) {", "            int equals = nvp.indexOf('=');", "            if (equals < 0) {", "                name = percentDecode(nvp);", "                name = percentDecode(nvp.substring(0, equals));", "                value = percentDecode(nvp.substring(equals + 1));", "            params.put(name, value);"]}
{"from": ["public static <T extends Map.Entry<String, String>> Map<String, String> toMap(Collection<T> from) {", "        if (from != null) {", "            for (Map.Entry<String, String> entry : from) {", "                String key = entry.getKey();", "                if (!map.containsKey(key)) {", "                    map.put(key, entry.getValue());"]}
{"name": ["public static String toHeaderElement(String name, String value) {", "        return OAuth.percentEncode(name) + \"=\\\"\" + OAuth.percentEncode(value) + \"\\\"\";"], "value": ["public static String toHeaderElement(String name, String value) {", "        return OAuth.percentEncode(name) + \"=\\\"\" + OAuth.percentEncode(value) + \"\\\"\";"]}
{"strKey": ["public boolean put(K strKey, E object, long ttl) {\r", "\t\treturn put(strKey, object, ttl, false);\r"], "object": ["public boolean put(K strKey, E object, long ttl) {\r", "\t\treturn put(strKey, object, ttl, false);\r"], "ttl": ["public boolean put(K strKey, E object, long ttl) {\r", "\t\treturn put(strKey, object, ttl, false);\r"]}
{"strKey": ["public boolean put(K strKey, E object, boolean eternal) {\r", "\t\treturn put(strKey, object, defaultTTL, eternal);\r"], "object": ["public boolean put(K strKey, E object, boolean eternal) {\r", "\t\treturn put(strKey, object, defaultTTL, eternal);\r"], "eternal": ["public boolean put(K strKey, E object, boolean eternal) {\r", "\t\treturn put(strKey, object, defaultTTL, eternal);\r"]}
{"k": ["protected synchronized boolean put(K k, E object, long ttl, boolean eternal) {\r", "\t\tif(exists(k)) {\r", "\t\t\tTTLObject<K, E> ttlObject = getTTLObject(k);\r", "\t\t\tKey<K> key = keys.get(k);\r", "\t\t\tkey.setTime(System.currentTimeMillis());\r", "\t\t\tttlObject.setEternal(eternal);\r", "\t\t\tttlObject.extendLife(ttl);\r", "\t\t\tttlObject.setObject(object);\r", "\t\t\tTTLObject<K, E> t = new TTLObject<K, E>(object, k, ttl);\r", "\t\t\t\tKey<K> key = new Key<K>(k, System.currentTimeMillis());\r", "\t\t\t\tkeys.put(k, key);\t\r", "\t\t\t\tt.getObject().onPut(k);\r"], "object": ["protected synchronized boolean put(K k, E object, long ttl, boolean eternal) {\r", "\t\t\tttlObject.setObject(object);\r", "\t\t\t\teventListener.onPut(object);\r", "\t\t\tTTLObject<K, E> t = new TTLObject<K, E>(object, k, ttl);\r", "\t\t\tlong addedSize = object.getSizeInBytes();\r", "\t\t\t\t\teventListener.onPut(object);\r"], "ttl": ["protected synchronized boolean put(K k, E object, long ttl, boolean eternal) {\r", "\t\t\tttlObject.extendLife(ttl);\r", "\t\t\tTTLObject<K, E> t = new TTLObject<K, E>(object, k, ttl);\r", "\t\t\tt.setEternal(eternal);\r", "\t\t\t\tobjects.put(key, t);\r", "\t\t\t\tt.getObject().onPut(k);\r"], "eternal": ["protected synchronized boolean put(K k, E object, long ttl, boolean eternal) {\r", "\t\t\tttlObject.setEternal(eternal);\r", "\t\t\tt.setEternal(eternal);\r"]}
{"strKey": ["public synchronized E getRaw(K strKey) {\r", "\t\tTTLObject<K, E> obj = getTTLObject(strKey);\r", "\t\tif(obj != null && !isExpired(obj)) {\r", "\t\t\treturn obj.getObject();\r"]}
{"key": ["public synchronized E get(K key) {\r", "\t\tTTLObject<K, E> obj = getTTLObject(key);\r", "\t\tif(obj != null && !isExpired(obj)) {\r", "\t\t\t\textendTTL(key);\r", "\t\t\t\teventListener.onGet(obj.getObject());\r", "\t\t\tobj.getObject().onGet();\r", "\t\t\treturn obj.getObject();\r", "\t\telse if(obj != null) {\r", "\t\t\tdestroy(obj.getKey());\r", "\t\tif (obj == null) {\r", "\t\t\t\tE object = objectFactory.create(key);\r", "\t\t\t\tif(object != null) {\r", "\t\t\t\t\tif(!put(key, object) && logger != null) {\r", "\t\t\t\treturn object;\r"]}
{"k": ["public boolean exists(K k) {\r", "\t\tKey<K> key = keys.get(k);\r", "\t\tif(key != null) {\r", "\t\t\treturn objects.get(key) != null;\r"]}
{"strKey": ["public synchronized void extendTTL(K strKey) {\r", "\t\tTTLObject<K, E> object = getTTLObject(strKey);\r", "\t\tif(object != null) {\r", "\t\t\tobject.setLifeExpectancy(System.currentTimeMillis() + object.getTtl());\r"]}
{"name": ["public void loadImageByData(final String name, final String encodedData, int width, int height, final ImageLoadListener listener) {\t\t", "\t\trequest.setUrl(name);"], "encodedData": ["public void loadImageByData(final String name, final String encodedData, int width, int height, final ImageLoadListener listener) {\t\t", "\t\trequest.setEncodedImageData(encodedData);"], "width": [], "height": [], "listener": ["public void loadImageByData(final String name, final String encodedData, int width, int height, final ImageLoadListener listener) {\t\t", "\t\tloadImage(request, listener);"]}
{"url": ["public void loadImageByUrl(final String url, int width, int height, final ImageLoadListener listener) {", "\t\trequest.setUrl(url);"], "width": ["public void loadImageByUrl(final String url, int width, int height, final ImageLoadListener listener) {", "\t\trequest.setScaleWidth(width);"], "height": ["public void loadImageByUrl(final String url, int width, int height, final ImageLoadListener listener) {", "\t\trequest.setScaleHeight(height);"], "listener": ["public void loadImageByUrl(final String url, int width, int height, final ImageLoadListener listener) {", "\t\tloadImage(request, listener);"]}
{"tagString": ["public static Map<String, String> parseTags(final String tagString) throws IllegalArgumentException {", "        Scanner scanner = new Scanner(tagString).useDelimiter(\"\\\\s+|=\");", "            throw new IllegalArgumentException(\"Invalid tag string '\" + tagString + \"'\");"]}
{"tagMap": ["public static String formatTags(final Map<String, String> tagMap) {", "        for (Map.Entry<String, String> tag : tagMap.entrySet()) {", "                    .append(sanitize(tag.getKey()))", "                    .append(sanitize(tag.getValue()));"]}
{"name": ["public static String fixEncodedTagsInNameAfterPrefix(final String name) {", "        if (name == null)", "            return name;", "        int tagStart = name.indexOf(\"TAG(\");", "            return name; // no tags in this name", "            return name; // tag string is already correct", "        int tagEnd = name.lastIndexOf(')');", "            throw new IllegalArgumentException(\"Tag definition missing closing parenthesis for metric '\" + name + \"'\");", "        String tagString = name.substring(tagStart, tagEnd+1);", "        return tagString + name.substring(0, tagStart) + name.substring(tagEnd+1);"]}
{"name": ["public static Builder named(String name) {", "\t\tif (!hasEncodedTagInName(name)) {", "            return new Builder(name);", "        int tagEnd = name.lastIndexOf(')');", "            throw new IllegalArgumentException(\"Tag definition missing closing parenthesis for metric '\" + name + \"'\");", "        String tagString = name.substring(4, tagEnd);", "        name = name.substring(tagEnd+1);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"input": ["public static String percentDecode(final String input) {", "        if (input.isEmpty()) {", "            return input;", "            while (idx < input.length()) {", "                boolean isEOF = idx >= input.length();", "                int c = (isEOF)? 0x00 : input.codePointAt(idx);", "                while (!isEOF && c != '%') {", "                    if (c <= 0x7F) { // String.getBytes is slow, so do not perform encoding", "                        bytes.write((byte) c);", "                        bytes.write(new String(Character.toChars(c)).getBytes(UTF_8));", "                        idx += Character.charCount(c);", "                    isEOF = idx >= input.length();", "                    c = (isEOF)? 0x00 : input.codePointAt(idx);", "                if (c == '%' && (input.length() <= idx + 2 ||", "                        !isASCIIHexDigit(input.charAt(idx + 1)) ||", "                        !isASCIIHexDigit(input.charAt(idx + 2)))) {", "                    if (c <= 0x7F) { // String.getBytes is slow, so do not perform encoding", "                        bytes.write((byte) c);", "                        bytes.write(new String(Character.toChars(c)).getBytes(UTF_8));", "                        idx += Character.charCount(c);", "                    while (c == '%' && input.length() > idx + 2 &&", "                            isASCIIHexDigit(input.charAt(idx + 1)) &&", "                            isASCIIHexDigit(input.charAt(idx + 2))) {", "                        bytes.write(hexToInt(input.charAt(idx + 1), input.charAt(idx + 2)));", "                        c = (input.length() <= idx)? 0x00 : input.codePointAt(idx);"]}
{"name": ["public String queryParameter(final String name) {", "        if (name == null) {", "            if (thisNameLength == name.length() && query.regionMatches(start, name, 0, name.length())) {"]}
{"name": ["public List<String> queryParameters(final String name) {", "        if (name == null) {", "            if (thisNameLength == name.length() && query.regionMatches(start, name, 0, name.length())) {"]}
{"url": ["public String relativize(final URL url) {", "        if (this.isOpaque() || url.isOpaque()) {", "            return url.toString();", "        if (!this.scheme().equals(url.scheme())) {", "            return url.toString();", "        if (this.authority() == null ^ url.authority() == null) {", "            return url.toString();", "        if (this.authority() != null && !this.authority().equals(url.authority())) {", "            return url.toString();", "        if (!url.path().startsWith(prefixPath) && !this.path().equals(url.path())) {", "            return url.toString();", "        if (!this.path().equals(url.path())) {", "            output.append(url.path().replaceFirst(prefixPath, \"\"));", "        if (url.query() != null) {", "            output.append('?').append(url.query());", "        if (url.fragment() != null) {", "            output.append('#').append(url.fragment());"]}
{"scheme": ["public static URL buildHierarchical(final String scheme, final String host) throws GalimatiasParseException {", "        if (!URLUtils.isRelativeScheme(scheme)) {", "            throw new GalimatiasParseException(\"Scheme is not relative: \" + scheme);", "        return new URLParser(scheme + \"://\" + host).parse();"], "host": ["public static URL buildHierarchical(final String scheme, final String host) throws GalimatiasParseException {", "        return new URLParser(scheme + \"://\" + host).parse();"]}
{"scheme": ["public static URL buildOpaque(final String scheme) throws GalimatiasParseException {", "        if (URLUtils.isRelativeScheme(scheme)) {", "            throw new GalimatiasParseException(\"Scheme is relative: \" + scheme);", "        return new URLParser(scheme + \":\").parse();"]}
{"Result": "Method without Parameter"}
{"sql": ["            String sql,", "            = new StreamResultSetExtractor(sql, mapper, handleStream, excTranslator);", "        return jdbcTemplate.query(sql, pss, extractor);"], "pss": ["            PreparedStatementSetter pss,", "        return jdbcTemplate.query(sql, pss, extractor);"], "mapper": ["            RowMapper<T> mapper,", "            = new StreamResultSetExtractor(sql, mapper, handleStream, excTranslator);"], "handleStream": ["            Function<? super Stream<T>, U> handleStream) {", "            = new StreamResultSetExtractor(sql, mapper, handleStream, excTranslator);"]}
{"sql": ["            String sql,", "            = new StreamResultSetExtractor(sql, mapper, handleStream, excTranslator);", "        return namedJdbcTemplate.query(sql, sps, extractor);"], "sps": ["            SqlParameterSource sps,", "        return namedJdbcTemplate.query(sql, sps, extractor);"], "mapper": ["            RowMapper<T> mapper,", "            = new StreamResultSetExtractor(sql, mapper, handleStream, excTranslator);"], "handleStream": ["            Function<? super Stream<T>, U> handleStream) {", "            = new StreamResultSetExtractor(sql, mapper, handleStream, excTranslator);"]}
{"clazz": ["public static Field[] get(Class<?> clazz) {", "        Field[] fields = CACHED_FIELDS.get(clazz);", "        if (fields == null) {", "            fields = clazz.getFields();", "            CACHED_FIELDS.putIfAbsent(clazz, fields);", "        return fields;"]}
{"Result": "Method without Parameter"}
{"rs": ["protected static LocalDateTime getAsLocalDateTime(ResultSet rs, int index) throws SQLException {\r", "        Timestamp timestamp = rs.getTimestamp(index);\r"], "index": ["protected static LocalDateTime getAsLocalDateTime(ResultSet rs, int index) throws SQLException {\r", "        Timestamp timestamp = rs.getTimestamp(index);\r", "        if (timestamp != null) {\r", "            return timestamp.toLocalDateTime();\r"]}
{"rs": ["protected static LocalDate getAsLocalDate(ResultSet rs, int index) throws SQLException {\r", "        Date date = rs.getDate(index);\r"], "index": ["protected static LocalDate getAsLocalDate(ResultSet rs, int index) throws SQLException {\r", "        Date date = rs.getDate(index);\r", "        if (date != null) {\r", "            return date.toLocalDate();\r"]}
{"rs": ["protected static LocalTime getAsLocalTime(ResultSet rs, int index) throws SQLException {\r", "        Time time = rs.getTime(index);\r"], "index": ["protected static LocalTime getAsLocalTime(ResultSet rs, int index) throws SQLException {\r", "        Time time = rs.getTime(index);\r", "        if (time != null) {\r", "            return time.toLocalTime();\r"]}
{"rs": ["protected static ZonedDateTime getAsZonedDateTime(ResultSet rs, int index, ZoneId zoneId) throws SQLException {\r", "        Timestamp timestamp = rs.getTimestamp(index);\r"], "index": ["protected static ZonedDateTime getAsZonedDateTime(ResultSet rs, int index, ZoneId zoneId) throws SQLException {\r", "        Timestamp timestamp = rs.getTimestamp(index);\r", "        if (timestamp != null) {\r", "            return timestamp.toLocalDateTime().atZone(zoneId);\r"], "zoneId": ["protected static ZonedDateTime getAsZonedDateTime(ResultSet rs, int index, ZoneId zoneId) throws SQLException {\r", "            return timestamp.toLocalDateTime().atZone(zoneId);\r"]}
{"rs": ["protected static OffsetDateTime getAsOffsetDateTime(ResultSet rs, int index, ZoneId zoneId) throws SQLException {\r", "        Timestamp timestamp = rs.getTimestamp(index);\r"], "index": ["protected static OffsetDateTime getAsOffsetDateTime(ResultSet rs, int index, ZoneId zoneId) throws SQLException {\r", "        Timestamp timestamp = rs.getTimestamp(index);\r", "        if (timestamp != null) {\r", "            return timestamp.toLocalDateTime().atZone(zoneId).toOffsetDateTime();\r"], "zoneId": ["protected static OffsetDateTime getAsOffsetDateTime(ResultSet rs, int index, ZoneId zoneId) throws SQLException {\r", "            return timestamp.toLocalDateTime().atZone(zoneId).toOffsetDateTime();\r"]}
{"rs": ["protected static OffsetTime getAsOffsetTime(ResultSet rs, int index, ZoneId zoneId) throws SQLException {\r", "        Time time = rs.getTime(index);\r"], "index": ["protected static OffsetTime getAsOffsetTime(ResultSet rs, int index, ZoneId zoneId) throws SQLException {\r", "        Time time = rs.getTime(index);\r", "        if (time != null) {\r", "            return time.toLocalTime().atOffset(zoneId.getRules().getOffset(Instant.now()));\r"], "zoneId": ["protected static OffsetTime getAsOffsetTime(ResultSet rs, int index, ZoneId zoneId) throws SQLException {\r", "            return time.toLocalTime().atOffset(zoneId.getRules().getOffset(Instant.now()));\r"]}
{"rs": ["protected Object getColumnValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {", "        return Jsr310JdbcUtils.getResultSetValue(rs, index, requiredType, zoneId);"], "index": ["protected Object getColumnValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {", "        return Jsr310JdbcUtils.getResultSetValue(rs, index, requiredType, zoneId);"], "requiredType": ["protected Object getColumnValue(ResultSet rs, int index, Class<?> requiredType) throws SQLException {", "        return Jsr310JdbcUtils.getResultSetValue(rs, index, requiredType, zoneId);"]}
{"width": ["public CdnPathBuilder crop(int width, int height) {", "        dimensionsGuard(width, height);", "                .append(width)"], "height": ["public CdnPathBuilder crop(int width, int height) {", "        dimensionsGuard(width, height);", "                .append(height);"]}
{"width": ["public CdnPathBuilder cropCenter(int width, int height) {", "        dimensionsGuard(width, height);", "                .append(width)"], "height": ["public CdnPathBuilder cropCenter(int width, int height) {", "        dimensionsGuard(width, height);", "                .append(height)"]}
{"width": ["public CdnPathBuilder cropColor(int width, int height, Color color) {", "        dimensionsGuard(width, height);", "                .append(width)"], "height": ["public CdnPathBuilder cropColor(int width, int height, Color color) {", "        dimensionsGuard(width, height);", "                .append(height)"], "color": ["public CdnPathBuilder cropColor(int width, int height, Color color) {", "                .append(colorToHex(color));"]}
{"width": ["public CdnPathBuilder resizeWidth(int width) {", "        dimensionGuard(width);", "                .append(width)"]}
{"width": ["public CdnPathBuilder resize(int width, int height) {", "        dimensionsGuard(width, height);", "                .append(width)"], "height": ["public CdnPathBuilder resize(int width, int height) {", "        dimensionsGuard(width, height);", "                .append(height);"]}
{"width": ["public CdnPathBuilder scaleCrop(int width, int height) {", "        dimensionsGuard(width, height);", "                .append(width)"], "height": ["public CdnPathBuilder scaleCrop(int width, int height) {", "        dimensionsGuard(width, height);", "                .append(height);"]}
{"width": ["public CdnPathBuilder scaleCropCenter(int width, int height) {", "        dimensionsGuard(width, height);", "                .append(width)"], "height": ["public CdnPathBuilder scaleCropCenter(int width, int height) {", "        dimensionsGuard(width, height);", "                .append(height)"]}
{"strength": ["public CdnPathBuilder blur(int strength) {", "        if (strength < 0 || strength > 5000) {", "                .append(strength);"]}
{"strength": ["public CdnPathBuilder sharp(int strength) {", "        if (strength < 0 || strength > 20) {", "                .append(strength);"]}
{"width": ["public CdnPathBuilder preview(int width, int height) {", "        dimensionsGuard(width, height);", "                .append(width)"], "height": ["public CdnPathBuilder preview(int width, int height) {", "        dimensionsGuard(width, height);", "                .append(height);"]}
{"Result": "Method without Parameter"}
{"fileId": ["public File getFile(String fileId) {", "        URI url = Urls.apiFile(fileId);", "        FileData fileData = requestHelper.executeQuery(new HttpGet(url), true, FileData.class);"]}
{"fileId": ["public void deleteFile(String fileId) {", "        URI url = Urls.apiFile(fileId);", "        requestHelper.executeCommand(new HttpDelete(url), true);"]}
{"fileId": ["public void saveFile(String fileId) {", "        URI url = Urls.apiFileStorage(fileId);", "        requestHelper.executeCommand(new HttpPost(url), true);"]}
{"request": ["public HttpResponse executeCommand(HttpUriRequest request, boolean apiHeaders) {", "            setApiHeaders(request);", "            CloseableHttpResponse response = client.getHttpClient().execute(request);", "                checkResponseStatus(response);", "                return response;", "                response.close();"], "apiHeaders": ["public HttpResponse executeCommand(HttpUriRequest request, boolean apiHeaders) {", "        if (apiHeaders) {"]}
{"response": ["private void checkResponseStatus(HttpResponse response) throws IOException {", "        int statusCode = response.getStatusLine().getStatusCode();", "                    streamToString(response.getEntity().getContent()));", "                    streamToString(response.getEntity().getContent()));", "                            response.getEntity().getContent()));"]}
{"sourceUrl": ["public static URI uploadFromUrl(String sourceUrl, String pubKey, String store) {", "                .setParameter(\"source_url\", sourceUrl)"], "pubKey": ["public static URI uploadFromUrl(String sourceUrl, String pubKey, String store) {", "                .setParameter(\"pub_key\", pubKey)"], "store": ["public static URI uploadFromUrl(String sourceUrl, String pubKey, String store) {", "                .setParameter(\"store\", store);"]}
{"target": ["    public void inject(Object target) {", "        mObjectGraph.inject(target);"]}
{"context": ["public static Builder newBuilder(Context context, int themeResId) {", "            return new APi21Builder(context, themeResId);", "        return new Api20Builder(context, themeResId);"], "themeResId": ["public static Builder newBuilder(Context context, int themeResId) {", "            return new APi21Builder(context, themeResId);", "        return new Api20Builder(context, themeResId);"]}
{"className": ["    public Class<?> findClass(final String className)", "        Objects.requireNonNull(className);", "            return (Class<?>) findClass.invoke(loader, className);", "                + className + ')', e);"]}
{"className": ["public Class<?> loadClass(final String className, final byte[] bytecode)", "        Objects.requireNonNull(className);", "            return (Class<?>) loadClass.invoke(loader, className, bytecode, 0,"], "bytecode": ["public Class<?> loadClass(final String className, final byte[] bytecode)", "        Objects.requireNonNull(bytecode);", "            return (Class<?>) loadClass.invoke(loader, className, bytecode, 0,", "                bytecode.length);"]}
{"buffer": ["private int doSearch(final CharBuffer buffer, final int matchedLength,", "        if (!buffer.hasRemaining())", "        char c = buffer.get();", "        return nextNodes[index].doSearch(buffer, nextLength, currentLength + 1,"], "matchedLength": ["private int doSearch(final CharBuffer buffer, final int matchedLength,", "        final int nextLength = fullWord ? currentLength : matchedLength;", "            return nextLength;", "            return nextLength;", "        return nextNodes[index].doSearch(buffer, nextLength, currentLength + 1,"], "currentLength": ["        final int currentLength, final boolean ignoreCase)", "        final int nextLength = fullWord ? currentLength : matchedLength;", "        return nextNodes[index].doSearch(buffer, nextLength, currentLength + 1,"], "ignoreCase": ["        final int currentLength, final boolean ignoreCase)", "        if (index < 0 && ignoreCase) {", "            ignoreCase);"]}
{"word": ["public TrieBuilder addWord(@Nonnull final String word)", "        Objects.requireNonNull(word);", "        final int length = word.length();", "        nodeBuilder.addWord(word);"]}
{"c": ["public boolean append(final char c)", "            return set(new StringBuilder().append(c));", "        get().append(c);"]}
{"value": ["public final T getAndSet(final T value)", "        final T ret = this.value;", "        this.value = value;", "        return ret;"]}
{"classInternalName": ["public static boolean isAssignableTo(final String classInternalName,", "        Objects.requireNonNull(classInternalName, \"classInternalName\");", "        final Class<?> c = CACHE.loadClass(classInternalName);", "        return type.isAssignableFrom(c);"], "type": ["        final Class<?> type)", "        Objects.requireNonNull(type, \"type\");", "        return type.isAssignableFrom(c);"]}
{"zipfs": ["private void copyParseInfo(final FileSystem zipfs)", "        final Path path = zipfs.getPath(INFO_PATH);"]}
{"group": ["public static void hash(@Nonnull final InstructionGroup group,", "            = new InstructionGroupHasher(group, className);", "        group.setName(name);"], "className": ["        @Nonnull final String className)", "        final InstructionGroupHasher groupHasher", "            = new InstructionGroupHasher(group, className);", "        final String name = groupHasher.hashAndGetName();"]}
{"c": ["    public Rule ignoreCase(final char c)", "        return Character.isLowerCase(c) == Character.isUpperCase(c)", "            ? ch(c) : new CharIgnoreCaseMatcher(c);"]}
{"codePoint": ["    public Rule unicodeChar(final int codePoint)", "        if (!Character.isValidCodePoint(codePoint))", "                + codePoint);", "        return new CodePointMatcher(codePoint);"]}
{"low": ["    public Rule unicodeRange(final int low, final int high)", "        if (!Character.isValidCodePoint(low))", "            throw new InvalidGrammarException(\"invalid code point \" + low);", "        if (low > high)", "                + low + \" > \" + high);", "        return low == high ? new CodePointMatcher(low)", "            : new CodePointRangeMatcher(low, high);"], "high": ["    public Rule unicodeRange(final int low, final int high)", "        if (!Character.isValidCodePoint(high))", "            throw new InvalidGrammarException(\"invalid code point \" + high);", "        if (low > high)", "                + low + \" > \" + high);", "        return low == high ? new CodePointMatcher(low)", "            : new CodePointRangeMatcher(low, high);"]}
{"characters": ["    public Rule anyOf(final String characters)", "        Objects.requireNonNull(characters);", "        return anyOf(characters.toCharArray());"]}
{"characters": ["    public Rule anyOf(final Characters characters)", "        Objects.requireNonNull(characters);", "        if (!characters.isSubtractive() && characters.getChars().length == 1)", "            return ch(characters.getChars()[0]);", "        if (characters.equals(Characters.NONE))", "        return new AnyOfMatcher(characters);"]}
{"string": ["    public Rule string(final String string)"]}
{"Result": "Method without Parameter"}
{"string": ["    public Rule ignoreCase(final String string)", "        Objects.requireNonNull(string);", "        return ignoreCase(string.toCharArray());"]}
{"rule": ["    public Rule optional(final Object rule)", "        Objects.requireNonNull(rule);", "        return new OptionalMatcher(toRule(rule));"]}
{"rule": ["    public Rule optional(final Object rule, final Object rule2,", "        return optional(sequence(rule, rule2, moreRules));"], "rule2": ["    public Rule optional(final Object rule, final Object rule2,", "        return optional(sequence(rule, rule2, moreRules));"]}
{"rule": ["    public final RepeatMatcherBuilder<V> repeat(final Object rule,", "        return repeat(sequence(rule, rule2, moreRules));"], "rule2": ["        final Object rule2, final Object... moreRules)", "        return repeat(sequence(rule, rule2, moreRules));"]}
{"rule": ["    public Rule zeroOrMore(final Object rule, final Object rule2,", "        return repeat(rule, rule2, moreRules).min(0);"], "rule2": ["    public Rule zeroOrMore(final Object rule, final Object rule2,", "        return repeat(rule, rule2, moreRules).min(0);"]}
{"string": ["    protected Rule fromStringLiteral(final String string)", "        Objects.requireNonNull(string);", "        return fromCharArray(string.toCharArray());"]}
{"Result": "Method without Parameter"}
{"obj": ["    public Rule toRule(final Object obj)", "        Objects.requireNonNull(obj);", "        if (obj instanceof Rule)", "            return (Rule) obj;", "        if (obj instanceof Character)", "            return fromCharLiteral((Character) obj);", "        if (obj instanceof String)", "            return fromStringLiteral((String) obj);", "        if (obj instanceof char[])", "            return fromCharArray((char[]) obj);", "        if (obj instanceof Action) {", "            final Action<?> action = (Action<?>) obj;", "            return new ActionMatcher(action);", "        final String errmsg = obj instanceof  Boolean", "            : \"'\" + obj + \"' cannot be automatically converted to a rule\";"]}
{"down": ["public boolean push(final int down, final V value)", "        context.getValueStack().push(down, value);"], "value": ["public boolean push(final int down, final V value)", "        context.getValueStack().push(down, value);"]}
{"c": ["public <E extends V> E popAs(@Nonnull final Class<E> c)", "        return c.cast(pop());"]}
{"c": ["public <E extends V> E popAs(final Class<E> c, final int down)", "        return c.cast(pop(down));"], "down": ["public <E extends V> E popAs(final Class<E> c, final int down)", "        return c.cast(pop(down));"]}
{"c": ["public <E extends V> E peekAs(final Class<E> c)", "        return c.cast(peek());"]}
{"down": ["public boolean poke(final int down, final V value)", "        context.getValueStack().poke(down, value);"], "value": ["public boolean poke(final int down, final V value)", "        context.getValueStack().poke(down, value);"]}
{"context": ["    public <T> boolean match(final MatcherContext<T> context)", "        final Matcher matcher = context.getMatcher();", "        final PreMatchEvent<T> preMatchEvent = new PreMatchEvent<>(context);", "        bus.post(preMatchEvent);", "        final boolean match = matcher.match(context);", "        final MatchContextEvent<T> postMatchEvent = match", "            ? new MatchSuccessEvent<>(context)", "            : new MatchFailureEvent<>(context);", "        bus.post(postMatchEvent);", "        return match;"]}
{"other": ["public boolean overlapsWith(final IndexRange other)", "        Objects.requireNonNull(other, \"other\");", "        return end > other.start && other.end > start;"]}
{"other": ["public boolean touches(final IndexRange other)", "        Objects.requireNonNull(other, \"other\");", "        return other.end == start || end == other.start;"]}
{"other": ["public IndexRange mergedWith(final IndexRange other)", "        Objects.requireNonNull(other, \"other\");", "        return new IndexRange(Math.min(start, other.start),", "            Math.max(end, other.end));"]}
{"parserClass": ["        final Class<P> parserClass)", "            return ParserTransformer.getByteCode(parserClass);"]}
{"buffer": ["private void doAddWord(final CharBuffer buffer)", "        if (!buffer.hasRemaining()) {", "        final char c = buffer.get();", "        builder.doAddWord(buffer);"]}
{"matcher": ["public static Matcher unwrap(final Matcher matcher)", "        if (matcher instanceof ProxyMatcher) {", "            final ProxyMatcher proxyMatcher = (ProxyMatcher) matcher;", "            if (proxyMatcher.dirty)", "                proxyMatcher.apply();", "            return proxyMatcher.target == null ? proxyMatcher", "                : proxyMatcher.target;", "        return matcher;"]}
{"listener": ["public final boolean register(@Nonnull final Object listener)", "        bus.register(Objects.requireNonNull(listener));"]}
{"object": ["public final boolean post(@Nonnull final Object object)", "        Objects.requireNonNull(object);", "        bus.post(object);"]}
{"context": ["    public <V> MatcherContext<V> getSubContext(final MatcherContext<V> context)", "        return context.getSubContext(this);"]}
{"nrCycles": ["public Rule min(final int nrCycles)", "        Preconditions.checkArgument(nrCycles >= 0,", "            \"illegal repetition number specified (\" + nrCycles", "        return range(Range.atLeast(nrCycles));"]}
{"nrCycles": ["public Rule max(final int nrCycles)", "        Preconditions.checkArgument(nrCycles >= 0,", "            \"illegal repetition number specified (\" + nrCycles", "        return range(Range.atMost(nrCycles));"]}
{"nrCycles": ["public Rule times(final int nrCycles)", "        Preconditions.checkArgument(nrCycles >= 0,", "            \"illegal repetition number specified (\" + nrCycles", "        return range(Range.singleton(nrCycles));"]}
{"minCycles": ["public Rule times(final int minCycles, final int maxCycles)", "        Preconditions.checkArgument(minCycles >= 0,", "            \"illegal repetition number specified (\" + minCycles", "        Preconditions.checkArgument(maxCycles >= minCycles,", "            \"illegal range specified (\" + minCycles + \", \" + maxCycles", "        return range(Range.closed(minCycles, maxCycles));"], "maxCycles": ["public Rule times(final int minCycles, final int maxCycles)", "        Preconditions.checkArgument(maxCycles >= minCycles,", "            \"illegal range specified (\" + minCycles + \", \" + maxCycles", "        return range(Range.closed(minCycles, maxCycles));"]}
{"range": ["    public Rule range(final Range<Integer> range)"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"events": ["public void addMonitoringEventsToAllServices(Events events) {", "\t\tList<JAXBElement<? extends EventType>> events_ = events.getEvent();", "\t\t\t\t\tmonitor.setEvents(events);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"resolvedFileName": ["protected List<Dependency> readDependenciesFromFile(String resolvedFileName, String dependencyType) throws IOException {", "\t\tFile resolvedFile = new File(resolvedFileName);", "\t\tif (!resolvedFile.exists()) {", "\t\tFileInputStream fstream = new FileInputStream(resolvedFile);", "\t\tDataInputStream ds = new DataInputStream(fstream);", "\t\tBufferedReader br = new BufferedReader(new InputStreamReader(ds));", "\t\twhile ((strLine = br.readLine()) != null) {", "\t\t\tMatcher m = p.matcher(strLine);", "\t\t\tif (m.matches()) {", "\t\t\t\tgetLog().debug(m.group(0));", "\t\t\t\tString groupId = m.group(1);", "\t\t\t\tString artifactId = m.group(2);", "\t\t\t\tString version = m.group(3);", "\t\t\t\tString scope = m.group(4);", "\t\t\t\tdependency.setGroupId(groupId);", "\t\t\t\tdependency.setArtifactId(artifactId);", "\t\t\t\tdependency.setVersion(version);", "\t\t\t\tdependency.setScope(scope);", "\t\tbr.close();"], "dependencyType": ["protected List<Dependency> readDependenciesFromFile(String resolvedFileName, String dependencyType) throws IOException {", "\t\tPattern p = Pattern.compile(\"   (.*):(.*):\" + dependencyType + \":(.*):(.*)\"); // keep only selected type (projlib or jar or bw-ear) dependencies", "\t\t\t\tdependency.setType(dependencyType);"]}
{"binary": ["protected void launchTIBCOBinary(File binary, List<File> tras, ArrayList<String> arguments, File workingDir, String errorMsg) throws IOException, MojoExecutionException {", "\t\tlaunchTIBCOBinary(binary, tras, arguments, workingDir, errorMsg, false, true);"], "tras": ["protected void launchTIBCOBinary(File binary, List<File> tras, ArrayList<String> arguments, File workingDir, String errorMsg) throws IOException, MojoExecutionException {", "\t\tlaunchTIBCOBinary(binary, tras, arguments, workingDir, errorMsg, false, true);"], "arguments": ["protected void launchTIBCOBinary(File binary, List<File> tras, ArrayList<String> arguments, File workingDir, String errorMsg) throws IOException, MojoExecutionException {", "\t\tlaunchTIBCOBinary(binary, tras, arguments, workingDir, errorMsg, false, true);"], "workingDir": ["protected void launchTIBCOBinary(File binary, List<File> tras, ArrayList<String> arguments, File workingDir, String errorMsg) throws IOException, MojoExecutionException {", "\t\tlaunchTIBCOBinary(binary, tras, arguments, workingDir, errorMsg, false, true);"], "errorMsg": ["protected void launchTIBCOBinary(File binary, List<File> tras, ArrayList<String> arguments, File workingDir, String errorMsg) throws IOException, MojoExecutionException {", "\t\tlaunchTIBCOBinary(binary, tras, arguments, workingDir, errorMsg, false, true);"]}
{"Result": "Method without Parameter"}
{"directory": ["protected boolean cleanDirectory(File directory) {", "        if (directory.isDirectory() && directory.listFiles().length != 0) {", "            for (File file : directory.listFiles()) {", "                if (file.isFile()) {", "                    file.delete();", "        return directory.delete();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"list": ["private void addAlias(ArrayList<HashMap<String,Object>> list, String aliasName) {", "\t\tfor (HashMap<String, Object> h : list) {", "\t\t\tString name = (String) h.get(\"name\");", "\t\t\tif (name != null && name.equals(aliasName)) {", "\t\tlist.add(h);"], "aliasName": ["private void addAlias(ArrayList<HashMap<String,Object>> list, String aliasName) {", "\t\t\tif (name != null && name.equals(aliasName)) {", "\t\th.put(\"name\", aliasName);"]}
{"f": ["public void processFile(File f) throws MojoExecutionException {", "\t\t\tRepositoryModel repositoryModel = new RepositoryModel(f);", "\t\t\tArrayList<HashMap<String, Object>> aliases = readXMLBean(repositoryModel, f);", "\t\t\t\taliases.clear();", "\t\t\t\taddAlias(aliases, getJarAlias(dependency, false));", "\t\t\twriteXMLBean(repositoryModel, f, aliases);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"pom": ["public static void addDependency(File pom, Dependency dependency, Log logger) throws IOException, XmlPullParserException {", "\t\tModel model = getModelFromPOM(pom, logger);", "\t\twriteModelToPOM(model, pom, logger);"], "dependency": ["public static void addDependency(File pom, Dependency dependency, Log logger) throws IOException, XmlPullParserException {", "\t\tmodel.addDependency(dependency);"], "logger": ["public static void addDependency(File pom, Dependency dependency, Log logger) throws IOException, XmlPullParserException {", "\t\tModel model = getModelFromPOM(pom, logger);", "\t\tmodel.addDependency(dependency);", "\t\twriteModelToPOM(model, pom, logger);"]}
{"pom": ["public static void removeDependency(File pom, Dependency dependency, Log logger) throws IOException, XmlPullParserException {", "\t\tModel model = getModelFromPOM(pom, logger);", "\t\twriteModelToPOM(model, pom, logger);"], "dependency": ["public static void removeDependency(File pom, Dependency dependency, Log logger) throws IOException, XmlPullParserException {", "\t\t\tif (dependenciesEqual(it.next(), dependency)) {"], "logger": ["public static void removeDependency(File pom, Dependency dependency, Log logger) throws IOException, XmlPullParserException {", "\t\tModel model = getModelFromPOM(pom, logger);", "\t\tfor (Iterator<Dependency> it = model.getDependencies().iterator(); it.hasNext();){", "\t\t\tif (dependenciesEqual(it.next(), dependency)) {", "\t\t\t\tit.remove();", "\t\twriteModelToPOM(model, pom, logger);"]}
{"dependency": ["private static boolean dependencyExists(Dependency dependency, List<Dependency> dependencies) {", "\t\t\tif (dependenciesEqual(dependency, d)) {"], "dependencies": ["private static boolean dependencyExists(Dependency dependency, List<Dependency> dependencies) {", "\t\tfor (Dependency d : dependencies) {", "\t\t\tif (dependenciesEqual(dependency, d)) {"]}
{"pom": ["public static boolean dependencyExists(File pom, Dependency dependency, Log logger) throws IOException, XmlPullParserException {", "\t\tModel model = getModelFromPOM(pom, logger);"], "dependency": ["public static boolean dependencyExists(File pom, Dependency dependency, Log logger) throws IOException, XmlPullParserException {", "\t\treturn dependencyExists(dependency, model.getDependencies());"], "logger": ["public static boolean dependencyExists(File pom, Dependency dependency, Log logger) throws IOException, XmlPullParserException {", "\t\tModel model = getModelFromPOM(pom, logger);", "\t\treturn dependencyExists(dependency, model.getDependencies());"]}
{"pom": ["public static void addProjectAsModule(File pom, String relativePath, String profileId, Log logger) throws IOException, XmlPullParserException {", "\t\tModel model = getModelFromPOM(pom, logger);", "\t\twriteModelToPOM(model, pom, logger);"], "relativePath": ["public static void addProjectAsModule(File pom, String relativePath, String profileId, Log logger) throws IOException, XmlPullParserException {", "\t\tif (relativePath == null) return;", "\t\trelativePath = relativePath.replace(\"\\\\\", \"/\");"], "profileId": ["public static void addProjectAsModule(File pom, String relativePath, String profileId, Log logger) throws IOException, XmlPullParserException {", "\t\tif (profileId != null && !profileId.isEmpty()) {", "\t\t\tProfile p = getProfile(model, profileId);", "\t\t\tif (p != null) {", "\t\t\t\tp.addModule(relativePath);"], "logger": ["public static void addProjectAsModule(File pom, String relativePath, String profileId, Log logger) throws IOException, XmlPullParserException {", "\t\tModel model = getModelFromPOM(pom, logger);", "\t\t\tProfile p = getProfile(model, profileId);", "\t\t\tmodel.addModule(relativePath);", "\t\twriteModelToPOM(model, pom, logger);"]}
{"pom": ["public static boolean moduleExists(File pom, String relativePath, String profileId, Log logger) throws IOException, XmlPullParserException {", "\t\tModel model = getModelFromPOM(pom, logger);"], "relativePath": ["public static boolean moduleExists(File pom, String relativePath, String profileId, Log logger) throws IOException, XmlPullParserException {", "\t\tif (relativePath == null) return false;", "\t\trelativePath = relativePath.replace(\"\\\\\", \"/\");"], "profileId": ["public static boolean moduleExists(File pom, String relativePath, String profileId, Log logger) throws IOException, XmlPullParserException {", "\t\tif (profileId != null && !profileId.isEmpty()) {", "\t\t\tProfile p = getProfile(model, profileId);", "\t\t\tif (p != null) {", "\t\t\t\treturn p.getModules().indexOf(relativePath) >= 0;"], "logger": ["public static boolean moduleExists(File pom, String relativePath, String profileId, Log logger) throws IOException, XmlPullParserException {", "\t\tModel model = getModelFromPOM(pom, logger);", "\t\t\tProfile p = getProfile(model, profileId);", "\t\t\treturn model.getModules().indexOf(relativePath) >= 0;"]}
{"basedir": ["protected File getArtifactFile(File basedir, String finalName, String classifier) {", "        return new File(basedir, finalName + classifier + getArtifactFileExtension());"], "finalName": ["protected File getArtifactFile(File basedir, String finalName, String classifier) {", "        return new File(basedir, finalName + classifier + getArtifactFileExtension());"], "classifier": ["protected File getArtifactFile(File basedir, String finalName, String classifier) {", "        if (classifier == null) {", "        } else if (classifier.trim().length() > 0 && !classifier.startsWith(\"-\")) {", "            classifier = \"-\" + classifier;", "        return new File(basedir, finalName + classifier + getArtifactFileExtension());"]}
{"Result": "Method without Parameter"}
{"filename": ["protected String extractFileContent(final String filename)", "\t\tfinal BufferedReader bufferedReader = new BufferedReader(", "\t\t\t\tnew FileReader(filename));", "\t\t\twhile (temp != null) {", "\t\t\t\ttemp = bufferedReader.readLine();", "\t\t\t\tif (temp != null) {", "\t\t\t\t\tsb.append(temp);", "\t\t\tbufferedReader.close();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"clazz": ["private static <T> T newInstance(Class<T> clazz, Object... params) throws SQLException {", "                return clazz.newInstance();", "                for (Constructor<?> ctor : clazz.getConstructors()) {", "                    if (ctor.getParameterTypes().length != params.length) {", "                    for (Class<?> paramType : ctor.getParameterTypes()) {", "                        if (!paramType.isInstance(params[paramIndex])) {", "                    Constructor<T> theCtor = (Constructor<T>) ctor;", "                    return theCtor.newInstance(params);", "                throw new SQLException(\"Constructor not found for \" + clazz);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"query": ["public Timer.Context startStatementExecuteTimer(Query query) {", "        ensureSqlId(query);", "        String name = metricNamingStrategy.getStatementExecuteTimer(query.getSql(), query.getSqlId());"]}
{"query": ["public Timer.Context startCallableStatementLifeTimer(Query query) {", "        ensureSqlId(query);", "        String name = metricNamingStrategy.getCallableStatementLifeTimer(query.getSql(), query.getSqlId());"]}
{"query": ["public Timer.Context startResultSetLifeTimer(Query query) {", "        ensureSqlId(query);", "        String name = metricNamingStrategy.getResultSetLifeTimer(query.getSql(), query.getSqlId());"]}
{"query": ["public void markResultSetRowMeter(Query query) {", "        ensureSqlId(query);", "        String name = metricNamingStrategy.getResultSetRowMeter(query.getSql(), query.getSqlId());"]}
{"proxyHandler": ["private <T> T newProxy(JdbcProxyHandler<T> proxyHandler) {\r", "        return proxyFactory.newProxy(proxyHandler, proxyHandler.getProxyClass());\r"]}
{"wrappedConnection": ["public Connection wrapConnection(Connection wrappedConnection) {\r", "        return newProxy(new ConnectionProxyHandler(wrappedConnection, this, lifeTimerContext));\r"]}
{"statement": ["public Statement wrapStatement(Statement statement) {\r", "        return newProxy(new StatementProxyHandler(statement, this, lifeTimerContext));\r"]}
{"preparedStatement": ["public PreparedStatement wrapPreparedStatement(PreparedStatement preparedStatement, String sql) {\r", "        return newProxy(new PreparedStatementProxyHandler(preparedStatement, this, query, lifeTimerContext));\r"], "sql": ["public PreparedStatement wrapPreparedStatement(PreparedStatement preparedStatement, String sql) {\r", "        Query query = new Query(sql);\r", "        Timer.Context lifeTimerContext = getMetricHelper().startPreparedStatementLifeTimer(query);\r", "        return newProxy(new PreparedStatementProxyHandler(preparedStatement, this, query, lifeTimerContext));\r"]}
{"callableStatement": ["public CallableStatement wrapCallableStatement(CallableStatement callableStatement, String sql) {\r", "        return newProxy(new CallableStatementProxyHandler(callableStatement, this, query, lifeTimerContext));\r"], "sql": ["public CallableStatement wrapCallableStatement(CallableStatement callableStatement, String sql) {\r", "        Query query = new Query(sql);\r", "        Timer.Context lifeTimerContext = getMetricHelper().startCallableStatementLifeTimer(query);\r", "        return newProxy(new CallableStatementProxyHandler(callableStatement, this, query, lifeTimerContext));\r"]}
{"resultSet": ["private Class<? extends ResultSet> getResultSetType(ResultSet resultSet) {\r", "        if (resultSet instanceof RowSet) {\r", "            if (resultSet instanceof CachedRowSet) {\r", "                if (resultSet instanceof WebRowSet) {\r", "                    if (resultSet instanceof FilteredRowSet) {\r", "                    } else if (resultSet instanceof JoinRowSet) {\r", "            } else if (resultSet instanceof JdbcRowSet) {\r"]}
{"Result": "Method without Parameter"}
{"args": ["private void buildFaceArgs(final List<String> args) {", "\t\t\targs.add(flagify(mode));", "\t\t\t\targs.add(flagify(CowsayCli.Opt.EYES.toString()));", "\t\t\t\targs.add(eyes);", "\t\t\t\targs.add(flagify(CowsayCli.Opt.TONGUE.toString()));", "\t\t\t\targs.add(tongue);", "\t\t\t\targs.add(flagify(CowsayCli.Opt.COWFILE.toString()));", "\t\t\t\targs.add(cowfile);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"language": ["public static void setLanguage(final String language) {", "\t\tcurrentLocale = new Locale(language);", "\t\tmessages = ResourceBundle.getBundle(\"MessagesBundle\", currentLocale);"]}
{"key": ["protected static String getMessage(final String key) {", "\t\treturn messages.getString(key);"]}
{"args": ["private static String sayOrThink(final String[] args, final boolean think) {", "\t\t\tCommandLine commandLine = CowsayCli.parseCmdArgs(args);", "\t\t\tif (commandLine != null) {", "\t\t\t\tif (commandLine.hasOption(CowsayCli.Opt.HELP.toString())) {", "\t\t\t\telse if (commandLine.hasOption(CowsayCli.Opt.LIST_COWS.toString())) {", "\t\t\t\t\tif (commandLine.hasOption(CowsayCli.Opt.WRAP_AT.toString())) {", "\t\t\t\t\t\twordwrap = commandLine.getOptionValue(CowsayCli.Opt.WRAP_AT.toString());", "\t\t\t\t\telse if (commandLine.hasOption(CowsayCli.Opt.NOWRAP.toString())) {", "\t\t\t\t\tcowFace = getCowFaceByMode(commandLine);", "\t\t\t\t\tif (cowFace == null) {", "\t\t\t\t\t\tif (commandLine.hasOption(CowsayCli.Opt.COWFILE.toString())) {", "\t\t\t\t\t\t\tcowfileSpec = commandLine.getOptionValue(CowsayCli.Opt.COWFILE.toString());", "\t\t\t\t\t\tcowFace = getCowFace(commandLine);", "\t\t\t\t\tif (commandLine.hasOption(CowsayCli.Opt.THINK.toString())) {", "\t\t\t\t\t\tString moosages[] = commandLine.getArgs();", "\t\t\t\t\t\t\tString cow = CowFormatter.formatCow(cowTemplate, cowFace, message);", "\t\t\t\t\t\t\tcow = formatHtml(commandLine, cow, moosage, isThought);"], "think": ["private static String sayOrThink(final String[] args, final boolean think) {", "\t\t\tboolean isThought = think;", "\t\t\t\t\t\t\tMessage message = new Message(moosage, isThought);", "\t\t\t\t\t\t\t\tmessage.setWordwrap(wordwrap);", "\t\t\t\t\t\t\tString cow = CowFormatter.formatCow(cowTemplate, cowFace, message);", "\t\t\t\t\t\t\tcow = formatHtml(commandLine, cow, moosage, isThought);", "\t\t\t\t\t\t\treturn cow;"]}
{"commandLine": ["private static String formatHtml(final CommandLine commandLine, final String plainCow, final String moosage,", "\t\tif (commandLine.hasOption(CowsayCli.Opt.HTML.toString())) {", "\t\t\tif (commandLine.hasOption(CowsayCli.Opt.ALT.toString())) {", "\t\t\t\talt = commandLine.getOptionValue(CowsayCli.Opt.ALT.toString());"], "plainCow": ["private static String formatHtml(final CommandLine commandLine, final String plainCow, final String moosage,", "\t\tString cow = plainCow;", "\t\t\tcow = StringEscapeUtils.escapeHtml4(cow);", "\t\t\tcow = \"<figure><pre>\" + cow + \"</pre><figcaption style=\\\"left:-999px; position:absolute\\\">\";", "\t\treturn cow;"], "moosage": ["private static String formatHtml(final CommandLine commandLine, final String plainCow, final String moosage,", "\t\t\tString escaped = StringEscapeUtils.escapeHtml4(moosage);", "\t\t\tcow += String.format(alt, escaped);"], "isThought": ["\t\t\t\t\t\t\t\t\t final boolean isThought) {", "\t\t\t\talt = isThought ? I18n.getMessage(\"altthink\") : I18n.getMessage(\"altsay\");"]}
{"commandLine": ["private static CowFace getCowFaceByMode(final CommandLine commandLine) {", "\t\t\tif (commandLine.hasOption(mode)) {"]}
{"commandLine": ["private static CowFace getCowFace(final CommandLine commandLine) {", "\t\tif (commandLine.hasOption(CowsayCli.Opt.EYES.toString())) {", "\t\t\tcowFace.setEyes(commandLine.getOptionValue(CowsayCli.Opt.EYES.toString()));", "\t\tif (commandLine.hasOption(CowsayCli.Opt.TONGUE.toString())) {", "\t\t\tcowFace.setTongue(commandLine.getOptionValue(CowsayCli.Opt.TONGUE.toString()));"]}
{"cow": ["private static String extractCowTemplate(final String cow) throws CowParseException {", "\t\tMatcher matcher = COWSTART_RE.matcher(cow);", "\t\tif (matcher.find(0)) {", "\t\t\tString result = matcher.replaceFirst(\"\");", "\t\t\tthrow new CowParseException(\"Could not parse cow \" + cow);"]}
{"cowfileSpec": ["public static String load(final String cowfileSpec) {", "\t\tString effectiveCowfileSpec = (cowfileSpec != null) ? cowfileSpec.trim() : DEFAULT_COW;"]}
{"cowInputStream": ["private static String cowInputStreamToString(final InputStream cowInputStream) {", "\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(cowInputStream));", "\t\t\twhile ((line = reader.readLine()) != null) {", "\t\t\t\tsb.append(line);", "\t\t\treader.close();", "\t\t\tif (cowInputStream != null) {", "\t\t\t\t\tcowInputStream.close();"]}
{"path": ["private static InputStream getCowFromPath(final String path) {", "\t\t\tFile cowfile = new File(cwd, path);", "\t\t\tif (isCowfile(cowfile)) {", "\t\t\t\treturn cowfileToCowInputStream(cowfile);", "\t\tFile cowfile = new File(path);", "\t\tif (isCowfile(cowfile)) {", "\t\t\treturn cowfileToCowInputStream(cowfile);"]}
{"cowName": ["private static InputStream getCowFromCowPath(final String cowName) {", "\t\t\t\t\tFile cowfile = getCowfile(path, cowName);", "\t\t\t\t\tif (cowfile != null) {", "\t\t\t\t\t\treturn cowfileToCowInputStream(cowfile);", "\t\treturn getCowFromResources(cowName);"]}
{"cowfile": ["private static boolean isCowfile(final File cowfile) {", "\t\tif (cowfile != null && cowfile.exists()) {", "\t\t\treturn cowfile.getName().endsWith(COWFILE_EXT);"]}
{"cowfile": ["private static InputStream cowfileToCowInputStream(final File cowfile) {", "\t\t\tcowInputStream = new FileInputStream(cowfile);", "\t\treturn cowInputStream;"]}
{"folder": ["private static File getCowfile(final String folder, final String cowName) {", "\t\tFile[] cowfiles = getCowFiles(folder);", "\t\tfor (File cowfile : cowfiles) {", "\t\t\tif (cowfile.getName().equals(cowName)) {", "\t\t\t\treturn cowfile;"], "cowName": ["private static File getCowfile(final String folder, final String cowName) {", "\t\t\tif (cowfile.getName().equals(cowName)) {"]}
{"folder": ["private static File[] getCowFiles(final String folder) {", "\t\tFile dir = new File(folder);", "\t\tfiles = dir.listFiles(new FilenameFilter() {", "\t\t\tpublic boolean accept(final File dir, final String name) {"]}
{"mode": ["protected static CowFace getByMode(final String mode) {", "\t\tif (mode != null) {", "\t\t\treturn COW_MODES.get(mode);"]}
{"eyes": ["public final void setEyes(final String eyes) {", "\t\tif (eyes != null && eyes.length() > 0) {", "\t\t\tif (eyes.length() > 2) {", "\t\t\t\tthis.eyes = eyes.substring(0, 2);", "\t\t\t\tthis.eyes = eyes;"]}
{"tongue": ["public final void setTongue(final String tongue) {", "\t\tif (tongue != null && tongue.length() > 0) {", "\t\t\tif (tongue.length() > 2) {", "\t\t\t\tthis.tongue = tongue.substring(0, 2);", "\t\t\t\tthis.tongue = tongue;"]}
{"mode": ["public static final boolean isKnownMode(final String mode) {", "\t\treturn modes.contains(mode);"]}
{"argv": ["public static CommandLine parseCmdArgs(final String[] argv) {", "\t\t\tCommandLine parsed = cmdLineParser.parse(options, argv, true);", "\t\t\tif (parsed.hasOption(Opt.LANG.text)) {", "\t\t\t\tString language = parsed.getOptionValue(Opt.LANG.text);", "\t\t\treturn parsed;"]}
{"Result": "Method without Parameter"}
{"bubble": ["private static String formatBubble(final BubbleWrap bubble, final String message, final int longestLine) {", "\t\tsb.append(bubble.buildTop(longestLine));", "\t\t\tsb.append(bubble.formatMultiOpen(lines[0], longestLine));", "\t\t\t\tsb.append(bubble.formatMultiMid(lines[i], longestLine));", "\t\t\tsb.append(bubble.formatMultiEnd(lines[(lines.length - 1)], longestLine));", "\t\t\tsb.append(bubble.formatSingle(lines[0]));", "\t\tsb.append(bubble.buildBottom(longestLine));"], "message": ["private static String formatBubble(final BubbleWrap bubble, final String message, final int longestLine) {", "\t\tString[] lines = message.split(newLine);"], "longestLine": ["private static String formatBubble(final BubbleWrap bubble, final String message, final int longestLine) {", "\t\tsb.append(bubble.buildTop(longestLine));", "\t\t\tsb.append(bubble.formatMultiOpen(lines[0], longestLine));", "\t\t\t\tsb.append(bubble.formatMultiMid(lines[i], longestLine));", "\t\t\tsb.append(bubble.formatMultiEnd(lines[(lines.length - 1)], longestLine));", "\t\tsb.append(bubble.buildBottom(longestLine));"]}
{"message": ["private String wrapMessage(final String message) {", "\t\t\treturn message;", "\t\tString[] lines = message.split(newLine);"]}
{"message": ["private String formatMessage(final String message) {", "\t\tif (message != null) {", "\t\t\tresult = wrapMessage(message);", "\t\t\tint longestLine = getLongestLineLen(result);", "\t\t\t\tresult = Bubble.formatSpeech(result, longestLine);", "\t\t\t\tresult = Bubble.formatThought(result, longestLine);", "\t\t\treturn result;"]}
{"wordwrap": ["public void setWordwrap(final String wordwrap) {", "\t\t\tint ww = Integer.parseInt(wordwrap);", "\t\t\tif (ww >= 0) {", "\t\t\t\tthis.wordwrap = ww;"]}
{"message": ["private static int getLongestLineLen(final String message) {", "\t\tString[] lines = message.split(newLine);"]}
{"message": ["public boolean log(String message) {", "        if (message == null) return false;", "            ok = loggly.log(token, tags, message).isExecuted();"]}
{"message": ["public void log(String message, final Callback callback) {", "        if (message == null) return;", "                message,"], "callback": ["public void log(String message, final Callback callback) {", "                        callback.success();", "                        callback.failure(throwable.getMessage());"]}
{"messages": ["public void logBulk(Collection<String> messages, final Callback callback) {", "        if (messages == null) return;", "        String parcel = joinStrings(messages);", "        if (parcel.isEmpty()) return;", "                parcel,"], "callback": ["public void logBulk(Collection<String> messages, final Callback callback) {", "                        callback.success();", "                        callback.failure(throwable.getMessage());"]}
{"messages": ["private String joinStrings(Collection<String> messages) {", "        for (String s : messages) {", "            if (s == null || s.isEmpty()) {", "            b.append(s.replaceAll(\"[\\r\\n]\", \"\\r\")).append('\\n');"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"name": ["public Schema getSchema(String name) throws NoRowException, SQLException {", "\t\tSchema schema = getSchemas().get(name);", "\t\tif(schema==null) throw new NoRowException(\"name=\" + name);", "\t\treturn schema;"]}
{"sce": ["\tpublic void contextInitialized(ServletContextEvent sce) {", "\t\t\t\tservletContext = sce.getServletContext();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"name": ["public Table getTable(String name) throws NoRowException, SQLException {", "\t\tTable table = getTables().get(name);", "\t\tif(table==null) throw new NoRowException();", "\t\treturn table;"]}
{"out": ["private void writeToImpl(Writer out, long writeStart, long writeEnd) throws IOException {", "\t\t\t\t\t\tout.write(chars, 0, blockSize>>1);"], "writeStart": ["private void writeToImpl(Writer out, long writeStart, long writeEnd) throws IOException {", "\t\t\t\t\tlong index = writeStart;", "\t\t\t\t\traf.seek(index<<1);", "\t\t\t\t\twhile(index<writeEnd) {", "\t\t\t\t\t\tlong blockSizeLong = (writeEnd - index)<<1;", "\t\t\t\t\t\tint blockSize = blockSizeLong > BufferManager.BUFFER_SIZE ? BufferManager.BUFFER_SIZE : (int)blockSizeLong;", "\t\t\t\t\t\tassert (blockSize&1) == 0 : \"Must be an even number for UTF-16 conversion\";", "\t\t\t\t\t\traf.readFully(bytes, 0, blockSize);", "\t\t\t\t\t\t\tbpos<blockSize;", "\t\t\t\t\t\tout.write(chars, 0, blockSize>>1);", "\t\t\t\t\t\tindex += blockSize>>1;"], "writeEnd": ["private void writeToImpl(Writer out, long writeStart, long writeEnd) throws IOException {", "\t\t\t\t\twhile(index<writeEnd) {", "\t\t\t\t\t\tlong blockSizeLong = (writeEnd - index)<<1;", "\t\t\t\t\t\tint blockSize = blockSizeLong > BufferManager.BUFFER_SIZE ? BufferManager.BUFFER_SIZE : (int)blockSizeLong;", "\t\t\t\t\t\tassert (blockSize&1) == 0 : \"Must be an even number for UTF-16 conversion\";", "\t\t\t\t\t\traf.readFully(bytes, 0, blockSize);", "\t\t\t\t\t\t\tbpos<blockSize;", "\t\t\t\t\t\tout.write(chars, 0, blockSize>>1);", "\t\t\t\t\t\tindex += blockSize>>1;"]}
{"Result": "Method without Parameter"}
{"name": ["public Catalog getCatalog(String name) throws NoRowException, SQLException {", "\t\tCatalog catalog = getCatalogs().get(name);", "\t\tif(catalog==null) throw new NoRowException();", "\t\treturn catalog;"]}
{"additional": ["private char[] getBuffer(int additional) throws IOException {", "\t\tlong newLen = (long)length + additional;", "\t\tif(newLen > MAX_LENGTH) throw new IOException(\"Maximum buffer length is \" + MAX_LENGTH + \", \" + newLen + \" requested\");", "\t\tif(newLen > bufLen) {", "\t\t\twhile(newBufLen < newLen) {"]}
{"encoder": ["private void log(Encoder encoder) throws IOException {", "\t\tif(encoder==null) log.write(\"null\");", "\t\t\tString className = encoder.getClass().getName();"]}
{"writer": ["private void log(Writer writer) throws IOException {", "\t\tif(writer==null) {", "\t\t} else if(writer instanceof LoggingWriter) {", "\t\t\tLoggingWriter loggingWriter = (LoggingWriter)writer;", "\t\t\tlog.write(Long.toString(loggingWriter.getId()));", "\t\t} else if(writer instanceof EncoderWriter) {", "\t\t\tEncoderWriter encoderWriter = (EncoderWriter)writer;", "\t\t\tlog(encoderWriter.getEncoder());", "\t\t\tlog(encoderWriter.getOut());", "\t\t\tString classname = writer.getClass().getName();"]}
{"file": ["    final F file)", "    return LexicalPosition.of(0, 0, Optional.of(file));"]}
{"segmentIndex": ["private void append(int segmentIndex, int off, int len, StringBuilder buffer) {", "\t\tswitch(segmentTypes[segmentIndex]) {", "\t\t\t\t\t(String)segmentValues[segmentIndex],", "\t\t\t\tbuffer.append(((Character)segmentValues[segmentIndex]).charValue());"], "off": ["private void append(int segmentIndex, int off, int len, StringBuilder buffer) {", "\t\t\t\t\toff,", "\t\t\t\t\toff + len", "\t\t\t\tassert off==0;", "\t\t\t\tassert off==0;", "\t\t\t\tassert off==0;", "\t\t\t\tassert off==0;"], "len": ["private void append(int segmentIndex, int off, int len, StringBuilder buffer) {", "\t\t\t\t\toff + len", "\t\t\t\tassert len==1;", "\t\t\t\tassert len==1;", "\t\t\t\tassert len==1;", "\t\t\t\tassert len==1;"], "buffer": ["private void append(int segmentIndex, int off, int len, StringBuilder buffer) {", "\t\t\t\tbuffer.append(", "\t\t\t\tbuffer.append('\\n');", "\t\t\t\tbuffer.append('\"');", "\t\t\t\tbuffer.append('\\'');", "\t\t\t\tbuffer.append(((Character)segmentValues[segmentIndex]).charValue());"]}
{"segmentIndex": ["private void writeSegment(int segmentIndex, int off, int len, Encoder encoder, Writer out) throws IOException {", "\t\tswitch(segmentTypes[segmentIndex]) {", "\t\t\t\t\t(String)segmentValues[segmentIndex],", "\t\t\t\tencoder.write((Character)segmentValues[segmentIndex], out);"], "off": ["private void writeSegment(int segmentIndex, int off, int len, Encoder encoder, Writer out) throws IOException {", "\t\t\t\t\toff,", "\t\t\t\tassert off==0;", "\t\t\t\tassert off==0;", "\t\t\t\tassert off==0;", "\t\t\t\tassert off==0;"], "len": ["private void writeSegment(int segmentIndex, int off, int len, Encoder encoder, Writer out) throws IOException {", "\t\t\t\t\tlen,", "\t\t\t\tassert len==1;", "\t\t\t\tassert len==1;", "\t\t\t\tassert len==1;", "\t\t\t\tassert len==1;"], "encoder": ["private void writeSegment(int segmentIndex, int off, int len, Encoder encoder, Writer out) throws IOException {", "\t\t\t\tencoder.write(", "\t\t\t\tencoder.write('\\n', out);", "\t\t\t\tencoder.write('\"', out);", "\t\t\t\tencoder.write('\\'', out);", "\t\t\t\tencoder.write((Character)segmentValues[segmentIndex], out);"], "out": ["private void writeSegment(int segmentIndex, int off, int len, Encoder encoder, Writer out) throws IOException {", "\t\t\t\t\tout", "\t\t\t\tencoder.write('\\n', out);", "\t\t\t\tencoder.write('\"', out);", "\t\t\t\tencoder.write('\\'', out);", "\t\t\t\tencoder.write((Character)segmentValues[segmentIndex], out);"]}
{"type": ["private static char charAt(byte type, Object value, int charIndex) {", "\t\tswitch(type) {"], "value": ["private static char charAt(byte type, Object value, int charIndex) {", "\t\t\t\treturn ((String)value).charAt(charIndex);", "\t\t\t\treturn (Character)value;"], "charIndex": ["private static char charAt(byte type, Object value, int charIndex) {", "\t\t\t\treturn ((String)value).charAt(charIndex);", "\t\t\t\tassert charIndex==0;", "\t\t\t\tassert charIndex==0;", "\t\t\t\tassert charIndex==0;", "\t\t\t\tassert charIndex==0;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"name": ["public Column getColumn(String name) throws NoRowException, SQLException {", "\t\tColumn column = getColumnMap().get(name);", "\t\tif(column==null) throw new NoRowException();", "\t\treturn column;"]}
{"Result": "Method without Parameter"}
{"ordinalPosition": ["public Column getColumn(int ordinalPosition) throws NoRowException, SQLException {", "\t\t\treturn getColumns().get(ordinalPosition-1);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"type": ["private void addSegment(byte type, Object value, int off, int len) {", "\t\tsegmentTypes[segmentCount] = type;"], "value": ["private void addSegment(byte type, Object value, int off, int len) {", "\t\tsegmentValues[segmentCount] = value;"], "off": ["private void addSegment(byte type, Object value, int off, int len) {", "\t\tsegmentOffsets[segmentCount] = off;"], "len": ["private void addSegment(byte type, Object value, int off, int len) {", "\t\tassert len>0 : \"Empty segments should never be added\";", "\t\tsegmentLengths[segmentCount++] = len;"]}
{"ch": ["private void log(char ch) throws IOException {", "\t\tif(ch=='\\t') log.write(\"'\\\\t'\");", "\t\telse if(ch=='\\b') log.write(\"'\\\\b'\");", "\t\telse if(ch=='\\n') log.write(\"'\\\\n'\");", "\t\telse if(ch=='\\r') log.write(\"'\\\\r'\");", "\t\telse if(ch=='\\f') log.write(\"'\\\\f'\");", "\t\telse if(ch=='\\'') log.write(\"'\\\\'\");", "\t\telse if(ch=='\\\\') log.write(\"'\\\\\\\\'\");", "\t\telse if(ch=='\"') log.write(\"'\\\\\\\"'\");", "\t\telse if(ch<' ') {", "\t\t\tString hex = Integer.toHexString(ch);", "\t\t\tfor(int l=hex.length(); l<4; l++) log.write('0');", "\t\t\tlog.write(hex);", "\t\t\tlog.write(ch);"]}
{"value": ["private void log(String value) throws IOException {", "\t\tif(value==null) {", "\t\t\tfor(int i=0, len=value.length(); i<len; i++) {", "\t\t\t\tchar ch = value.charAt(i);", "\t\t\t\tif(ch=='\\t') log.write(\"\\\\t\");", "\t\t\t\telse if(ch=='\\b') log.write(\"\\\\b\");", "\t\t\t\telse if(ch=='\\n') log.write(\"\\\\n\");", "\t\t\t\telse if(ch=='\\r') log.write(\"\\\\r\");", "\t\t\t\telse if(ch=='\\f') log.write(\"\\\\f\");", "\t\t\t\telse if(ch=='\\\\') log.write(\"\\\\\\\\\");", "\t\t\t\telse if(ch=='\"') log.write(\"\\\\\\\"\");", "\t\t\t\telse if(ch<' ') {", "\t\t\t\t\tString hex = Integer.toHexString(ch);", "\t\t\t\t\tfor(int l=hex.length(); l<4; l++) log.write('0');", "\t\t\t\t\tlog.write(hex);", "\t\t\t\t\tlog.write(ch);"]}
{"target": ["public static ContentValues putAll(ContentValues target, Object... values) {", "                target.putNull(key);", "                target.put(key, (String) val);", "                target.put(key, (Long) val);", "                target.put(key, (Integer) val);", "                target.put(key, (Boolean) val);", "                target.put(key, (Double) val);", "                target.put(key, (Float) val);", "                target.put(key, (byte[]) val);", "                target.put(key, (Byte) val);", "                target.put(key, (Short) val);"]}
{"map": ["public void moveCameraToLastLocation(GoogleMap map, float zoom) {", "        mProvider.getLastLocation().subscribe(location -> map.moveCamera(CameraUpdateFactory"], "zoom": ["public void moveCameraToLastLocation(GoogleMap map, float zoom) {", "                .newLatLngZoom(new LatLng(location.getLatitude(), location.getLongitude()), zoom)));"]}
{"map": ["public void animateCameraToIncludePosition(GoogleMap map, LatLng position, long delay) {", "        if (!map.getProjection().getVisibleRegion().latLngBounds.contains(position)) {", "                        .postDelayed(() -> doAnimateCameraToIncludePosition(map, position), delay);", "                doAnimateCameraToIncludePosition(map, position);"], "position": ["public void animateCameraToIncludePosition(GoogleMap map, LatLng position, long delay) {", "        if (!map.getProjection().getVisibleRegion().latLngBounds.contains(position)) {", "                        .postDelayed(() -> doAnimateCameraToIncludePosition(map, position), delay);", "                doAnimateCameraToIncludePosition(map, position);"], "delay": ["public void animateCameraToIncludePosition(GoogleMap map, LatLng position, long delay) {", "            if (delay > 0) {", "                        .postDelayed(() -> doAnimateCameraToIncludePosition(map, position), delay);"]}
{"circle": ["public static Animator circleToRect(View circle, View rect) {", "        return circleRect(circle, rect, true);"], "rect": ["public static Animator circleToRect(View circle, View rect) {", "        return circleRect(circle, rect, true);"]}
{"circle": ["public static Animator circleFromRect(View circle, View rect) {", "        return circleRect(circle, rect, false);"], "rect": ["public static Animator circleFromRect(View circle, View rect) {", "        return circleRect(circle, rect, false);"]}
{"context": ["public static Transition arcMotion(Context context) {", "            sArc = TransitionInflater.from(context).inflateTransition("]}
{"i": ["public static StyleSpan bold(int i) {", "        if (i < sBolds.size()) {", "            return sBolds.get(i);"]}
{"view": ["public static ViewPropertyAnimator scaleIn(View view) {", "        return scale(view, 1.0f, enterScreen(), R.integer.anim_duration_enter);"]}
{"view": ["public static ViewPropertyAnimator scaleOut(View view) {", "        return scale(view, 0.0f, exitScreen(), R.integer.anim_duration_exit);"]}
{"view": ["public static ViewPropertyAnimator scaleShowNext(ViewSwitcher view, Runnable endAction) {", "        return scale(view, view::showNext, endAction);"], "endAction": ["public static ViewPropertyAnimator scaleShowNext(ViewSwitcher view, Runnable endAction) {", "        return scale(view, view::showNext, endAction);"]}
{"context": ["public static int getCount(Context context, Uri uri) {", "        return Cursors.firstInt(context.getContentResolver().query(uri, proj, null, null, null));"], "uri": ["public static int getCount(Context context, Uri uri) {", "        return Cursors.firstInt(context.getContentResolver().query(uri, proj, null, null, null));"]}
{"address": ["public static String concatAddressLines(Address address, String delimiter) {", "        for (int i = 0, max = address.getMaxAddressLineIndex(); i <= max; i++) {", "            s.append(address.getAddressLine(i));"], "delimiter": ["public static String concatAddressLines(Address address, String delimiter) {", "                s.append(delimiter);"]}
{"client": ["public static GoogleApiClient connect(GoogleApiClient client, ConnectedListener connected,", "        client.registerConnectionCallbacks(new ConnectionListener(connected));", "        client.registerConnectionFailedListener(failed);", "        client.connect();", "        return client;"], "connected": ["public static GoogleApiClient connect(GoogleApiClient client, ConnectedListener connected,", "        client.registerConnectionCallbacks(new ConnectionListener(connected));"], "failed": ["                                          OnConnectionFailedListener failed) {", "        client.registerConnectionFailedListener(failed);"]}
{"fm": ["    private static FragmentTransaction transit(FragmentManager fm, int transit) {", "        return fm != null ? fm.beginTransaction().setTransition(transit) : null;"], "transit": ["    private static FragmentTransaction transit(FragmentManager fm, int transit) {"]}
{"Result": "Method without Parameter"}
{"listener": ["public static void setOnClickListeners(OnClickListener listener, View... views) {", "            view.setOnClickListener(listener);"]}
{"level": ["public static String getLevelName(int level) {", "        switch (level) {"]}
{"source": ["public static ActivityOptions makeScaleUpAnimation(View source) {", "                source, 0, 0, source.getWidth(), source.getHeight());"]}
{"view": ["public static void show(View view) {", "        view.postDelayed(() -> Managers.inputMethod(view.getContext()).showSoftInput(view, 0),"]}
{"view": ["public static void hide(View view) {", "        Managers.inputMethod(view.getContext()).hideSoftInputFromWindow(view.getWindowToken(), 0);"]}
{"cursor": ["public static boolean hasPosition(Cursor cursor, int position) {", "        return !cursor.isClosed() && position >= 0 && position < cursor.getCount();"], "position": ["public static boolean hasPosition(Cursor cursor, int position) {", "        return !cursor.isClosed() && position >= 0 && position < cursor.getCount();"]}
{"cursor": ["public static int count(Cursor cursor, boolean close) {", "        int count = cursor.getCount();", "        close(cursor, close);"], "close": ["public static int count(Cursor cursor, boolean close) {", "        close(cursor, close);"]}
{"cursor": ["public static int firstInt(Cursor cursor, boolean close) {", "        int i = cursor.moveToFirst() ? cursor.getInt(0) : Integer.MIN_VALUE;", "        close(cursor, close);"], "close": ["public static int firstInt(Cursor cursor, boolean close) {", "        close(cursor, close);"]}
{"cursor": ["public static long firstLong(Cursor cursor, boolean close) {", "        long l = cursor.moveToFirst() ? cursor.getLong(0) : Long.MIN_VALUE;", "        close(cursor, close);"], "close": ["public static long firstLong(Cursor cursor, boolean close) {", "        close(cursor, close);"]}
{"cursor": ["    public static String firstString(Cursor cursor, boolean close) {", "        String s = cursor.moveToFirst() ? cursor.getString(0) : null;", "        close(cursor, close);"], "close": ["    public static String firstString(Cursor cursor, boolean close) {", "        close(cursor, close);"]}
{"cursor": ["public static int[] allInts(Cursor cursor, boolean close) {", "        if (cursor.moveToFirst()) {", "            i = new int[cursor.getCount()];", "                i[cursor.getPosition()] = cursor.getInt(0);", "        close(cursor, close);"], "close": ["public static int[] allInts(Cursor cursor, boolean close) {", "        close(cursor, close);"]}
{"cursor": ["public static long[] allLongs(Cursor cursor, boolean close) {", "        if (cursor.moveToFirst()) {", "            l = new long[cursor.getCount()];", "                l[cursor.getPosition()] = cursor.getLong(0);", "        close(cursor, close);"], "close": ["public static long[] allLongs(Cursor cursor, boolean close) {", "        close(cursor, close);"]}
{"cursor": ["public static String[] allStrings(Cursor cursor, boolean close) {", "        if (cursor.moveToFirst()) {", "            s = new String[cursor.getCount()];", "                s[cursor.getPosition()] = cursor.getString(0);", "        close(cursor, close);"], "close": ["public static String[] allStrings(Cursor cursor, boolean close) {", "        close(cursor, close);"]}
{"view": ["    public static void load(ImageView view, Drawable placeholder, Uri load, boolean resize,", "        RequestCreator req = Picasso.with(view.getContext()).load(load).placeholder(placeholder);", "        req.into(view);"], "placeholder": ["    public static void load(ImageView view, Drawable placeholder, Uri load, boolean resize,", "        RequestCreator req = Picasso.with(view.getContext()).load(load).placeholder(placeholder);", "            req.fit().centerCrop(); // view width/height isn't available yet", "            req.transform(Transformations.circle());", "        req.into(view);"], "load": ["    public static void load(ImageView view, Drawable placeholder, Uri load, boolean resize,"], "resize": ["    public static void load(ImageView view, Drawable placeholder, Uri load, boolean resize,", "        if (resize) {"], "transform": ["                            String transform) {", "        if (TextUtils.equals(transform, \"circle\")) {", "            req.transform(Transformations.circle());"]}
{"view": ["public static int getOrientation(RecyclerView view) {", "        LayoutManager layout = view.getLayoutManager();"]}
{"view": ["public static int getSpanCount(RecyclerView view) {", "        LayoutManager layout = view.getLayoutManager();"]}
{"view": ["public static RelativeLayout.LayoutParams addRule(View view, int verb, int anchor) {", "        RelativeLayout.LayoutParams params = getParams(view);", "        params.addRule(verb, anchor);", "        view.requestLayout();", "        return params;"], "verb": ["public static RelativeLayout.LayoutParams addRule(View view, int verb, int anchor) {", "        params.addRule(verb, anchor);"], "anchor": ["public static RelativeLayout.LayoutParams addRule(View view, int verb, int anchor) {", "        params.addRule(verb, anchor);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"array": ["    public static <E> List<E> values(SparseArray<E> array) {", "        return (List<E>) values(array, null, null, null, null);"]}
{"array": ["    public static <E> List<E> values(LongSparseArray<E> array) {", "        return (List<E>) values(null, null, null, null, array);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"position": ["private void updateMatrix(int position, float offset) {", "            mMatrix.setTranslate(-mPageX * position - mPageX * offset,", "                    -mPageY * position - mPageY * offset);"], "offset": ["private void updateMatrix(int position, float offset) {", "            mMatrix.setTranslate(-mPageX * position - mPageX * offset,", "                    -mPageY * position - mPageY * offset);"]}
{"op": ["private int updDel(int op, Uri uri, ContentValues vals, String sel, String[] args) {", "        Sql sql = elements(op, uri, new String[]{\"rowid\"}, sel, args, null);", "        int rows = op == UPDATE ? db.update(sql.table(), vals, sql.sel(), sql.args())"], "uri": ["private int updDel(int op, Uri uri, ContentValues vals, String sel, String[] args) {", "        Sql sql = elements(op, uri, new String[]{\"rowid\"}, sel, args, null);", "                notifyChange(ContentUris.withAppendedId(sql.notifyUri(), id), uri);"], "vals": ["private int updDel(int op, Uri uri, ContentValues vals, String sel, String[] args) {", "        int rows = op == UPDATE ? db.update(sql.table(), vals, sql.sel(), sql.args())"], "sel": ["private int updDel(int op, Uri uri, ContentValues vals, String sel, String[] args) {", "        Sql sql = elements(op, uri, new String[]{\"rowid\"}, sel, args, null);", "        int rows = op == UPDATE ? db.update(sql.table(), vals, sql.sel(), sql.args())", "                : db.delete(sql.table(), !TextUtils.isEmpty(sql.sel()) ? sql.sel() : \"1\","], "args": ["private int updDel(int op, Uri uri, ContentValues vals, String sel, String[] args) {", "        Sql sql = elements(op, uri, new String[]{\"rowid\"}, sel, args, null);", "        int rows = op == UPDATE ? db.update(sql.table(), vals, sql.sel(), sql.args())", "                        sql.args());", "        if (rows > 0) {", "        return rows;"]}
{"op": ["private Sql elements(int op, Uri uri, String[] proj, String sel, String[] args, String order) {", "        if (sql.notifyUri() == null && op != SELECT) {", "        if (op != INSERT) { // run the query and return the cursor"], "uri": ["private Sql elements(int op, Uri uri, String[] proj, String sel, String[] args, String order) {", "        MutableSql sql = translate(uri);", "        if (sql == null) {", "        if (sql.table() == null) {", "            sql.table(uri.getPathSegments().get(0));", "        if (sql.notifyUri() == null && op != SELECT) {", "            sql.notifyUri(uri.buildUpon().path(sql.table()).clearQuery().fragment(null).build());", "            String from = sql.join() != null ? sql.table() + ' ' + sql.join() : sql.table();", "            if ((sql.sel() == null || sql.args() == null) && uri.getPathSegments().size() == 2) {", "                    long id = ContentUris.parseId(uri);", "                    if (id > 0) {", "                        if (sql.sel() == null) {", "                            sql.sel(\"rowid = ?\");", "                        if (sql.args() == null) {", "                            sql.args(String.valueOf(id));", "                sql.sel(DatabaseUtils.concatenateWhere(sql.sel(), sel));", "                sql.args(DatabaseUtils.appendSelectionArgs(sql.args(), args));", "            String groupBy = uri.getQueryParameter(GROUP_BY);", "                sql.groupBy(groupBy);", "            String having = uri.getQueryParameter(HAVING);", "                sql.having(having);", "                sql.orderBy(order);", "            String limit = uri.getQueryParameter(LIMIT);", "                sql.limit(limit);", "                    .query(from, proj, sql.sel(), sql.args(), sql.groupBy(), sql.having(),", "                            sql.orderBy(), sql.limit());", "        return sql;"], "proj": ["private Sql elements(int op, Uri uri, String[] proj, String sel, String[] args, String order) {", "                    .query(from, proj, sql.sel(), sql.args(), sql.groupBy(), sql.having(),"], "sel": ["private Sql elements(int op, Uri uri, String[] proj, String sel, String[] args, String order) {", "            if ((sql.sel() == null || sql.args() == null) && uri.getPathSegments().size() == 2) {", "                        if (sql.sel() == null) {", "                            sql.sel(\"rowid = ?\");", "            if (sel != null) { // append caller values", "                sql.sel(DatabaseUtils.concatenateWhere(sql.sel(), sel));", "                    .query(from, proj, sql.sel(), sql.args(), sql.groupBy(), sql.having(),"], "args": ["private Sql elements(int op, Uri uri, String[] proj, String sel, String[] args, String order) {", "            if ((sql.sel() == null || sql.args() == null) && uri.getPathSegments().size() == 2) {", "                        if (sql.args() == null) {", "                            sql.args(String.valueOf(id));", "            if (args != null) {", "                sql.args(DatabaseUtils.appendSelectionArgs(sql.args(), args));", "                    .query(from, proj, sql.sel(), sql.args(), sql.groupBy(), sql.having(),"], "order": ["private Sql elements(int op, Uri uri, String[] proj, String sel, String[] args, String order) {", "            if (order != null) {", "                sql.orderBy(order);"]}
{"width": ["public static int getByteCount(int width, int height, Config config) {", "        return width * height * bytes;"], "height": ["public static int getByteCount(int width, int height, Config config) {", "        return width * height * bytes;"], "config": ["public static int getByteCount(int width, int height, Config config) {", "        switch (config) {"]}
{"source": ["    public static Bitmap mutable(Bitmap source) {", "        if (source.isMutable()) {", "            return source;", "        Config config = source.getConfig();", "        Bitmap bm = source.copy(config != null ? config : ARGB_8888, true);", "            source.recycle();"]}
{"context": ["public static boolean hasActivity(Context context, Intent intent) {", "        return context.getPackageManager().resolveActivity(intent, MATCH_DEFAULT_ONLY) != null;"], "intent": ["public static boolean hasActivity(Context context, Intent intent) {", "        return context.getPackageManager().resolveActivity(intent, MATCH_DEFAULT_ONLY) != null;"]}
{"to": ["public static Intent mailto(List<String> to, List<String> cc, List<String> bcc, String subject,", "        return new Intent(ACTION_SENDTO, Uris.mailto(to, cc, bcc, subject, body));"], "cc": ["public static Intent mailto(List<String> to, List<String> cc, List<String> bcc, String subject,", "        return new Intent(ACTION_SENDTO, Uris.mailto(to, cc, bcc, subject, body));"], "bcc": ["public static Intent mailto(List<String> to, List<String> cc, List<String> bcc, String subject,", "        return new Intent(ACTION_SENDTO, Uris.mailto(to, cc, bcc, subject, body));"], "subject": ["public static Intent mailto(List<String> to, List<String> cc, List<String> bcc, String subject,", "        return new Intent(ACTION_SENDTO, Uris.mailto(to, cc, bcc, subject, body));"], "body": ["                                String body) {", "        return new Intent(ACTION_SENDTO, Uris.mailto(to, cc, bcc, subject, body));"]}
{"Result": "Method without Parameter"}
{"pane": ["    public <T extends Fragment> T findFragmentByPane(@IntRange(from = 1, to = 2) int pane) {", "        String tag = Elements.get(sPanes, pane - 1);"]}
{"key1": ["public static Bundle of(String key1, int value1, String key2, int value2) {", "        b.putInt(key1, value1);"], "value1": ["public static Bundle of(String key1, int value1, String key2, int value2) {", "        b.putInt(key1, value1);"], "key2": ["public static Bundle of(String key1, int value1, String key2, int value2) {", "        b.putInt(key2, value2);"], "value2": ["public static Bundle of(String key1, int value1, String key2, int value2) {", "        b.putInt(key2, value2);"]}
{"context": ["public static Intent newIntent(Context context, String action, Uri data, ContentValues values) {", "        return newIntent(context, action, data, values, null, null);"], "action": ["public static Intent newIntent(Context context, String action, Uri data, ContentValues values) {", "        return newIntent(context, action, data, values, null, null);"], "data": ["public static Intent newIntent(Context context, String action, Uri data, ContentValues values) {", "        return newIntent(context, action, data, values, null, null);"], "values": ["public static Intent newIntent(Context context, String action, Uri data, ContentValues values) {", "        return newIntent(context, action, data, values, null, null);"]}
{"context": ["public static Intent newUpdateIntent(Context context, Uri data, ContentValues values,", "        return newIntent(context, ACTION_EDIT, data, values, selection, selectionArgs);"], "data": ["public static Intent newUpdateIntent(Context context, Uri data, ContentValues values,", "        return newIntent(context, ACTION_EDIT, data, values, selection, selectionArgs);"], "values": ["public static Intent newUpdateIntent(Context context, Uri data, ContentValues values,", "        return newIntent(context, ACTION_EDIT, data, values, selection, selectionArgs);"], "selection": ["                                         String selection, String[] selectionArgs) {", "        return newIntent(context, ACTION_EDIT, data, values, selection, selectionArgs);"], "selectionArgs": ["                                         String selection, String[] selectionArgs) {", "        return newIntent(context, ACTION_EDIT, data, values, selection, selectionArgs);"]}
{"context": ["public static Intent newDeleteIntent(Context context, Uri data) {", "        return newIntent(context, ACTION_DELETE, data, null, null, null);"], "data": ["public static Intent newDeleteIntent(Context context, Uri data) {", "        return newIntent(context, ACTION_DELETE, data, null, null, null);"]}
{"context": ["public static Intent newDeleteIntent(Context context, Uri data, String selection,", "        return newIntent(context, ACTION_DELETE, data, null, selection, selectionArgs);"], "data": ["public static Intent newDeleteIntent(Context context, Uri data, String selection,", "        return newIntent(context, ACTION_DELETE, data, null, selection, selectionArgs);"], "selection": ["public static Intent newDeleteIntent(Context context, Uri data, String selection,", "        return newIntent(context, ACTION_DELETE, data, null, selection, selectionArgs);"], "selectionArgs": ["                                         String[] selectionArgs) {", "        return newIntent(context, ACTION_DELETE, data, null, selection, selectionArgs);"]}
{"context": ["public static int getActionBarSize(Context context) {", "        TypedArray a = context.obtainStyledAttributes(sActionBarSize);"]}
{"context": ["    public static Drawable getActionBarBackground(Context context) {", "        TypedArray a = context.obtainStyledAttributes(attrs);", "            a = context.obtainStyledAttributes(id, attrs);"]}
{"context": ["public static boolean isConnected(Context context) {", "        NetworkInfo info = Managers.connectivity(context).getActiveNetworkInfo();"]}
{"diffs": ["public void diff_cleanupEfficiency(LinkedList<Diff> diffs) {", "    if (diffs.isEmpty()) {", "    ListIterator<Diff> pointer = diffs.listIterator();", "      diff_cleanupMerge(diffs);"]}
{"text1": ["public LinkedList<Patch> patch_make(String text1, LinkedList<Diff> diffs) {", "    if (text1 == null || diffs == null) {", "    String prepatch_text = text1;", "    String postpatch_text = text1;", "        postpatch_text = postpatch_text.substring(0, char_count2)", "            + aDiff.text + postpatch_text.substring(char_count2);", "        postpatch_text = postpatch_text.substring(0, char_count2)", "            + postpatch_text.substring(char_count2 + aDiff.text.length());", "            patch_addContext(patch, prepatch_text);", "            prepatch_text = postpatch_text;", "      patch_addContext(patch, prepatch_text);"], "diffs": ["public LinkedList<Patch> patch_make(String text1, LinkedList<Diff> diffs) {", "    if (text1 == null || diffs == null) {", "    if (diffs.isEmpty()) {", "    for (Diff aDiff : diffs) {", "      if (patch.diffs.isEmpty() && aDiff.operation != Operation.EQUAL) {", "        patch.start1 = char_count1;", "        patch.start2 = char_count2;", "      switch (aDiff.operation) {", "        patch.diffs.add(aDiff);", "        patch.length2 += aDiff.text.length();", "        postpatch_text = postpatch_text.substring(0, char_count2)", "            + aDiff.text + postpatch_text.substring(char_count2);", "        patch.length1 += aDiff.text.length();", "        patch.diffs.add(aDiff);", "        postpatch_text = postpatch_text.substring(0, char_count2)", "            + postpatch_text.substring(char_count2 + aDiff.text.length());", "        if (aDiff.text.length() <= 2 * Patch_Margin", "            && !patch.diffs.isEmpty() && aDiff != diffs.getLast()) {", "          patch.diffs.add(aDiff);", "          patch.length1 += aDiff.text.length();", "          patch.length2 += aDiff.text.length();", "        if (aDiff.text.length() >= 2 * Patch_Margin) {", "          if (!patch.diffs.isEmpty()) {", "            patch_addContext(patch, prepatch_text);", "            patches.add(patch);", "            prepatch_text = postpatch_text;", "            char_count1 = char_count2;", "      if (aDiff.operation != Operation.INSERT) {", "        char_count1 += aDiff.text.length();", "      if (aDiff.operation != Operation.DELETE) {", "        char_count2 += aDiff.text.length();", "    if (!patch.diffs.isEmpty()) {", "      patch_addContext(patch, prepatch_text);", "      patches.add(patch);"]}
{"function": ["    public <R> Option<R> flatMap(ThrowableFunction1<T, Option<R>> function) {", "            return function.apply(value);"]}
{"soapMessage": ["String convertSoapMessageAsString(SOAPMessage soapMessage) {", "\t\tif (soapMessage == null) {", "\t\t\tsoapMessage.writeTo(os);", "\t\t\treturn new String(os.toByteArray(), determineMessageEncoding(soapMessage));", "\t\t\tlogger.error(\"Couldn't create string representation of soapMessage: \" + soapMessage.toString());"]}
{"filer": ["protected static synchronized FileObjectWrapper getOrCreateProfileProperties(final Filer filer, String fileName) throws IOException {", "\t\t\tfileObject = new FileObjectWrapper(filer.createResource(StandardLocation.SOURCE_OUTPUT, \"\", fileName, null));"], "fileName": ["protected static synchronized FileObjectWrapper getOrCreateProfileProperties(final Filer filer, String fileName) throws IOException {", "\t\tFileObjectWrapper fileObject = traceeProfileProperties.get(fileName);", "\t\tif (fileObject == null) {", "\t\t\tfileObject = new FileObjectWrapper(filer.createResource(StandardLocation.SOURCE_OUTPUT, \"\", fileName, null));", "\t\t\ttraceeProfileProperties.put(fileName, fileObject);", "\t\treturn fileObject;"]}
{"element": ["protected boolean isValidMethod(Element element) {", "        if (element.getKind() != ElementKind.METHOD) {", "            error(element, \"Element %s annotated with annotation %s must be a method\", element.getSimpleName(),", "        if (!element.getModifiers().contains(Modifier.PUBLIC)) {", "            error(element, \"Method %s annotated with annotation %s must be public\", element.getSimpleName(),", "        if (element.getModifiers().contains(Modifier.ABSTRACT)) {", "            error(element, \"Method %s annotated with annotation %s must not be abstract\", element.getSimpleName(),", "        if (element.getModifiers().contains(Modifier.STATIC)) {", "            error(element, \"Method %s annotated with annotation %s must not be static\", element.getSimpleName(),"]}
{"executableElement": ["protected boolean isGetterMethod(ExecutableElement executableElement) {", "        TypeMirror returnTypeMirror = executableElement.getReturnType();", "            error(executableElement, \"method %s must have a non void return type\", executableElement.getSimpleName().toString());", "        List parameters = executableElement.getParameters();", "            error(executableElement, \"method %s must have no parameters \", executableElement.getSimpleName().toString());"]}
{"propertyKey": ["public Boolean getPropertyValue(final String propertyKey) {", "\t\tif (propertyKey == null) {", "\t\t\tBoolean manualOverrideCheck = toTraceeContextStringRepresentationBuilder.getManualContextOverrides().get(propertyKey);", "\t\t\tif (manualOverrideCheck != null) {", "\t\t\t\treturn manualOverrideCheck;", "\t\t\tString value = profileProperties.getProperty(propertyKey);", "\t\t\tif (value != null) {", "\t\t\t\treturn Boolean.valueOf(value);"]}
{"typeElement": ["protected boolean checkIfClassHasNoargsConstructor(TypeElement typeElement) {", "        for (Element child : typeElement.getEnclosedElements()) {", "            if (ElementKind.CONSTRUCTOR.equals(child.getKind())) {", "                ExecutableElement constructor = (ExecutableElement) child;", "                if (constructor.getParameters().size() == 0) {"]}
{"instance": ["public static <T extends Annotation> T getAnnotationFromType(final Object instance, Class<T> annotation) {", "        if (instance == null || annotation == null) {", "        return instance.getClass().getAnnotation(annotation);"], "annotation": ["public static <T extends Annotation> T getAnnotationFromType(final Object instance, Class<T> annotation) {", "        if (instance == null || annotation == null) {", "        return instance.getClass().getAnnotation(annotation);"]}
{"method": ["public static boolean checkMethodHasNonVoidReturnType(final Method method) {", "        if (method == null) {", "            return !(Void.TYPE == method.getReturnType());"]}
{"stringBuilder": ["public boolean apply(final StringBuilder stringBuilder, final OutputStyle outputStyle, final OutputElement outputElement) {", "                result = handleCollectionType(stringBuilder, outputStyle, outputElement);", "                    result = handleTraceeContextprovider(stringBuilder, outputStyle, outputElement);", "                    result = handleComplexType(stringBuilder, outputStyle, outputElement);"], "outputStyle": ["public boolean apply(final StringBuilder stringBuilder, final OutputStyle outputStyle, final OutputElement outputElement) {", "                result = handleCollectionType(stringBuilder, outputStyle, outputElement);", "                    result = handleTraceeContextprovider(stringBuilder, outputStyle, outputElement);", "                    result = handleComplexType(stringBuilder, outputStyle, outputElement);"], "outputElement": ["public boolean apply(final StringBuilder stringBuilder, final OutputStyle outputStyle, final OutputElement outputElement) {", "        if (outputElement != null) {", "            if (OutputElementType.COLLECTION.equals(outputElement.getOutputElementType())) {", "                result = handleCollectionType(stringBuilder, outputStyle, outputElement);", "            } else if (OutputElementType.COMPLEX.equals(outputElement.getOutputElementType())) {", "                if (TraceeContextLogAnnotationUtilities.getAnnotationFromType(outputElement.getEncapsulatedInstance()) != null) {", "                    result = handleTraceeContextprovider(stringBuilder, outputStyle, outputElement);", "                    result = handleComplexType(stringBuilder, outputStyle, outputElement);", "        return result;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"connectorOutputProvider": ["final void sendErrorReportToConnectors(ConnectorOutputProvider connectorOutputProvider) {", "            connector.sendErrorReport(connectorOutputProvider);"]}
{"Result": "Method without Parameter"}
{"connectorName": ["final Map<String, String> getPropertiesForConnectorConfigurationName(final String connectorName) {", "        final String patternString = String.format(CONNECTOR_PROPERTY_GRABBER_PATTERN, connectorName);", "        final Pattern propertyGrabPattern = Pattern.compile(patternString);", "            final Matcher matcher = propertyGrabPattern.matcher(key);", "            if (value != null && matcher.matches() && matcher.groupCount() > 0) {", "                final String propertyName = matcher.group(1);", "                propertyMap.put(propertyName, value.toString());"]}
{"connectorConfigurationName": ["final Connector createConnector(final String connectorConfigurationName) {", "        Map<String, String> propertyMap = this.getPropertiesForConnectorConfigurationName(connectorConfigurationName);", "        String type = propertyMap.get(TraceeContextLoggerConstants.SYSTEM_PROPERTY_CONTEXT_LOGGER_CONNECTOR_TYPE);", "            connector.init(propertyMap);", "            LOGGER.error(\"An error occurred while creating connector with name '\" + connectorConfigurationName + \"' of type '\" + type + \"'\", e);"]}
{"connectorClass": ["private boolean isConnectorConfigured(Class connectorClass) {", "            if (connectorClass.isInstance(connector)) {"]}
{"method": ["boolean hasGetterPrefixInMethodName(Method method) {", "        String methodName = method.getName();"]}
{"method": ["boolean isPublicNonStaticMethod(final Method method) {", "        int modifiers = method.getModifiers();"]}
{"type": ["boolean hasCompatibleReturnTypes(Class type, Method method) {", "        Field correspondingField = getCorrespondingField(type, method);"], "method": ["boolean hasCompatibleReturnTypes(Class type, Method method) {", "        Field correspondingField = getCorrespondingField(type, method);", "        return correspondingField != null && method.getReturnType().isAssignableFrom(correspondingField.getType());"]}
{"type": ["Field getCorrespondingField(Class type, Method method) {", "            return type.getDeclaredField(GetterUtilities.getFieldName(method));"], "method": ["Field getCorrespondingField(Class type, Method method) {", "            return type.getDeclaredField(GetterUtilities.getFieldName(method));"]}
{"methodName": ["public static boolean isGetterMethod(final String methodName) {", "        if (methodName != null) {", "                if (methodName.startsWith(prefix)) {"]}
{"input": ["static String capitalizeFirstCharOfString(final String input) {", "        if (input == null || input.length() == 0) {", "        else if (input.length() == 1) {", "            return input.toUpperCase();", "            return input.substring(0, 1).toUpperCase() + input.substring(1);"]}
{"input": ["static String decapitalizeFirstCharOfString(final String input) {", "        if (input == null || input.length() == 0) {", "        else if (input.length() == 1) {", "            return input.toLowerCase();", "            return input.substring(0, 1).toLowerCase() + input.substring(1);"]}
{"input": ["static String stripGetterPrefix(final String input) {", "        if (input != null) {", "                if (input.startsWith(prefix)) {", "                    return input.substring(prefix.length());", "        return input;"]}
{"proceedingJoinPoint": ["void sendErrorReportToConnectors(ProceedingJoinPoint proceedingJoinPoint, String annotatedId, Throwable e) {", "\t\tErrorMessage errorMessage = WatchdogUtils.getErrorMessageAnnotation(proceedingJoinPoint);", "\t\tif (errorMessage == null) {", "\t\t\t\t\t\t\tCoreImplicitContextProviders.TRACEE, WatchdogDataWrapper.wrap(annotatedId, proceedingJoinPoint), e);", "\t\t\t\t\t\t\tTraceeMessage.wrap(errorMessage.value()), CoreImplicitContextProviders.COMMON, CoreImplicitContextProviders.TRACEE,", "\t\t\t\t\t\t\tWatchdogDataWrapper.wrap(annotatedId, proceedingJoinPoint), e);"], "annotatedId": ["void sendErrorReportToConnectors(ProceedingJoinPoint proceedingJoinPoint, String annotatedId, Throwable e) {", "\t\t\t\t\t\t\tCoreImplicitContextProviders.TRACEE, WatchdogDataWrapper.wrap(annotatedId, proceedingJoinPoint), e);", "\t\t\t\t\t\t\tWatchdogDataWrapper.wrap(annotatedId, proceedingJoinPoint), e);"], "e": ["void sendErrorReportToConnectors(ProceedingJoinPoint proceedingJoinPoint, String annotatedId, Throwable e) {", "\t\t\t\t\t\t\tCoreImplicitContextProviders.TRACEE, WatchdogDataWrapper.wrap(annotatedId, proceedingJoinPoint), e);", "\t\t\t\t\t\t\tWatchdogDataWrapper.wrap(annotatedId, proceedingJoinPoint), e);"]}
{"contextLoggerConfiguration": ["public Object apply(ContextLoggerConfiguration contextLoggerConfiguration, Object instanceToWrap) {", "\t\t\treturn createInstance((Class) contextLoggerConfiguration.getImplicitContextProviderClass((ImplicitContext) instanceToWrap));", "\t\tClass matchingWrapperType = contextLoggerConfiguration.getContextProviderClass(instanceToWrap.getClass());", "\t\t\tfor (TypeToWrapper wrapper : contextLoggerConfiguration.getWrapperList()) {", "\t\t\t\tif (wrapper.getWrappedInstanceType().isAssignableFrom(instanceToWrap.getClass())) {", "\t\t\t\t\tmatchingWrapperType = wrapper.getWrapperType();", "\t\tif (matchingWrapperType != null) {", "\t\t\t\tWrappedContextData wrapperInstance = (WrappedContextData) createInstance(matchingWrapperType);", "\t\t\t\twrapperInstance.setContextData(instanceToWrap);", "\t\t\t\treturn wrapperInstance;"], "instanceToWrap": ["public Object apply(ContextLoggerConfiguration contextLoggerConfiguration, Object instanceToWrap) {", "\t\tif (IsImplicitContextEnumValuePredicate.getInstance().apply(instanceToWrap)) {", "\t\t\treturn createInstance((Class) contextLoggerConfiguration.getImplicitContextProviderClass((ImplicitContext) instanceToWrap));", "\t\tClass matchingWrapperType = contextLoggerConfiguration.getContextProviderClass(instanceToWrap.getClass());", "\t\t\t\tif (wrapper.getWrappedInstanceType().isAssignableFrom(instanceToWrap.getClass())) {", "\t\t\t\twrapperInstance.setContextData(instanceToWrap);", "\t\treturn instanceToWrap;"]}
{"type": ["protected Object createInstance(final Class type) {", "\t\tif (type != null) {", "\t\t\t\treturn type.newInstance();"]}
{"Result": "Method without Parameter"}
{"propertyFileName": ["public static Properties openProperties(final String propertyFileName) throws IOException {", "\t\tif (propertyFileName == null) {", "\t\t\tinputStream = Profile.class.getResourceAsStream(propertyFileName);", "\t\t\tif (inputStream != null) {", "\t\t\t\tproperties.load(inputStream);", "\t\t\tif (inputStream != null) {", "\t\t\t\tinputStream.close();"]}
{"contexts": ["private void fillManualContextOverrideMap(final String[] contexts, final boolean value) {", "\t\tif (contexts != null) {", "\t\t\tfor (String context : contexts) {", "\t\t\t\tif (!context.isEmpty()) {", "\t\t\t\t\tthis.manualContextOverrides.put(context, value);"], "value": ["private void fillManualContextOverrideMap(final String[] contexts, final boolean value) {", "\t\t\t\t\tthis.manualContextOverrides.put(context, value);"]}
{"Result": "Method without Parameter"}
{"proceedingJoinPoint": ["public static boolean checkIfMethodThrowsContainsPassedException(final ProceedingJoinPoint proceedingJoinPoint, Throwable thrownException) {", "        if (proceedingJoinPoint == null || thrownException == null) {", "        Class[] throwsClassesFromMethodSignature = getDefinedThrowsFromMethodSignature(proceedingJoinPoint);", "        return checkClassIsDefinedInThrowsException(throwsClassesFromMethodSignature, thrownException);"], "thrownException": ["public static boolean checkIfMethodThrowsContainsPassedException(final ProceedingJoinPoint proceedingJoinPoint, Throwable thrownException) {", "        if (proceedingJoinPoint == null || thrownException == null) {", "        return checkClassIsDefinedInThrowsException(throwsClassesFromMethodSignature, thrownException);"]}
{"classes": ["public static boolean checkClassIsDefinedInThrowsException(Class[] classes, Throwable thrownException) {", "        if (classes == null || thrownException == null) {", "        for (Class clazz : classes) {", "            if (clazz.isInstance(thrownException)) {"], "thrownException": ["public static boolean checkClassIsDefinedInThrowsException(Class[] classes, Throwable thrownException) {", "        if (classes == null || thrownException == null) {", "            if (clazz.isInstance(thrownException)) {"]}
{"proceedingJoinPoint": ["public static Class[] getDefinedThrowsFromMethodSignature(final ProceedingJoinPoint proceedingJoinPoint) {", "        if (proceedingJoinPoint == null) {", "        MethodSignature methodSignature = (MethodSignature)proceedingJoinPoint.getSignature();"]}
{"watchdogAnnotation": ["public static boolean checkProcessWatchdog(final Watchdog watchdogAnnotation, final ProceedingJoinPoint proceedingJoinPoint, final Throwable throwable) {", "        if (watchdogAnnotation != null && watchdogAnnotation.isActive()) {", "            if (!watchdogAnnotation.suppressThrowsExceptions() || (watchdogAnnotation.suppressThrowsExceptions() && !throwableIsPartOfThrowsDeclaration)) {"], "proceedingJoinPoint": ["public static boolean checkProcessWatchdog(final Watchdog watchdogAnnotation, final ProceedingJoinPoint proceedingJoinPoint, final Throwable throwable) {", "            boolean throwableIsPartOfThrowsDeclaration = WatchdogUtils.checkIfMethodThrowsContainsPassedException(proceedingJoinPoint, throwable);"], "throwable": ["public static boolean checkProcessWatchdog(final Watchdog watchdogAnnotation, final ProceedingJoinPoint proceedingJoinPoint, final Throwable throwable) {", "            boolean throwableIsPartOfThrowsDeclaration = WatchdogUtils.checkIfMethodThrowsContainsPassedException(proceedingJoinPoint, throwable);", "            if (!watchdogAnnotation.suppressThrowsExceptions() || (watchdogAnnotation.suppressThrowsExceptions() && !throwableIsPartOfThrowsDeclaration)) {"]}
{"expected": ["public final @NotNull S hasSize(int expected) {", "    if (size == expected) {", "    throw failure(format(\"expected size:<%s> but was:<%s> for <%s>\", expected, size, actual));"]}
{"Result": "Method without Parameter"}
{"index": ["public View getDropDownView(int index, View convertView, ViewGroup parent) {", "        return dropDownViewFactory.getView(convertView, itemList.get(index));"], "convertView": ["public View getDropDownView(int index, View convertView, ViewGroup parent) {", "        return dropDownViewFactory.getView(convertView, itemList.get(index));"], "parent": []}
{"name": ["protected final int reserveTermName(String name) {", "\t\tcheckInitializationPrecondition(TermUtils.isValidTermName(name), \"Object '%s' is not a valid term name\",name);", "\t\tcheckInitializationPrecondition(!this.nameOrdinal.containsKey(name),\"Term '%s' has been already reserved\",name);", "\t\tthis.nameOrdinal.put(name, ++this.ordinal);"]}
{"term": ["protected final <S extends ImmutableTerm> void registerTerm(S term) {", "\t\tcheckInitializationPrecondition(this.nameOrdinal.containsKey(term.name()),\"Term '%s' has not been reserved\",term.name());", "\t\tcheckInitializationPrecondition(term.ordinal()>=0 && term.ordinal()<=this.ordinal,\"Invalid ordinal '%d' for reserved name '%s'\",term.ordinal(),term.name());", "\t\tthis.terms.put(term.ordinal(),this.termClass.cast(term));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"target": ["private static URIRef relativeResolution(URI target, URI base) {", "\t\tURIRef R=URIRef.create(target); // NOSONAR", "\t\tif(defined(R.scheme)) {", "\t\t\tT.scheme    = R.scheme;", "\t\t\tT.authority = R.authority;", "\t\t\tT.path      = removeDotSegments(R.path);", "\t\t\tT.query     = R.query;", "\t\t\tif(defined(R.authority)) {", "\t\t\t\tT.authority = R.authority;", "\t\t\t\tT.path      = removeDotSegments(R.path);", "\t\t\t\tT.query     = R.query;", "\t\t\t\tresolvePathOnlyTarget(Base, R, T);", "\t\tT.fragment = R.fragment;"], "base": ["private static URIRef relativeResolution(URI target, URI base) {", "\t\tURIRef Base=URIRef.create(base); // NOSONAR", "\t\t\t\tresolvePathOnlyTarget(Base, R, T);", "\t\t\tT.scheme = Base.scheme;"]}
{"path": ["private static String merge(String path, String relativePath, boolean hasAuthority) {", "\t\tString parent=path;", "\t\tif(hasAuthority && parent.isEmpty()) {", "\t\treturn parent.substring(0,parent.lastIndexOf('/')+1).concat(relativePath);"], "relativePath": ["private static String merge(String path, String relativePath, boolean hasAuthority) {", "\t\treturn parent.substring(0,parent.lastIndexOf('/')+1).concat(relativePath);"], "hasAuthority": ["private static String merge(String path, String relativePath, boolean hasAuthority) {", "\t\tif(hasAuthority && parent.isEmpty()) {"]}
{"path": ["private static String removeDotSegments(String path) {", "\t\tString input=path==null?EMPTY:path;", "\t\twhile(!input.isEmpty()) {", "\t\t\tinput=processInput(outputBuffer, input);"]}
{"name": ["public Name<String> name(String name, String... names) {"]}
{"clazz": ["public Name<String> name(Class<?> clazz, String... names) {", "\t\treturn name(clazz.getCanonicalName(), names);"]}
{"type": ["public static MediaType wildcard(String type) {", "\t\trequireNonNull(type,TYPE_CANNOT_BE_NULL);", "\t\treturn new ImmutableMediaType(MediaTypes.preferredSyntax(),type,WILDCARD_TYPE,null,null);"]}
{"type": ["public static MediaType wildcard(String type, String suffix) {", "\t\trequireNonNull(type,TYPE_CANNOT_BE_NULL);", "\t\treturn new ImmutableMediaType(MediaTypes.preferredSyntax(),type,WILDCARD_TYPE,suffix,null);"], "suffix": ["public static MediaType wildcard(String type, String suffix) {", "\t\trequireNonNull(suffix,\"Suffix cannot be null\");", "\t\treturn new ImmutableMediaType(MediaTypes.preferredSyntax(),type,WILDCARD_TYPE,suffix,null);"]}
{"type": ["public static MediaType of(String type, String subtype) {", "\t\trequireNonNull(type,TYPE_CANNOT_BE_NULL);", "\t\treturn fromString(type+\"/\"+subtype);"], "subtype": ["public static MediaType of(String type, String subtype) {", "\t\trequireNonNull(subtype,\"Subtype cannot be null\");", "\t\treturn fromString(type+\"/\"+subtype);"]}
{"mediaType": ["public static String toHeader(final MediaType mediaType) {", "\t\trequireNonNull(mediaType,REFERENCE_MEDIA_TYPE_CANNOT_BE_NULL);", "\t\t\t\tappend(mediaType.type().toLowerCase(Locale.ENGLISH)).", "\t\t\t\tappend(mediaType.subType().toLowerCase(Locale.ENGLISH));", "\t\tfinal String suffix=mediaType.suffix();", "\t\tfinal Charset charset=mediaType.charset();", "\t\tfor(Entry<String,String> entry:mediaType.parameters().entrySet()) {", "\t\t\tfinal String key=entry.getKey();", "\t\t\tif(isStandardParameter(key)) {", "\t\t\tbuilder.append(';').append(key.toLowerCase(Locale.ENGLISH)).append('=').append(entry.getValue());"]}
{"Result": "Method without Parameter"}
{"other": ["\tpublic int compareTo(Term other) {", "\t\tif(self.getDeclaringVocabulary() != other.getDeclaringVocabulary()) {", "\t\treturn self.ordinal - other.ordinal();"]}
{"attachmentId": ["public List<Name<String>> pendingAttachmentNames(String attachmentId) {", "\t\tNameSource source = this.attachmentNameSources.get(attachmentId);", "\t\tif(source!=null) {", "\t\t\tresult.addAll(source.pendingNames);"]}
{"attachmentId": ["public void addAttachmentName(String attachmentId, Name<String> nextName) {", "\t\tnameSource(attachmentId).addName(nextName);"], "nextName": ["public void addAttachmentName(String attachmentId, Name<String> nextName) {", "\t\tnameSource(attachmentId).addName(nextName);"]}
{"attachmentId": ["public Name<String> nextAttachmentName(String attachmentId) {", "\t\tNameSource result = this.attachmentNameSources.get(attachmentId);", "\t\tif(result==null) {", "\t\t\tresult=new NameSource(\"attachment <<\"+attachmentId+\">>\");", "\t\treturn result.nextName();"]}
{"resource": ["public static NameProvider create(Name<String> resource) {", "\t\tObjects.requireNonNull(resource,\"Owner name cannot be null\");", "\t\treturn new NameProvider(resource);"]}
{"mr": ["private static void parseSuffix(final MediaRange mr, final String mediaType) {", "\t\tfinal String subType=mr.subType;"], "mediaType": ["private static void parseSuffix(final MediaRange mr, final String mediaType) {", "\t\t\tthrow new InvalidMediaTypeException(mediaType,\"missing subtype for structured media type (\"+subType.substring(1)+\")\");", "\t\t\tthrow new InvalidMediaTypeException(mediaType,\"missing suffix for structured media type (\"+subType.substring(0,subType.length()-1)+\")\");"]}
{"quotedString": ["private static void checkQuotedString(final String quotedString) {", "\t\tfor(int i=0;i<quotedString.length();i++) {", "\t\t\tfinal char ch=quotedString.charAt(i);", "\t\t\t\tcheckArgument(QUOTED_PAIR.get(ch),\"Invalid quoted-pair character '%s' in quoted string '%s' at %d\",ch,quotedString ,i);", "\t\t\t} else if(ch==SLASH) {", "\t\t\t\tcheckArgument(QDTEXT.get(ch),\"Invalid character '%s' in quoted string '%s' at %d\",ch,quotedString ,i);", "\t\tcheckArgument(!quotedPair,\"Missing quoted-pair character in quoted string '%s' at %d\",quotedString,quotedString.length());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"is": ["private static void closeQuietly(final InputStream is, final String message) {", "\t\tif(is!=null) {", "\t\t\tis.close();"], "message": ["private static void closeQuietly(final InputStream is, final String message) {", "\t\t\t\tLOGGER.warn(message,e);"]}
{"codePoint": ["static boolean isNameStartChar(final int codePoint) {", "\t\t\t(codePoint == ':')                             ||", "\t\t\t(codePoint >= 'A' && codePoint <= 'Z')         ||", "\t\t\t(codePoint == '_')                             ||", "\t\t\t(codePoint >= 'a' && codePoint <= 'z')         ||", "\t\t\t(codePoint >= 0xC0 && codePoint <= 0xD6)       ||", "\t\t\t(codePoint >= 0xD8 && codePoint <= 0xF6)       ||", "\t\t\t(codePoint >= 0xF8 && codePoint <= 0x2FF)      ||", "\t\t\t(codePoint >= 0x370 && codePoint <= 0x37D)     ||", "\t\t\t(codePoint >= 0x37F && codePoint <= 0x1FFF)    ||", "\t\t\t(codePoint >= 0x200C && codePoint <= 0x200D)   ||", "\t\t\t(codePoint >= 0x2070 && codePoint <= 0x218F)   ||", "\t\t\t(codePoint >= 0x2C00 && codePoint <= 0x2FEF)   ||", "\t\t\t(codePoint >= 0x3001 && codePoint <= 0xD7FF)   ||", "\t\t\t(codePoint >= 0xF900 && codePoint <= 0xFDCF)   ||", "\t\t\t(codePoint >= 0xFDF0 && codePoint <= 0xFFFD)   ||", "\t\t\t(codePoint >= 0x10000 && codePoint <= 0xEFFFF);"]}
{"codePoint": ["static boolean isNameChar(final int codePoint) {", "\t\t\tisNameStartChar(codePoint)                   ||", "\t\t\t(codePoint == '-')                           ||", "\t\t\t(codePoint == '.')                           ||", "\t\t\t(codePoint >= '0' && codePoint <= '9')       ||", "\t\t\t(codePoint == 0xB7)                          ||", "\t\t\t(codePoint >= 0x0300 && codePoint <= 0x036F) ||", "\t\t\t(codePoint >= 0x203F && codePoint <= 0x2040);"]}
{"token": ["static void checkToken(final String token, final String message, Object... args) {", "\t\t\tvalidateLength(token);", "\t\t\tvalidateCharacters(token);", "\t\t\tthrow new InvalidTokenException(String.format(message,args),token,e);"], "message": ["static void checkToken(final String token, final String message, Object... args) {", "\t\tcheckNotNull(message,\"Message cannot be null\");", "\t\t\tthrow new InvalidTokenException(String.format(message,args),token,e);"]}
{"mediaType": ["public DataTransformator mediaType(MediaType mediaType) {"]}
{"clazz": ["static void registerAdapterClass(Class<?> clazz) {", "\t\tObjects.requireNonNull(clazz,\"Adapter class cannot be null\");", "\t\tTypeAdapter.ADAPTER_CLASSES.addIfAbsent(clazz);"]}
{"sourceType": ["static <S,T> TypeAdapter<S,T> createAdapter(Class<? extends S> sourceType, Class<? extends T> targetType) {", "\t\treturn doCreateAdapter(targetType,AdapterMethodValidator.newInstance(targetType, sourceType));"], "targetType": ["static <S,T> TypeAdapter<S,T> createAdapter(Class<? extends S> sourceType, Class<? extends T> targetType) {", "\t\treturn doCreateAdapter(targetType,AdapterMethodValidator.newInstance(targetType, sourceType));"]}
{"object": ["static <S,T> T adapt(S object, Class<? extends T> resultClass) {", "\t\treturn TypeAdapter.<S,T>doCreateAdapter(resultClass, AdapterMethodValidator.newInstance(resultClass, object)).adapt(object);"], "resultClass": ["static <S,T> T adapt(S object, Class<? extends T> resultClass) {", "\t\treturn TypeAdapter.<S,T>doCreateAdapter(resultClass, AdapterMethodValidator.newInstance(resultClass, object)).adapt(object);"]}
{"prefix": ["public ImmutableNamespaces withPrefix(String prefix, String namespaceURI) {", "\t\tObjects.requireNonNull(prefix, \"Prefix cannot be null\");", "\t\tresult.map.put(prefix, namespaceURI);"], "namespaceURI": ["public ImmutableNamespaces withPrefix(String prefix, String namespaceURI) {", "\t\tObjects.requireNonNull(namespaceURI, \"Namespace URI cannot be null\");", "\t\tresult.map.put(prefix, namespaceURI);"]}
{"Result": "Method without Parameter"}
{"s": ["public static String escapeXML(final CharSequence s) {", "\t\tfinal StringBuilder sb = new StringBuilder(s.length() * 2);", "\t\tfinal CodePointIterator iterator = new CodePointIterator(s);", "\t\twhile (iterator.hasNext()) {", "\t\t\tfinal int codePoint = iterator.next();", "\t\t\tif (codePoint == '<') {", "\t\t\t} else if (codePoint == '>') {", "\t\t\t} else if (codePoint == '\\\"') {", "\t\t\t} else if (codePoint == '&') {", "\t\t\t} else if (codePoint == '\\'') {", "\t\t\t\tsb.appendCodePoint(codePoint);"]}
{"resource": ["\tpublic DataSet query(ResourceSnapshot resource, Query query, ReadSession session) throws InvalidQueryException {", "\t\treturn QuerySupport.getDescription(resource.name(), query);"], "query": ["\tpublic DataSet query(ResourceSnapshot resource, Query query, ReadSession session) throws InvalidQueryException {"], "session": []}
{"containerName": ["public final void addNameProvider(Name<String> containerName, NameProvider provider) {", "\t\tthis.nameProviders.put(containerName, provider);"], "provider": ["public final void addNameProvider(Name<String> containerName, NameProvider provider) {", "\t\tthis.nameProviders.put(containerName, provider);"]}
{"containerName": ["public final NameProvider nameProvider(Name<?> containerName) {", "\t\tNameProvider result = this.nameProviders.get(containerName);", "\t\tif(result==null) {", "\t\t\tthrow new ApplicationRuntimeException(\"Unknown container '\"+containerName+\"'\");", "\t\treturn result;"]}
{"clazz": ["public <T> T unwrap(final Class<? extends T> clazz) throws ApplicationEngineException {", "\t\tcheckNotNull(clazz,\"Target class cannot be null\");", "\t\tif(!clazz.isInstance(this)) {", "\t\t\tthrow new ApplicationEngineException(\"Application Engine implementation is not compatible with \"+clazz.getCanonicalName());", "\t\treturn clazz.cast(this);"]}
{"Result": "Method without Parameter"}
{"directory": ["public Path withDirectory(final String directory) {", "\t\tresult.setDirectory(directory);"]}
{"file": ["public Path withFile(final String file) {", "\t\tresult.setFile(file);"]}
{"path": ["private Path assembleRelativeSegments(final Path path, final Path base, final Deque<String> segments) {", "\t\tif(segments.isEmpty() && path.isDirectory() && base.isFile()) {", "\t\treturn Path.create(assembleSegments(segments,path.getFile()));"], "base": ["private Path assembleRelativeSegments(final Path path, final Path base, final Deque<String> segments) {", "\t\tif(segments.isEmpty() && path.isDirectory() && base.isFile()) {"], "segments": ["private Path assembleRelativeSegments(final Path path, final Path base, final Deque<String> segments) {", "\t\tif(segments.isEmpty() && path.isDirectory() && base.isFile()) {", "\t\t\tsegments.add(CURRENT);", "\t\treturn Path.create(assembleSegments(segments,path.getFile()));"]}
{"clazz": ["static <T> Class<T> getTypeParameter(Class<?> clazz, Class<? super T> bound) {", "\t\tType t = checkNotNull(clazz);", "\t\twhile (t instanceof Class<?>) {", "\t\t\tt = ((Class<?>) t).getGenericSuperclass();", "\t\tif(t instanceof ParameterizedType) {", "\t\t\tClass<T> result=processParameterizedType(bound, (ParameterizedType) t);", "\t\t\tif(result!=null) {", "\t\t\t\treturn result;", "\t\tthrow new IllegalStateException(\"Cannot figure out type parameterization for \"+ clazz.getName());"], "bound": ["static <T> Class<T> getTypeParameter(Class<?> clazz, Class<? super T> bound) {", "\t\t\tClass<T> result=processParameterizedType(bound, (ParameterizedType) t);"]}
{"valueClass": ["public static <T> PrimitiveObjectFactory<T> create(final Class<? extends T> valueClass) {", "\t\tcheckNotNull(valueClass, \"Value class cannot be null\");", "\t\tcheckArgument(valueClass.isPrimitive(), \"Value class '\" + valueClass.getName() + \"' is not primitive\");", "\t\treturn new PrimitiveObjectFactory<T>(valueClass);"]}
{"Result": "Method without Parameter"}
{"dataSet": ["\tpublic Individual<T,S> resolve(DataSet dataSet) {", "\t\treturn (Individual<T,S>) dataSet.individualOfId(ref());"]}
{"value": ["    public static <T extends ViewGroup> Matcher<T> equalChildrenCountAs(int value) {", "        return new ViewGroupComparison<T>(value, EQUAL, EQUAL);"]}
{"value": ["    public static <T extends ViewGroup> Matcher<T> moreChildrenThan(int value) {", "        return new ViewGroupComparison<T>(value, GREATER_THAN, GREATER_THAN);"]}
{"value": ["    public static <T extends ViewGroup> Matcher<T> moreChildrenOrEqual(int value) {", "        return new ViewGroupComparison<T>(value, EQUAL, GREATER_THAN);"]}
{"value": ["    public static <T extends ViewGroup> Matcher<T> lessChildrenThan(int value) {", "        return new ViewGroupComparison<T>(value, LESS_THAN, LESS_THAN);"]}
{"value": ["    public static <T extends ViewGroup> Matcher<T> lessChildrenOrEqual(int value) {", "        return new ViewGroupComparison<T>(value, LESS_THAN, EQUAL);"]}
{"year": ["public Measures getMeasuresByYearState(String year, String stateId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Measure.getMeasuresByYearState\", new ArgMap(\"year\", year, \"stateId\", stateId), Measures.class );\r"], "stateId": ["public Measures getMeasuresByYearState(String year, String stateId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Measure.getMeasuresByYearState\", new ArgMap(\"year\", year, \"stateId\", stateId), Measures.class );\r"]}
{"measureId": ["public Measure getMeasure(String measureId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Measure.getMeasure\", new ArgMap(\"measureId\", measureId), Measure.class );\r"]}
{"candidateId": ["public CandidateRating getCandidateRating(String candidateId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Rating.getCandidateRating\", new ArgMap(\"candidateId\", candidateId), CandidateRating.class );\r"]}
{"ratingId": ["public Rating getRating(String ratingId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Rating.getRating\", new ArgMap(\"ratingId\", ratingId), Rating.class );\r"]}
{"year": ["public Elections getElectionByYearState(String year) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Election.getElectionByYearState\", new ArgMap(\"year\", year), Elections.class );\r"]}
{"zip5": ["public ElectionByZip getElectionByZip(String zip5) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Election.getElectionByZip\", new ArgMap(\"zip5\", zip5), ElectionByZip.class );\r"]}
{"electionId": ["public StageCandidates getStageCandidates(String electionId, String stageId, String party) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Election.getStageCandidates\", new ArgMap(\"electionId\", electionId, \"stageId\", stageId, \"party\", party), StageCandidates .class );\r"], "stageId": ["public StageCandidates getStageCandidates(String electionId, String stageId, String party) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Election.getStageCandidates\", new ArgMap(\"electionId\", electionId, \"stageId\", stageId, \"party\", party), StageCandidates .class );\r"], "party": ["public StageCandidates getStageCandidates(String electionId, String stageId, String party) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Election.getStageCandidates\", new ArgMap(\"electionId\", electionId, \"stageId\", stageId, \"party\", party), StageCandidates .class );\r"]}
{"officeId": ["public AddressAddress getOfficeByOfficeState(String officeId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Address.getOfficeByOfficeState\", new ArgMap(\"officeId\", officeId), AddressAddress.class );\r"]}
{"officeTypeId": ["public Offices getOfficesByType(String officeTypeId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Office.getOfficesByType\", new ArgMap(\"officeTypeId\", officeTypeId), Offices.class );\r"]}
{"levelId": ["public Offices getOfficesByLevel(String levelId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Office.getOfficesByLevel\", new ArgMap(\"levelId\", levelId), Offices.class );\r"]}
{"officeTypeId": ["public Offices getOfficesByTypeLevel(String officeTypeId, String officeLevelId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Office.getOfficesByTypeLevel\", new ArgMap(\"officeTypeId\", officeTypeId, \"officeLevelId\", officeLevelId), Offices.class );\r"], "officeLevelId": ["public Offices getOfficesByTypeLevel(String officeTypeId, String officeLevelId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Office.getOfficesByTypeLevel\", new ArgMap(\"officeTypeId\", officeTypeId, \"officeLevelId\", officeLevelId), Offices.class );\r"]}
{"branchId": ["public Offices getOfficesByBranchLevel(String branchId, String levelId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Office.getOfficesByBranchLevel\", new ArgMap(\"branchId\", branchId, \"levelId\", levelId), Offices.class );\r"], "levelId": ["public Offices getOfficesByBranchLevel(String branchId, String levelId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Office.getOfficesByBranchLevel\", new ArgMap(\"branchId\", branchId, \"levelId\", levelId), Offices.class );\r"]}
{"stateId": ["public Counties getCounties(String stateId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Local.getCounties\", new ArgMap(\"stateId\", stateId), Counties.class );\r"]}
{"stateId": ["public Cities getCities(String stateId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Local.getCities\", new ArgMap(\"stateId\", stateId), Cities.class );\r"]}
{"localId": ["public LocalCandidateList getOfficials(String localId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Local.getOfficials\", new ArgMap(\"localId\", localId), LocalCandidateList.class );\r"]}
{"method": ["public <T> T query(String method, ArgMap argMap, Class<T> responseType) throws VoteSmartException, VoteSmartErrorException {", "\t\t\tif ( isCaching(method, argMap) ) {", "\t\t\t\tFile file = getCacheFile(method, argMap);", "\t\t\t\t\tVoteSmart.cacheFileFromAPI(method, argMap, file);", "\t\t\t\tconn = VoteSmart.getConnectionFromAPI(method, argMap);", "\t        \tthrow new VoteSmartErrorException( ((ErrorBase)e.getValue()), method, argMap );"], "argMap": ["public <T> T query(String method, ArgMap argMap, Class<T> responseType) throws VoteSmartException, VoteSmartErrorException {", "\t\t\tif ( isCaching(method, argMap) ) {", "\t\t\t\tFile file = getCacheFile(method, argMap);", "\t\t\t\tlong fileLength = file.length(); ", "\t\t\t\tlogger.fine(\"Length of File in cache:\" + fileLength + \": \" + file.getName());", "\t\t\t\t\tVoteSmart.cacheFileFromAPI(method, argMap, file);", "\t\t\t\treader = new BufferedReader(new InputStreamReader(new FileInputStream(file), charSet));", "\t\t\t\tconn = VoteSmart.getConnectionFromAPI(method, argMap);", "\t\t\t\tcharSet = getCharset(conn);", "\t\t\t\treader = new BufferedReader(new InputStreamReader(conn.getInputStream(), charSet));", "\t        JAXBElement<T> e = unmarshaller.unmarshal( new StreamSource( reader ), responseType );", "\t        \tthrow new VoteSmartErrorException( ((ErrorBase)e.getValue()), method, argMap );", "\t\t\tif ( conn != null ) conn.disconnect();", "\t\t\tif ( reader != null ) {", "\t\t\t\t\treader.close();"], "responseType": ["public <T> T query(String method, ArgMap argMap, Class<T> responseType) throws VoteSmartException, VoteSmartErrorException {", "\t        JAXBElement<T> e = unmarshaller.unmarshal( new StreamSource( reader ), responseType );", "\t        if ( e.getName().getLocalPart().equals(\"error\") ) {", "\t        \tthrow new VoteSmartErrorException( ((ErrorBase)e.getValue()), method, argMap );", "\t        \treturn e.getValue();", "\t\t} catch ( JAXBException e ) {", "\t\t\tthrow new VoteSmartException(e);", "\t\t} catch (URISyntaxException e) {", "\t\t\tthrow new VoteSmartException(e);", "\t\t} catch (IOException e) {", "\t\t\tthrow new VoteSmartException(e);", "\t\t\t\t} catch (IOException e) {", "\t\t\t\t\tthrow new VoteSmartException(e);"]}
{"stateId": ["public CandidateList getStatewide(String stateId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Officials.getStatewide\", new ArgMap(\"stateId\", stateId), CandidateList.class );\r"]}
{"officeTypeId": ["public CandidateList getByOfficeTypeState(String officeTypeId, String stateId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Officials.getByOfficeTypeState\", new ArgMap(\"officeTypeId\", officeTypeId, \"stateId\", stateId), CandidateList.class );\r"], "stateId": ["public CandidateList getByOfficeTypeState(String officeTypeId, String stateId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Officials.getByOfficeTypeState\", new ArgMap(\"officeTypeId\", officeTypeId, \"stateId\", stateId), CandidateList.class );\r"]}
{"zip5": ["public CandidateList getByZip(String zip5) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Officials.getByZip\", new ArgMap(\"zip5\", zip5), CandidateList.class );\r"]}
{"candidateId": ["public AddlBio getAddlBio(String candidateId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"CandidateBio.getAddlBio\", new ArgMap(\"candidateId\", candidateId), AddlBio.class );\r"]}
{"candidateId": ["public Bio getBio(String candidateId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"CandidateBio.getDetailedBio\", new ArgMap(\"candidateId\", candidateId), Bio.class );\r"]}
{"lastName": ["public CandidateList getByLastname(String lastName, String electionYear) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Candidates.getByLastname\", new ArgMap(\"lastName\", lastName, \"electionYear\", electionYear), CandidateList.class );\r"], "electionYear": ["public CandidateList getByLastname(String lastName, String electionYear) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Candidates.getByLastname\", new ArgMap(\"lastName\", lastName, \"electionYear\", electionYear), CandidateList.class );\r"]}
{"electionId": ["public CandidateList getByElection(String electionId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Candidates.getByElection\", new ArgMap(\"electionId\", electionId), CandidateList.class );\r"]}
{"districtId": ["public CandidateList getByDistrict(String districtId, String electionYear) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Candidates.getByDistrict\", new ArgMap(\"districtId\", districtId, \"electionYear\", electionYear), CandidateList.class );\r"], "electionYear": ["public CandidateList getByDistrict(String districtId, String electionYear) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Candidates.getByDistrict\", new ArgMap(\"districtId\", districtId, \"electionYear\", electionYear), CandidateList.class );\r"]}
{"typeId": ["public Committees getCommitteesByTypeState(String typeId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Committee.getCommitteesByTypeState\", new ArgMap(\"typeId\", typeId), Committees.class );\r"]}
{"committeeId": ["public Committee getCommittee(String committeeId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Committee.getCommittee\", new ArgMap(\"committeeId\", committeeId), Committee.class );\r"]}
{"committeeId": ["public CommitteeMembers getCommitteeMembers(String committeeId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Committee.getCommitteeMembers\", new ArgMap(\"committeeId\", committeeId), CommitteeMembers.class );\r"]}
{"stateId": ["public Leadership getPositions(String stateId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Leadership.getPositions\", new ArgMap(\"stateId\", stateId), Leadership.class );\r"]}
{"leadershipId": ["public Leaders getOfficials(String leadershipId) throws VoteSmartException, VoteSmartErrorException {\r", "\t\treturn api.query(\"Leadership.getOfficials\", new ArgMap(\"leadershipId\", leadershipId), Leaders.class );\r"]}
{"ms": ["public static void sleep(int ms) {", "      long deadline = System.currentTimeMillis() + ms;", "      while (System.currentTimeMillis() < deadline) {", "            Thread.sleep(Math.max(1, (deadline - System.currentTimeMillis()) / 2));"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"stream": ["public static <K, V, M extends Map<K, V>> M merge(Stream<? extends Map<K, V>> stream,", "\t\tAssert.notNull(stream, \"Missing map merge function!\");", "\t\treturn stream.collect(mapSupplier,"], "mergeFunction": ["\t                                                  BinaryOperator<V> mergeFunction,", "\t\tAssert.notNull(mergeFunction, \"Missing map merge function!\");", "\t\t                      (a, b) -> b.forEach((k, v) -> a.merge(k, v, mergeFunction)),"], "mapSupplier": ["\t                                                  Supplier<M> mapSupplier) {", "\t\tAssert.notNull(mapSupplier, \"Missing map supplier!\");", "\t\treturn stream.collect(mapSupplier,"]}
{"map": ["public static <K, V> List<Map<K, V>> split(Map<K, V> map, int limit) {", "\t\tAssert.notNull(map, \"Missing map!\");", "\t\tif (map.size() <= limit) {", "\t\t\treturn Collections.singletonList(map); // nothing to do", "\t\treturn map.entrySet().parallelStream().collect(mapSizer(limit));"], "limit": ["public static <K, V> List<Map<K, V>> split(Map<K, V> map, int limit) {", "\t\tAssert.isTrue(limit > 0, \"Map limit must be > 0!\");", "\t\tif (map.size() <= limit) {", "\t\treturn map.entrySet().parallelStream().collect(mapSizer(limit));"]}
{"limit": ["private static <K, V> Collector<Map.Entry<K, V>, ?, List<Map<K, V>>> mapSizer(int limit) {", "\t\t\t                    if (l.isEmpty() || l.get(l.size() - 1).size() == limit) {", "\t\t\t                    if (l1.get(l1.size() - 1).size() < limit) {", "\t\t\t\t                    while (mapsIte.hasPrevious() && map.size() < limit) {", "\t\t\t\t\t                    while (ite.hasNext() && map.size() < limit) {"]}
{"map": ["public static <K, V> Map<K, V> sort(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator) {", "\t\tAssert.notNull(map, \"Missing map!\");", "\t\tList<Map.Entry<K, V>> list = new LinkedList<>(map.entrySet());"], "comparator": ["public static <K, V> Map<K, V> sort(Map<K, V> map, Comparator<Map.Entry<K, V>> comparator) {", "\t\tAssert.notNull(comparator, \"Missing comparator!\");", "\t\tCollections.sort(list, comparator);"]}
{"map": ["public static <T> T firstValue(Map<String, T> map) {", "\t\tif (map == null || map.size() == 0) {", "\t\tString firstKey = map.keySet().iterator().next();", "\t\treturn map.get(firstKey);"]}
{"test": ["public static <T> void isNull(T test, String message) {", "\t\tisTrue(test == null, message);"], "message": ["public static <T> void isNull(T test, String message) {", "\t\tisTrue(test == null, message);"]}
{"test": ["public static <T> void notNull(T test, String message) {", "\t\tisFalse(test == null, message);"], "message": ["public static <T> void notNull(T test, String message) {", "\t\tisFalse(test == null, message);"]}
{"value": ["public static void notNullOrEmptyTrimmed(String value, String message) {", "\t\tisFalse(StringUtils.isNullOrEmptyTrimmed(value), message);"], "message": ["public static void notNullOrEmptyTrimmed(String value, String message) {", "\t\tisFalse(StringUtils.isNullOrEmptyTrimmed(value), message);"]}
{"set": ["public static <T> void isNullOrEmpty(Set<T> set, String message) {", "\t\tisTrue(set == null || set.size() == 0, message);"], "message": ["public static <T> void isNullOrEmpty(Set<T> set, String message) {", "\t\tisTrue(set == null || set.size() == 0, message);"]}
{"array": ["public static <T> void isNullOrEmpty(T[] array, String message) {", "\t\tisTrue(array == null || array.length == 0, message);"], "message": ["public static <T> void isNullOrEmpty(T[] array, String message) {", "\t\tisTrue(array == null || array.length == 0, message);"]}
{"resourceFile": ["\tpublic static String getResourceAsString(String resourceFile, Class clazz) {", "\t\tAssert.notNullOrEmptyTrimmed(resourceFile, \"Missing resource file!\");", "\t\t\tInputStream resource = clazz.getResourceAsStream(resourceFile);", "\t\t\tscanner = new Scanner(resource, UTF_8);"], "clazz": ["\tpublic static String getResourceAsString(String resourceFile, Class clazz) {", "\t\t\tInputStream resource = clazz.getResourceAsStream(resourceFile);"]}
{"resourceFile": ["public static Set<String> getResourceWords(String resourceFile, Class clazz) {", "\t\tAssert.notNullOrEmptyTrimmed(resourceFile, \"Missing resource file!\");", "\t\t\tInputStream resource = clazz.getResourceAsStream(resourceFile);", "\t\t\tscanner = new Scanner(resource, UTF_8);"], "clazz": ["public static Set<String> getResourceWords(String resourceFile, Class clazz) {", "\t\t\tInputStream resource = clazz.getResourceAsStream(resourceFile);"]}
{"resourceFile": ["\tpublic static Long getLastModifiedTime(String resourceFile, Class clazz) {", "\t\tAssert.notNullOrEmptyTrimmed(resourceFile, \"Missing resource file!\");", "\t\t\tURL url = clazz.getResource(resourceFile);", "\t\t\treturn url.openConnection().getLastModified(); // get last modified date of resource"], "clazz": ["\tpublic static Long getLastModifiedTime(String resourceFile, Class clazz) {", "\t\t\tURL url = clazz.getResource(resourceFile);"]}
{"is": ["public static String getString(final InputStream is, String encoding) {", "\t\tif (is == null) {", "\t\t\ttry (Reader in = new InputStreamReader(is, encoding)) {"], "encoding": ["public static String getString(final InputStream is, String encoding) {", "\t\tif (StringUtils.isNullOrEmptyTrimmed(encoding)) {", "\t\t\ttry (Reader in = new InputStreamReader(is, encoding)) {"]}
{"is": ["public static byte[] getBytes(InputStream is) {", "\t\tif (is == null) {", "\t\t\twhile ((nRead = is.read(data, 0, data.length)) != -1) {", "\t\t\t\tbuffer.write(data, 0, nRead);"]}
{"file": ["public static String readFileToString(File file) throws IOException {", "\t\tAssert.isTrue(file.exists(), \"File '\" + file + \"' does not exist\");", "\t\tAssert.isFalse(file.isDirectory(), \"File '\" + file + \"' is a directory\");", "\t\tAssert.isTrue(file.canRead(), \"File '\" + file + \"' cannot be read\");", "\t\tFileInputStream stream = new FileInputStream(file);", "\t\treturn getString(stream);"]}
{"resource": ["\tpublic static String getResourceAbsolutePath(String resource, Class clazz) {", "\t\tAssert.notNullOrEmptyTrimmed(resource, \"Missing resource name!\");", "\t\tURL file = clazz.getResource(resource);", "\t\tAssert.notNull(file, \"Resource: '\" + resource + \"', not found!\");", "\t\treturn file.getFile();"], "clazz": ["\tpublic static String getResourceAbsolutePath(String resource, Class clazz) {", "\t\tURL file = clazz.getResource(resource);"]}
{"length": ["public static String generateString(int length) {", "\t\tif (length <= 0 || length > 100) {", "\t\t\tthrow new IllegalArgumentException(\"Can't generate random id with length: \" + length);", "\t\tStringBuilder sb = new StringBuilder(length);", "\t\tfor (int i = 0; i < length; i++) {", "\t\t\tsb.append(ELEMENTS.charAt(random.nextInt(ELEMENTS.length())));", "\t\treturn sb.toString();"]}
{"length": ["public static long generateLong(int length) {", "\t\tif (length <= 0 || length > 19) {", "\t\t\tthrow new IllegalArgumentException(\"Can't generate random id with length: \" + length);", "\t\tStringBuilder sb = new StringBuilder(length);", "\t\tif (length == 19) {", "\t\t\tsb.append(NUMBERS_NO_NINE_AND_ZERO.charAt(random.nextInt(NUMBERS_NO_NINE_AND_ZERO.length())));", "\t\t\tsb.append(NUMBERS_NO_ZERO.charAt(random.nextInt(NUMBERS_NO_ZERO.length())));", "\t\tfor (int i = 1; i < length; i++) {", "\t\t\tsb.append(NUMBERS.charAt(random.nextInt(NUMBERS.length())));", "\t\treturn Long.parseLong(sb.toString());"]}
{"array1": ["\tpublic static <T> T[] join(final T[] array1, final T... array2) {", "\t\tif (isEmpty(array1) && isEmpty(array2)) {", "\t\tif (isEmpty(array1)) {", "\t\t\treturn array1;", "\t\tfinal Class<?> type1 = array1.getClass().getComponentType();", "\t\tfinal T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);", "\t\tfor (T item : array1) {", "\t\t\tjoinedArray[index++] = item;"]}
{"set": ["public static <T> List<Set<T>> split(Set<T> set, int maxSize) {", "\t\tAssert.notNull(set, \"Missing set to be split!\");", "\t\tif (set.size() < maxSize) {", "\t\t\treturn Collections.singletonList(set);", "\t\tIterator<T> iterator = set.iterator();"], "maxSize": ["public static <T> List<Set<T>> split(Set<T> set, int maxSize) {", "\t\tAssert.isTrue(maxSize > 0, \"Max size must be > 0!\");", "\t\tif (set.size() < maxSize) {", "\t\t\tfor (int j = 0; j < maxSize && iterator.hasNext(); j++) {"]}
{"time": ["public static Instant getMonthStart(Instant time) {", "\t\tAssert.notNull(time, \"Missing date time\");", "\t\tLocalDateTime dateTime = LocalDateTime.ofInstant(time, ZoneOffset.UTC);"]}
{"time": ["public static Instant getMonthEnd(Instant time) {", "\t\tAssert.notNull(time, \"Missing date time\");", "\t\tLocalDateTime dateTime = LocalDateTime.ofInstant(time, ZoneOffset.UTC);"]}
{"text": ["public static String trimToNull(String text) {", "\t\ttext = trim(text);", "\t\tif (text == null || text.isEmpty()) {", "\t\treturn text;"]}
{"input": ["public static String capitalize(String input) {", "\t\tif (input == null) {", "\t\tif (input.length() > 1) {", "\t\t\tfor (int i = 0; i < input.length(); i++) {", "\t\t\t\tif (Character.isAlphabetic(input.charAt(i))) {", "\t\t\t\t\treturn input.substring(0, i) + Character.toString(input.charAt(i)).toUpperCase() + input.substring(i + 1);", "\t\treturn input.toUpperCase();"]}
{"args": ["public static String join(Object[] args, String separator) {", "\t\treturn join(args, separator, null);"], "separator": ["public static String join(Object[] args, String separator) {", "\t\treturn join(args, separator, null);"]}
{"items": ["public static String join(Set<?> items, String separator) {", "\t\treturn join(items, separator, null);"], "separator": ["public static String join(Set<?> items, String separator) {", "\t\treturn join(items, separator, null);"]}
{"text": ["public static List<String> getWords(String text) {", "\t\tif (isNullOrEmptyTrimmed(text)) {", "\t\tMatcher m = p.matcher(text);", "\t\twhile (m.find()) {", "\t\t\toutput.add(m.group());"]}
{"text": ["public static String trimTextDown(String text, int size) {", "\t\tif (text == null || text.length() <= size) {", "\t\t\treturn text;", "\t\tint pos = text.lastIndexOf(\" \", size);", "\t\t\treturn text.substring(0, size);", "\t\treturn text.substring(0, pos);"], "size": ["public static String trimTextDown(String text, int size) {", "\t\tif (text == null || text.length() <= size) {", "\t\tint pos = text.lastIndexOf(\" \", size);", "\t\tif (pos < 0) {", "\t\t\treturn text.substring(0, size);", "\t\treturn text.substring(0, pos);"]}
{"text": ["public static String trimTextDown(String text, int sizeMinusAppend, String append) {", "\t\tif (text == null || text.length() <= sizeMinusAppend) {", "\t\t\treturn text;", "\t\tint pos = text.lastIndexOf(\" \", sizeMinusAppend);", "\t\t\treturn text.substring(0, sizeMinusAppend) + append;", "\t\treturn text.substring(0, pos) + append;"], "sizeMinusAppend": ["public static String trimTextDown(String text, int sizeMinusAppend, String append) {", "\t\tif (text == null || text.length() <= sizeMinusAppend) {", "\t\tsizeMinusAppend = sizeMinusAppend - append.length();"], "append": ["public static String trimTextDown(String text, int sizeMinusAppend, String append) {", "\t\tAssert.notNull(append, \"Missing append!\");", "\t\tsizeMinusAppend = sizeMinusAppend - append.length();", "\t\t\treturn text.substring(0, sizeMinusAppend) + append;", "\t\treturn text.substring(0, pos) + append;"]}
{"text": ["public static List<String> asListOfChars(String text) {", "\t\tif (StringUtils.isNullOrEmptyTrimmed(text)) {", "\t\tfor (int i = 0; i < text.length(); i++) {", "\t\t\tlist.add(Character.toString(text.charAt(i)));"]}
{"value": ["public static int relevance(String value, String search) {", "\t\tif (StringUtils.isNullOrEmptyTrimmed(value) ||", "\t\tif (search.length() > value.length()) {", "\t\tint len = value.length();", "\t\t\t\tchar letter = value.charAt(letterIndex);", "\t\t\t\tif (match == letter) {"], "search": ["public static int relevance(String value, String search) {", "\t\t\tStringUtils.isNullOrEmptyTrimmed(search)) {", "\t\tif (search.length() > value.length()) {", "\t\tint searchLen = search.length();", "\t\t\tchar match = search.charAt(searchIndex);", "\t\t\t\tif (match == letter) {"]}
{"text": ["public static String unQuote(String text) {", "\t\tif (isNullOrEmptyTrimmed(text)) {", "\t\t\treturn text;", "\t\tif ((text.startsWith(\"\\\"\") && text.endsWith(\"\\\"\")) ||", "\t\t    (text.startsWith(\"'\") && text.endsWith(\"'\"))) {", "\t\t\treturn text.substring(1, text.length() - 1);", "\t\treturn text;"]}
{"time": ["public static long getTimezoneTime(long time, int timezone) {", "\t\tCalendar calendar = getCalendar(time);", "\t\tint hour = calendar.get(Calendar.HOUR_OF_DAY);", "\t\t\tcalendar.add(Calendar.DAY_OF_MONTH, -1);", "\t\tcalendar.set(Calendar.HOUR_OF_DAY, hour);", "\t\treturn calendar.getTimeInMillis();"], "timezone": ["public static long getTimezoneTime(long time, int timezone) {", "\t\thour = (hour + timezone) % 24;"]}
{"tagID": ["public List<Integer> hasTag(final Integer tagID) {", "            if (tag.getTag().getTagId().equals(tagID)) retValue.add(tag.getTagState());"]}
{"severity": ["private boolean isViolation(String severity) {", "        if (\"error\".equals(severity)) {", "        } else if (\"warning\".equals(severity)) {", "        } else if (\"info\".equals(severity)) {"]}
{"level": ["public void iconSeverity(String level) {", "        sink.figureGraphics(\"images/icon_\" + level + \"_sml.gif\");"]}
{"level": ["public void iconSeverity(String level, int textType) {", "        sink.figureGraphics(\"images/icon_\" + level + \"_sml.gif\");", "            sink.text(bundle.getString(\"report.checkstyle.\" + level + suffix(textType)));"], "textType": ["public void iconSeverity(String level, int textType) {", "        if (textType > 0) {", "            sink.text(bundle.getString(\"report.checkstyle.\" + level + suffix(textType)));"]}
{"brLineBreak": ["    public String getTagsList(final boolean brLineBreak) {", "        final String lineBreak = brLineBreak ? \"<br/>\" : \"\\n\";", "        final String boldStart = brLineBreak ? \"<b>\" : \"\";", "        final String boldEnd = brLineBreak ? \"</b>\" : \"\";"]}
{"next": ["    public void setNextAndClean(CSNode next) {", "        setNextInternal(next);", "        if (next != null) {", "            next.setPreviousInternal(this);"]}
{"previous": ["    public void setPreviousAndClean(CSNode previous) {", "        setPreviousInternal(previous);", "        if (previous != null) {", "            previous.setNextInternal(this);"]}
{"host": ["public Node find(String host, int port) {", "\t\treturn socketToNodeMap.get(Utils.toKey(host, port));"], "port": ["public Node find(String host, int port) {", "\t\treturn socketToNodeMap.get(Utils.toKey(host, port));"]}
{"host": ["public Set<Node> find(String host) {", "\t\tif (host != null) {", "\t\t\t\tif (host.equals(node.getHost())) {"]}
{"Result": "Method without Parameter"}
{"node": ["public void add(Node node) {", "\t\tsocketToNodeMap.put(Utils.toKey(node), node);", "\t\tsendEvent(node, NodeEventType.ADDED);"]}
{"node": ["public void remove(Node node) {", "\t\tsocketToNodeMap.remove(Utils.toKey(node));", "\t\tsendEvent(node, NodeEventType.REMOVED);"]}
{"node": ["public void markAsAlive(Node node) {", "\t\tif (!NodeStatus.ALIVE.equals(node.getStatus())) {", "\t\t\tsocketToNodeMap.get(Utils.toKey(node)).markAsAlive();", "\t\t\tsendEvent(node, NodeEventType.MARKED_AS_ALIVE);"]}
{"node": ["public void markAsDead(Node node) {", "\t\tif (!NodeStatus.DEAD.equals(node.getStatus())) {", "\t\t\tsocketToNodeMap.get(Utils.toKey(node)).markAsDead();", "\t\t\tsendEvent(node, NodeEventType.MARKED_AS_DEAD);"]}
{"node": ["private void sendEvent(Node node, NodeEventType type) {", "\t\tNodeEvent event = new NodeEvent(node, type);"], "type": ["private void sendEvent(Node node, NodeEventType type) {", "\t\tNodeEvent event = new NodeEvent(node, type);", "\t\t\thandler.handle(event);"]}
{"Result": "Method without Parameter"}
{"resourceManager": ["private void configureResourceLocator(final ResourceManager resourceManager,", "        resourceManager.setOutputDirectory(new File(project.getBuild().getDirectory()));", "            resourceManager.addSearchPath(FileResourceLoader.ID, dir.getAbsolutePath());", "        resourceManager.addSearchPath(\"url\", \"\");", "                        resourceManager.addSearchPath(\"jar\", \"jar:\" + licenseArtifact.getFile().toURI().toURL());"], "request": ["                                          final CheckstyleExecutorRequest request,", "        final MavenProject project = request.getProject();"], "additionalArtifacts": ["                                          final List<Artifact> additionalArtifacts) {", "        if (additionalArtifacts != null) {", "            for (Artifact licenseArtifact : additionalArtifacts) {", "                    if (licenseArtifact != null) {", "                            getLogger().debug(\"Adding licenceArtifact [\" + licenseArtifact.getGroupId() + \":\"", "                                    + licenseArtifact.getArtifactId() + \":\" + licenseArtifact.getVersion()", "                        resourceManager.addSearchPath(\"jar\", \"jar:\" + licenseArtifact.getFile().toURI().toURL());"]}
{"Result": "Method without Parameter"}
{"defaultPropertyValues": ["private Map<String, Object> createObjectPropertyValues(Map<String, Object> defaultPropertyValues, List<Object> attributes) {", "        Map<String, Object> propertyValues = new HashMap<String, Object>(defaultPropertyValues);", "            propertyValues.putAll(propertyOverrideMap);", "        return propertyValues;"], "attributes": ["private Map<String, Object> createObjectPropertyValues(Map<String, Object> defaultPropertyValues, List<Object> attributes) {", "        if(attributes != null) {", "            Iterator<Object> iterator = attributes.iterator();"]}
{"name": ["private int currentSequence(String name) {", "        Integer seq = sequencesForClass.get(name);", "        seq = seq == null ? 1 : seq + 1;", "        sequencesForClass.put(name, seq);"]}
{"that": ["    public int compareTo(final NodeID that) {", "        if (that == this) {", "        } else if (null == that) {", "        return this.getId().compareTo(that.getId());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"target": ["public static boolean setProperty(Object target, String name, Object value) {", "            for (PropertyDescriptor pd : Introspector.getBeanInfo(target.getClass()).getPropertyDescriptors()) {", "                if (pd.getWriteMethod() != null && pd.getName().equals(name)) {", "                    pd.getWriteMethod().invoke(target, value);"], "name": ["public static boolean setProperty(Object target, String name, Object value) {", "                if (pd.getWriteMethod() != null && pd.getName().equals(name)) {"], "value": ["public static boolean setProperty(Object target, String name, Object value) {", "                    pd.getWriteMethod().invoke(target, value);"]}
{"target": ["public static boolean setField(Object target, String name, Object value) {", "            Field field = target.getClass().getDeclaredField(name);", "            field.set(target, value);"], "name": ["public static boolean setField(Object target, String name, Object value) {", "            Field field = target.getClass().getDeclaredField(name);", "            field.setAccessible(true);", "            field.set(target, value);"], "value": ["public static boolean setField(Object target, String name, Object value) {", "            field.set(target, value);"]}
{"targetClass": ["public static List<Method> getAnnotatedMethods(Class targetClass, Class<? extends Annotation> annotationType) {", "        for(Method method : targetClass.getDeclaredMethods()) {", "            if(method.isAnnotationPresent(annotationType)) {", "                annotatedMethods.add(method);"], "annotationType": ["public static List<Method> getAnnotatedMethods(Class targetClass, Class<? extends Annotation> annotationType) {", "            if(method.isAnnotationPresent(annotationType)) {"]}
{"target": ["public static void invokeMethod(Object target, Method method, Object... arguments) {", "            method.invoke(target, arguments);"], "method": ["public static void invokeMethod(Object target, Method method, Object... arguments) {", "        method.setAccessible(true); // so we can call private and protected methods too", "            method.invoke(target, arguments);"]}
{"args": ["public static void main(String[] args) throws Exception {", "\t\tif (args.length > 0) {", "\t\t\tloadClasses(args[0]);"]}
{"config": ["private String getConfigAttribute(Configuration config, ChainedItem<Configuration> parentConfiguration,", "            ret = config.getAttribute(attributeName);"], "parentConfiguration": ["private String getConfigAttribute(Configuration config, ChainedItem<Configuration> parentConfiguration,", "            if (parentConfiguration != null) {", "                        getConfigAttribute(parentConfiguration.value, parentConfiguration.parent, attributeName,"], "attributeName": ["                                      String attributeName, String defaultValue) {", "            ret = config.getAttribute(attributeName);", "                        getConfigAttribute(parentConfiguration.value, parentConfiguration.parent, attributeName,", "        return ret;"], "defaultValue": ["                                      String attributeName, String defaultValue) {", "                ret =", "                                defaultValue);", "                ret = defaultValue;", "        return ret;"]}
{"results": ["private void doRulesSummary(CheckstyleResults results) {", "            for (ConfReference ref : sortConfiguration(results)) {", "                doRuleRow(ref, results, category);", "                category = ref.category;"]}
{"event": ["public boolean matchRule(AuditEvent event, String ruleName, String expectedMessage, String expectedSeverity) {", "        if (!ruleName.equals(RuleUtil.getName(event))) {", "            return expectedMessage.equals(event.getMessage()) || msgWithoutSingleQuote.equals(event.getMessage());", "            return expectedSeverity.equals(event.getSeverityLevel().getName());"], "ruleName": ["public boolean matchRule(AuditEvent event, String ruleName, String expectedMessage, String expectedSeverity) {", "        if (!ruleName.equals(RuleUtil.getName(event))) {"], "expectedMessage": ["public boolean matchRule(AuditEvent event, String ruleName, String expectedMessage, String expectedSeverity) {", "        if (expectedMessage != null) {", "            String msgWithoutSingleQuote = StringUtils.replace(expectedMessage, \"'\", \"\");", "            return expectedMessage.equals(event.getMessage()) || msgWithoutSingleQuote.equals(event.getMessage());"], "expectedSeverity": ["public boolean matchRule(AuditEvent event, String ruleName, String expectedMessage, String expectedSeverity) {", "        if (expectedSeverity != null) {", "            return expectedSeverity.equals(event.getSeverityLevel().getName());"]}
{"fromClusterName": ["private String createReceivedAtKey(String fromClusterName,", "\t\treturn KEY_PREFIX + fromClusterName + \"-\" + toClusterName"], "toClusterName": ["\t\tString toClusterName) {", "\t\treturn KEY_PREFIX + fromClusterName + \"-\" + toClusterName"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"timeout": ["public boolean waitFor(long timeout) {", "\t\t\t+ timeout);", "\t\tUtils.execute(connectionCheckTask, timeout);"]}
{"Result": "Method without Parameter"}
{"connected": ["public void printState(boolean connected) {", "\t\t\tif (connected) {"]}
{"args": ["public static void main(String[] args) {", "\t\t\tif (args.length != 7) {", "\t\t\tString cluster = args[0];", "\t\t\t\t.stringToProperties(args[1]);", "\t\t\tlong timeout = Long.parseLong(args[2]);", "\t\t\tString regionName = args[3];", "\t\t\tboolean debugEnabled = (\"true\".equals(args[4]) ? true : false);", "\t\t\tboolean quiet = (\"true\".equals(args[5]) ? true : false);", "\t\t\tlong processingStartedAt = Long.parseLong(args[6]);"]}
{"Result": "Method without Parameter"}
{"version": ["public short getVersionModelHashCode(int version) {", "            if (version == -1 || version >= field.getPropertyVersion()) {"]}
{"Result": "Method without Parameter"}
{"entriesKeysForPage": ["\tprivate List<V> getValues(List<Object> entriesKeysForPage) {", "\t\tif (entriesKeysForPage.isEmpty()) {", "\t\tMap<Object, V> entriesMap = queryRegion.getAll(entriesKeysForPage);", "\t\tList<V> entries = new ArrayList<V>(entriesKeysForPage.size());", "\t\tfor (Object key : entriesKeysForPage) {", "\t\t\tentries.add(entriesMap.get(key));"]}
{"force": ["\tprivate void prepareResultData(boolean force) throws QueryException {", "\t\tif (this.infoLoaded && !force) {", "\t\tif (!force) {"]}
{"resultKeys": ["private void storeResults(List<Object> resultKeys) {", "\t\tif (resultKeys.size() > queryLimit) {", "\t\t\tresultKeys = resultKeys.subList(0, queryLimit);", "\t\tfor (Object key : resultKeys) {", "\t\t\tpage.add(key);"]}
{"Result": "Method without Parameter"}
{"o1": ["    public int compare(final TagToCategory o1, final TagToCategory o2) {", "        if (o1 == null && o2 == null) return 0;", "        if (o1 == null) return lessThan;", "        if (o1.getSorting() == null && o2.getSorting() == null) return compareSecondLevel(o1, o2);", "        if (o1.getSorting() == null) return greaterThan;", "        if (o1.getSorting().equals(o2.getSorting())) return compareSecondLevel(o1, o2);", "        return o1.getSorting().compareTo(o2.getSorting()) * greaterThan;"], "o2": ["    public int compare(final TagToCategory o1, final TagToCategory o2) {", "        if (o1 == null && o2 == null) return 0;", "        if (o2 == null) return greaterThan;", "        if (o1.getSorting() == null && o2.getSorting() == null) return compareSecondLevel(o1, o2);", "        if (o2.getSorting() == null) return lessThan;", "        if (o1.getSorting().equals(o2.getSorting())) return compareSecondLevel(o1, o2);", "        return o1.getSorting().compareTo(o2.getSorting()) * greaterThan;"]}
{"preparedStmt": ["private void migrateBrokenLocales(final PreparedStatement preparedStmt, final Map<String, Integer> localeMap) throws SQLException {", "            migrateBrokenLocale(preparedStmt, localeMap, \"es_US\", enUSLocaleID);", "            migrateBrokenLocale(preparedStmt, localeMap, \"en_AU\", enUSLocaleID);", "            migrateBrokenLocale(preparedStmt, localeMap, \"ar\", enUSLocaleID);", "            migrateBrokenLocale(preparedStmt, localeMap, \"as\", enUSLocaleID);"], "localeMap": ["private void migrateBrokenLocales(final PreparedStatement preparedStmt, final Map<String, Integer> localeMap) throws SQLException {", "        final Integer enUSLocaleID = localeMap.get(\"en-US\");", "            migrateBrokenLocale(preparedStmt, localeMap, \"es_US\", enUSLocaleID);", "            migrateBrokenLocale(preparedStmt, localeMap, \"en_AU\", enUSLocaleID);", "            migrateBrokenLocale(preparedStmt, localeMap, \"ar\", enUSLocaleID);", "            migrateBrokenLocale(preparedStmt, localeMap, \"as\", enUSLocaleID);"]}
{"topic": ["public static boolean recalculateMinHash(final Topic topic, final List<MinHashXOR> minHashXORs) {", "        final Set<MinHash> existingMinHashes = topic.getMinHashes();", "        final Map<Integer, Integer> minHashes = getMinHashes(topic.getTopicXML(), minHashXORs);", "                topic.addMinHash(minHash);"], "minHashXORs": ["public static boolean recalculateMinHash(final Topic topic, final List<MinHashXOR> minHashXORs) {", "        final Map<Integer, Integer> minHashes = getMinHashes(topic.getTopicXML(), minHashXORs);", "        for (final Integer funcId : minHashes.keySet()) {", "                if (minHash.getMinHashFuncID().equals(funcId)) {", "                    if (!minHash.getMinHash().equals(minHashes.get(funcId))) {", "                        minHash.setMinHash(minHashes.get(funcId));", "                minHash.setMinHashFuncID(funcId);", "                minHash.setMinHash(minHashes.get(funcId));"]}
{"xml": ["public static Map<Integer, Integer> getMinHashes(final String xml, final List<MinHashXOR> minHashXORs) {", "        final String cleanedXML = cleanXMLForMinHash(xml);", "        final Integer baseMinHash = getMinHashInternal(cleanedXML, null);", "                    final Integer minHash = getMinHashInternal(cleanedXML, minHashXOR.getMinHashXOR());", "                    if (minHash != null) {", "                        retValue.put(funcId, minHash);"], "minHashXORs": ["public static Map<Integer, Integer> getMinHashes(final String xml, final List<MinHashXOR> minHashXORs) {", "            for (final MinHashXOR minHashXOR : minHashXORs) {", "                if (minHashXOR.getMinHashXORFuncId() == funcId) {", "                    final Integer minHash = getMinHashInternal(cleanedXML, minHashXOR.getMinHashXOR());", "                    if (minHash != null) {", "                        retValue.put(funcId, minHash);"]}
{"xml": ["protected static String cleanXMLForMinHash(final String xml) {", "        final String fixedXML = xml == null ? \"\" : xml;", "            final Document doc = XMLUtilities.convertStringToDocument(fixedXML);", "            if (doc != null) {", "                text = doc.getDocumentElement().getTextContent();", "            text = fixedXML.replaceAll(\"</?.*?/?>\", \" \");"]}
{"topic": ["public static void validateAndFixRelationships(final Topic topic) {", "        for (final TopicToTopic topicToTopic : topic.getParentTopicToTopics())", "            if (topicToTopic.getRelatedTopic().getTopicId().equals(topic.getTopicId())) removeList.add(topicToTopic);", "            topic.getParentTopicToTopics().remove(topicToTopic);", "        for (final TopicToTopic topicToTopic : topic.getChildTopicToTopics())", "            if (topicToTopic.getMainTopic().getTopicId().equals(topic.getTopicId())) removeChildList.add(topicToTopic);", "            topic.getChildTopicToTopics().remove(topicToTopic);"]}
{"topic": ["public static void updateContentHash(final Topic topic) {", "        if (topic.getTopicXML() != null) {", "            topic.setTopicContentHash(HashUtilities.generateSHA256(topic.getTopicXML()).toCharArray());"]}
{"topic": ["public static void validateAndFixTags(final Topic topic) {", "        for (final TopicToTag topicToTag : topic.getTopicToTags()) {", "            final Tag tag = topicToTag.getTag();", "            for (final TagToCategory tagToCategory : tag.getTagToCategories()) {", "                final Category category = tagToCategory.getCategory();", "                if (!tagDB.containsKey(category)) tagDB.put(category, new ArrayList<TagToCategory>());", "                tagDB.get(category).add(tagToCategory);", "                    for (final TopicToTag topicToTag : topic.getTopicToTags()) {", "                        if (topicToTag.getTag().equals(removeTag)) removeTopicToTagList.add(topicToTag);", "                        topic.getTopicToTags().remove(removeTopicToTag);", "                            topic.getTopicToTags()).size() != 0 && // make", "                                    topic.getTopicToTags()).size() != 0 && // make", "                        with(topic.getTopicToTags()).remove(having(on(TopicToTag.class).getTag(), equalTo(exclusionTag)));"]}
{"Result": "Method without Parameter"}
{"helper": ["    public final void execute(final EnforcerRuleHelper helper) throws EnforcerRuleException {", "            project = (MavenProject) helper.evaluate(\"${project}\");", "            performValidation(project, helper);"]}
{"toSplice": ["protected static List<String> splice(final String toSplice) {", "        final StringTokenizer tok = new StringTokenizer(toSplice, \",\", false);"]}
{"toSplice": ["protected static List<Pattern> splice2Pattern(final String toSplice) throws PatternSyntaxException {", "        for (final String current : splice(toSplice)) {", "            toReturn.add(Pattern.compile(current));"]}
{"source": ["protected static boolean containsPrefix(final List<String> source, final String toCheck) {", "        if (source != null) {", "            for (final String current : source) {", "                if (toCheck.startsWith(current)) {"], "toCheck": ["protected static boolean containsPrefix(final List<String> source, final String toCheck) {", "                if (toCheck.startsWith(current)) {"]}
{"factoryClass": ["private static Class<?extends ObjectFactory> getFactoryClass(Class<?> factoryClass) {", "        return factoryClasses.get(factoryClass);"]}
{"subject": ["public void send(String subject, String content) throws MessagingException {", "\t\tMimeMessage message = compose(subject, content,"], "content": ["public void send(String subject, String content) throws MessagingException {", "\t\tMimeMessage message = compose(subject, content,"]}
{"subject": ["public void send(String subject, String content, String to)", "\t\tMimeMessage message = compose(subject, content, to);"], "content": ["public void send(String subject, String content, String to)", "\t\tMimeMessage message = compose(subject, content, to);"], "to": ["public void send(String subject, String content, String to)", "\t\tMimeMessage message = compose(subject, content, to);", "\t\ttransport(message);"]}
{"pool": ["private int executeZeroFunction(Pool pool) throws FunctionException,", "\t\tResultCollector<?, ?> collector = FunctionService.onServer(pool)"]}
{"functionContext": ["    public void execute(FunctionContext functionContext) {", "\tResultSender<Serializable> resultSender = functionContext.getResultSender();", "\tRegionFunctionContext regionFunctionContext = (RegionFunctionContext) functionContext;", "\tif (functionContext.getArguments() == null) {", "\tif (!(functionContext.getArguments() instanceof BucketOrientedQueryFunctionArgument)) {", "\tBucketOrientedQueryFunctionArgument argument = (BucketOrientedQueryFunctionArgument) functionContext", "\tLocalDataSet localData = (LocalDataSet) PartitionRegionHelper.getLocalDataForContext(regionFunctionContext);", "\tQueryService queryService = localData.getCache().getQueryService();", "\t    SelectResults<?> result = (SelectResults<?>) localData.executeQuery((DefaultQuery) query,", "\t\t    argument.getQueryParameters(), localData.getBucketSet());"]}
{"e": ["    private void handleException(Throwable e, ResultSender<Serializable> resultSender, String queryString) {", "\tlogger.error(\"Failed to execute bucket oriented query\" + (queryString != null ? \": \" + queryString : \".\"), e);", "\tresultSender.sendException(new FunctionException(e.getMessage()));"], "resultSender": ["    private void handleException(Throwable e, ResultSender<Serializable> resultSender, String queryString) {", "\tresultSender.sendException(new FunctionException(e.getMessage()));"], "queryString": ["    private void handleException(Throwable e, ResultSender<Serializable> resultSender, String queryString) {", "\tlogger.error(\"Failed to execute bucket oriented query\" + (queryString != null ? \": \" + queryString : \".\"), e);"]}
{"selectResults": ["private List<Object> formatResults(SelectResults<?> selectResults) {", "\tList<Object> results = new ArrayList<Object>(selectResults.size() + 1);", "\tresults.addAll(selectResults.asList());", "\tresults.add(selectResults.getCollectionType().getElementType());"]}
{"message": ["    public final void addErrorMessage(final String message) {", "        if (message == null || \"\".equals(message)) {", "        errorMessages.add(message);"]}
{"Result": "Method without Parameter"}
{"host": ["public static boolean isSocketAlive(String host, int port) {", "\t    socket = new Socket(host, port);"], "port": ["public static boolean isSocketAlive(String host, int port) {", "\t    socket = new Socket(host, port);", "\t    socketAlive = socket.isConnected();", "\t    if (socket != null) {", "\t\t    socket.close();"]}
{"thread": ["public static void execute(Thread thread, long timeout) {", "\tthread.start();", "\t    thread.join(timeout);", "\tif (thread.isAlive()) {", "\t    thread.interrupt();"], "timeout": ["public static void execute(Thread thread, long timeout) {", "\t    thread.join(timeout);"]}
{"resources": ["private boolean hasResources(List<Resource> resources) {", "        for (Resource resource : resources) {", "            if (new File(resource.getDirectory()).exists()) {"]}
{"Result": "Method without Parameter"}
{"queryString": ["public static String addQueryLimit(String queryString, int queryLimit) {", "\t\tint limitIndex = queryString.lastIndexOf(\"limit\");", "\t\t\tlimitIndex = queryString.lastIndexOf(\"LIMIT\");", "\t\t\treturn queryString + \" LIMIT \" + (queryLimit + 1);", "\t\tint limitNumber = Integer.parseInt(queryString", "\t\treturn (limitNumber > queryLimit) ? queryString", "\t\t\t\t: queryString;"], "queryLimit": ["public static String addQueryLimit(String queryString, int queryLimit) {", "\t\t\treturn queryString + \" LIMIT \" + (queryLimit + 1);", "\t\treturn (limitNumber > queryLimit) ? queryString", "\t\t\t\t.substring(0, limitIndex) + \" LIMIT \" + (queryLimit + 1)"]}
{"locatorsString": ["\t\t\tString locatorsString) {", "\t\tif (locatorsString == null || locatorsString.length() == 0) {", "\t\tfirstLocator[0] = locatorsString.substring(0,", "\t\t\t\tlocatorsString.indexOf('[')).trim();", "\t\tlocatorsString = locatorsString", "\t\t\t\t.substring(locatorsString.indexOf('[') + 1);"]}
{"region": ["public static int getRegionSize(Region<?, ?> region) {", "\t\tResultCollector<?, ?> rc = FunctionService.onRegion(region)"]}
{"Result": "Method without Parameter"}
{"region": ["public static <K> void removeAll(Region<K, ?> region, Set<K> keys) {", "\t\tResultCollector<?, ?> rc = FunctionService.onRegion(region)", "\t\t\t\t.withFilter(keys).withArgs(region.getName()).execute(function);"], "keys": ["public static <K> void removeAll(Region<K, ?> region, Set<K> keys) {", "\t\tif (keys == null) {", "\t\tif (keys.isEmpty()) {", "\t\t\t\t.withFilter(keys).withArgs(region.getName()).execute(function);"]}
{"runnable": ["public static <T> T retryWithExponentialBackoff(Retryable<T> runnable,", "\t\t\t\treturn runnable.execute();"], "maxRetries": ["\t\t\tint maxRetries) throws InterruptedException,", "\t\twhile (retry < maxRetries) {"]}
{"in": ["protected void generateBufferedImage(TranscoderInput in, int w, int h) throws TranscoderException {", "        t.transcode(in, null);"], "w": ["protected void generateBufferedImage(TranscoderInput in, int w, int h) throws TranscoderException {", "        if (w != 0 && h != 0) {", "            t.setDimensions(w, h);"], "h": ["protected void generateBufferedImage(TranscoderInput in, int w, int h) throws TranscoderException {", "        if (w != 0 && h != 0) {", "            t.setDimensions(w, h);"]}
{"c": [], "g": ["    public void paintIcon(Component c, Graphics g, int x, int y) {", "        if (backgroundColour == null) g.drawImage(bufferedImage, x, y, null);", "        else g.drawImage(bufferedImage, x, y, backgroundColour, null);"], "x": ["    public void paintIcon(Component c, Graphics g, int x, int y) {", "        if (backgroundColour == null) g.drawImage(bufferedImage, x, y, null);", "        else g.drawImage(bufferedImage, x, y, backgroundColour, null);"], "y": ["    public void paintIcon(Component c, Graphics g, int x, int y) {", "        if (backgroundColour == null) g.drawImage(bufferedImage, x, y, null);", "        else g.drawImage(bufferedImage, x, y, backgroundColour, null);"]}
{"Result": "Method without Parameter"}
{"message": ["public static void waitForEnter(String message) {", "        System.out.println(message);"]}
{"args": ["public void execute(String[] args, boolean debugEnabled, boolean quiet) {", "\t\t\t\t+ Arrays.asList(args));", "\t\t\tparseCommandLineArguments(args);"], "debugEnabled": ["public void execute(String[] args, boolean debugEnabled, boolean quiet) {", "\t\t\tthis.debugEnabled = debugEnabled;", "\t\t\t\tregionName, debugEnabled, quiet);"], "quiet": ["public void execute(String[] args, boolean debugEnabled, boolean quiet) {", "\t\t\tProcessorTask task = new ProcessorTask(clustersProperties, timeout,", "\t\t\t\tregionName, debugEnabled, quiet);", "\t\t\tUtils.execute(task, timeout + DELTA_TIMEOUT);", "\t\t\tint exitCode = task.getExitCode();"]}
{"commandLineArguments": ["protected void parseCommandLineArguments(String[] commandLineArguments) {", "\t\tif (commandLineArguments.length < 1) {", "\t\t\tCommandLine line = parser.parse(options, commandLineArguments);", "\t\t\tif (line.hasOption(HELP_OPTION)) {", "\t\t\tif (line.hasOption(REGION_OPTION)) {", "\t\t\t\tregionName = line.getOptionValue(REGION_OPTION);", "\t\t\tif (line.hasOption(TIMEOUT_OPTION)) {", "\t\t\t\tString timeoutString = line.getOptionValue(TIMEOUT_OPTION);", "\t\t\tif (line.hasOption(CLUSTER_OPTION)) {", "\t\t\t\tclustersProperties = line.getOptionProperties(CLUSTER_OPTION);"]}
{"options": ["protected void printHelp(final Options options) {", "\t\tformatter.printHelp(\"check-replication [options]\", options);"]}
{"Result": "Method without Parameter"}
{"taskResults": ["private static void aggregateSingleClusterMemberData(List<ResultCollector> taskResults) {", "        for (ResultCollector singleCluster : taskResults) {", "            List membersResult = (List) singleCluster.getResult();", "            for (Object resultFromNode : membersResult) {", "                System.out.print(((HashMap) resultFromNode).get(\"ds\") + \":\");"]}
{"property": ["public ExpressionBuilder notNull(final Object property, final String name) {", "        if (property == null) {"], "name": ["public ExpressionBuilder notNull(final Object property, final String name) {", "            messageContainer.addErrorMessage(\"Property '\" + name + \"' cannot be null\");"]}
{"commandLineArguments": ["private static void parseCommandLineArguments(String[] commandLineArguments) {", "\t    CommandLine line = parser.parse(options, commandLineArguments);", "\t    if (line.hasOption(HELP_OPTION)) {", "\t    if (line.hasOption(DEBUG_OPTION)) {", "\t    if (!debugEnabled && line.hasOption(QUIET_OPTION)) {"]}
{"options": ["private static void printHelp(final Options options) {", "\tformatter.printHelp(sb.toString(), options);"]}
{"Result": "Method without Parameter"}
{"args": ["private static int findCommandIndex(String[] args) {", "\tfor (int i = 0; i < args.length; i++) {", "\t\tif (command.getName().equals(args[i].trim())) {"]}
{"args": ["private static String[] extractLauncherArgs(String[] args, int commandIndex) {", "\tSystem.arraycopy(args, 0, launcherArgs, 0, commandIndex);"], "commandIndex": ["private static String[] extractLauncherArgs(String[] args, int commandIndex) {", "\tString[] launcherArgs = new String[commandIndex];", "\tSystem.arraycopy(args, 0, launcherArgs, 0, commandIndex);", "\treturn launcherArgs;"]}
{"args": ["private static String[] extractCommandArgs(String[] args, int commandIndex) {", "\tString[] commandArgs = new String[args.length - commandIndex - 1];", "\tSystem.arraycopy(args, commandIndex + 1, commandArgs, 0, args.length - commandIndex - 1);"], "commandIndex": ["private static String[] extractCommandArgs(String[] args, int commandIndex) {", "\tString[] commandArgs = new String[args.length - commandIndex - 1];", "\tSystem.arraycopy(args, commandIndex + 1, commandArgs, 0, args.length - commandIndex - 1);"]}
{"args": ["public static void main(String[] args) {", "\t    int commandIndex = findCommandIndex(args);", "\t    if (commandIndex < 0) {", "\t    String[] launcherArgs = extractLauncherArgs(args, commandIndex);", "\t    String[] commandArgs = extractCommandArgs(args, commandIndex);", "\t    parseCommandLineArguments(launcherArgs);", "\t    debug(\"Launcher#main(): args = \" + Arrays.asList(args));", "\t    debug(\"Launcher#main(): launcherArgs = \" + Arrays.asList(launcherArgs));", "\t    debug(\"Launcher#main(): commandArgs = \" + Arrays.asList(commandArgs));", "\t    String commandName = args[commandIndex];", "\t    Executable tool = Command.getUtil(commandName);", "\t    if (tool != null) {", "\t\ttool.execute(commandArgs, debugEnabled, quiet);", "\t\tdebug(\"Launcher#main(): Command \\\"\" + commandName + \"\\\" not found\");"]}
{"message": ["private static void debug(String message, Throwable t) {", "\t    System.err.println(\"0 [Launcher] \" + message);"], "t": ["private static void debug(String message, Throwable t) {", "\t    if (t != null) {", "\t\tt.printStackTrace(System.err);"]}
{"Result": "Method without Parameter"}
{"regionNames": ["public Set<Region<?, ?>> createRegions(Map<String, String> regionNames) {", "\tfor (String regionPath : regionNames.keySet()) {", "\t    Region region = createRegion(regionPath, regionNames.get(regionPath));", "\t    regions.add(region);"]}
{"region": ["public long process(Region<?, ?> region, ExpirationPolicy policy) {", "\t\t\tif (region == null) {", "\t\t\t\t\t+ region", "\t\t\t\t.onRegion(region)", "\t\t\t\t\t+ region + \", policy = \" + policy + \", packetSize = \""], "policy": ["public long process(Region<?, ?> region, ExpirationPolicy policy) {", "\t\t\tif (policy == null) {", "\t\t\t\t\t+ policy", "\t\t\tDestroyedEntriesCountCollector collector = (DestroyedEntriesCountCollector) FunctionService", "\t\t\t\t.execute(new ExpirationFunction(policy));", "\t\t\tObject result = collector.getResult();", "\t\t\t\t\t+ region + \", policy = \" + policy + \", packetSize = \""]}
{"indentationToken": ["public final void setIndentationToken(final String indentationToken) {", "        if (indentationToken == null || indentationToken.isEmpty()) {", "        this.indentationToken = indentationToken;"]}
{"sourceFile": ["    public String getPackage(final File sourceFile) {", "        String aLine = getPackage(sourceFile, PACKAGE_STATEMENT);"]}
{"root": ["public static boolean start(final RootDoc root) {", "        final boolean toReturn = Standard.start(root);", "        eventSequence.add(\"start (root): \" + toReturn);", "        return toReturn;"]}
{"member": ["private Set<Integer> extractPortsSet(SystemMember member)", "\t\tSystemMemberCache cache = member.getCache();"]}
{"host": ["private Pool findOrCreatePool(String host, int port) {", "\t\tString poolName = Utils.toKey(host, port);", "\t\t\tpoolFactory.addServer(host, port);"], "port": ["private Pool findOrCreatePool(String host, int port) {", "\t\tString poolName = Utils.toKey(host, port);", "\t\tPool pool = PoolManager.find(poolName);", "\t\tif (pool == null) {", "\t\t\tpoolFactory.addServer(host, port);", "\t\t\tpool = poolFactory.create(poolName);", "\t\treturn pool;"]}
{"eventSrcName": ["public static String getName(String eventSrcName) {", "        if (eventSrcName == null) {", "        if (eventSrcName.endsWith(\"Check\")) {", "            eventSrcName = eventSrcName.substring(0, eventSrcName.length() - 5);", "        return eventSrcName.substring(eventSrcName.lastIndexOf('.') + 1);"]}
{"eventSrcName": ["public static String getCategory(String eventSrcName) {", "        if (eventSrcName == null) {", "        int end = eventSrcName.lastIndexOf('.');", "        eventSrcName = eventSrcName.substring(0, end);"]}
{"className": ["public static void enterFrame(String className) {", "        classNames.get().add(className);"]}
{"className": ["public static void exitFrame(String className) {", "        if (!className.equals(frameToExit)) {", "            throw new RuntimeException(\"Method frame counter try to exit from the class '\" + className"]}
{"Result": "Method without Parameter"}
{"packageExtractorImplementations": ["public final void setPackageExtractors(final String packageExtractorImplementations)", "        if(packageExtractorImplementations == null) {", "        for (String current : splice(packageExtractorImplementations)) {", "                final Class<?> aClass = getClass().getClassLoader().loadClass(current);", "                extractors.add((PackageExtractor) aClass.newInstance());", "                        + current + \"]. Validate that implementation has a default constructor, and implements the\""]}
{"fileOrDirectory": ["private void addPackages(final File fileOrDirectory,", "            if (fileOrDirectory.isFile() && sourceFileDefinitionFilter.accept(fileOrDirectory)) {", "                final String thePackage = current.getPackage(fileOrDirectory);", "                SortedSet<String> sourceFileNames = package2FileNamesMap.get(thePackage);", "                if (sourceFileNames == null) {", "                    package2FileNamesMap.put(thePackage, sourceFileNames);", "                sourceFileNames.add(fileOrDirectory.getName());", "            } else if (fileOrDirectory.isDirectory()) {", "                for (File currentChild : fileOrDirectory.listFiles(sourceFileDefinitionFilter)) {", "                    addPackages(currentChild, package2FileNamesMap);", "                for (File currentSubdirectory : fileOrDirectory.listFiles(DIRECTORY_FILTER)) {", "                    addPackages(currentSubdirectory, package2FileNamesMap);"], "package2FileNamesMap": ["                             final SortedMap<String, SortedSet<String>> package2FileNamesMap) {", "                SortedSet<String> sourceFileNames = package2FileNamesMap.get(thePackage);", "                if (sourceFileNames == null) {", "                    package2FileNamesMap.put(thePackage, sourceFileNames);", "                sourceFileNames.add(fileOrDirectory.getName());", "                    addPackages(currentChild, package2FileNamesMap);", "                    addPackages(currentSubdirectory, package2FileNamesMap);"]}
{"Result": "Method without Parameter"}
{"uiOriginalFileName": ["public void setUiOriginalFileName(final String uiOriginalFileName) {", "        this.uiOriginalFileName = uiOriginalFileName;", "        if (this.uiOriginalFileName != null && !this.uiOriginalFileName.isEmpty()) originalFileName = this.uiOriginalFileName;"]}
{"queryString": ["private static int extractLimit(String queryString) {", "\tint limitIndex = queryString.lastIndexOf(\"limit\");", "\t    limitIndex = queryString.lastIndexOf(\"LIMIT\");", "\tString limitValue = queryString.substring(limitIndex + 5);"]}
{"queryResults": ["    private static SelectResults<Object> formatSelectResults(List<List<Object>> queryResults, int limit) {", "\tfor (List<Object> queryResult : queryResults) {", "\t    ObjectType elementType = (ObjectType) queryResult.remove(queryResult.size() - 1);", "\t    if (baseElementType == null) {", "\t\tbaseElementType = elementType;", "\t    } else if (!baseElementType.equals(elementType)) {", "\t    list.addAll(queryResult);", "\treturn limit == -1 ? new ResultsCollectionWrapper(baseElementType, list) : new ResultsCollectionWrapper(", "\t\tbaseElementType, list, limit);"], "limit": ["    private static SelectResults<Object> formatSelectResults(List<List<Object>> queryResults, int limit) {", "\t    if (limit != -1 && list.size() >= limit) {", "\treturn limit == -1 ? new ResultsCollectionWrapper(baseElementType, list) : new ResultsCollectionWrapper(", "\t\tbaseElementType, list, limit);"]}
{"obj": ["private static void checkAllowedInRealTime0(Object obj, int depth) throws InvalidClassException {", "        Class<?> clazz = obj.getClass();", "            final int length = Array.getLength(obj);", "            for (int k = 0; k < length; k++) {", "                Object elem = Array.get(obj, k);", "                checkAllowedInRealTime0(elem, depth + 1);", "            for (Object elem : ((Collection) obj)) {", "                checkAllowedInRealTime0(elem, depth + 1);", "            for (Map.Entry<Object, Object> elem : ((Map<Object, Object>) obj).entrySet()) {", "                checkAllowedInRealTime0(elem.getKey(), depth + 1);", "                checkAllowedInRealTime0(elem.getValue(), depth + 1);"], "depth": ["private static void checkAllowedInRealTime0(Object obj, int depth) throws InvalidClassException {", "        if (depth >= MethodFrameCounter.MAX_STACK_DEPTH) { //todo: correct >? or >=?", "                checkAllowedInRealTime0(elem, depth + 1);", "                checkAllowedInRealTime0(elem, depth + 1);", "                checkAllowedInRealTime0(elem.getKey(), depth + 1);", "                checkAllowedInRealTime0(elem.getValue(), depth + 1);"]}
{"id": ["public Process runWithConfirmation(String id, Class<?> klass,", "\t\tProcess process = startProcess(id, klass, javaArguments, processArguments,"], "klass": ["public Process runWithConfirmation(String id, Class<?> klass,", "\t\tProcess process = startProcess(id, klass, javaArguments, processArguments,", "\t\twaitConfirmation(klass.getSimpleName(), process);", "\t\tnew StreamRedirector(process.getInputStream(), klass.getSimpleName()"], "javaArguments": ["\t\t\tString[] javaArguments, String[] processArguments)", "\t\tProcess process = startProcess(id, klass, javaArguments, processArguments,"], "processArguments": ["\t\t\tString[] javaArguments, String[] processArguments)", "\t\tProcess process = startProcess(id, klass, javaArguments, processArguments,", "\t\twaitConfirmation(klass.getSimpleName(), process);", "\t\tnew StreamRedirector(process.getInputStream(), klass.getSimpleName()", "\t\treturn process;"]}
{"klass": ["public Process runWithStartupDelay(Class<?> klass, String[] javaArguments,", "\t\treturn runWithStartupDelay(klass, javaArguments, processArguments,"], "javaArguments": ["public Process runWithStartupDelay(Class<?> klass, String[] javaArguments,", "\t\treturn runWithStartupDelay(klass, javaArguments, processArguments,"], "processArguments": ["\t\t\tString[] processArguments) throws IOException,", "\t\treturn runWithStartupDelay(klass, javaArguments, processArguments,"]}
{"klass": ["public Process runWithStartupDelay(Class<?> klass, String[] javaArguments,", "\t\tProcess process = runWithConfirmation(\"\", klass, javaArguments,"], "javaArguments": ["public Process runWithStartupDelay(Class<?> klass, String[] javaArguments,", "\t\tProcess process = runWithConfirmation(\"\", klass, javaArguments,"], "processArguments": ["\t\t\tString[] processArguments, long processStartupTime)", "\t\tProcess process = runWithConfirmation(\"\", klass, javaArguments,", "\t\t\t\tprocessArguments);", "\t\treturn process;"], "processStartupTime": ["\t\t\tString[] processArguments, long processStartupTime)", "\t\tif (processStartupTime > 0) {", "\t\t\tThread.sleep(processStartupTime);"]}
{"process": ["public void stopBySendingNewLineIntoProcess(Process process)", "\t\tif (process != null) {", "\t\t\t\t\tprocess.getOutputStream()));", "\t\t\tprocess.waitFor();"]}
{"id": ["private Process startProcess(String id, Class<?> klass, String[] javaArguments,", "\t\tredirectProcessStreams(id, klass, process, !withConfirmation);"], "klass": ["private Process startProcess(String id, Class<?> klass, String[] javaArguments,", "\t\tList<String> arguments = createCommandLineForProcess(klass,", "\t\tredirectProcessStreams(id, klass, process, !withConfirmation);"], "javaArguments": ["private Process startProcess(String id, Class<?> klass, String[] javaArguments,", "\t\t\t\tjavaArguments, processArguments);"], "processArguments": ["\t\t\tString[] processArguments, boolean withConfirmation)", "\t\tList<String> arguments = createCommandLineForProcess(klass,", "\t\t\t\tjavaArguments, processArguments);", "\t\tProcess process = new ProcessBuilder(arguments).start();"], "withConfirmation": ["\t\t\tString[] processArguments, boolean withConfirmation)", "\t\tredirectProcessStreams(id, klass, process, !withConfirmation);"]}
{"id": ["private void redirectProcessStreams(String id, Class<?> klass, Process process,", "\t\tString errorStreamType = (printType ? klass.getSimpleName() + id", "\t\t\tString outputStreamType = (printType ? klass.getSimpleName() + id"], "klass": ["private void redirectProcessStreams(String id, Class<?> klass, Process process,", "\t\tString errorStreamType = (printType ? klass.getSimpleName() + id", "\t\t\tString outputStreamType = (printType ? klass.getSimpleName() + id"], "process": ["private void redirectProcessStreams(String id, Class<?> klass, Process process,", "\t\tnew StreamRedirector(process.getErrorStream(), errorStreamType,", "\t\t\tnew StreamRedirector(process.getInputStream(), outputStreamType,"], "redirectProcessStdOut": ["\t\t\tboolean redirectProcessStdOut) {", "\t\tif (redirectProcessStdOut) {"]}
{"className": ["private void waitConfirmation(String className, Process process)", "\t\t\t\t\t\t+ className + \")...\");", "\t\t\t\tSystem.out.println(\"The process (\" + className", "\t\t\t\tSystem.out.println(className + PROCESS_STDOUT_STREAM_PREFIX", "\t\t\t\t\t\t+ className"], "process": ["private void waitConfirmation(String className, Process process)", "\t\t\t\tnew InputStreamReader(process.getInputStream()));"]}
{"outputFilename": ["public void generate( String outputFilename, String template, Context context )", "            File f = new File( outputFilename );", "            if ( !f.getParentFile().exists() )", "                f.getParentFile().mkdirs();", "            writer = new FileWriter( f );", "            getVelocity().getEngine().mergeTemplate( templateDirectory + \"/\" + template, context, writer );", "            if ( writer != null )", "                writer.flush();", "                writer.close();", "                getLog().debug( \"File \" + outputFilename + \" created...\" );"], "template": ["public void generate( String outputFilename, String template, Context context )", "            getVelocity().getEngine().mergeTemplate( templateDirectory + \"/\" + template, context, writer );", "            throw new ResourceNotFoundException( \"Template not found: \" + templateDirectory + \"/\" + template, e );"], "context": ["public void generate( String outputFilename, String template, Context context )", "            getVelocity().getEngine().mergeTemplate( templateDirectory + \"/\" + template, context, writer );"]}
{"Result": "Method without Parameter"}
{"clazz": ["public static boolean isA(Class clazz, ParameterizedType pType) {\r", "        return clazz.isAssignableFrom((Class) pType.getRawType());\r"], "pType": ["public static boolean isA(Class clazz, ParameterizedType pType) {\r", "        return clazz.isAssignableFrom((Class) pType.getRawType());\r"]}
{"method": ["public static boolean isCompatible(Method method, Method intfMethod) {\r", "        if (method == intfMethod)\r", "        if (!method.getName().equals(intfMethod.getName()))\r", "        if (method.getParameterTypes().length != intfMethod.getParameterTypes().length)\r", "        for (int i = 0; i < method.getParameterTypes().length; i++) {\r", "            Class rootParam = method.getParameterTypes()[i];\r", "            if (!intfParam.isAssignableFrom(rootParam))\r"], "intfMethod": ["public static boolean isCompatible(Method method, Method intfMethod) {\r", "        if (method == intfMethod)\r", "        if (!method.getName().equals(intfMethod.getName()))\r", "        if (method.getParameterTypes().length != intfMethod.getParameterTypes().length)\r", "            Class intfParam = intfMethod.getParameterTypes()[i];\r", "            if (!intfParam.isAssignableFrom(rootParam))\r"]}
{"clazz": ["public static Method getImplementingMethod(Class clazz, Method intfMethod) {\r", "        if (declaringClass.equals(clazz))\r", "            Type[] intfTypes = findParameterizedTypes(clazz, declaringClass);\r", "            return clazz.getMethod(intfMethod.getName(), paramTypes);\r", "            Method tmp = clazz.getMethod(intfMethod.getName(), intfMethod.getParameterTypes());\r"], "intfMethod": ["public static Method getImplementingMethod(Class clazz, Method intfMethod) {\r", "        Class<?> declaringClass = intfMethod.getDeclaringClass();\r", "            return intfMethod;\r", "        Class[] paramTypes = intfMethod.getParameterTypes();\r", "            Type[] paramGenericTypes = intfMethod.getGenericParameterTypes();\r", "            return clazz.getMethod(intfMethod.getName(), paramTypes);\r", "            Method tmp = clazz.getMethod(intfMethod.getName(), intfMethod.getParameterTypes());\r", "        return intfMethod;\r"]}
{"genericType": ["public static Class<?> getTypeArgument(Type genericType) {\r", "        if (!(genericType instanceof ParameterizedType))\r", "        ParameterizedType parameterizedType = (ParameterizedType) genericType;\r", "        Class<?> typeArg = (Class<?>) parameterizedType.getActualTypeArguments()[0];\r"]}
{"root": ["public static Type resolveTypeVariable(Class<?> root, TypeVariable<?> typeVariable) {\r", "            Type[] types = findParameterizedTypes(root, classDeclaringTypeVariable);\r"], "typeVariable": ["public static Type resolveTypeVariable(Class<?> root, TypeVariable<?> typeVariable) {\r", "        if (typeVariable.getGenericDeclaration() instanceof Class<?>) {\r", "            Class<?> classDeclaringTypeVariable = (Class<?>) typeVariable.getGenericDeclaration();\r", "                if (tv.equals(typeVariable)) {\r"]}
{"classToSearch": ["public static Type[] getActualTypeArgumentsOfAnInterface(Class<?> classToSearch, Class<?> interfaceToFind) {\r", "        Type[] types = findParameterizedTypes(classToSearch, interfaceToFind);\r"], "interfaceToFind": ["public static Type[] getActualTypeArgumentsOfAnInterface(Class<?> classToSearch, Class<?> interfaceToFind) {\r", "        Type[] types = findParameterizedTypes(classToSearch, interfaceToFind);\r", "        if (types == null)\r", "            throw new RuntimeException(\"Unable to find type arguments of \" + interfaceToFind);\r", "        return types;\r"]}
{"Result": "Method without Parameter"}
{"method": ["private void addReturnOptionDescription(Method method, Return.ReturnBuilder returnBuilder) {", "        DocReturn returnAnno = getNonExceptionDocReturn(method);", "        String returnOptionDesc = (returnAnno == null) ? null : returnAnno.description();", "        returnBuilder.description(StringUtils.isEmpty(returnOptionDesc) ? null : returnAnno.description());"], "returnBuilder": ["private void addReturnOptionDescription(Method method, Return.ReturnBuilder returnBuilder) {", "        returnBuilder.description(StringUtils.isEmpty(returnOptionDesc) ? null : returnAnno.description());"]}
{"pool": ["private void returnObject(ObjectPool<Classifier> pool, Classifier object) {", "            pool.returnObject(object);"], "object": ["private void returnObject(ObjectPool<Classifier> pool, Classifier object) {", "            pool.returnObject(object);"]}
{"destinationName": ["private Destination getDestination(final String destinationName) {", "        if (!destinations.containsKey(destinationName)) {", "            Destination destination = destinationSupplier.apply(destinationName);", "            destinations.put(destinationName, destination);", "        return destinations.get(destinationName);"]}
{"destinationName": ["private MessageConsumer getConsumer(final String destinationName) {", "        if (!consumers.containsKey(destinationName)) {", "            Destination destination = getDestination(destinationName);", "                MessageConsumer consumer = session.createConsumer(destination);", "                consumers.put(destinationName, consumer);", "                        + destinationName, e);", "        return consumers.get(destinationName);"]}
{"destinationName": ["private MessageProducer getProducer(final String destinationName) {", "        if (!producers.containsKey(destinationName)) {", "            Destination destination = getDestination(destinationName);", "                producer = session.createProducer(destination);", "                        + destinationName, e);", "            producers.put(destinationName, producer);", "        return producers.get(destinationName);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"destinationName": ["public void sendTextMessageWithDestination(final String destinationName, final String messageContent) {", "            throw new JmsNotConnectedException(\"JMS connection is down \" + destinationName);", "        final MessageProducer producer = getProducer(destinationName);", "            producer.send(message);", "            throw new JmsException(\"Unable to send message to \" + destinationName, e);"], "messageContent": ["public void sendTextMessageWithDestination(final String destinationName, final String messageContent) {", "            TextMessage message = session.createTextMessage(messageContent);", "            producer.send(message);"]}
{"destinationName": ["public void listenTextMessagesWithDestination(final String destinationName,", "        final MessageConsumer consumer = getConsumer(destinationName);", "            consumer.setMessageListener(message -> {", "                    throw new JmsException(\"Unable to register get text from message in listener \" + destinationName, e);", "                    throw new IllegalStateException(\"Unable handle JMS Consumer  \" + destinationName, ex);", "            throw new JmsException(\"Unable to register message listener \" + destinationName, e);"], "messageListener": ["                                                  final Consumer<String> messageListener) {", "                    messageListener.accept("]}
{"destinationName": ["public String receiveTextMessageFromDestinationWithTimeout(final String destinationName, final int timeout) {", "        MessageConsumer consumer = getConsumer(destinationName);", "                message = (TextMessage) consumer.receiveNoWait();", "                message = (TextMessage) consumer.receive(timeout);", "            throw new JmsException(\"Unable to receive message from \" + destinationName, e);"], "timeout": ["public String receiveTextMessageFromDestinationWithTimeout(final String destinationName, final int timeout) {", "            if (timeout == 0) {", "                message = (TextMessage) consumer.receive(timeout);", "            if (message != null) {", "                    message.acknowledge();", "                return message.getText();"]}
{"Result": "Method without Parameter"}
{"loadedUser": ["private void handleLoadFromUserDataService(final User loadedUser,", "            List<Recommendation> recommendations = runRulesEngineAgainstUser(loadedUser);", "            recommendationsCallback.accept(recommendations);"], "recommendationsCallback": ["                                               final Callback<List<Recommendation>> recommendationsCallback) {", "            recommendationsCallback.accept(recommendations);"]}
{"Result": "Method without Parameter"}
{"id": ["public void setId(UUID id) {", "        this.id = id;", "        this.modelConfig.setProperty(ID, id.toString());"]}
{"model": ["public void setModel(File model) {", "        this.model = model;", "        this.modelConfig.setProperty(MODEL_FILE, model.getAbsolutePath());"]}
{"wekaModelConfig": ["public void addOrUpdate(WekaModelConfig wekaModelConfig) throws FOSException {", "        checkNotNull(wekaModelConfig, \"Model config cannot be null\");", "        WekaThreadSafeScorer newWekaThreadSafeScorer = new WekaThreadSafeScorerPool(wekaModelConfig, wekaManagerConfig);", "        WekaThreadSafeScorer oldWekaThreadSafeScorer = quickSwitch(wekaModelConfig.getId(), newWekaThreadSafeScorer);"]}
{"modelId": ["public void removeModel(UUID modelId) {", "        WekaThreadSafeScorer oldWekaThreadSafeScorer = quickSwitch(modelId, newWekaThreadSafeScorer);"]}
{"eventBusCluster": ["                                                          EventBusCluster eventBusCluster) {", "        if (eventBusCluster == null) {", "        return eventBusCluster.eventServiceQueue();"]}
{"eventConnectorHub": ["    public EventManager clusteredEventManagerImpl(final EventConnectorHub eventConnectorHub) {", "                .setEventConnector(eventConnectorHub)"]}
{"string": ["public static String encodeNonCodes(String string) {\r", "        Matcher matcher = nonCodes.matcher(string);\r", "        while (matcher.find(idx)) {\r", "            int start = matcher.start();\r", "            buf.append(string.substring(idx, start));\r", "            idx = start + 1;\r", "        buf.append(string.substring(idx));\r"]}
{"map": ["public static MultivaluedMap<String, String> decode(MultivaluedMap<String, String> map) {\r", "        for (Map.Entry<String, List<String>> entry : map.entrySet()) {\r", "            List<String> values = entry.getValue();\r", "            for (String value : values) {\r", "                    decoded.add(URLDecoder.decode(entry.getKey(), UTF_8), URLDecoder.decode(value, UTF_8));\r"]}
{"resourceClasses": ["public ServiceGroup createServiceGroup(Set<ResourceClass> resourceClasses, ServiceGroup.ServiceGroupBuilder serviceGroupBuilder) {", "        for (ResourceClass resourceClass : resourceClasses) {", "            Logger.info(\"{0} processing started\", resourceClass.getClazz().getCanonicalName());", "            Service service = createResource(resourceClass);", "            serviceGroupBuilder.service(service);", "            Logger.info(\"{0} processing finished\", resourceClass.getClazz().getCanonicalName());"], "serviceGroupBuilder": ["public ServiceGroup createServiceGroup(Set<ResourceClass> resourceClasses, ServiceGroup.ServiceGroupBuilder serviceGroupBuilder) {", "            serviceGroupBuilder.service(service);", "        return serviceGroupBuilder.build();"]}
{"Result": "Method without Parameter"}
{"event": ["    public void forwardEvent(final EventTransferObject<Object> event) {", "                return event.channel();", "                return event.id();", "                return event.body();", "                return event.params();", "                return event.headers();", "                return event.equals(obj);", "                return event.hashCode();"]}
{"method": ["public static Annotation[] getResourcesAnnotations(Method method) {", "        for (Annotation annotation : method.getDeclaringClass().getAnnotations()) {", "            annotations.put(annotation.getClass(), annotation);", "        for (Annotation annotation : method.getAnnotations()) {", "            annotations.put(annotation.getClass(), annotation);"]}
{"type": ["public static <T extends Annotation> T findAnnotation(Class<?> type, Annotation[] annotations, Class<T> annotation) {", "            config = type.getAnnotation(annotation);"], "annotations": ["public static <T extends Annotation> T findAnnotation(Class<?> type, Annotation[] annotations, Class<T> annotation) {", "        T config = FindAnnotation.findAnnotation(annotations, annotation);"], "annotation": ["public static <T extends Annotation> T findAnnotation(Class<?> type, Annotation[] annotations, Class<T> annotation) {", "        T config = FindAnnotation.findAnnotation(annotations, annotation);", "        if (config == null) {", "            config = type.getAnnotation(annotation);", "        return config;"]}
{"annotatedResourceClass": ["public static ResourceConstructor constructor(Class<?> annotatedResourceClass) {\r", "        Constructor constructor = PickConstructor.pickPerRequestConstructor(annotatedResourceClass);\r", "        if (constructor == null) {\r", "            throw new RuntimeException(\"Could not find constructor for class: \" + annotatedResourceClass.getName());\r", "        ResourceConstructorBuilder builder = rootResource(annotatedResourceClass).constructor(constructor);\r", "        if (constructor.getParameterTypes() != null) {\r", "            for (int i = 0; i < constructor.getParameterTypes().length; i++)\r", "                builder.param(i).fromAnnotations();\r", "        return builder.buildConstructor().buildClass().getConstructor();\r"]}
{"clazz": ["public static ResourceClass rootResourceFromAnnotations(Class<?> clazz) {\r", "        ResourceClass resourceClass = fromAnnotations(false, clazz);\r", "        return resourceClass;\r"]}
{"bagging": ["public static void setupBaggingClassifiers(IteratedSingleClassifierEnhancer bagging) throws Exception {", "        bagging.m_Classifiers = Classifier.makeCopies(bagging.m_Classifier, bagging.m_NumIterations);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"file": ["public void write(File file) throws IOException {", "        checkNotNull(file, \"Output file cannot be null\");", "        FileUtils.writeByteArrayToFile(file, serializedObject);"]}
{"classDistribution": ["public static String leafScoreFromDistribution(double[] classDistribution, Instances instances) {", "        if (classDistribution != null) {", "            sum = Utils.sum(classDistribution);", "            maxIndex = Utils.maxIndex(classDistribution);", "            maxCount = classDistribution[maxIndex];", "        return instances.classAttribute().value(maxIndex);"], "instances": ["public static String leafScoreFromDistribution(double[] classDistribution, Instances instances) {", "        return instances.classAttribute().value(maxIndex);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"jacksonType": ["public Type getType(SimpleType jacksonType) {", "            String signature = JacksonSignature.createSignature(jacksonType);", "            CustomType type = new CustomType(jacksonType.getRawClass().getName(), signature, jacksonType.getRawClass());", "            if (cache.containsKey(signature)) {", "                return cache.get(signature);", "            cache.put(signature, type);", "            ObjectWriter objectWriter = objectMapper.writerFor(jacksonType);", "            Field prefetchField = objectWriter.getClass().getDeclaredField(\"_prefetch\");", "            ObjectWriter.Prefetch prefetch = (ObjectWriter.Prefetch) prefetchField.get(objectWriter);", "            doIntrospection(prefetch.valueSerializer, type);"]}
{"type": ["public Type getType(JavaType type) {", "        if (type instanceof SimpleType) {", "            return getType((SimpleType) type);", "        } else if (type instanceof CollectionType) {", "            return getType((CollectionLikeType) type);", "        } else if (type instanceof ArrayType) {", "            return getType((ArrayType) type);", "        } else if (type instanceof MapLikeType) {", "            return getType((MapLikeType) type);", "        throw new RuntimeException(\"Unimplemented Jackson type: \" + type);"]}
{"serializer": ["private void doIntrospection(JsonSerializer serializer, Type type) {", "        if (serializer == null) {", "        if (EnumSerializer.class.isAssignableFrom(serializer.getClass())) {", "            introspectSerializer((EnumSerializer) serializer, (CustomType) type);", "        } else if (BeanSerializerBase.class.isAssignableFrom(serializer.getClass())) {", "            introspectSerializer((BeanSerializerBase) serializer, (CustomType) type);", "        } else if (StdScalarSerializer.class.isAssignableFrom(serializer.getClass())) {", "            introspectSerializer((StdScalarSerializer) serializer, (CustomType) type);", "        } else if (AsArraySerializerBase.class.isAssignableFrom(serializer.getClass())) {", "            introspectSerializer((AsArraySerializerBase) serializer, (CollectionTypeJrapidoc) type);", "        } else if (MapSerializer.class.isAssignableFrom(serializer.getClass())) {", "            introspectSerializer((MapSerializer) serializer, (MapTypeJrapidoc) type);"], "type": ["private void doIntrospection(JsonSerializer serializer, Type type) {", "            introspectSerializer((EnumSerializer) serializer, (CustomType) type);", "            introspectSerializer((BeanSerializerBase) serializer, (CustomType) type);", "            introspectSerializer((StdScalarSerializer) serializer, (CustomType) type);", "            introspectSerializer((AsArraySerializerBase) serializer, (CollectionTypeJrapidoc) type);", "            introspectSerializer((MapSerializer) serializer, (MapTypeJrapidoc) type);"]}
{"beanSerializer": ["private void introspectSerializer(BeanSerializerBase beanSerializer, CustomType type) {", "            Field propsField = beanSerializer.getClass().getSuperclass().getDeclaredField(\"_props\");", "            BeanPropertyWriter[] props = (BeanPropertyWriter[]) propsField.get(beanSerializer);", "            for (BeanPropertyWriter prop : props) {", "                JavaType propType = prop.getType();", "                getType(propType);", "                String signature = JacksonSignature.createSignature(propType);", "                type.addBeanProperty(new BeanProperty(prop.getName(), signature, prop.getPropertyType(), prop.getMetadata().getDescription(), prop"], "type": ["private void introspectSerializer(BeanSerializerBase beanSerializer, CustomType type) {", "                type.addBeanProperty(new BeanProperty(prop.getName(), signature, prop.getPropertyType(), prop.getMetadata().getDescription(), prop"]}
{"enumSerializer": ["private void introspectSerializer(EnumSerializer enumSerializer, CustomType type) {", "        for (SerializableString value : enumSerializer.getEnumValues().values()) {", "            type.addEnumeration(value.getValue());"], "type": ["private void introspectSerializer(EnumSerializer enumSerializer, CustomType type) {", "            type.addEnumeration(value.getValue());"]}
{"mapSerializer": ["private void introspectSerializer(MapSerializer mapSerializer, MapTypeJrapidoc type) {", "            Field keyTypeField = mapSerializer.getClass().getDeclaredField(\"_keyType\");", "            JavaType keyType = (JavaType) keyTypeField.get(mapSerializer);", "            JavaType valueType = mapSerializer.getContentType();", "            getType(keyType);"], "type": []}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"args": []}
{"number": ["public String makeLastName(int number) {", "\t\tif (number < 0 && number > TpccConstants.NUM_DISTINCT_CLAST - 1)", "\t\tint indicies[] = { number / 100, (number / 10) % 10, number % 10 };"]}
{"Result": "Method without Parameter"}
{"in": ["public static File getRelativePath(File in, File repositoryPath) throws JavaGitException {", "    String path = in.getPath();", "    String absolutePath = in.getAbsolutePath();"], "repositoryPath": ["public static File getRelativePath(File in, File repositoryPath) throws JavaGitException {", "      String workingTreePath = repositoryPath.getAbsolutePath();"]}
{"Result": "Method without Parameter"}
{"comment": ["public GitCommitResponse commit(String comment) throws IOException, JavaGitException {", "    return gitCommit.commitOnly(workingTree.getPath(), comment, list);"]}
{"dest": ["public GitMvResponse mv(File dest) throws IOException, JavaGitException {", "    File relativeDest = getRelativePath(dest, workingTree.getPath());", "    file = dest;"]}
{"Result": "Method without Parameter"}
{"file": ["public static void checkFileValidity(File file) throws IOException {", "    if (!file.exists()) {", "          + file.getName() + \"] }\");"]}
{"l1": ["public static boolean checkUnorderedListsEqual(List<?> l1, List<?> l2) {", "    if (null == l1 && null != l2) {", "    if (null != l1 && null == l2) {", "    if (l1.size() != l2.size()) {", "    for (Object o : l1) {", "      if (!l2.contains(o)) {", "      if (!l1.contains(o)) {"], "l2": ["public static boolean checkUnorderedListsEqual(List<?> l1, List<?> l2) {", "    if (null == l1 && null != l2) {", "    if (null != l1 && null == l2) {", "    if (l1.size() != l2.size()) {", "      if (!l2.contains(o)) {", "    for (Object o : l2) {", "      if (!l1.contains(o)) {"]}
{"index": ["public static void checkIntInRange(int index, int start, int end) {", "    if (index < start) {", "          + index + \"], start=[\" + start + \"], end=[\" + end + \"] }\");", "    if (index >= end) {", "          + index + \"], start=[\" + start + \"], end=[\" + end + \"] }\");"], "start": ["public static void checkIntInRange(int index, int start, int end) {", "    if (index < start) {", "          + index + \"], start=[\" + start + \"], end=[\" + end + \"] }\");", "          + index + \"], start=[\" + start + \"], end=[\" + end + \"] }\");"], "end": ["public static void checkIntInRange(int index, int start, int end) {", "          + index + \"], start=[\" + start + \"], end=[\" + end + \"] }\");", "    if (index >= end) {", "          + index + \"], start=[\" + start + \"], end=[\" + end + \"] }\");"]}
{"clientType": ["public IClient getClientInstance(ClientType clientType) {", "    IClient clientInstance = clientImpls.get(clientType);", "    if (null == clientInstance) {", "      if (ClientType.CLI == clientType) {", "      if (null != clientInstance) {", "        clientImpls.put(clientType, clientInstance);", "    return clientInstance;"]}
{"preferredClientType": ["public void setPreferredClientType(ClientType preferredClientType) {", "    if (null == preferredClientType) {", "      this.preferredClientType = preferredClientType;"]}
{"repositoryPath": ["public GitAddResponse add(File repositoryPath, GitAddOptions options, List<File> paths)", "        CheckUtilities.checkFileValidity(repositoryPath);", "        List<String> command = buildCommand(repositoryPath, options, paths);", "        GitAddResponseImpl response = (GitAddResponseImpl) ProcessUtilities.runCommand(repositoryPath,"], "options": ["public GitAddResponse add(File repositoryPath, GitAddOptions options, List<File> paths)", "        List<String> command = buildCommand(repositoryPath, options, paths);", "        if (options != null) {", "            addDryRun(options, response);"], "paths": ["public GitAddResponse add(File repositoryPath, GitAddOptions options, List<File> paths)", "        List<String> command = buildCommand(repositoryPath, options, paths);", "                command, parser);"]}
{"repositoryPath": ["public GitAddResponse add(File repositoryPath, List<File> files) throws JavaGitException,", "        return add(repositoryPath, options, files);"], "files": ["public GitAddResponse add(File repositoryPath, List<File> files) throws JavaGitException,", "        return add(repositoryPath, options, files);"]}
{"repositoryPath": ["public GitAddResponse add(File repositoryPath, File file) throws JavaGitException, IOException {", "        return add(repositoryPath, options, filePaths);"], "file": ["public GitAddResponse add(File repositoryPath, File file) throws JavaGitException, IOException {", "        filePaths.add(file);"]}
{"repositoryPath": ["public GitAddResponse add(File repositoryPath, GitAddOptions options, File file)", "        return add(repositoryPath, options, paths);"], "options": ["public GitAddResponse add(File repositoryPath, GitAddOptions options, File file)", "        return add(repositoryPath, options, paths);"], "file": ["public GitAddResponse add(File repositoryPath, GitAddOptions options, File file)", "        paths.add(file);"]}
{"repositoryPath": ["public GitAddResponse addDryRun(File repositoryPath, List<File> paths) throws JavaGitException,", "        return add(repositoryPath, options, paths);"], "paths": ["public GitAddResponse addDryRun(File repositoryPath, List<File> paths) throws JavaGitException,", "        return add(repositoryPath, options, paths);"]}
{"repositoryPath": ["public GitAddResponse addVerbose(File repositoryPath, List<File> paths) throws JavaGitException,", "        return add(repositoryPath, options, paths);"], "paths": ["public GitAddResponse addVerbose(File repositoryPath, List<File> paths) throws JavaGitException,", "        return add(repositoryPath, options, paths);"]}
{"repositoryPath": ["public GitAddResponse addWithForce(File repositoryPath, List<File> paths)", "        return add(repositoryPath, options, paths);"], "paths": ["public GitAddResponse addWithForce(File repositoryPath, List<File> paths)", "        return add(repositoryPath, options, paths);"]}
{"options": ["private void addDryRun(GitAddOptions options, GitAddResponseImpl response) {", "        if (options.dryRun()) {"], "response": ["private void addDryRun(GitAddOptions options, GitAddResponseImpl response) {", "            response.setDryRun(true);"]}
{"that": ["private int compareToReleaseMinor(GitVersion that) {", "        if (this.containsReleaseMinor() && that.containsReleaseMinor())", "            return compareToInt(this.getReleaseMinor(), that.getReleaseMinor());", "        else if (!this.containsReleaseMinor() && !that.containsReleaseMinor())", "        else if (this.containsReleaseMinor() && !that.containsReleaseMinor())"]}
{"repositoryPath": ["public GitAddResponse add(File repositoryPath, GitAddOptions options, List<File> paths)", "    CheckUtilities.checkFileValidity(repositoryPath.getAbsoluteFile());", "    return gitAdd.add(repositoryPath, options, paths);"], "options": ["public GitAddResponse add(File repositoryPath, GitAddOptions options, List<File> paths)", "    return gitAdd.add(repositoryPath, options, paths);"], "paths": ["public GitAddResponse add(File repositoryPath, GitAddOptions options, List<File> paths)", "    return gitAdd.add(repositoryPath, options, paths);"]}
{"repositoryPath": ["public GitAddResponse addVerbose(File repositoryPath, List<File> paths) throws IOException,", "    return gitAdd.addVerbose(repositoryPath, paths);"], "paths": ["public GitAddResponse addVerbose(File repositoryPath, List<File> paths) throws IOException,", "    return gitAdd.addVerbose(repositoryPath, paths);"]}
{"repository": ["protected GitCommitResponseImpl commitProcessor(File repository, GitCommitOptions options,", "        CheckUtilities.checkNullArgument(repository, \"repository\");", "        GitCommitParser parser = new GitCommitParser(repository.getAbsolutePath());", "        return (GitCommitResponseImpl) ProcessUtilities.runCommand(repository, commandLine, parser);"], "options": ["protected GitCommitResponseImpl commitProcessor(File repository, GitCommitOptions options,", "        List<String> commandLine = buildCommand(options, message, paths);"], "message": ["                                                    String message, List<File> paths) throws IOException, JavaGitException {", "        CheckUtilities.checkStringArgument(message, \"message\");", "        List<String> commandLine = buildCommand(options, message, paths);"], "paths": ["                                                    String message, List<File> paths) throws IOException, JavaGitException {", "        List<String> commandLine = buildCommand(options, message, paths);", "        return (GitCommitResponseImpl) ProcessUtilities.runCommand(repository, commandLine, parser);"]}
{"path": ["public static void setGitPath(File path) throws IOException, JavaGitException {", "    if (path != null) {", "      CheckUtilities.checkFileValidity(path);", "      if (!(path.isDirectory())) {", "            + path.getPath() + \"] }\");", "       determineGitVersion(path);", "          + path.getPath() + \"] }\", e);", "    gitPath = (path != null) ? path.getAbsoluteFile() : null;"]}
{"method": ["private static List<IParameter> createList(Method method) {", "    Class<?> paramTypes[] = method.getParameterTypes();", "    Annotation[][] methodAnnotations = method.getParameterAnnotations();"]}
{"functionOffset": ["public int[] getFunctionDefinitionArray(int functionOffset, int maxParams, int returnType) {", "    definition[0] = functionOffset;", "    for (int i = 0; i < fullParamCount; i++) {"], "maxParams": ["public int[] getFunctionDefinitionArray(int functionOffset, int maxParams, int returnType) {", "    int[] definition = new int[maxParams + EXTRA_FUNC_DEF_VALUES];", "    if (paramCount > maxParams) {", "          + \"max parameter count \" + maxParams + \" is smaller than real param count \" + paramCount);"], "returnType": ["public int[] getFunctionDefinitionArray(int functionOffset, int maxParams, int returnType) {", "    definition[definition.length - 1] = returnType;", "    return definition;"]}
{"ws": ["public Object[] getValueArray(Workspace ws, DataBinder binder, ExecutionContext ctx) {", "    for (int i = 0; i < this.parameters.size(); i++) {", "          paramArray[i] = ws;", "        SystemUtils.trace(\"twine\", \"getArgumentValue failed on parameter \" + (i + 1) + \": \" + e.getMessage());", "    return paramArray;"], "binder": ["public Object[] getValueArray(Workspace ws, DataBinder binder, ExecutionContext ctx) {", "    for (int i = 0; i < this.parameters.size(); i++) {", "          paramArray[i] = binder;", "        SystemUtils.trace(\"twine\", \"getArgumentValue failed on parameter \" + (i + 1) + \": \" + e.getMessage());", "    return paramArray;"], "ctx": ["public Object[] getValueArray(Workspace ws, DataBinder binder, ExecutionContext ctx) {", "    for (int i = 0; i < this.parameters.size(); i++) {", "          paramArray[i] = ctx;", "        SystemUtils.trace(\"twine\", \"getArgumentValue failed on parameter \" + (i + 1) + \": \" + e.getMessage());", "    return paramArray;"]}
{"path": ["public static synchronized boolean existsInstance(File path) {", "      canonicalPath = path.getCanonicalPath();"]}
{"name": ["public Ref createBranch(String name) throws IOException, JavaGitException {", "    Ref newBranch = Ref.createBranchRef(name);", "    gitBranch.createBranch(path, newBranch);", "    return newBranch;"]}
{"branch": ["public void deleteBranch(Ref branch, boolean forceDelete) ", "    gitBranch.deleteBranch(path, forceDelete, false, branch);"], "forceDelete": ["public void deleteBranch(Ref branch, boolean forceDelete) ", "    gitBranch.deleteBranch(path, forceDelete, false, branch);"]}
{"branchFrom": ["public Ref renameBranch(Ref branchFrom, String nameTo, boolean forceRename) ", "    gitBranch.renameBranch(path, forceRename, branchFrom, newBranch);"], "nameTo": ["public Ref renameBranch(Ref branchFrom, String nameTo, boolean forceRename) ", "    Ref newBranch = Ref.createBranchRef(nameTo);", "    gitBranch.renameBranch(path, forceRename, branchFrom, newBranch);", "    return newBranch;"], "forceRename": ["public Ref renameBranch(Ref branchFrom, String nameTo, boolean forceRename) ", "    gitBranch.renameBranch(path, forceRename, branchFrom, newBranch);"]}
{"Result": "Method without Parameter"}
{"repository": ["public GitCommitResponseImpl commitAll(File repository, String message) throws IOException,", "    CheckUtilities.checkNullArgument(repository, \"repository\");", "    return gitCommit.commitAll(repository, message);"], "message": ["public GitCommitResponseImpl commitAll(File repository, String message) throws IOException,", "    CheckUtilities.checkStringArgument(message, \"message\");", "    return gitCommit.commitAll(repository, message);"]}
{"from": ["  public static <T> T convert(Object from, Class<T> to) {", "    if (from == null) {", "    if (to.isAssignableFrom(from.getClass())) {", "      return to.cast(from);", "    String converterId = from.getClass().getName() + \"_\" + to.getName();", "      throw new UnsupportedOperationException(\"Cannot convert from \" + from.getClass().getName() + \" to \"", "        return (T) converter.invoke(to, from);", "      return to.cast(converter.invoke(to, from));", "      throw new RuntimeException(\"Cannot convert from \" + from.getClass().getName() + \" to \" + to.getName()"], "to": ["  public static <T> T convert(Object from, Class<T> to) {", "    if (to.isAssignableFrom(from.getClass())) {", "      return to.cast(from);", "    String converterId = from.getClass().getName() + \"_\" + to.getName();", "          + to.getName() + \". Requested converter does not exist.\");", "      if (to.isPrimitive()) {", "        return (T) converter.invoke(to, from);", "      return to.cast(converter.invoke(to, from));", "      throw new RuntimeException(\"Cannot convert from \" + from.getClass().getName() + \" to \" + to.getName()"]}
{"value": ["public static Boolean integerToBoolean(Integer value) {", "    return value.intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;"]}
{"value": ["public static Integer booleanToInteger(Boolean value) {", "    return value.booleanValue() ? Integer.valueOf(1) : Integer.valueOf(0);"]}
{"value": ["public static String longToString(Date value) {", "    if (value == null) {", "    return sdf.format(value);"]}
{"code": ["public static String getMessage(String code) {", "    String str = MESSAGE_MAP.get(code);", "    if (null == str) {", "      return \"NO MESSAGE FOR ERROR CODE. { code=[\" + code + \"] }\";", "    return str;"]}
{"index": ["public File getFileNeedingUpdate(int index) {", "    CheckUtilities.checkIntIndexInListRange(filesNeedingUpdate, index);", "    return filesNeedingUpdate.get(index);"]}
{"file": ["public void addToDeletedFilesToCommit(File file) {", "    deletedFilesToCommit.add(file);", "    fileToStatus.put(file, Status.DELETED_TO_COMMIT);"]}
{"file": ["public void addToDeletedFilesNotUpdated(File file) {", "    deletedFilesNotUpdated.add(file);", "    fileToStatus.put(file, Status.DELETED);"]}
{"file": ["public void addToModifiedFilesToCommit(File file) {", "    modifiedFilesToCommit.add(file);", "    fileToStatus.put(file, Status.MODIFIED_TO_COMMIT);"]}
{"file": ["public void addToModifiedFilesNotUpdated(File file) {", "    modifiedFilesNotUpdated.add(file);", "    fileToStatus.put(file, Status.MODIFIED);"]}
{"file": ["public void addToNewFilesToCommit(File file) {", "    newFilesToCommit.add(file);", "    fileToStatus.put(file, Status.NEW_TO_COMMIT);"]}
{"file": ["public void addToRenamedFilesToCommit(File file) {", "    renamedFilesToCommit.add(file);", "    fileToStatus.put(file, Status.RENAMED_TO_COMMIT);"]}
{"file": ["public void addToUntrackedFiles(File file) {", "    untrackedFiles.add(file);", "    fileToStatus.put(file, Status.UNTRACKED);"]}
{"name": ["public static Parameter create(String name, Class<?> type, boolean required) throws IllegalArgumentException {", "      return new InjectedParameter(name, type);", "      String msg = \"Parameter [\" + name + \"] found with non-nullable type. Use a wrapper type or change to required\";", "      p = new StringParameter(name, type);", "      p = new IntegerParameter(name, type);", "      p = new LongParameter(name, type);", "      p = new FloatParameter(name, type);", "      p = new DoubleParameter(name, type);", "      p = new DateParameter(name, type);", "      p = new ResultSetParameter(name, type);", "      p = new BooleanParameter(name, type);", "      p = new ProviderParameter(name);", "    p.setRequired(required);", "    return p;"], "type": ["public static Parameter create(String name, Class<?> type, boolean required) throws IllegalArgumentException {", "    if (InjectedParameter.isValidType(type)) {", "      return new InjectedParameter(name, type);", "    if (type.isPrimitive() && !required) {", "    if (type == String.class) {", "      p = new StringParameter(name, type);", "    } else if (type == Integer.class || type == int.class) {", "      p = new IntegerParameter(name, type);", "    } else if (type == Long.class || type == long.class) {", "      p = new LongParameter(name, type);", "    } else if (type == Float.class || type == float.class) {", "      p = new FloatParameter(name, type);", "    } else if (type == Double.class || type == double.class) {", "      p = new DoubleParameter(name, type);", "    } else if (type == Date.class) {", "      p = new DateParameter(name, type);", "    } else if (type == ResultSet.class || type == DataResultSet.class) {", "      p = new ResultSetParameter(name, type);", "    } else if (type == Boolean.class || type == boolean.class) {", "      p = new BooleanParameter(name, type);", "    } else if (type == Provider.class) {", "      throw new IllegalArgumentException(\"Parameter type \" + type.getName() + \" is not valid\");", "    p.setRequired(required);", "    return p;"], "required": ["public static Parameter create(String name, Class<?> type, boolean required) throws IllegalArgumentException {", "    if (type.isPrimitive() && !required) {", "    p.setRequired(required);"]}
{"binder": ["public String getStringValue(DataBinder binder) {", "    String value = (String) binder.getLocal(this.name);"]}
{"optVerbose": ["public void setOptVerbose(boolean optVerbose) {", "    if ((false == optVerbose) && (optAbbrev || optNoAbbrev)) {", "    this.optVerbose = optVerbose;"]}
{"optDLower": ["public void setOptDLower(boolean optDLower) {", "    if (optDLower && optDUpper) {", "    this.optDLower = optDLower;"]}
{"optDUpper": ["public void setOptDUpper(boolean optDUpper) {", "    if (optDLower && optDUpper) {", "    this.optDUpper = optDUpper;"]}
{"optMLower": ["public void setOptMLower(boolean optMLower) {", "    if (optMLower && optMUpper) {", "    this.optMLower = optMLower;"]}
{"optMUpper": ["public void setOptMUpper(boolean optMUpper) {", "    if (optMLower && optMUpper) {", "    this.optMUpper = optMUpper;"]}
{"m": ["public Integer getFunctionReturnType(Method m) {", "    Class<?> type = m.getReturnType();"]}
{"info": ["public boolean evaluateFunction(ScriptInfo info, Object[] args, ExecutionContext context) throws ServiceException {", "    int config[] = (int[]) info.m_entry;", "    String functionCalled = info.m_key;"], "args": ["public boolean evaluateFunction(ScriptInfo info, Object[] args, ExecutionContext context) throws ServiceException {", "    int nargs = args.length - 1;", "      args[nargs] = runFunctionMethod(functionIndex, args, context);"], "context": ["public boolean evaluateFunction(ScriptInfo info, Object[] args, ExecutionContext context) throws ServiceException {", "    UserData userData = (UserData) context.getCachedObject(\"UserData\");", "      args[nargs] = runFunctionMethod(functionIndex, args, context);"]}
{"method": ["public Object[] getInjectedValueArray(Method method, Object[] args, ExecutionContext ctx)", "    ParameterMarshaller marshaller = new ParameterMarshaller(method);", "    return marshaller.getValueArray(args, (Service) ctx);"], "args": ["public Object[] getInjectedValueArray(Method method, Object[] args, ExecutionContext ctx)", "    return marshaller.getValueArray(args, (Service) ctx);"], "ctx": ["public Object[] getInjectedValueArray(Method method, Object[] args, ExecutionContext ctx)", "    if ((ctx instanceof Service) == false) {", "    return marshaller.getValueArray(args, (Service) ctx);"]}
{"functionIndex": ["public Object runFunctionMethod(int functionIndex, Object[] args, ExecutionContext ctx) throws SecurityException,", "    Method method = functionMethods[functionIndex];", "    Object params[] = getInjectedValueArray(method, args, ctx);", "      result = method.invoke(m_class.newInstance(), params);"], "args": ["public Object runFunctionMethod(int functionIndex, Object[] args, ExecutionContext ctx) throws SecurityException,", "    Object params[] = getInjectedValueArray(method, args, ctx);"], "ctx": ["public Object runFunctionMethod(int functionIndex, Object[] args, ExecutionContext ctx) throws SecurityException,", "    Object params[] = getInjectedValueArray(method, args, ctx);", "      result = method.invoke(m_class.newInstance(), params);", "    if (result == null) {", "      return result;", "    return convertReturnValue(result);"]}
{"result": ["private Object convertReturnValue(Object result) {", "    if (boolean.class.isInstance(result) || result instanceof Boolean) {", "      return ScriptExtensionUtils.computeReturnObject(1, ((Boolean) result).booleanValue(), 0, 0.0, null);", "    } else if (long.class.isInstance(result)) {", "      return (Long) result;", "    } else if (int.class.isInstance(result) || result instanceof Integer) {", "      return new Long((Integer) result);", "    } else if (double.class.isInstance(result)) {", "      return (Double) result;", "    return result;"]}
{"info": ["public boolean evaluateValue(ScriptInfo info, boolean[] returnBool, String[] returnString, ExecutionContext context,", "    int config[] = (int[]) info.m_entry;", "    String key = info.m_key;"], "returnBool": [], "returnString": [], "context": ["public boolean evaluateValue(ScriptInfo info, boolean[] returnBool, String[] returnString, ExecutionContext context,", "    if ((context instanceof Service) == false) {", "    UserData userData = (UserData) context.getCachedObject(\"UserData\");", "      result = runVariableMethod(variableIndex, context);", "      returnBool[0] = ObjectConverter.convert(result, boolean.class);", "      returnString[0] = ObjectConverter.convert(result, String.class);"], "isConditional": ["      boolean isConditional) throws ServiceException {", "    if (isConditional) {"]}
{"repositoryPath": ["public GitBranchResponse branch(File repositoryPath) throws IOException, JavaGitException {", "    CheckUtilities.checkNullArgument(repositoryPath, \"repository path\");", "    return gitBranch.branch(repositoryPath);"]}
{"repositoryPath": ["public GitBranchResponse deleteBranch(File repositoryPath, boolean forceDelete, boolean remote, ", "    CheckUtilities.checkNullArgument(repositoryPath, \"repository path\");", "    return gitBranch.deleteBranch(repositoryPath, forceDelete, remote, branchName);"], "forceDelete": ["public GitBranchResponse deleteBranch(File repositoryPath, boolean forceDelete, boolean remote, ", "    return gitBranch.deleteBranch(repositoryPath, forceDelete, remote, branchName);"], "remote": ["public GitBranchResponse deleteBranch(File repositoryPath, boolean forceDelete, boolean remote, ", "    return gitBranch.deleteBranch(repositoryPath, forceDelete, remote, branchName);"], "branchName": ["      Ref branchName) throws IOException, JavaGitException {", "    CheckUtilities.checkNullArgument(branchName, \"branch name\");", "    CheckUtilities.validateArgumentRefType(branchName, Ref.RefType.BRANCH, \"branch name\");", "    return gitBranch.deleteBranch(repositoryPath, forceDelete, remote, branchName);"]}
{"repositoryPath": ["public GitBranchResponse deleteBranch(File repositoryPath, boolean forceDelete, boolean remote, ", "    CheckUtilities.checkNullArgument(repositoryPath, \"repository path\");", "    return gitBranch.deleteBranches(repositoryPath, forceDelete, remote, branchList);"], "forceDelete": ["public GitBranchResponse deleteBranch(File repositoryPath, boolean forceDelete, boolean remote, ", "    return gitBranch.deleteBranches(repositoryPath, forceDelete, remote, branchList);"], "remote": ["public GitBranchResponse deleteBranch(File repositoryPath, boolean forceDelete, boolean remote, ", "    return gitBranch.deleteBranches(repositoryPath, forceDelete, remote, branchList);"], "branchList": ["      List<Ref> branchList) throws IOException, JavaGitException {", "    CheckUtilities.checkNullListArgument(branchList, \"branch list\");", "    CheckUtilities.validateListRefType(branchList, Ref.RefType.BRANCH, \"branch list\");", "    return gitBranch.deleteBranches(repositoryPath, forceDelete, remote, branchList);"]}
{"repositoryPath": ["public GitBranchResponse renameBranch(File repositoryPath, boolean forceRename, Ref newName) ", "    CheckUtilities.checkNullArgument(repositoryPath, \"repository path\");", "    return gitBranch.renameBranch(repositoryPath, forceRename, newName);"], "forceRename": ["public GitBranchResponse renameBranch(File repositoryPath, boolean forceRename, Ref newName) ", "    return gitBranch.renameBranch(repositoryPath, forceRename, newName);"], "newName": ["public GitBranchResponse renameBranch(File repositoryPath, boolean forceRename, Ref newName) ", "    CheckUtilities.checkNullArgument(newName, \"new name\");", "    CheckUtilities.validateArgumentRefType(newName, Ref.RefType.BRANCH, \"new name\");", "    return gitBranch.renameBranch(repositoryPath, forceRename, newName);"]}
{"comment": ["public GitCommitResponse commit(String comment) throws IOException, JavaGitException {", "    return gitCommit.commit(path, comment);"]}
{"Result": "Method without Parameter"}
{"ref": ["public void checkout(Ref ref) throws IOException, JavaGitException {", "    gitCheckout.checkout(path, null, ref);"]}
{"Result": "Method without Parameter"}
{"repository": ["public GitRmResponse rm(File repository, File path) throws IOException, JavaGitException {", "    CheckUtilities.checkNullArgument(repository, \"repository\");", "    return GitRm.rm(repository, path);"], "path": ["public GitRmResponse rm(File repository, File path) throws IOException, JavaGitException {", "    CheckUtilities.checkNullArgument(path, \"path\");", "    return GitRm.rm(repository, path);"]}
{"index": ["public File getFileFromNewFilesToCommit(int index) {", "    CheckUtilities.checkIntIndexInListRange(newFilesToCommit, index);", "    return newFilesToCommit.get(index);"]}
{"index": ["public File getFileFromDeletedFilesToCommit(int index) {", "    CheckUtilities.checkIntIndexInListRange(deletedFilesToCommit, index);", "    return deletedFilesToCommit.get(index);"]}
{"index": ["public File getFileFromModifiedFilesToCommit(int index) {", "    CheckUtilities.checkIntIndexInListRange(modifiedFilesToCommit, index);", "    return modifiedFilesToCommit.get(index);"]}
{"index": ["public File getFileFromDeletedFilesNotUpdated(int index) {", "    CheckUtilities.checkIntIndexInListRange(deletedFilesNotUpdated, index);", "    return deletedFilesNotUpdated.get(index);"]}
{"index": ["public File getFileFromModifiedFilesNotUpdated(int index) {", "    CheckUtilities.checkIntIndexInListRange(modifiedFilesNotUpdated, index);", "    return modifiedFilesNotUpdated.get(index);"]}
{"index": ["public File getFileFromUntrackedFiles(int index) {", "    CheckUtilities.checkIntIndexInListRange(untrackedFiles, index);", "    return untrackedFiles.get(index);"]}
{"index": ["public File getFileFromRenamedFiles(int index) {", "    CheckUtilities.checkIntIndexInListRange(renamedFilesToCommit, index);", "    return renamedFilesToCommit.get(index);"]}
{"index": ["public String getError(int index) {", "    if (index < errors.size()) {", "      ErrorDetails errorDetails = errors.get(index);", "      return errorDetails.lineNumber + \". \" + errorDetails.error;"]}
{"Result": "Method without Parameter"}
{"repository": ["public static GitResetResponse gitReset(File repository) throws IOException, JavaGitException {", "    CheckUtilities.checkNullArgument(repository, \"repository\");", "    return gitReset.gitReset(repository);"]}
{"pathToFile": ["public boolean addAddedFile(File pathToFile, String mode) {", "    if (null == pathToFile) {", "    return addedFiles.add(new AddedOrDeletedFile(pathToFile, mode));"], "mode": ["public boolean addAddedFile(File pathToFile, String mode) {", "    return addedFiles.add(new AddedOrDeletedFile(pathToFile, mode));"]}
{"sourceFilePath": ["public boolean addCopiedFile(File sourceFilePath, File destinationFilePath, int percentage) {", "    if (null == sourceFilePath || null == destinationFilePath) {", "    return copiedFiles.add(new CopiedOrMovedFile(sourceFilePath, destinationFilePath, percentage));"], "destinationFilePath": ["public boolean addCopiedFile(File sourceFilePath, File destinationFilePath, int percentage) {", "    if (null == sourceFilePath || null == destinationFilePath) {", "    return copiedFiles.add(new CopiedOrMovedFile(sourceFilePath, destinationFilePath, percentage));"], "percentage": ["public boolean addCopiedFile(File sourceFilePath, File destinationFilePath, int percentage) {", "    return copiedFiles.add(new CopiedOrMovedFile(sourceFilePath, destinationFilePath, percentage));"]}
{"pathToFile": ["public boolean addDeletedFile(File pathToFile, String mode) {", "    if (null == pathToFile) {", "    return deletedFiles.add(new AddedOrDeletedFile(pathToFile, mode));"], "mode": ["public boolean addDeletedFile(File pathToFile, String mode) {", "    return deletedFiles.add(new AddedOrDeletedFile(pathToFile, mode));"]}
{"filesChangedStr": ["public boolean setFilesChanged(String filesChangedStr) {", "      this.filesChanged = Integer.parseInt(filesChangedStr);"]}
{"linesDeletedStr": ["public boolean setLinesDeleted(String linesDeletedStr) {", "      this.linesDeleted = Integer.parseInt(linesDeletedStr);"]}
{"linesInsertedStr": ["public boolean setLinesInserted(String linesInsertedStr) {", "      this.linesInserted = Integer.parseInt(linesInsertedStr);"]}
{"repoPath": ["public GitMvResponseImpl mvProcess(File repoPath, GitMvOptions options, List<File> source,", "    return (GitMvResponseImpl) ProcessUtilities.runCommand(repoPath, commandLine, parser);"], "options": ["public GitMvResponseImpl mvProcess(File repoPath, GitMvOptions options, List<File> source,", "    List<String> commandLine = buildCommand(options, source, destination);"], "source": ["public GitMvResponseImpl mvProcess(File repoPath, GitMvOptions options, List<File> source,", "    List<String> commandLine = buildCommand(options, source, destination);"], "destination": ["      File destination) throws IOException, JavaGitException {", "    List<String> commandLine = buildCommand(options, source, destination);", "    return (GitMvResponseImpl) ProcessUtilities.runCommand(repoPath, commandLine, parser);"]}
{"str": ["public static int indexOfLeft(String str, int from, char c) {", "            if ( str.charAt(f--) == c )"], "from": ["public static int indexOfLeft(String str, int from, char c) {", "        int f = from;", "        while(  f >= 0 && pos == -1 )"], "c": ["public static int indexOfLeft(String str, int from, char c) {", "            if ( str.charAt(f--) == c )"]}
{"name": ["private DataResultSet getResultSet(String name, Service service) {", "    ResultSet rs = service.getBinder().getResultSet(name);", "    if (rs != null) {", "      drs.copy(rs);"], "service": ["private DataResultSet getResultSet(String name, Service service) {", "    ResultSet rs = service.getBinder().getResultSet(name);"]}
{"repositoryPath": ["public List<Commit> log(File repositoryPath, GitLogOptions options)", "\t\tCheckUtilities.checkFileValidity(repositoryPath);", "\t\tList<String> command = buildCommand(repositoryPath, options);", "\t\tGitLogResponse response =  (GitLogResponse) ProcessUtilities.runCommand(repositoryPath,"], "options": ["public List<Commit> log(File repositoryPath, GitLogOptions options)", "\t\tList<String> command = buildCommand(repositoryPath, options);", "\t\t\t\tcommand, parser);"]}
{"Result": "Method without Parameter"}
{"filename": ["public void addFile(String filename,int linesAdded, int linesDeleted){", "\t\tCommitFile commitFile = new CommitFile(filename, linesAdded, linesDeleted);"], "linesAdded": ["public void addFile(String filename,int linesAdded, int linesDeleted){", "\t\tCommitFile commitFile = new CommitFile(filename, linesAdded, linesDeleted);"], "linesDeleted": ["public void addFile(String filename,int linesAdded, int linesDeleted){", "\t\tCommitFile commitFile = new CommitFile(filename, linesAdded, linesDeleted);", "\t\tthis.files.add(commitFile);"]}
{"repositoryPath": ["public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref ref)", "        CheckUtilities.checkFileValidity(repositoryPath);", "        GitCheckoutResponse response = (GitCheckoutResponse) ProcessUtilities.runCommand(repositoryPath,"], "options": ["public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref ref)", "        List<String> command = buildCommand(options, ref);"], "ref": ["public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref ref)", "        checkRefAgainstRefType(ref, RefType.HEAD);", "        List<String> command = buildCommand(options, ref);", "                command, parser);"]}
{"repositoryPath": ["public GitCheckoutResponse checkout(File repositoryPath) throws JavaGitException, IOException {", "        return checkout(repositoryPath, options, null);"]}
{"repositoryPath": ["public GitCheckoutResponse checkout(File repositoryPath, Ref branch) throws JavaGitException,", "        return checkout(repositoryPath, null, branch);"], "branch": ["public GitCheckoutResponse checkout(File repositoryPath, Ref branch) throws JavaGitException,", "        return checkout(repositoryPath, null, branch);"]}
{"repositoryPath": ["public GitCheckoutResponse checkout(File repositoryPath, List<File> paths)", "        CheckUtilities.checkFileValidity(repositoryPath);", "        GitCheckoutResponse response = (GitCheckoutResponse) ProcessUtilities.runCommand(repositoryPath,"], "paths": ["public GitCheckoutResponse checkout(File repositoryPath, List<File> paths)", "        CheckUtilities.checkNullListArgument(paths, \"list of file paths\");", "        List<String> command = buildCommand(null, null, paths);", "                command, parser);"]}
{"repositoryPath": ["public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref ref,", "        CheckUtilities.checkFileValidity(repositoryPath);", "        return (GitCheckoutResponse) ProcessUtilities.runCommand(repositoryPath, command, parser);"], "options": ["public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref ref,", "        List<String> command = buildCommand(options, ref, paths);"], "ref": ["public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref ref,", "        if (ref != null && ref.getRefType() == RefType.HEAD) {", "        List<String> command = buildCommand(options, ref, paths);"], "paths": ["                                        List<File> paths) throws JavaGitException, IOException {", "        List<String> command = buildCommand(options, ref, paths);", "        return (GitCheckoutResponse) ProcessUtilities.runCommand(repositoryPath, command, parser);"]}
{"repositoryPath": ["public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref branch,", "        CheckUtilities.checkFileValidity(repositoryPath);", "        GitCheckoutResponse response = (GitCheckoutResponse) ProcessUtilities.runCommand(repositoryPath,"], "options": ["public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref branch,", "        List<String> command = buildCommand(options, branch, paths);"], "branch": ["public GitCheckoutResponse checkout(File repositoryPath, GitCheckoutOptions options, Ref branch,", "        List<String> command = buildCommand(options, branch, paths);"], "path": ["                                        File path) throws JavaGitException, IOException {", "        paths.add(path);"]}
{"ref": ["private void checkRefAgainstRefType(Ref ref, RefType refType) {", "        if (ref != null && ref.getRefType() == refType) {"], "refType": ["private void checkRefAgainstRefType(Ref ref, RefType refType) {", "        if (ref != null && ref.getRefType() == refType) {"]}
{"Result": "Method without Parameter"}
{"index": ["public File getRemovedFile(int index) {\r", "    CheckUtilities.checkIntIndexInListRange(removedFiles, index);\r", "    return removedFiles.get(index);\r"]}
{"repositoryPath": ["public GitCheckoutResponse checkout(File repositoryPath, List<File> paths) throws IOException,", "    CheckUtilities.checkFileValidity(repositoryPath);", "    return gitCheckout.checkout(repositoryPath, paths);"], "paths": ["public GitCheckoutResponse checkout(File repositoryPath, List<File> paths) throws IOException,", "    CheckUtilities.checkNullListArgument(paths, \"List of Paths\");", "    return gitCheckout.checkout(repositoryPath, paths);"]}
{"repositoryPath": ["public GitCheckoutResponse checkout(File repositoryPath, Ref ref, List<File> paths)", "    CheckUtilities.checkFileValidity(repositoryPath);", "    return gitCheckout.checkout(repositoryPath, ref, paths);"], "ref": ["public GitCheckoutResponse checkout(File repositoryPath, Ref ref, List<File> paths)", "    if ( ref != null && ( ref.getRefType() != RefType.BRANCH && ref.getRefType() != RefType.SHA1) ) {", "          + \" RefType passed: \" + ref.getRefType());", "    return gitCheckout.checkout(repositoryPath, ref, paths);"], "paths": ["public GitCheckoutResponse checkout(File repositoryPath, Ref ref, List<File> paths)", "    CheckUtilities.checkNullListArgument(paths, \"List of files\");", "    return gitCheckout.checkout(repositoryPath, ref, paths);"]}
{"lineNumber": ["public void setComment(int lineNumber, String commentString) {", "    ResponseString comment = new ResponseString(lineNumber, commentString);"], "commentString": ["public void setComment(int lineNumber, String commentString) {", "    ResponseString comment = new ResponseString(lineNumber, commentString);", "    comments.add(comment);"]}
{"options": ["public void setDeleteOptions(GitBranchOptions options, boolean forceDelete, boolean remote) {", "      options.setOptDUpper(true);", "      options.setOptDLower(true);", "      options.setOptR(true);"], "forceDelete": ["public void setDeleteOptions(GitBranchOptions options, boolean forceDelete, boolean remote) {", "    if (forceDelete) {"], "remote": ["public void setDeleteOptions(GitBranchOptions options, boolean forceDelete, boolean remote) {", "    if (remote) {"]}
{"klass": ["  public void inject(Class<?> klass) throws DataException {", "    Method[] classMethods = klass.getMethods();"]}
{"method": ["private static void injectServiceMethod(Method method, ServiceMethod annotation) throws DataException {", "    String methodHashCode = MethodRegistry.addMethod(method);", "    if (methodHashCode == null) {", "      throw new DataException(\"Cannot register method \" + method.toString() + \" because it has a null hashCode\");", "      serviceData.addAction(Action.CODE_TYPE, \"delegateWithParameters\", methodHashCode, controlFlags, \"\");"], "annotation": ["private static void injectServiceMethod(Method method, ServiceMethod annotation) throws DataException {", "    String template = annotation.template();", "    int accessLevel = annotation.accessLevel();", "    String serviceType = (!annotation.type().equals(\"\")) ? annotation.type() : null;", "    String errorMessage = annotation.errorMessage();", "    String subjects = annotation.subjects();", "    String serviceName = annotation.name();"]}
{"newBranch": ["public void setOptB(Ref newBranch) {", "    CheckUtilities.validateArgumentRefType(newBranch, RefType.BRANCH, \"New Branch Name\");", "    optB = newBranch;"]}
{"workingDirectoryPath": ["public GitCloneResponseImpl cloneProcess(File workingDirectoryPath, GitCloneOptions options,", "    return (GitCloneResponseImpl) ProcessUtilities.runCommand(workingDirectoryPath, commandLine, parser);"], "options": ["public GitCloneResponseImpl cloneProcess(File workingDirectoryPath, GitCloneOptions options,", "    List<String> commandLine = buildCommand(options, repository, directory);"], "repository": ["      URL repository, File directory) throws IOException, JavaGitException {", "    List<String> commandLine = buildCommand(options, repository, directory);"], "directory": ["      URL repository, File directory) throws IOException, JavaGitException {", "    List<String> commandLine = buildCommand(options, repository, directory);", "    return (GitCloneResponseImpl) ProcessUtilities.runCommand(workingDirectoryPath, commandLine, parser);"]}
{"ws": [], "binder": [], "ctx": ["public int doFilter(Workspace ws, DataBinder binder, ExecutionContext ctx) throws DataException, ServiceException {", "    String configFileName = (String) ctx.getCachedObject(\"filterParameter\");"]}
{"classLoader": ["private Enumeration<URL> getResources11g(ClassLoader classLoader, String configFileName) {", "    if (classLoader.getClass().getSimpleName().equalsIgnoreCase(\"IdcClassLoader\")) {", "        Field field = classLoader.getClass().getField(\"m_zipfiles\");", "        Map<String, IdcZipFile> zipFiles = (Map<String, IdcZipFile>) field.get(classLoader);", "        for (Entry<String, IdcZipFile> entry : zipFiles.entrySet()) {", "          if (entry.getValue().m_entries.get(configFileName) != null) {", "            String jarFile = entry.getKey();", "            if (!jarFile.startsWith(\"/\")) {", "              jarFile = \"/\" + jarFile;", "              URL u = new URL(\"jar:file:\" + entry.getKey() + \"!/\" + configFileName);", "              newProps.add(u);"], "configFileName": ["private Enumeration<URL> getResources11g(ClassLoader classLoader, String configFileName) {", "          if (entry.getValue().m_entries.get(configFileName) != null) {", "              URL u = new URL(\"jar:file:\" + entry.getKey() + \"!/\" + configFileName);", "              newProps.add(u);"]}
{"resetType": ["private void setup(ResetType resetType, Ref commitName) {", "    CheckUtilities.checkNullArgument(resetType, \"resetType\");", "    this.resetType = resetType;"], "commitName": ["private void setup(ResetType resetType, Ref commitName) {", "    CheckUtilities.checkNullArgument(commitName, \"commitName\");", "    this.commitName = commitName;"]}
{"m": ["public static String addMethod(Method m) {", "    String hashCode = String.valueOf(m.hashCode());", "      methods.put(hashCode, m);", "    return String.valueOf(m.hashCode());"]}
{"ws": ["public int doFilter(Workspace ws, DataBinder binder, ExecutionContext ctx) throws DataException, ServiceException {", "      Object[] params = marshaller.getValueArray(ws, binder, ctx);"], "binder": ["public int doFilter(Workspace ws, DataBinder binder, ExecutionContext ctx) throws DataException, ServiceException {", "      Object[] params = marshaller.getValueArray(ws, binder, ctx);"], "ctx": ["public int doFilter(Workspace ws, DataBinder binder, ExecutionContext ctx) throws DataException, ServiceException {", "      String methodID = (String) ctx.getCachedObject(\"filterParameter\");", "      Object[] params = marshaller.getValueArray(ws, binder, ctx);", "      returnVal = m.invoke(context, params);", "    if (returnVal != null && returnVal instanceof Integer) {", "      return ((Integer) returnVal).intValue();"]}
{"Result": "Method without Parameter"}
{"dbConsumer": ["public void consumeDatabase(DbConsumer dbConsumer) {", "\t\t\tdbConsumer.consume(db);"]}
{"table": ["public Cursor query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy) {", "\t\treturn new DbClosingCursor(db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy), this);"], "columns": ["public Cursor query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy) {", "\t\treturn new DbClosingCursor(db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy), this);"], "selection": ["public Cursor query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy) {", "\t\treturn new DbClosingCursor(db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy), this);"], "selectionArgs": ["public Cursor query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy) {", "\t\treturn new DbClosingCursor(db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy), this);"], "groupBy": ["public Cursor query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy) {", "\t\treturn new DbClosingCursor(db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy), this);"], "having": ["public Cursor query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy) {", "\t\treturn new DbClosingCursor(db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy), this);"], "orderBy": ["public Cursor query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy) {", "\t\treturn new DbClosingCursor(db.query(table, columns, selection, selectionArgs, groupBy, having, orderBy), this);"]}
{"sql": ["public Cursor rawQuery(String sql) {", "\t\treturn new DbClosingCursor(db.rawQuery(sql, null), this);"]}
{"options": ["private List<String> buildCommandLine(GitRmOptions options, File path, List<File> paths) {", "    if (null != options) {", "      if (options.isOptCached()) {", "      if (options.isOptF()) {", "      if (options.isOptN()) {", "      if (options.isOptQ()) {", "      if (options.isOptR()) {"], "path": ["private List<String> buildCommandLine(GitRmOptions options, File path, List<File> paths) {", "    if (null != path) {", "      cmdline.add(path.getPath());"], "paths": ["private List<String> buildCommandLine(GitRmOptions options, File path, List<File> paths) {", "      for (File f : paths) {", "        cmdline.add(f.getPath());"]}
{"index": ["public File getAddedFile(int index) {", "    CheckUtilities.checkIntIndexInListRange(addedFiles, index);", "    return addedFiles.get(index);"]}
{"index": ["public File getDeletedFile(int index) {", "    CheckUtilities.checkIntIndexInListRange(deletedFiles, index);", "    return deletedFiles.get(index);"]}
{"index": ["public File getModifiedFile(int index) {", "    CheckUtilities.checkIntIndexInListRange(modifiedFiles, index);", "    return modifiedFiles.get(index);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"string": ["public boolean matches(String string) {", "        String src = string;", "                result = src.length() == 1;", "                    result = src.equalsIgnoreCase(pattern.getText());", "                    result = src.equals(pattern.getText());", "                src = src.toLowerCase();", "                 result = src.startsWith(pattern1.getText()) && (pattern2.getType() == GLOB_MULTIPLE || src.length() == pattern1.getTextLength()+1);", "                result = src.endsWith(pattern2.getText()) && (pattern1.getType() == GLOB_MULTIPLE || src.length() == pattern2.getTextLength()+1);", "            result = matches(src.toCharArray());"]}
{"entry": ["    protected void updateListAfterHit(CacheEntry<K, V> entry) {", "        if (entry != null && !entry.equals(_first)) {", "            if (entry.equals(_last)) {", "                setLast(entry.getPrevious());", "                final CacheEntry<K, V> previous = entry.getPrevious();", "                final CacheEntry<K, V> next = entry.getNext();", "            _first.setPrevious(entry);", "            entry.setNext(_first);", "            setFirst(entry);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"entry": ["    protected void updateListAfterHit(CacheEntry<K, V> entry) {", "        if (entry != null && !entry.equals(_first)) {", "            if (entry.getHits() > entry.getPrevious().getHits()) {", "                final CacheEntry<K, V> beforePrevious = entry.getPrevious().getPrevious();", "                final CacheEntry<K, V> previous = entry.getPrevious();", "                final CacheEntry<K, V> next = entry.getNext();", "                    beforePrevious.setNext(entry);", "                    _first = entry;", "                entry.setPrevious(beforePrevious);", "                previous.setPrevious(entry);", "                entry.setNext(previous);"]}
{"src": ["public static boolean startsWith(char[] src, char[] find, int startAt) {", "        if (src.length < startPos + find.length) {", "                if (src[startPos] != find[a]) {"], "find": ["public static boolean startsWith(char[] src, char[] find, int startAt) {", "        if (src.length < startPos + find.length) {", "            final int max = find.length;", "                if (src[startPos] != find[a]) {"], "startAt": ["public static boolean startsWith(char[] src, char[] find, int startAt) {", "        int startPos = startAt;", "        if (src.length < startPos + find.length) {", "                if (src[startPos] != find[a]) {"]}
{"requestToken": [], "verifier": ["    public Token getAccessToken(Token requestToken, Verifier verifier) {", "        request.addBodyParameter(\"code\", verifier.getValue());"]}
{"accessToken": ["    public void signRequest(Token accessToken, OAuthRequest request) {", "        request.addHeader(\"Authorization\", \"Bearer \" + accessToken.getToken());"], "request": ["    public void signRequest(Token accessToken, OAuthRequest request) {", "        request.addHeader(\"Authorization\", \"Bearer \" + accessToken.getToken());"]}
{"config": ["    public String getAuthorizationUrl(OAuthConfig config) {", "        Preconditions.checkValidUrl(config.getCallback(),", "        return String.format(AUTHORIZE_URL, config.getApiKey(),", "                OAuthEncoder.encode(config.getCallback()), SCOPES);"]}
{"Result": "Method without Parameter"}
{"containerName": ["private void doFinish(String containerName, IPath location, IProgressMonitor monitor) throws CoreException {", "\t\tmonitor.beginTask(\"Creating \" + containerName, 2);"], "location": ["private void doFinish(String containerName, IPath location, IProgressMonitor monitor) throws CoreException {", "\t\tList<IProject> projects = MavenPlugin.getProjectConfigurationManager().createArchetypeProjects(location, archetype, groupId, artifactId, version, javaPackage, properties, importConfiguration, monitor);"], "monitor": ["private void doFinish(String containerName, IPath location, IProgressMonitor monitor) throws CoreException {", "\t\tmonitor.beginTask(\"Creating \" + containerName, 2);", "\t\tmonitor.worked(1);", "\t\tList<IProject> projects = MavenPlugin.getProjectConfigurationManager().createArchetypeProjects(location, archetype, groupId, artifactId, version, javaPackage, properties, importConfiguration, monitor);"]}
{"parent": ["public void createControl(Composite parent) {", "\t\tComposite composite = new Composite(parent, SWT.NULL);"]}
{"Result": "Method without Parameter"}
{"visible": ["public void setVisible(boolean visible) {", "\t\tsuper.setVisible(visible);", "\t\tif (visible) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"parent": ["public void createPartControl(Composite parent) {\r", "\t\tviewer.createControl(parent);\r"]}
{"category": ["private void addPaletteItem(String category,IPaletteItem item){\r", "\t\tif(items.get(category)==null){\r", "\t\t\titems.put(category,list);\r", "\t\tList<IPaletteItem> list = items.get(category);\r", "\t\tlist.add(item);\r"], "item": ["private void addPaletteItem(String category,IPaletteItem item){\r", "\t\tlist.add(item);\r"]}
{"category": ["private IPaletteItem[] getPaletteItems(String category){\r", "\t\tList<IPaletteItem> list = items.get(category);\r", "\t\tif(list==null){\r", "\t\treturn list.toArray(new IPaletteItem[list.size()]);\r"]}
{"parent": ["private void configureTableResizing(final Composite parent, final Table table, final TableColumn column1, final TableColumn column2) {", "\t\tparent.addControlListener(new ControlAdapter() {", "\t\t\t\tRectangle area = parent.getClientArea();"], "table": ["private void configureTableResizing(final Composite parent, final Table table, final TableColumn column1, final TableColumn column2) {", "\t\t\t\tPoint preferredSize = table.computeSize(SWT.DEFAULT, SWT.DEFAULT);", "\t\t\t\tint width = area.width - 2 * table.getBorderWidth();", "\t\t\t\t\tPoint vBarSize = table.getVerticalBar().getSize();", "\t\t\t\tPoint oldSize = table.getSize();", "\t\t\t\t\ttable.setSize(width, area.height);", "\t\t\t\t\ttable.setSize(width, area.height);"], "column1": ["private void configureTableResizing(final Composite parent, final Table table, final TableColumn column1, final TableColumn column2) {", "\t\t\t\t\tcolumn1.setWidth(width / 2);", "\t\t\t\t\tcolumn1.setWidth(width / 2);"], "column2": ["private void configureTableResizing(final Composite parent, final Table table, final TableColumn column1, final TableColumn column2) {", "\t\t\t\t\tcolumn2.setWidth(width / 2);", "\t\t\t\t\tcolumn2.setWidth(width / 2);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"templateName": ["private void setSelectedTemplate(String templateName) {", "\t\tif (templateName != null && templateName.length() > 0) {", "\t\t\ttemplate = fTemplateStore.findTemplate(templateName, CardContextType.CONTEXT_TYPE);"]}
{"Result": "Method without Parameter"}
{"relativePath": ["public static Criterion in(String relativePath, Collection<?> values) {", "    return new InExpression(relativePath, values.toArray());"], "values": ["public static Criterion in(String relativePath, Collection<?> values) {", "    return new InExpression(relativePath, values.toArray());"]}
{"relativePath": ["public static Criterion memberOf(String relativePath, Object value) {", "    return new MemberOfExpression(relativePath, value, false);"], "value": ["public static Criterion memberOf(String relativePath, Object value) {", "    return new MemberOfExpression(relativePath, value, false);"]}
{"relativePath": ["public static Criterion notMemberOf(String relativePath, Object value) {", "    return new MemberOfExpression(relativePath, value, true);"], "value": ["public static Criterion notMemberOf(String relativePath, Object value) {", "    return new MemberOfExpression(relativePath, value, true);"]}
{"Result": "Method without Parameter"}
{"path": ["public static String getLastPathComponent(String path) {", "    int pos = path.lastIndexOf('.');", "    return pos >= 0 ? path.substring(pos + 1) : path;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"fileName": ["private boolean extensionValidForContentType(String fileName) {", "\t\tif (fileName.lastIndexOf('.') != -1) {", "\t\t\tIContentType[] types = Platform.getContentTypeManager().findContentTypesFor(fileName);", "\t\t\twhile (i < types.length && !valid) {", "\t\t\t\tvalid = types[i].isKindOf(type);", "\t\treturn valid;"]}
{"filename": ["String addDefaultExtension(String filename) {", "\t\tStringBuffer newFileName = new StringBuffer(filename);", "\t\tnewFileName.append(\".\"); //$NON-NLS-1$", "\t\tnewFileName.append(ext);", "\t\treturn newFileName.toString();"]}
{"path": ["private IProject getProjectFromPath(IPath path) {", "\t\tif (path != null) {", "\t\t\tif (workspace.validatePath(path.toString(), IResource.PROJECT).isOK()) {", "\t\t\t\tproject = workspace.getRoot().getProject(path.toString());", "\t\t\t\tproject = workspace.getRoot().getFile(path).getProject();"]}
{"request": ["public String getUserId(HttpServletRequest request) {", "\t\tHttpSession session = request.getSession();"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"event": ["public void resourceChanged(final IResourceChangeEvent event) {", "\t\tif (event.getType() == IResourceChangeEvent.PRE_CLOSE) {", "\t\t\t\t\t\tif (((FileEditorInput) textEditor.getEditorInput()).getFile().getProject().equals(event.getResource())) {"]}
{"Result": "Method without Parameter"}
{"query": ["public static String createQueryLogMessage(String query, List<Object> parameterValues) {", "    builder.append(query);"], "parameterValues": ["public static String createQueryLogMessage(String query, List<Object> parameterValues) {", "    if(parameterValues != null && parameterValues.size() > 0) {", "      Iterator<Object> parameterIterator = parameterValues.iterator();"]}
{"obj": ["private static String objectToString(Object obj) {", "    if(obj == null) {", "    if(obj instanceof CharSequence) {", "      return \"\\\"\"+obj.toString()+\"\\\"\";", "    return obj.toString();"]}
{"item": ["public TimelineItem insertTimelineItem(TimelineItem item) throws IOException {", "\t\treturn getMirror().timeline().insert(item).execute();"]}
{"item": ["public void insertTimelineItem(TimelineItem item, String attachmentContentType, byte[] attachmentData) throws IOException {", "\t\ttimeline.insert(item, new ByteArrayContent(attachmentContentType, attachmentData)).execute();"], "attachmentContentType": ["public void insertTimelineItem(TimelineItem item, String attachmentContentType, byte[] attachmentData) throws IOException {", "\t\ttimeline.insert(item, new ByteArrayContent(attachmentContentType, attachmentData)).execute();"], "attachmentData": ["public void insertTimelineItem(TimelineItem item, String attachmentContentType, byte[] attachmentData) throws IOException {", "\t\ttimeline.insert(item, new ByteArrayContent(attachmentContentType, attachmentData)).execute();"]}
{"item": ["public void insertTimelineItem(TimelineItem item, String attachmentContentType, InputStream attachmentInputStream) throws IOException {", "\t\tinsertTimelineItem(item, attachmentContentType, ByteStreams.toByteArray(attachmentInputStream));"], "attachmentContentType": ["public void insertTimelineItem(TimelineItem item, String attachmentContentType, InputStream attachmentInputStream) throws IOException {", "\t\tinsertTimelineItem(item, attachmentContentType, ByteStreams.toByteArray(attachmentInputStream));"], "attachmentInputStream": ["public void insertTimelineItem(TimelineItem item, String attachmentContentType, InputStream attachmentInputStream) throws IOException {", "\t\tinsertTimelineItem(item, attachmentContentType, ByteStreams.toByteArray(attachmentInputStream));"]}
{"response": ["private void validate(final CacheResponse response, final String keyword) {", "\t\tif (!response.getMessage().toLowerCase(Locale.US).startsWith(keyword)) {", "\t\t\tthrow new IllegalArgumentException(response.getMessage());"], "keyword": ["private void validate(final CacheResponse response, final String keyword) {", "\t\tif (!response.getMessage().toLowerCase(Locale.US).startsWith(keyword)) {"]}
{"criteria": ["public String toQueryString(Criteria criteria, CriteriaQueryBuilder queryBuilder) {", "    String absolutePath = queryBuilder.getAbsolutePath(criteria, relativePath);"], "queryBuilder": ["public String toQueryString(Criteria criteria, CriteriaQueryBuilder queryBuilder) {", "    String absolutePath = queryBuilder.getAbsolutePath(criteria, relativePath);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"editor": ["protected IAction getAction(ITextEditor editor, String actionID) {", "\t\treturn (editor == null ? null : editor.getAction(actionID));"], "actionID": ["protected IAction getAction(ITextEditor editor, String actionID) {", "\t\treturn (editor == null ? null : editor.getAction(actionID));"]}
{"Result": "Method without Parameter"}
{"sql": ["protected void appendLimitAndOffSet(final StringBuilder sql, final Page page) {", "\t\tsql.append(\" LIMIT \").append(page.getPageSize()).append(\" OFFSET \").append(page.getOffset());"], "page": ["protected void appendLimitAndOffSet(final StringBuilder sql, final Page page) {", "\t\tsql.append(\" LIMIT \").append(page.getPageSize()).append(\" OFFSET \").append(page.getOffset());"]}
{"name": ["public static <N> NamedProperty<N> NamedProperty(final N name, final PropertyValue<N> value) {", "    return new NamedProperty.Impl<>(name, value);"], "value": ["public static <N> NamedProperty<N> NamedProperty(final N name, final PropertyValue<N> value) {", "    return new NamedProperty.Impl<>(name, value);"]}
{"name": ["public static <N> NamedProperty<N> NamedProperty(final N name, final String value) {", "    return NamedProperty(name, Datatree.<N>Literal(value));"], "value": ["public static <N> NamedProperty<N> NamedProperty(final N name, final String value) {", "    return NamedProperty(name, Datatree.<N>Literal(value));"]}
{"name": ["public static <N> NamedProperty<N> NamedProperty(final N name, final NestedDocument<N> value) {", "    return new NamedProperty.Impl<>(name, value);"], "value": ["public static <N> NamedProperty<N> NamedProperty(final N name, final NestedDocument<N> value) {", "    return new NamedProperty.Impl<>(name, value);"]}
{"value": ["public static <N> Literal.StringLiteral<N> Literal(final String value) {", "    return new Literal.StringLiteral<>(value);"]}
{"value": ["public static <N> Literal.UriLiteral<N> Literal(final URI value) {", "    return new Literal.UriLiteral<>(value);"]}
{"value": ["public static <N> Literal.TypedLiteral<N> Literal(final String value, final QName type) {", "    return new Literal.TypedLiteral<>(value, type);"], "type": ["public static <N> Literal.TypedLiteral<N> Literal(final String value, final QName type) {", "    return new Literal.TypedLiteral<>(value, type);"]}
{"namespaceURI": ["public static QName QName(String namespaceURI, String localPart, String prefix) {", "    return new QName(namespaceURI, localPart, prefix);"], "localPart": ["public static QName QName(String namespaceURI, String localPart, String prefix) {", "    return new QName(namespaceURI, localPart, prefix);"], "prefix": ["public static QName QName(String namespaceURI, String localPart, String prefix) {", "    return new QName(namespaceURI, localPart, prefix);"]}
{"filterConfig": ["public void init(final FilterConfig filterConfig)", "\t\tProperties props = getFilterInitParameters(filterConfig);", "\t\t\tconfig = new CORSConfiguration(props);", "\t\thandler = new CORSRequestHandler(config);"]}
{"createdByEntityId": ["public void created(final UUID createdByEntityId) {", "\t\tthis.createdByEntityId = createdByEntityId;", "\t\tthis.updatedByEntityId = createdByEntityId;"]}
{"parser": ["protected void init(JsonParser parser) throws IOException {", "\t\tLoggerFactory.getLogger(getClass()).warn(\"init(JsonParser parser) invoked to handle field: {}\", parser.getCurrentName());"]}
{"lastupdatedByEntityId": ["public void updated(final UUID lastupdatedByEntityId) {", "\t\tAssert.notNull(lastupdatedByEntityId, \"lastupdatedByEntityId is required\");", "\t\tupdatedByEntityId = lastupdatedByEntityId;"]}
{"port": ["public void close( int port ) {", "        if (port == -1 || sh.isPort( port )) {"]}
{"args": ["public static final void main( String[] args ) {", "    if (args.length != 1) {", "    int port = Integer.valueOf( args[0] ).intValue();"]}
{"instance": ["public void validateOpts(Object instance) {\r", "        final Set<ConstraintViolation<Object>> set = validator.validate(instance);\r", "        for (ConstraintViolation<Object> violation : set) {\r", "            final Path path = violation.getPropertyPath();\r", "            final String msg = violation.getMessage();\r", "            sb.append(path.toString()).append(\" \").append(msg).append(\". \");\r"]}
{"args": ["public void validateArgs(List<Object> args, Object instance, Method m, Command cmd) {\r", "                args.toArray());\r"], "instance": ["public void validateArgs(List<Object> args, Object instance, Method m, Command cmd) {\r", "        final Set<ConstraintViolation<Object>> set = validator.validateParameters(instance, m,\r"], "m": ["public void validateArgs(List<Object> args, Object instance, Method m, Command cmd) {\r", "        final Set<ConstraintViolation<Object>> set = validator.validateParameters(instance, m,\r"], "cmd": ["public void validateArgs(List<Object> args, Object instance, Method m, Command cmd) {\r", "                Argument arg = cmd.getArguments().get(pos);\r", "                sb.append(arg.getName()).append(\" \").append(msg).append(\". \");\r"]}
{"name": ["public void subscribe( String name,  Listener listener, Map headers ) {", "        List list = (List)_listeners.get( name );", "        if (list == null) {", "          _listeners.put( name, list );", "        if (!list.contains( listener )) list.add( listener );", "    headers.put( \"destination\", name );"], "listener": ["public void subscribe( String name,  Listener listener, Map headers ) {", "      if (listener != null) {", "        if (!list.contains( listener )) list.add( listener );"], "headers": ["public void subscribe( String name,  Listener listener, Map headers ) {", "    if (headers == null) headers = new HashMap();", "    headers.put( \"destination\", name );", "    transmit( Command.SUBSCRIBE, headers );"]}
{"name": ["public void unsubscribe( String name, Listener l ) {", "      List list = (List)_listeners.get( name );", "      if (list != null) {", "        list.remove( l );", "        if (list.size() == 0) {", "          unsubscribe( name );"], "l": ["public void unsubscribe( String name, Listener l ) {", "        list.remove( l );"]}
{"name": ["public void unsubscribe( String name, Map header ) {", "    synchronized( _listeners ) { _listeners.remove( name ); }", "    header.put( \"destination\", name );"], "header": ["public void unsubscribe( String name, Map header ) {", "    if (header == null) header = new HashMap();", "    header.put( \"destination\", name );", "    transmit( Command.UNSUBSCRIBE, header );"]}
{"name": ["public void unsubscribeW( String name, Map header ) throws InterruptedException {", "    unsubscribe( name, (HashMap)null );"], "header": ["public void unsubscribeW( String name, Map header ) throws InterruptedException {", "    String receipt = addReceipt( header );", "    waitOnReceipt( receipt );"]}
{"dest": ["public void send( String dest, String mesg, Map header ) {", "    header.put( \"destination\", dest );"], "mesg": ["public void send( String dest, String mesg, Map header ) {", "    transmit( Command.SEND, header, mesg );"], "header": ["public void send( String dest, String mesg, Map header ) {", "    if (header == null) header = new HashMap();", "    header.put( \"destination\", dest );", "    transmit( Command.SEND, header, mesg );"]}
{"name": ["public Message getNext( String name ) {", "        if (m.headers().get( \"destination\" ).equals(name)) {"]}
{"receipt_id": ["public boolean hasReceipt( String receipt_id ) {", "        if (o.equals(receipt_id)) return true;"]}
{"receipt_id": ["public void clearReceipt( String receipt_id ) {", "        if (o.equals(receipt_id)) i.remove();"]}
{"deadEvent": ["\tpublic void logDeadEvent(final DeadEvent deadEvent) {", "\t\tfinal Object event = deadEvent.getEvent();"]}
{"source": ["public <T> T convert(final Object source, final Class<T> targetclass) {", "        if (source == null) {", "        final Class<?> sourceclass = source.getClass();", "            return (T) converter.convert(source, targetclass);", "        return (T) converter.convert(source, targetclass);"], "targetclass": ["public <T> T convert(final Object source, final Class<T> targetclass) {", "        final SourceTargetPairKey key = new SourceTargetPairKey(sourceclass, targetclass);", "        Converter converter = cache.get(key);", "        if (converter != null) {", "            return (T) converter.convert(source, targetclass);", "            SourceTargetPairMatch match = pair.match(sourceclass, targetclass);", "            if (match.matchesSource() && match.matchesTarget()) {", "                matches.add(match);", "                    + targetclass.getName() + \"] and source value [\" + sourceclass.getName()", "        converter = matches.get(0).pair.converter;", "        cache.put(key, converter);", "        return (T) converter.convert(source, targetclass);"]}
{"lines": ["protected Priority getPriority(final int lines) {", "        if (lines >= highThreshold) {", "        else if (lines >= normalThreshold) {"]}
{"p": ["public void execute(GNUishParser p) {", "      if (!m.getName().equals(p.getCommand())) {", "      final List<Object> args = adjustArgs(p.getArgs(), m);", "      injectOpts(p, clazz);", "        validateArgs(args, instance, m, this);", "        m.invoke(instance, args.toArray());", "    System.out.println(p.getCommand() + \": command not found\");"]}
{"p": ["private void injectOpts(GNUishParser p, Class<?> clazz) {", "      String value = p.getShortOpt(anno.shortName());", "      if (value == null) {", "        value = p.getLongOpt(f.getName());", "        if (value == null) {", "        f.set(instance, c.convert(value, f.getType()));", "        throw CliException.WRONG_OPT_TYPE(f.getName(), f.getType().getName(), value);"], "clazz": ["private void injectOpts(GNUishParser p, Class<?> clazz) {", "    for (Field f : clazz.getDeclaredFields()) {", "      f.setAccessible(true);", "      final CliOption anno = f.getAnnotation(CliOption.class);", "      if (anno == null) {", "      String value = p.getShortOpt(anno.shortName());", "      if (value == null) {", "        value = p.getLongOpt(f.getName());", "        if (value == null) {", "        f.set(instance, c.convert(value, f.getType()));", "        throw CliException.WRONG_OPT_TYPE(f.getName(), f.getType().getName(), value);"]}
{"args": ["private List<Object> adjustArgs(List<String> args, Method m) {", "    for (int i = 0; i < args.size(); i++) {", "          varargs.add(c.convert(args.get(i), types[types.length - 1]));", "          result.add(c.convert(args.get(i), types[i]));", "                types[i].getName(), args.get(i));"], "m": ["private List<Object> adjustArgs(List<String> args, Method m) {", "    final Class<?>[] types = m.getParameterTypes();", "    if (m.isVarArgs()) {", "        if (m.isVarArgs() && i >= types.length - 1) {", "    if (m.isVarArgs()) {"]}
{"metadataManager": ["private List<MigrationResult> migratePersonality(final MetadataManager metadataManager, final String personalityName, final Integer targetVersion, final MigratoryOption [] options)", "        final Integer currentVersion = metadataManager.getCurrentVersion(personalityName);", "        final List<MetadataInfo> history = metadataManager.getPersonalityHistory(personalityName);"], "personalityName": ["private List<MigrationResult> migratePersonality(final MetadataManager metadataManager, final String personalityName, final Integer targetVersion, final MigratoryOption [] options)", "        final Integer currentVersion = metadataManager.getCurrentVersion(personalityName);", "        if (currentVersion == null  && !migratoryConfig.isCreatePersonalities()) {", "        final List<MetadataInfo> history = metadataManager.getPersonalityHistory(personalityName);", "        final MigrationManager migrationManager = new MigrationManager(migratoryContext, personalityName);", "        if (history != null && !history.isEmpty()) {", "                final DbValidator dbValidator = new DbValidator(migrationManager);", "                final ValidationResult validationResult = dbValidator.validate(history);", "                if (validationResult.getValidationStatus() != ValidationStatus.OK) {", "                    throw new MigratoryException(Reason.VALIDATION_FAILED, \"Validation for Personality '%s' failed\", personalityName);", "        final MigrationPlanner migrationPlanner = new MigrationPlanner(migrationManager, currentVersion, targetVersion);"], "targetVersion": ["private List<MigrationResult> migratePersonality(final MetadataManager metadataManager, final String personalityName, final Integer targetVersion, final MigratoryOption [] options)", "        final MigrationPlanner migrationPlanner = new MigrationPlanner(migrationManager, currentVersion, targetVersion);", "        migrationPlanner.plan();", "        LOG.info(\"{}\", migrationPlanner.toString());", "        switch(migrationPlanner.getDirection()) {", "            LOG.warn(\"Encountered State {}. This should never happen!\", migrationPlanner.getDirection());", "        final DbMigrator migrator = new DbMigrator(migratoryContext, migrationPlanner);", "        final List<MigrationResult> results = migrator.migrate(options);"], "options": ["private List<MigrationResult> migratePersonality(final MetadataManager metadataManager, final String personalityName, final Integer targetVersion, final MigratoryOption [] options)", "            if (!MigratoryOption.containsOption(MigratoryOption.NO_VERIFY, options)) {", "        final List<MigrationResult> results = migrator.migrate(options);", "        LOG.info(\"Migration finished in '{}' steps, result is {}\",  results.size(), MigrationResult.determineMigrationState(results));", "        return results;"]}
{"request": ["public void tagRequest(final HttpServletRequest request) {", "\t\tfinal CORSRequestType type = CORSRequestType.detect(request);", "\t\tswitch (type) {", "\t\t\t\trequest.setAttribute(\"cors.isCorsRequest\", true);", "\t\t\t\trequest.setAttribute(\"cors.origin\", request.getHeader(\"Origin\"));", "\t\t\t\trequest.setAttribute(\"cors.requestType\", \"actual\");", "\t\t\t\trequest.setAttribute(\"cors.isCorsRequest\", true);", "\t\t\t\trequest.setAttribute(\"cors.origin\", request.getHeader(\"Origin\"));", "\t\t\t\trequest.setAttribute(\"cors.requestType\", \"preflight\");", "\t\t\t\trequest.setAttribute(\"cors.requestHeaders\", request.getHeader(\"Access-Control-Request-Headers\"));", "\t\t\t\trequest.setAttribute(\"cors.isCorsRequest\", false);"]}
{"request": ["public void handleActualRequest(final HttpServletRequest request, final HttpServletResponse response)", "\t\tif (CORSRequestType.detect(request) != CORSRequestType.ACTUAL)", "\t\tOrigin requestOrigin = new Origin(request.getHeader(\"Origin\"));", "\t\t\tmethod = HTTPMethod.valueOf(request.getMethod());", "\t\t\tthrow new UnsupportedHTTPMethodException(\"Unsupported HTTP method: \" + request.getMethod());", "\t\trequest.setAttribute(\"cors.origin\", requestOrigin.toString());", "\t\trequest.setAttribute(\"cors.requestType\", \"actual\");"], "response": ["public void handleActualRequest(final HttpServletRequest request, final HttpServletResponse response)", "\t\tresponse.addHeader(\"Access-Control-Allow-Origin\", requestOrigin.toString());", "\t\t\tresponse.addHeader(\"Access-Control-Allow-Credentials\", \"true\");", "\t\t\tresponse.addHeader(\"Access-Control-Expose-Headers\", exposedHeaders);"]}
{"request": ["public void handlePreflightRequest(final HttpServletRequest request, final HttpServletResponse response)", "\t\tif (CORSRequestType.detect(request) != CORSRequestType.PREFLIGHT)", "\t\tOrigin requestOrigin = new Origin(request.getHeader(\"Origin\"));", "\t\tString requestMethodHeader = request.getHeader(\"Access-Control-Request-Method\");", "\t\tfinal String[] requestHeaderValues = parseMultipleHeaderValues(request.getHeader(\"Access-Control-Request-Headers\"));"], "response": ["public void handlePreflightRequest(final HttpServletRequest request, final HttpServletResponse response)", "\t\t\tresponse.addHeader(\"Access-Control-Allow-Origin\", requestOrigin.toString());", "\t\t\tresponse.addHeader(\"Access-Control-Allow-Credentials\", \"true\");", "\t\t\t\tresponse.addHeader(\"Access-Control-Allow-Origin\", \"*\");", "\t\t\t\tresponse.addHeader(\"Access-Control-Allow-Origin\", requestOrigin.toString());", "\t\t\tresponse.addHeader(\"Access-Control-Max-Age\", Integer.toString(config.maxAge));", "\t\tresponse.addHeader(\"Access-Control-Allow-Methods\", supportedMethods);", "\t\t\tresponse.addHeader(\"Access-Control-Allow-Headers\", supportedHeaders);"]}
{"options": ["public boolean setOptions(String[] options) throws Exception {", "      ns = parser.parseArgs(options);", "    setJavaHome(ns.get(\"javahome\"));", "    setClassPath(ns.getString(\"classpath\"));", "    setClassesFile(ns.get(\"classes\"));", "    setAdditionalFile(ns.get(\"additional\"));", "    setPackages(ns.getList(\"packages\"));", "    setOutputFile(ns.get(\"output\"));"]}
{"Result": "Method without Parameter"}
{"lines": ["protected List<String> filter(List<String> lines, String regexp, boolean invert) {", "    for (String line: lines) {", "\tif (!pattern.matcher(line).matches())", "\t  result.add(line);", "\tif (pattern.matcher(line).matches())", "\t  result.add(line);"], "regexp": ["protected List<String> filter(List<String> lines, String regexp, boolean invert) {", "    pattern = Pattern.compile(regexp);", "\tif (!pattern.matcher(line).matches())", "\tif (pattern.matcher(line).matches())"], "invert": ["protected List<String> filter(List<String> lines, String regexp, boolean invert) {", "      if (invert) {"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"instanceProvider": ["  public int compareTo(InstanceProvider instanceProvider) {", "    if (this.getPriority().equals(instanceProvider.getPriority())) {", "      return this.getName().compareTo(instanceProvider.getName());", "      return this.getPriority().compareTo(instanceProvider.getPriority());"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"uploadedFile": ["    public Set<String> getObjectId(File uploadedFile) throws HarvesterException {", "            objectIds.add(createDigitalObject(uploadedFile));"]}
{"file": ["private String createDigitalObject(File file) throws HarvesterException,", "            object = StorageUtils.storeFile(getStorage(), file,", "            String oid = StorageUtils.generateOid(file);", "            String pid = StorageUtils.generatePid(file);", "            object = getStorage().createObject(oid);", "                    object.createStoredPayload(pid, new FileInputStream(file));", "                object.createLinkedPayload(pid, file.getAbsolutePath());", "        Properties props = object.getMetadata();", "                FilenameUtils.separatorsToUnix(file.getAbsolutePath()));", "        objectId = object.getId();", "        String ext = FilenameUtils.getExtension(file.getName());", "        object.close();"]}
{"props": ["private void storeList(Properties props, Map<String, List<String>> details,", "        String currentValue = props.getProperty(field, \"\");", "        props.setProperty(field, joinedList);"], "details": ["private void storeList(Properties props, Map<String, List<String>> details,", "        valueSet.addAll(details.get(field));"], "field": ["            String field) {", "        String currentValue = props.getProperty(field, \"\");", "        valueSet.addAll(details.get(field));", "        props.setProperty(field, joinedList);"]}
{"options": ["public List<MetadataInfo> ensureMetadata(final MigratoryOption [] options)", "            final List<MigrationResult> results = migrator.migrate(options);", "            return commit(results);"]}
{"owner": ["private Object createDrySourceDetail(final AbstractBuild<?, ?> owner,", "            return new SourceDetail(owner, ((DuplicateCode)fromAnnotation).getLink(to), defaultEncoding);"], "container": ["            final AnnotationContainer container, final String defaultEncoding,", "        FileAnnotation fromAnnotation = container.getAnnotation(from);"], "defaultEncoding": ["            final AnnotationContainer container, final String defaultEncoding,", "            return new SourceDetail(owner, ((DuplicateCode)fromAnnotation).getLink(to), defaultEncoding);"], "fromString": ["            final String fromString, final String toString) {", "        long from = Long.parseLong(fromString);", "        FileAnnotation fromAnnotation = container.getAnnotation(from);", "        if (fromAnnotation instanceof DuplicateCode) {", "            return new SourceDetail(owner, ((DuplicateCode)fromAnnotation).getLink(to), defaultEncoding);"], "toString": ["            final String fromString, final String toString) {", "        long to = Long.parseLong(toString);", "            return new SourceDetail(owner, ((DuplicateCode)fromAnnotation).getLink(to), defaultEncoding);"]}
{"highThreshold": ["private FormValidation validate(final String highThreshold, final String normalThreshold, final String message) {", "            int high = Integer.parseInt(highThreshold);", "            if (isValid(normal, high)) {"], "normalThreshold": ["private FormValidation validate(final String highThreshold, final String normalThreshold, final String message) {", "            int normal = Integer.parseInt(normalThreshold);", "            if (isValid(normal, high)) {"], "message": ["private FormValidation validate(final String highThreshold, final String normalThreshold, final String message) {", "        return FormValidation.error(message);"]}
{"args": ["static void validateArgs(List<Object> args, Object instance, Method m, Command cmd) {", "            validate.invoke(validator, args, instance, m, cmd);"], "instance": ["static void validateArgs(List<Object> args, Object instance, Method m, Command cmd) {", "            validate.invoke(validator, args, instance, m, cmd);"], "m": ["static void validateArgs(List<Object> args, Object instance, Method m, Command cmd) {", "            validate.invoke(validator, args, instance, m, cmd);"], "cmd": ["static void validateArgs(List<Object> args, Object instance, Method m, Command cmd) {", "            validate.invoke(validator, args, instance, m, cmd);"]}
{"instance": ["static void validateOpts(Object instance) {", "            validate.invoke(validator, instance);"]}
{"className": ["static boolean onClasspath(String className) {", "            cl.loadClass(className);"]}
{"uri": ["public boolean accept(final URI uri)", "            if (loader.accept(uri)) {"]}
{"fileUri": ["public String loadFile(final URI fileUri)", "                if (loader.accept(fileUri)) {", "                    return loader.loadFile(fileUri);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"target": [], "baseRequest": [], "request": [], "response": []}
{"target": [], "baseRequest": [], "request": [], "response": []}
{"migrationPlan": ["public Map<String, List<MetadataInfo>> dbMigrate(final MigrationPlan migrationPlan, final MigratoryOption ... options) throws MigratoryException", "        return migrator.migrate(migrationPlan, options);"]}
{"personalities": ["public Map<String, ValidationResult> dbValidate(final Collection<String> personalities, final MigratoryOption ... options) throws MigratoryException", "        return validator.validate(personalities, options);"]}
{"personalities": ["public Map<String, List<MetadataInfo>> dbHistory(final Collection<String> personalities, final MigratoryOption ... options)", "        return internalHistory.history(personalities, options);"]}
{"Result": "Method without Parameter"}
{"lines": ["List<SqlStatement> linesToStatements(List<String> lines)", "        for (final String line : lines)", "            if (StringUtils.isBlank(line)) {", "            statementSql.append(line);", "            final String oldDelimiter = delimiter;", "            delimiter = changeDelimiterIfNecessary(statementSql.toString(), line, delimiter);", "            if (!StringUtils.equals(delimiter, oldDelimiter) && isDelimiterChangeExplicit()) {", "            if (StringUtils.endsWith(line, delimiter)) {", "                statementSql.setLength(statementSql.length() - delimiter.length());"]}
{"notable": ["            final Object notable,", "        if(notable == null) {", "        final Bookmark bookmark = bookmarkService.bookmarkFor(notable);", "        if(bookmark == null) {", "        final String notableStr = bookmark.toString();"], "calendarName": ["            final String calendarName) {", "        if(calendarName == null) {", "                        \"calendarName\", calendarName));"]}
{"note": ["    public void updateLink(final Note note) {", "        final NotableLink link = findByNote(note);", "        sync(note, link);"]}
{"args": ["private String[] parseOpts(String[] args) {\r", "        if (args == null || args.length == 0) {\r", "        final List<String> argsList = Arrays.asList(args);\r", "        final ListIterator<String> argsIt = argsList.listIterator();\r"]}
{"c": ["public void transmit( Command c, Map h, String b ) {", "    _server.receive( c, h, b, this );"], "h": ["public void transmit( Command c, Map h, String b ) {", "    _server.receive( c, h, b, this );"], "b": ["public void transmit( Command c, Map h, String b ) {", "    _server.receive( c, h, b, this );"]}
{"Result": "Method without Parameter"}
{"linkHashCode": ["public FileAnnotation getLink(final long linkHashCode) {", "            if (link.getKey() == linkHashCode) {", "        throw new NoSuchElementException(\"Linked annotation not found: key=\" + linkHashCode);"]}
{"c": ["public void transmit( Command c, Map h, String b ) {", "      Transmitter.transmit( c, h, b, _output );"], "h": ["public void transmit( Command c, Map h, String b ) {", "      Transmitter.transmit( c, h, b, _output );"], "b": ["public void transmit( Command c, Map h, String b ) {", "      Transmitter.transmit( c, h, b, _output );"]}
{"contextPath": ["public static JAXBContext get(final String contextPath) {", "\t\tAssert.hasText(contextPath, \"contextPath is required\");", "\t\tJAXBContext ctx = jaxbContexts.get(contextPath);", "\t\tif (ctx == null) {", "\t\t\t\tctx = JAXBContext.newInstance(contextPath);", "\t\t\t\tthrow new IllegalArgumentException(\"Failed to create JAXBContext - invalid JAXB context path: \" + contextPath, e);", "\t\t\tjaxbContexts.put(contextPath, ctx);", "\t\t\tLoggerFactory.getLogger(JAXBContextCache.class).info(\"cached : {}\", contextPath);", "\t\treturn ctx;"]}
{"root": ["private void createBoxList(Box root, Vector<BoxNode> list)", "        if (root.isDisplayed())", "            if (!(root instanceof Viewport) && root.isVisible())", "                BoxNode newnode = new BoxNode(root, page, zoom);", "            if (root instanceof ElementBox)", "                ElementBox elem = (ElementBox) root;", "                for (int i = elem.getStartChild(); i < elem.getEndChild(); i++)", "                    createBoxList(elem.getSubBox(i), list);"], "list": ["private void createBoxList(Box root, Vector<BoxNode> list)", "                list.add(newnode);", "                    createBoxList(elem.getSubBox(i), list);"]}
{"rootbox": ["private BoxNode createBoxTree(ElementBox rootbox, Vector<BoxNode> boxlist, boolean useBounds, boolean useVisualBounds, boolean preserveAux)", "        BoxNode root = new BoxNode(rootbox, page, zoom);"], "boxlist": ["private BoxNode createBoxTree(ElementBox rootbox, Vector<BoxNode> boxlist, boolean useBounds, boolean useVisualBounds, boolean preserveAux)", "        Vector<BoxNode> list = new Vector<BoxNode>(boxlist);", "        for (BoxNode node : list)", "            node.removeFromTree();", "            for (Iterator<BoxNode> it = list.iterator(); it.hasNext(); )", "                BoxNode node = it.next();", "                if (!node.isVisuallySeparated() || !node.isVisible())", "                    it.remove();", "        for (BoxNode node : list)", "                node.markNodesInside(list, useVisualBounds);", "                node.markChildNodes(list);", "        for (Iterator<BoxNode> it = list.iterator(); it.hasNext();)", "            BoxNode node = it.next();", "            if (node.isRootNode())", "                root.appendChild(node);", "                it.remove();", "            ((BoxNode) root.getChildAt(i)).takeChildren(list);"], "useBounds": ["private BoxNode createBoxTree(ElementBox rootbox, Vector<BoxNode> boxlist, boolean useBounds, boolean useVisualBounds, boolean preserveAux)", "            if (useBounds)"], "useVisualBounds": ["private BoxNode createBoxTree(ElementBox rootbox, Vector<BoxNode> boxlist, boolean useBounds, boolean useVisualBounds, boolean preserveAux)", "                node.markNodesInside(list, useVisualBounds);"], "preserveAux": ["private BoxNode createBoxTree(ElementBox rootbox, Vector<BoxNode> boxlist, boolean useBounds, boolean useVisualBounds, boolean preserveAux)", "        if (!preserveAux)"]}
{"root": ["private void computeBackgrounds(BoxNode root, Color currentbg)", "        Color newbg = root.getBackgroundColor();", "        root.setEfficientBackground(newbg);", "        root.setBackgroundSeparated(!newbg.equals(currentbg));", "        for (int i = 0; i < root.getChildCount(); i++)", "            computeBackgrounds((BoxNode) root.getChildAt(i), newbg);"], "currentbg": ["private void computeBackgrounds(BoxNode root, Color currentbg)", "            newbg = currentbg;", "        root.setEfficientBackground(newbg);", "        root.setBackgroundSeparated(!newbg.equals(currentbg));", "            computeBackgrounds((BoxNode) root.getChildAt(i), newbg);"]}
{"url": ["public void setMappingFile(URL url, String realFile){", "        componentFiles.put(url.getFile(), file);"], "realFile": ["public void setMappingFile(URL url, String realFile){", "        File file = new File(realFile);", "        componentFiles.put(url.getFile(), file);"]}
{"url": ["public File getMappingFile(URL url) throws IOException {", "        String fileName = FilenameUtils.normalize(url.getFile(), true);", "            componentFile = guessFile(url, \"app\", \"lib\", \"repository\");"]}
{"spec": ["public static VersionRange createFromVersionSpec( String spec )", "        if ( spec == null )", "        String process = spec;", "        while ( process.startsWith( \"[\" ) || process.startsWith( \"(\" ) )", "            int index1 = process.indexOf( \")\" );", "            int index2 = process.indexOf( \"]\" );", "            int index = index2;", "            if ( index2 < 0 || index1 < index2 )", "                if ( index1 >= 0 )", "                    index = index1;", "            if ( index < 0 )", "                throw new InvalidVersionSpecificationException( \"Unbounded range: \" + spec );", "            Restriction restriction = parseRestriction( process.substring( 0, index + 1 ) );", "            if ( lowerBound == null )", "                lowerBound = restriction.getLowerBound();", "            if ( upperBound != null )", "                if ( restriction.getLowerBound() == null || restriction.getLowerBound().compareTo( upperBound ) < 0 )", "                    throw new InvalidVersionSpecificationException( \"Ranges overlap: \" + spec );", "            restrictions.add( restriction );", "            upperBound = restriction.getUpperBound();", "            process = process.substring( index + 1 ).trim();", "            if ( process.length() > 0 && process.startsWith( \",\" ) )", "                process = process.substring( 1 ).trim();", "        if ( process.length() > 0 )", "                    \"Only fully-qualified sets allowed in multiple set scenario: \" + spec );", "                version = new ComponentVersion( process );", "        return new VersionRange( version, restrictions );"]}
{"src": ["public BoxTransform concatenate(BoxTransform src)", "        if (src.isEmpty())", "            return src;", "            ret.transform.concatenate(src.transform);"]}
{"rect": ["public Rectangular transformRect(Rectangular rect)", "            Rectangle src = new Rectangle(rect.getX1(), rect.getY1(), rect.getWidth(), rect.getHeight());", "            return rect;"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"childNode": ["public boolean visuallyEncloses1(BoxNode childNode)", "        int cx1 = childNode.getVisualBounds().getX1();", "        int cy1 = childNode.getVisualBounds().getY1();", "        int cx2 = childNode.getVisualBounds().getX2();", "        int cy2 = childNode.getVisualBounds().getY2();", "           return this.getOrder() < childNode.getOrder();"]}
{"list": ["public void takeChildren(Vector<BoxNode> list)", "        for (Iterator<BoxNode> it = list.iterator(); it.hasNext();)", "            BoxNode node = it.next();", "            if (node.nearestParent.equals(this))    ", "                appendChild(node);", "                it.remove();", "            ((BoxNode) getChildAt(i)).takeChildren(list);"]}
{"command": ["protected void process(String command) {", "            Method method = this.getClass().getMethod(command);", "            logger.info(\"Try to delegate '{}' to launcher directly.\", command);", "            method.invoke(this);", "            logger.info(\"Invoke '{}' to launcher directly successfully. \\r\\n\", command);", "            logger.warn(\"unrecognized command: '{}'\", command);", "            logger.warn(\"Failed to execute: '{}'\", command);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"config": ["public void setup(PlatformConfiguration config, Environment env) {", "        this.configuration = Preconditions.checkNotNull(config, \"Configuration cannot be null.\");"], "env": ["public void setup(PlatformConfiguration config, Environment env) {", "        this.environment = Preconditions.checkNotNull(env, \"Environment cannot be null.\");"]}
{"methodMap": ["public <T> T query(MethodMap methodMap, ArgMap argMap, Class<T> responseType ) throws OpenStatesException {", "\t\t\tif ( isCaching(methodMap, argMap) ) {", "\t\t\t\tFile file = getCacheFile(methodMap, argMap);", "\t\t\t\t\tOpenStates.cacheFileFromAPI(methodMap, argMap, file, responseType);", "\t\t\t\tconn = OpenStates.getConnectionFromAPI(methodMap, argMap);", "\t\t\t    \tthrow new OpenStatesException(rcode, msg, methodMap, argMap, responseType);", "\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);", "\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);", "\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);", "\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);", "\t\t\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);"], "argMap": ["public <T> T query(MethodMap methodMap, ArgMap argMap, Class<T> responseType ) throws OpenStatesException {", "\t\t\tif ( isCaching(methodMap, argMap) ) {", "\t\t\t\tFile file = getCacheFile(methodMap, argMap);", "\t\t\t\tlong fileLength = file.length(); ", "\t\t\t\tlogger.fine(\"Length of File in cache:\" + fileLength + \": \" + file.getName());", "\t\t\t\t\tOpenStates.cacheFileFromAPI(methodMap, argMap, file, responseType);", "\t\t\t\treader = new BufferedReader(new InputStreamReader(new FileInputStream(file), charSet));", "\t\t\t\tconn = OpenStates.getConnectionFromAPI(methodMap, argMap);", "\t\t\t\tcharSet = getCharset(conn);", "\t\t\t\tint rcode = conn.getResponseCode();", "\t\t\t    \tString msg = conn.getResponseMessage();", "\t\t\t    \tconn.disconnect();", "\t\t\t    \tthrow new OpenStatesException(rcode, msg, methodMap, argMap, responseType);", "\t\t\t\treader = new BufferedReader(new InputStreamReader(conn.getInputStream(), charSet));", "        \treturn mapper.readValue( reader, responseType );", "\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);", "\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);", "\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);", "\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);", "\t\t\tif ( conn != null ) conn.disconnect();", "\t\t\tif ( reader != null ) {", "\t\t\t\t\treader.close();", "\t\t\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);"], "responseType": ["public <T> T query(MethodMap methodMap, ArgMap argMap, Class<T> responseType ) throws OpenStatesException {", "\t\t\t\t\tOpenStates.cacheFileFromAPI(methodMap, argMap, file, responseType);", "\t\t\t    \tthrow new OpenStatesException(rcode, msg, methodMap, argMap, responseType);", "        \treturn mapper.readValue( reader, responseType );", "\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);", "\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);", "\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);", "\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);", "\t\t\t\t\tthrow new OpenStatesException(e, methodMap, argMap, responseType);"]}
{"command": ["public void register(Command command) {", "\t\tPreconditions.checkArgument(command != null, \"Parameter 'command' must not be [\" + command + \"]\");", "\t\tregister(command.name(), command);"]}
{"name": ["public void register(String name, Command command) {", "\t\tPreconditions.checkArgument(name != null && !name.isEmpty(), \"Parameter 'name' must not be [\" + name + \"]\");", "\t\tcommands.put(name, command);"], "command": ["public void register(String name, Command command) {", "\t\tPreconditions.checkArgument(command != null, \"Parameter 'command' must not be [\" + command + \"]\");", "\t\tcommands.put(name, command);"]}
{"name": ["public void unregister(String name) {", "\t\tPreconditions.checkArgument(name != null && !name.isEmpty(), \"Parameter 'name' must not be [\" + name + \"]\");", "\t\tcommands.remove(name);"]}
{"line": ["\tpublic void exec(String line) {", "\t\tString[] strings = line.split(\"\\\\s\");"]}
{"Result": "Method without Parameter"}
{"state": ["public Committees searchByStateChamber(String state, String chamber) throws OpenStatesException {\r", "\t\t\tnew ArgMap(\"state\", state, \"chamber\", chamber), \r"], "chamber": ["public Committees searchByStateChamber(String state, String chamber) throws OpenStatesException {\r", "\t\t\tnew ArgMap(\"state\", state, \"chamber\", chamber), \r"]}
{"id": ["public Committee detail(String id) throws OpenStatesException {\r", "\t\treturn api.query(new MethodMap(\"committees\", id), null, Committee.class);\r"]}
{"host": ["private static JMXConnector connect(String host, String port, String login, String password) throws IOException {", "                    .append(host)", "                    .append(host)"], "port": ["private static JMXConnector connect(String host, String port, String login, String password) throws IOException {", "                    .append(port)", "                    .append(port)"], "login": ["private static JMXConnector connect(String host, String port, String login, String password) throws IOException {", "        serviceEnv.put(\"jmx.remote.credentials\", new String[]{login, password});"], "password": ["private static JMXConnector connect(String host, String port, String login, String password) throws IOException {", "        serviceEnv.put(\"jmx.remote.credentials\", new String[]{login, password});"]}
{"properties": ["private static String getProperty(Properties properties, String key) {", "        if (properties == null || properties.getProperty(key) == null) {", "        return properties.getProperty(key);"], "key": ["private static String getProperty(Properties properties, String key) {", "        if (properties == null || properties.getProperty(key) == null) {", "            throw new IllegalArgumentException(\"The property \" + key + \" does not exist.\");", "        return properties.getProperty(key);"]}
{"proxy": [], "method": ["    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {", "            result = method.invoke(object, args);"], "args": ["    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {", "            result = method.invoke(object, args);", "        return result;"]}
{"state": ["public Districts searchByState(String state) throws OpenStatesException {\r", "\t\treturn api.query(new MethodMap(\"districts\", state), null, Districts.class);\r"]}
{"state": ["public Districts search(String state, String chamber) throws OpenStatesException {\r", "\t\treturn api.query(new MethodMap(\"districts\", state, chamber), null, Districts.class);\r"], "chamber": ["public Districts search(String state, String chamber) throws OpenStatesException {\r", "\t\treturn api.query(new MethodMap(\"districts\", state, chamber), null, Districts.class);\r"]}
{"boundary_id": ["public District boundaryLookup(String boundary_id) throws OpenStatesException {\r", "\t\treturn api.query(new MethodMap(\"districts\", \"boundary\", boundary_id ), null, District.class);\r"]}
{"state": ["public Metadata state(String state) throws OpenStatesException {\r"]}
{"interfaceClass": ["private static <T> T createObject(Class<T> interfaceClass) {", "        ServiceLoader<T> loader = ServiceLoader.load(interfaceClass);", "        for (T loadedObject : loader) {", "            if (object == null) {", "                object = loadedObject;", "        if (object == null) {", "        return object;"]}
{"interfaceClass": ["public static <T> ObjectName register(Class<T> interfaceClass, ObjectName objectName) throws MBeanException {", "        if (interfaceClass == null) {", "                ObjectInstance objectInstance = mBeanServer.registerMBean(createObject(interfaceClass), objectName);"], "objectName": ["public static <T> ObjectName register(Class<T> interfaceClass, ObjectName objectName) throws MBeanException {", "            if (!mBeanServer.isRegistered(objectName)) {", "                ObjectInstance objectInstance = mBeanServer.registerMBean(createObject(interfaceClass), objectName);", "                objectName = objectInstance.getObjectName();", "        return objectName;"]}
{"objectName": ["public static void unregister(ObjectName objectName) throws MBeanException {", "            if (mBeanServer.isRegistered(objectName)) {", "                mBeanServer.unregisterMBean(objectName);", "                    objectName.getCanonicalName() + \".\");"]}
{"interfaceClass": ["protected static void validateMBean(Class interfaceClass, ObjectName objectName, MBeanServerConnection mBeanServerConnection)  throws MBeanException {", "            if (interfaceClass == null) {", "            if (!JMX.isMXBeanInterface(interfaceClass)) {", "                        \"The interface class \" + interfaceClass.getName() +", "            if (!mBeanServerConnection.isInstanceOf(objectName, interfaceClass.getName())) {", "                        interfaceClass.getName() + \".\");", "                    interfaceClass.getName() + \" and object name \" +"], "objectName": ["protected static void validateMBean(Class interfaceClass, ObjectName objectName, MBeanServerConnection mBeanServerConnection)  throws MBeanException {", "            if (!mBeanServerConnection.isRegistered(objectName)) {", "                        \"The object name \" + objectName.getCanonicalName() +", "            if (!mBeanServerConnection.isInstanceOf(objectName, interfaceClass.getName())) {", "                        \"The object name \" + objectName.getCanonicalName() +", "                    \"The object name \" + objectName.getCanonicalName() +", "                    objectName.getCanonicalName() + \".\");"], "mBeanServerConnection": ["protected static void validateMBean(Class interfaceClass, ObjectName objectName, MBeanServerConnection mBeanServerConnection)  throws MBeanException {", "            if (!mBeanServerConnection.isRegistered(objectName)) {", "            if (!mBeanServerConnection.isInstanceOf(objectName, interfaceClass.getName())) {"]}
{"Result": "Method without Parameter"}
{"value": ["public void addValue(String value, boolean isDefault) {", "        p(\"Adding \" + (isDefault ? \"default \" : \"\") + \"value:\" + value + \" to parameter:\" + m_field.getName());", "        validateParameter(name, value);", "        Object convertedValue = m_jCommander.convertValue(this, value);", "                if (convertedValue instanceof Collection) {", "                    l.addAll((Collection) convertedValue);", "                    l.add(convertedValue);", "                m_wrappedParameter.addValue(m_field, m_object, convertedValue);"], "isDefault": ["public void addValue(String value, boolean isDefault) {", "        p(\"Adding \" + (isDefault ? \"default \" : \"\") + \"value:\" + value + \" to parameter:\" + m_field.getName());", "                if (l == null || fieldIsSetForTheFirstTime(isDefault)) {", "            if (!isDefault) m_assigned = true;"]}
{"state": ["\t\t\tString state \r", "\t\t\tnew ArgMap( \"state\", state ), \r"]}
{"state": ["\t\t\tString state, \r", "\t\t\t\t\"state\", state, \r"], "active": ["\t\t\tBoolean active \r", "\t\t\t\t\"active\", active.toString()\r"]}
{"state": ["\t\t\tString state, \r", "\t\t\t\t\"state\", state, \r"], "term": ["\t\t\tString term \r", "\t\t\t\t\"term\", term \r"]}
{"state": ["\t\t\tString state, \r", "\t\t\t\t\"state\", state, \r"], "active": ["\t\t\tBoolean active, \r", "\t\t\t\t\"active\", active==null?null:active.toString(), \r"], "term": ["\t\t\tString term, \r", "\t\t\t\t\"term\", term, \r"], "chamber": ["\t\t\tString chamber,\r", "\t\t\t\t\"chamber\", chamber, \r"], "district": ["\t\t\tString district, \r", "\t\t\t\t\"district\", district\r"], "party": ["\t\t\tString party, \r", "\t\t\t\t\"party\", party, \r"], "first_name": ["\t\t\tString first_name, \r", "\t\t\t\t\"first_name\", first_name, \r"], "last_name": ["\t\t\tString last_name \r", "\t\t\t\t\"last_name\", last_name, \r"]}
{"id": ["public Legislator detail(String id) throws OpenStatesException {\r", "\t\treturn api.query(new MethodMap(\"legislators\", id), null, Legislator.class);\r"]}
{"o": ["public int compareTo(E o) {", "\t\tif (o.getClass() != getClass()) {", "\t\treturn ordinal - TypesafeEnum.class.cast(o).ordinal;"]}
{"mappedClass": ["public void setMappedClass(Class<T> mappedClass) {", "        if (this.mappedClass == null) {", "            initialize(mappedClass);", "            if (!this.mappedClass.equals(mappedClass)) {", "                        mappedClass + \" since it is already providing mapping for \" + this.mappedClass);"]}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"Result": "Method without Parameter"}
{"responseText": ["protected String responseToPid( final String responseText ) throws IOException {", "        LOGGER.debug(\"responseToPid({})\", responseText);", "            return responseText.replaceFirst(regex,\"\");", "                return xpath( responseText, xpath );", "            return responseText;"]}
{"xml": ["private static String xpath( final String xml, final XPathExpression xpath )", "        final Document doc = builder.parse(new ByteArrayInputStream(xml.getBytes()));"], "xpath": ["private static String xpath( final String xml, final XPathExpression xpath )"]}
{"Result": "Method without Parameter"}
{"klass": ["public static <T extends Configuration> ConfigurationBinder<T> forClass(Class<T> klass, Binder binder) {", "        return new ConfigurationBinder<>(klass, binder);"], "binder": ["public static <T extends Configuration> ConfigurationBinder<T> forClass(Class<T> klass, Binder binder) {", "        return new ConfigurationBinder<>(klass, binder);"]}
{"configuration": ["public void toInstance(Config configuration) {", "        Preconditions.checkNotNull(configuration, \"Configuration Instance cannot be null.\");", "            binder.bind(configClass).toInstance(configuration);", "            binder.bind(configClass).annotatedWith(annotationClass).toInstance(configuration);"]}
{"dispatcherTypes": ["            EnumSet<DispatcherType> dispatcherTypes,", "        return new FilterPattern(dispatcherTypes, matchAfter, ImmutableList.copyOf(patterns));"], "matchAfter": ["            boolean matchAfter,", "        return new FilterPattern(dispatcherTypes, matchAfter, ImmutableList.copyOf(patterns));"], "patterns": ["            Iterable<String> patterns) {", "        return new FilterPattern(dispatcherTypes, matchAfter, ImmutableList.copyOf(patterns));"]}
{"Result": "Method without Parameter"}
